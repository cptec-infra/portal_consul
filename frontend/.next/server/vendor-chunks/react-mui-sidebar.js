"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-mui-sidebar";
exports.ids = ["vendor-chunks/react-mui-sidebar"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-mui-sidebar/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-mui-sidebar/dist/index.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logo: () => (/* binding */ Gm),\n/* harmony export */   Menu: () => (/* binding */ Ym),\n/* harmony export */   MenuItem: () => (/* binding */ qm),\n/* harmony export */   Sidebar: () => (/* binding */ Um),\n/* harmony export */   Submenu: () => (/* binding */ Hm)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar Gs = Object.defineProperty;\nvar Ks = (e, t, r) => t in e ? Gs(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;\nvar cr = (e, t, r) => Ks(e, typeof t != \"symbol\" ? t + \"\" : t, r);\n\n\n\n\nfunction ec(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nvar Ur = { exports: {} }, lr = {};\n/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar ai;\nfunction tc() {\n  if (ai) return lr;\n  ai = 1;\n  var e = Symbol.for(\"react.transitional.element\"), t = Symbol.for(\"react.fragment\");\n  function r(n, o, i) {\n    var s = null;\n    if (i !== void 0 && (s = \"\" + i), o.key !== void 0 && (s = \"\" + o.key), \"key\" in o) {\n      i = {};\n      for (var c in o)\n        c !== \"key\" && (i[c] = o[c]);\n    } else i = o;\n    return o = i.ref, {\n      $$typeof: e,\n      type: n,\n      key: s,\n      ref: o !== void 0 ? o : null,\n      props: i\n    };\n  }\n  return lr.Fragment = t, lr.jsx = r, lr.jsxs = r, lr;\n}\nvar ur = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar si;\nfunction rc() {\n  return si || (si = 1,  true && function() {\n    function e(v) {\n      if (v == null) return null;\n      if (typeof v == \"function\")\n        return v.$$typeof === te ? null : v.displayName || v.name || null;\n      if (typeof v == \"string\") return v;\n      switch (v) {\n        case w:\n          return \"Fragment\";\n        case h:\n          return \"Portal\";\n        case L:\n          return \"Profiler\";\n        case k:\n          return \"StrictMode\";\n        case D:\n          return \"Suspense\";\n        case j:\n          return \"SuspenseList\";\n      }\n      if (typeof v == \"object\")\n        switch (typeof v.tag == \"number\" && console.error(\n          \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n        ), v.$$typeof) {\n          case d:\n            return (v.displayName || \"Context\") + \".Provider\";\n          case B:\n            return (v._context.displayName || \"Context\") + \".Consumer\";\n          case A:\n            var M = v.render;\n            return v = v.displayName, v || (v = M.displayName || M.name || \"\", v = v !== \"\" ? \"ForwardRef(\" + v + \")\" : \"ForwardRef\"), v;\n          case W:\n            return M = v.displayName || null, M !== null ? M : e(v.type) || \"Memo\";\n          case z:\n            M = v._payload, v = v._init;\n            try {\n              return e(v(M));\n            } catch {\n            }\n        }\n      return null;\n    }\n    function t(v) {\n      return \"\" + v;\n    }\n    function r(v) {\n      try {\n        t(v);\n        var M = !1;\n      } catch {\n        M = !0;\n      }\n      if (M) {\n        M = console;\n        var Y = M.error, oe = typeof Symbol == \"function\" && Symbol.toStringTag && v[Symbol.toStringTag] || v.constructor.name || \"Object\";\n        return Y.call(\n          M,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          oe\n        ), t(v);\n      }\n    }\n    function n() {\n    }\n    function o() {\n      if (H === 0) {\n        X = console.log, _ = console.info, q = console.warn, G = console.error, re = console.group, Z = console.groupCollapsed, ae = console.groupEnd;\n        var v = {\n          configurable: !0,\n          enumerable: !0,\n          value: n,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: v,\n          log: v,\n          warn: v,\n          error: v,\n          group: v,\n          groupCollapsed: v,\n          groupEnd: v\n        });\n      }\n      H++;\n    }\n    function i() {\n      if (H--, H === 0) {\n        var v = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: I({}, v, { value: X }),\n          info: I({}, v, { value: _ }),\n          warn: I({}, v, { value: q }),\n          error: I({}, v, { value: G }),\n          group: I({}, v, { value: re }),\n          groupCollapsed: I({}, v, { value: Z }),\n          groupEnd: I({}, v, { value: ae })\n        });\n      }\n      0 > H && console.error(\n        \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n      );\n    }\n    function s(v) {\n      if (O === void 0)\n        try {\n          throw Error();\n        } catch (Y) {\n          var M = Y.stack.trim().match(/\\n( *(at )?)/);\n          O = M && M[1] || \"\", ye = -1 < Y.stack.indexOf(`\n    at`) ? \" (<anonymous>)\" : -1 < Y.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n        }\n      return `\n` + O + v + ye;\n    }\n    function c(v, M) {\n      if (!v || Ee) return \"\";\n      var Y = Me.get(v);\n      if (Y !== void 0) return Y;\n      Ee = !0, Y = Error.prepareStackTrace, Error.prepareStackTrace = void 0;\n      var oe = null;\n      oe = F.H, F.H = null, o();\n      try {\n        var Re = {\n          DetermineComponentFrameRoot: function() {\n            try {\n              if (M) {\n                var We = function() {\n                  throw Error();\n                };\n                if (Object.defineProperty(We.prototype, \"props\", {\n                  set: function() {\n                    throw Error();\n                  }\n                }), typeof Reflect == \"object\" && Reflect.construct) {\n                  try {\n                    Reflect.construct(We, []);\n                  } catch (ut) {\n                    var Ue = ut;\n                  }\n                  Reflect.construct(v, [], We);\n                } else {\n                  try {\n                    We.call();\n                  } catch (ut) {\n                    Ue = ut;\n                  }\n                  v.call(We.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (ut) {\n                  Ue = ut;\n                }\n                (We = v()) && typeof We.catch == \"function\" && We.catch(function() {\n                });\n              }\n            } catch (ut) {\n              if (ut && Ue && typeof ut.stack == \"string\")\n                return [ut.stack, Ue.stack];\n            }\n            return [null, null];\n          }\n        };\n        Re.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n        var ue = Object.getOwnPropertyDescriptor(\n          Re.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        ue && ue.configurable && Object.defineProperty(\n          Re.DetermineComponentFrameRoot,\n          \"name\",\n          { value: \"DetermineComponentFrameRoot\" }\n        );\n        var K = Re.DetermineComponentFrameRoot(), be = K[0], we = K[1];\n        if (be && we) {\n          var Oe = be.split(`\n`), ce = we.split(`\n`);\n          for (K = ue = 0; ue < Oe.length && !Oe[ue].includes(\n            \"DetermineComponentFrameRoot\"\n          ); )\n            ue++;\n          for (; K < ce.length && !ce[K].includes(\n            \"DetermineComponentFrameRoot\"\n          ); )\n            K++;\n          if (ue === Oe.length || K === ce.length)\n            for (ue = Oe.length - 1, K = ce.length - 1; 1 <= ue && 0 <= K && Oe[ue] !== ce[K]; )\n              K--;\n          for (; 1 <= ue && 0 <= K; ue--, K--)\n            if (Oe[ue] !== ce[K]) {\n              if (ue !== 1 || K !== 1)\n                do\n                  if (ue--, K--, 0 > K || Oe[ue] !== ce[K]) {\n                    var Ie = `\n` + Oe[ue].replace(\n                      \" at new \",\n                      \" at \"\n                    );\n                    return v.displayName && Ie.includes(\"<anonymous>\") && (Ie = Ie.replace(\"<anonymous>\", v.displayName)), typeof v == \"function\" && Me.set(v, Ie), Ie;\n                  }\n                while (1 <= ue && 0 <= K);\n              break;\n            }\n        }\n      } finally {\n        Ee = !1, F.H = oe, i(), Error.prepareStackTrace = Y;\n      }\n      return Oe = (Oe = v ? v.displayName || v.name : \"\") ? s(Oe) : \"\", typeof v == \"function\" && Me.set(v, Oe), Oe;\n    }\n    function l(v) {\n      if (v == null) return \"\";\n      if (typeof v == \"function\") {\n        var M = v.prototype;\n        return c(\n          v,\n          !(!M || !M.isReactComponent)\n        );\n      }\n      if (typeof v == \"string\") return s(v);\n      switch (v) {\n        case D:\n          return s(\"Suspense\");\n        case j:\n          return s(\"SuspenseList\");\n      }\n      if (typeof v == \"object\")\n        switch (v.$$typeof) {\n          case A:\n            return v = c(v.render, !1), v;\n          case W:\n            return l(v.type);\n          case z:\n            M = v._payload, v = v._init;\n            try {\n              return l(v(M));\n            } catch {\n            }\n        }\n      return \"\";\n    }\n    function u() {\n      var v = F.A;\n      return v === null ? null : v.getOwner();\n    }\n    function p(v) {\n      if (R.call(v, \"key\")) {\n        var M = Object.getOwnPropertyDescriptor(v, \"key\").get;\n        if (M && M.isReactWarning) return !1;\n      }\n      return v.key !== void 0;\n    }\n    function m(v, M) {\n      function Y() {\n        ve || (ve = !0, console.error(\n          \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n          M\n        ));\n      }\n      Y.isReactWarning = !0, Object.defineProperty(v, \"key\", {\n        get: Y,\n        configurable: !0\n      });\n    }\n    function g() {\n      var v = e(this.type);\n      return Pe[v] || (Pe[v] = !0, console.error(\n        \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n      )), v = this.props.ref, v !== void 0 ? v : null;\n    }\n    function x(v, M, Y, oe, Re, ue) {\n      return Y = ue.ref, v = {\n        $$typeof: b,\n        type: v,\n        key: M,\n        props: ue,\n        _owner: Re\n      }, (Y !== void 0 ? Y : null) !== null ? Object.defineProperty(v, \"ref\", {\n        enumerable: !1,\n        get: g\n      }) : Object.defineProperty(v, \"ref\", { enumerable: !1, value: null }), v._store = {}, Object.defineProperty(v._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      }), Object.defineProperty(v, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      }), Object.freeze && (Object.freeze(v.props), Object.freeze(v)), v;\n    }\n    function y(v, M, Y, oe, Re, ue) {\n      if (typeof v == \"string\" || typeof v == \"function\" || v === w || v === L || v === k || v === D || v === j || v === U || typeof v == \"object\" && v !== null && (v.$$typeof === z || v.$$typeof === W || v.$$typeof === d || v.$$typeof === B || v.$$typeof === A || v.$$typeof === J || v.getModuleId !== void 0)) {\n        var K = M.children;\n        if (K !== void 0)\n          if (oe)\n            if (Q(K)) {\n              for (oe = 0; oe < K.length; oe++)\n                f(K[oe], v);\n              Object.freeze && Object.freeze(K);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else f(K, v);\n      } else\n        K = \"\", (v === void 0 || typeof v == \"object\" && v !== null && Object.keys(v).length === 0) && (K += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\"), v === null ? oe = \"null\" : Q(v) ? oe = \"array\" : v !== void 0 && v.$$typeof === b ? (oe = \"<\" + (e(v.type) || \"Unknown\") + \" />\", K = \" Did you accidentally export a JSX literal instead of a component?\") : oe = typeof v, console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          oe,\n          K\n        );\n      if (R.call(M, \"key\")) {\n        K = e(v);\n        var be = Object.keys(M).filter(function(Oe) {\n          return Oe !== \"key\";\n        });\n        oe = 0 < be.length ? \"{key: someKey, \" + be.join(\": ..., \") + \": ...}\" : \"{key: someKey}\", ze[K + oe] || (be = 0 < be.length ? \"{\" + be.join(\": ..., \") + \": ...}\" : \"{}\", console.error(\n          `A props object containing a \"key\" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />`,\n          oe,\n          K,\n          be,\n          K\n        ), ze[K + oe] = !0);\n      }\n      if (K = null, Y !== void 0 && (r(Y), K = \"\" + Y), p(M) && (r(M.key), K = \"\" + M.key), \"key\" in M) {\n        Y = {};\n        for (var we in M)\n          we !== \"key\" && (Y[we] = M[we]);\n      } else Y = M;\n      return K && m(\n        Y,\n        typeof v == \"function\" ? v.displayName || v.name || \"Unknown\" : v\n      ), x(v, K, ue, Re, u(), Y);\n    }\n    function f(v, M) {\n      if (typeof v == \"object\" && v && v.$$typeof !== Qe) {\n        if (Q(v))\n          for (var Y = 0; Y < v.length; Y++) {\n            var oe = v[Y];\n            S(oe) && E(oe, M);\n          }\n        else if (S(v))\n          v._store && (v._store.validated = 1);\n        else if (v === null || typeof v != \"object\" ? Y = null : (Y = V && v[V] || v[\"@@iterator\"], Y = typeof Y == \"function\" ? Y : null), typeof Y == \"function\" && Y !== v.entries && (Y = Y.call(v), Y !== v))\n          for (; !(v = Y.next()).done; )\n            S(v.value) && E(v.value, M);\n      }\n    }\n    function S(v) {\n      return typeof v == \"object\" && v !== null && v.$$typeof === b;\n    }\n    function E(v, M) {\n      if (v._store && !v._store.validated && v.key == null && (v._store.validated = 1, M = P(M), !Le[M])) {\n        Le[M] = !0;\n        var Y = \"\";\n        v && v._owner != null && v._owner !== u() && (Y = null, typeof v._owner.tag == \"number\" ? Y = e(v._owner.type) : typeof v._owner.name == \"string\" && (Y = v._owner.name), Y = \" It was passed a child from \" + Y + \".\");\n        var oe = F.getCurrentStack;\n        F.getCurrentStack = function() {\n          var Re = l(v.type);\n          return oe && (Re += oe() || \"\"), Re;\n        }, console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          M,\n          Y\n        ), F.getCurrentStack = oe;\n      }\n    }\n    function P(v) {\n      var M = \"\", Y = u();\n      return Y && (Y = e(Y.type)) && (M = `\n\nCheck the render method of \\`` + Y + \"`.\"), M || (v = e(v)) && (M = `\n\nCheck the top-level render call using <` + v + \">.\"), M;\n    }\n    var T = react__WEBPACK_IMPORTED_MODULE_0__, b = Symbol.for(\"react.transitional.element\"), h = Symbol.for(\"react.portal\"), w = Symbol.for(\"react.fragment\"), k = Symbol.for(\"react.strict_mode\"), L = Symbol.for(\"react.profiler\"), B = Symbol.for(\"react.consumer\"), d = Symbol.for(\"react.context\"), A = Symbol.for(\"react.forward_ref\"), D = Symbol.for(\"react.suspense\"), j = Symbol.for(\"react.suspense_list\"), W = Symbol.for(\"react.memo\"), z = Symbol.for(\"react.lazy\"), U = Symbol.for(\"react.offscreen\"), V = Symbol.iterator, te = Symbol.for(\"react.client.reference\"), F = T.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, R = Object.prototype.hasOwnProperty, I = Object.assign, J = Symbol.for(\"react.client.reference\"), Q = Array.isArray, H = 0, X, _, q, G, re, Z, ae;\n    n.__reactDisabledLog = !0;\n    var O, ye, Ee = !1, Me = new (typeof WeakMap == \"function\" ? WeakMap : Map)(), Qe = Symbol.for(\"react.client.reference\"), ve, Pe = {}, ze = {}, Le = {};\n    ur.Fragment = w, ur.jsx = function(v, M, Y, oe, Re) {\n      return y(v, M, Y, !1, oe, Re);\n    }, ur.jsxs = function(v, M, Y, oe, Re) {\n      return y(v, M, Y, !0, oe, Re);\n    };\n  }()), ur;\n}\nvar ci;\nfunction nc() {\n  return ci || (ci = 1,  false ? 0 : Ur.exports = rc()), Ur.exports;\n}\nvar N = nc();\nconst Er = {\n  black: \"#000\",\n  white: \"#fff\"\n}, Wt = {\n  50: \"#ffebee\",\n  100: \"#ffcdd2\",\n  200: \"#ef9a9a\",\n  300: \"#e57373\",\n  400: \"#ef5350\",\n  500: \"#f44336\",\n  600: \"#e53935\",\n  700: \"#d32f2f\",\n  800: \"#c62828\",\n  900: \"#b71c1c\",\n  A100: \"#ff8a80\",\n  A200: \"#ff5252\",\n  A400: \"#ff1744\",\n  A700: \"#d50000\"\n}, Ut = {\n  50: \"#f3e5f5\",\n  100: \"#e1bee7\",\n  200: \"#ce93d8\",\n  300: \"#ba68c8\",\n  400: \"#ab47bc\",\n  500: \"#9c27b0\",\n  600: \"#8e24aa\",\n  700: \"#7b1fa2\",\n  800: \"#6a1b9a\",\n  900: \"#4a148c\",\n  A100: \"#ea80fc\",\n  A200: \"#e040fb\",\n  A400: \"#d500f9\",\n  A700: \"#aa00ff\"\n}, Yt = {\n  50: \"#e3f2fd\",\n  100: \"#bbdefb\",\n  200: \"#90caf9\",\n  300: \"#64b5f6\",\n  400: \"#42a5f5\",\n  500: \"#2196f3\",\n  600: \"#1e88e5\",\n  700: \"#1976d2\",\n  800: \"#1565c0\",\n  900: \"#0d47a1\",\n  A100: \"#82b1ff\",\n  A200: \"#448aff\",\n  A400: \"#2979ff\",\n  A700: \"#2962ff\"\n}, Ht = {\n  50: \"#e1f5fe\",\n  100: \"#b3e5fc\",\n  200: \"#81d4fa\",\n  300: \"#4fc3f7\",\n  400: \"#29b6f6\",\n  500: \"#03a9f4\",\n  600: \"#039be5\",\n  700: \"#0288d1\",\n  800: \"#0277bd\",\n  900: \"#01579b\",\n  A100: \"#80d8ff\",\n  A200: \"#40c4ff\",\n  A400: \"#00b0ff\",\n  A700: \"#0091ea\"\n}, qt = {\n  50: \"#e8f5e9\",\n  100: \"#c8e6c9\",\n  200: \"#a5d6a7\",\n  300: \"#81c784\",\n  400: \"#66bb6a\",\n  500: \"#4caf50\",\n  600: \"#43a047\",\n  700: \"#388e3c\",\n  800: \"#2e7d32\",\n  900: \"#1b5e20\",\n  A100: \"#b9f6ca\",\n  A200: \"#69f0ae\",\n  A400: \"#00e676\",\n  A700: \"#00c853\"\n}, fr = {\n  50: \"#fff3e0\",\n  100: \"#ffe0b2\",\n  200: \"#ffcc80\",\n  300: \"#ffb74d\",\n  400: \"#ffa726\",\n  500: \"#ff9800\",\n  600: \"#fb8c00\",\n  700: \"#f57c00\",\n  800: \"#ef6c00\",\n  900: \"#e65100\",\n  A100: \"#ffd180\",\n  A200: \"#ffab40\",\n  A400: \"#ff9100\",\n  A700: \"#ff6d00\"\n}, oc = {\n  50: \"#fafafa\",\n  100: \"#f5f5f5\",\n  200: \"#eeeeee\",\n  300: \"#e0e0e0\",\n  400: \"#bdbdbd\",\n  500: \"#9e9e9e\",\n  600: \"#757575\",\n  700: \"#616161\",\n  800: \"#424242\",\n  900: \"#212121\",\n  A100: \"#f5f5f5\",\n  A200: \"#eeeeee\",\n  A400: \"#bdbdbd\",\n  A700: \"#616161\"\n};\nfunction kt(e, ...t) {\n  const r = new URL(`https://mui.com/production-error/?code=${e}`);\n  return t.forEach((n) => r.searchParams.append(\"args[]\", n)), `Minified MUI error #${e}; visit ${r} for the full message.`;\n}\nconst wt = \"$$material\";\nfunction fn() {\n  return fn = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var r = arguments[t];\n      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);\n    }\n    return e;\n  }, fn.apply(null, arguments);\n}\nfunction ic(e) {\n  if (e.sheet)\n    return e.sheet;\n  for (var t = 0; t < document.styleSheets.length; t++)\n    if (document.styleSheets[t].ownerNode === e)\n      return document.styleSheets[t];\n}\nfunction ac(e) {\n  var t = document.createElement(\"style\");\n  return t.setAttribute(\"data-emotion\", e.key), e.nonce !== void 0 && t.setAttribute(\"nonce\", e.nonce), t.appendChild(document.createTextNode(\"\")), t.setAttribute(\"data-s\", \"\"), t;\n}\nvar sc = /* @__PURE__ */ function() {\n  function e(r) {\n    var n = this;\n    this._insertTag = function(o) {\n      var i;\n      n.tags.length === 0 ? n.insertionPoint ? i = n.insertionPoint.nextSibling : n.prepend ? i = n.container.firstChild : i = n.before : i = n.tags[n.tags.length - 1].nextSibling, n.container.insertBefore(o, i), n.tags.push(o);\n    }, this.isSpeedy = r.speedy === void 0 ? !0 : r.speedy, this.tags = [], this.ctr = 0, this.nonce = r.nonce, this.key = r.key, this.container = r.container, this.prepend = r.prepend, this.insertionPoint = r.insertionPoint, this.before = null;\n  }\n  var t = e.prototype;\n  return t.hydrate = function(n) {\n    n.forEach(this._insertTag);\n  }, t.insert = function(n) {\n    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(ac(this));\n    var o = this.tags[this.tags.length - 1];\n    if (this.isSpeedy) {\n      var i = ic(o);\n      try {\n        i.insertRule(n, i.cssRules.length);\n      } catch {\n      }\n    } else\n      o.appendChild(document.createTextNode(n));\n    this.ctr++;\n  }, t.flush = function() {\n    this.tags.forEach(function(n) {\n      var o;\n      return (o = n.parentNode) == null ? void 0 : o.removeChild(n);\n    }), this.tags = [], this.ctr = 0;\n  }, e;\n}(), Ye = \"-ms-\", dn = \"-moz-\", fe = \"-webkit-\", xa = \"comm\", So = \"rule\", Eo = \"decl\", cc = \"@import\", Sa = \"@keyframes\", lc = \"@layer\", uc = Math.abs, Rn = String.fromCharCode, fc = Object.assign;\nfunction dc(e, t) {\n  return Be(e, 0) ^ 45 ? (((t << 2 ^ Be(e, 0)) << 2 ^ Be(e, 1)) << 2 ^ Be(e, 2)) << 2 ^ Be(e, 3) : 0;\n}\nfunction Ea(e) {\n  return e.trim();\n}\nfunction pc(e, t) {\n  return (e = t.exec(e)) ? e[0] : e;\n}\nfunction de(e, t, r) {\n  return e.replace(t, r);\n}\nfunction oo(e, t) {\n  return e.indexOf(t);\n}\nfunction Be(e, t) {\n  return e.charCodeAt(t) | 0;\n}\nfunction Cr(e, t, r) {\n  return e.slice(t, r);\n}\nfunction mt(e) {\n  return e.length;\n}\nfunction Co(e) {\n  return e.length;\n}\nfunction Yr(e, t) {\n  return t.push(e), e;\n}\nfunction mc(e, t) {\n  return e.map(t).join(\"\");\n}\nvar $n = 1, Zt = 1, Ca = 0, Je = 0, je = 0, ir = \"\";\nfunction Pn(e, t, r, n, o, i, s) {\n  return { value: e, root: t, parent: r, type: n, props: o, children: i, line: $n, column: Zt, length: s, return: \"\" };\n}\nfunction dr(e, t) {\n  return fc(Pn(\"\", null, null, \"\", null, null, 0), e, { length: -e.length }, t);\n}\nfunction hc() {\n  return je;\n}\nfunction gc() {\n  return je = Je > 0 ? Be(ir, --Je) : 0, Zt--, je === 10 && (Zt = 1, $n--), je;\n}\nfunction et() {\n  return je = Je < Ca ? Be(ir, Je++) : 0, Zt++, je === 10 && (Zt = 1, $n++), je;\n}\nfunction vt() {\n  return Be(ir, Je);\n}\nfunction an() {\n  return Je;\n}\nfunction Ar(e, t) {\n  return Cr(ir, e, t);\n}\nfunction Tr(e) {\n  switch (e) {\n    // \\0 \\t \\n \\r \\s whitespace token\n    case 0:\n    case 9:\n    case 10:\n    case 13:\n    case 32:\n      return 5;\n    // ! + , / > @ ~ isolate token\n    case 33:\n    case 43:\n    case 44:\n    case 47:\n    case 62:\n    case 64:\n    case 126:\n    // ; { } breakpoint token\n    case 59:\n    case 123:\n    case 125:\n      return 4;\n    // : accompanied token\n    case 58:\n      return 3;\n    // \" ' ( [ opening delimit token\n    case 34:\n    case 39:\n    case 40:\n    case 91:\n      return 2;\n    // ) ] closing delimit token\n    case 41:\n    case 93:\n      return 1;\n  }\n  return 0;\n}\nfunction Ta(e) {\n  return $n = Zt = 1, Ca = mt(ir = e), Je = 0, [];\n}\nfunction wa(e) {\n  return ir = \"\", e;\n}\nfunction sn(e) {\n  return Ea(Ar(Je - 1, io(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));\n}\nfunction yc(e) {\n  for (; (je = vt()) && je < 33; )\n    et();\n  return Tr(e) > 2 || Tr(je) > 3 ? \"\" : \" \";\n}\nfunction bc(e, t) {\n  for (; --t && et() && !(je < 48 || je > 102 || je > 57 && je < 65 || je > 70 && je < 97); )\n    ;\n  return Ar(e, an() + (t < 6 && vt() == 32 && et() == 32));\n}\nfunction io(e) {\n  for (; et(); )\n    switch (je) {\n      // ] ) \" '\n      case e:\n        return Je;\n      // \" '\n      case 34:\n      case 39:\n        e !== 34 && e !== 39 && io(je);\n        break;\n      // (\n      case 40:\n        e === 41 && io(e);\n        break;\n      // \\\n      case 92:\n        et();\n        break;\n    }\n  return Je;\n}\nfunction vc(e, t) {\n  for (; et() && e + je !== 57; )\n    if (e + je === 84 && vt() === 47)\n      break;\n  return \"/*\" + Ar(t, Je - 1) + \"*\" + Rn(e === 47 ? e : et());\n}\nfunction xc(e) {\n  for (; !Tr(vt()); )\n    et();\n  return Ar(e, Je);\n}\nfunction Sc(e) {\n  return wa(cn(\"\", null, null, null, [\"\"], e = Ta(e), 0, [0], e));\n}\nfunction cn(e, t, r, n, o, i, s, c, l) {\n  for (var u = 0, p = 0, m = s, g = 0, x = 0, y = 0, f = 1, S = 1, E = 1, P = 0, T = \"\", b = o, h = i, w = n, k = T; S; )\n    switch (y = P, P = et()) {\n      // (\n      case 40:\n        if (y != 108 && Be(k, m - 1) == 58) {\n          oo(k += de(sn(P), \"&\", \"&\\f\"), \"&\\f\") != -1 && (E = -1);\n          break;\n        }\n      // \" ' [\n      case 34:\n      case 39:\n      case 91:\n        k += sn(P);\n        break;\n      // \\t \\n \\r \\s\n      case 9:\n      case 10:\n      case 13:\n      case 32:\n        k += yc(y);\n        break;\n      // \\\n      case 92:\n        k += bc(an() - 1, 7);\n        continue;\n      // /\n      case 47:\n        switch (vt()) {\n          case 42:\n          case 47:\n            Yr(Ec(vc(et(), an()), t, r), l);\n            break;\n          default:\n            k += \"/\";\n        }\n        break;\n      // {\n      case 123 * f:\n        c[u++] = mt(k) * E;\n      // } ; \\0\n      case 125 * f:\n      case 59:\n      case 0:\n        switch (P) {\n          // \\0 }\n          case 0:\n          case 125:\n            S = 0;\n          // ;\n          case 59 + p:\n            E == -1 && (k = de(k, /\\f/g, \"\")), x > 0 && mt(k) - m && Yr(x > 32 ? ui(k + \";\", n, r, m - 1) : ui(de(k, \" \", \"\") + \";\", n, r, m - 2), l);\n            break;\n          // @ ;\n          case 59:\n            k += \";\";\n          // { rule/at-rule\n          default:\n            if (Yr(w = li(k, t, r, u, p, o, c, T, b = [], h = [], m), i), P === 123)\n              if (p === 0)\n                cn(k, t, w, w, b, i, m, c, h);\n              else\n                switch (g === 99 && Be(k, 3) === 110 ? 100 : g) {\n                  // d l m s\n                  case 100:\n                  case 108:\n                  case 109:\n                  case 115:\n                    cn(e, w, w, n && Yr(li(e, w, w, 0, 0, o, c, T, o, b = [], m), h), o, h, m, c, n ? b : h);\n                    break;\n                  default:\n                    cn(k, w, w, w, [\"\"], h, 0, c, h);\n                }\n        }\n        u = p = x = 0, f = E = 1, T = k = \"\", m = s;\n        break;\n      // :\n      case 58:\n        m = 1 + mt(k), x = y;\n      default:\n        if (f < 1) {\n          if (P == 123)\n            --f;\n          else if (P == 125 && f++ == 0 && gc() == 125)\n            continue;\n        }\n        switch (k += Rn(P), P * f) {\n          // &\n          case 38:\n            E = p > 0 ? 1 : (k += \"\\f\", -1);\n            break;\n          // ,\n          case 44:\n            c[u++] = (mt(k) - 1) * E, E = 1;\n            break;\n          // @\n          case 64:\n            vt() === 45 && (k += sn(et())), g = vt(), p = m = mt(T = k += xc(an())), P++;\n            break;\n          // -\n          case 45:\n            y === 45 && mt(k) == 2 && (f = 0);\n        }\n    }\n  return i;\n}\nfunction li(e, t, r, n, o, i, s, c, l, u, p) {\n  for (var m = o - 1, g = o === 0 ? i : [\"\"], x = Co(g), y = 0, f = 0, S = 0; y < n; ++y)\n    for (var E = 0, P = Cr(e, m + 1, m = uc(f = s[y])), T = e; E < x; ++E)\n      (T = Ea(f > 0 ? g[E] + \" \" + P : de(P, /&\\f/g, g[E]))) && (l[S++] = T);\n  return Pn(e, t, r, o === 0 ? So : c, l, u, p);\n}\nfunction Ec(e, t, r) {\n  return Pn(e, t, r, xa, Rn(hc()), Cr(e, 2, -2), 0);\n}\nfunction ui(e, t, r, n) {\n  return Pn(e, t, r, Eo, Cr(e, 0, n), Cr(e, n + 1, -1), n);\n}\nfunction Xt(e, t) {\n  for (var r = \"\", n = Co(e), o = 0; o < n; o++)\n    r += t(e[o], o, e, t) || \"\";\n  return r;\n}\nfunction Cc(e, t, r, n) {\n  switch (e.type) {\n    case lc:\n      if (e.children.length) break;\n    case cc:\n    case Eo:\n      return e.return = e.return || e.value;\n    case xa:\n      return \"\";\n    case Sa:\n      return e.return = e.value + \"{\" + Xt(e.children, n) + \"}\";\n    case So:\n      e.value = e.props.join(\",\");\n  }\n  return mt(r = Xt(e.children, n)) ? e.return = e.value + \"{\" + r + \"}\" : \"\";\n}\nfunction Tc(e) {\n  var t = Co(e);\n  return function(r, n, o, i) {\n    for (var s = \"\", c = 0; c < t; c++)\n      s += e[c](r, n, o, i) || \"\";\n    return s;\n  };\n}\nfunction wc(e) {\n  return function(t) {\n    t.root || (t = t.return) && e(t);\n  };\n}\nfunction Oa(e) {\n  var t = /* @__PURE__ */ Object.create(null);\n  return function(r) {\n    return t[r] === void 0 && (t[r] = e(r)), t[r];\n  };\n}\nvar Oc = function(t, r, n) {\n  for (var o = 0, i = 0; o = i, i = vt(), o === 38 && i === 12 && (r[n] = 1), !Tr(i); )\n    et();\n  return Ar(t, Je);\n}, Rc = function(t, r) {\n  var n = -1, o = 44;\n  do\n    switch (Tr(o)) {\n      case 0:\n        o === 38 && vt() === 12 && (r[n] = 1), t[n] += Oc(Je - 1, r, n);\n        break;\n      case 2:\n        t[n] += sn(o);\n        break;\n      case 4:\n        if (o === 44) {\n          t[++n] = vt() === 58 ? \"&\\f\" : \"\", r[n] = t[n].length;\n          break;\n        }\n      // fallthrough\n      default:\n        t[n] += Rn(o);\n    }\n  while (o = et());\n  return t;\n}, $c = function(t, r) {\n  return wa(Rc(Ta(t), r));\n}, fi = /* @__PURE__ */ new WeakMap(), Pc = function(t) {\n  if (!(t.type !== \"rule\" || !t.parent || // positive .length indicates that this rule contains pseudo\n  // negative .length indicates that this rule has been already prefixed\n  t.length < 1)) {\n    for (var r = t.value, n = t.parent, o = t.column === n.column && t.line === n.line; n.type !== \"rule\"; )\n      if (n = n.parent, !n) return;\n    if (!(t.props.length === 1 && r.charCodeAt(0) !== 58 && !fi.get(n)) && !o) {\n      fi.set(t, !0);\n      for (var i = [], s = $c(r, i), c = n.props, l = 0, u = 0; l < s.length; l++)\n        for (var p = 0; p < c.length; p++, u++)\n          t.props[u] = i[l] ? s[l].replace(/&\\f/g, c[p]) : c[p] + \" \" + s[l];\n    }\n  }\n}, kc = function(t) {\n  if (t.type === \"decl\") {\n    var r = t.value;\n    // charcode for l\n    r.charCodeAt(0) === 108 && // charcode for b\n    r.charCodeAt(2) === 98 && (t.return = \"\", t.value = \"\");\n  }\n};\nfunction Ra(e, t) {\n  switch (dc(e, t)) {\n    // color-adjust\n    case 5103:\n      return fe + \"print-\" + e + e;\n    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)\n    case 5737:\n    case 4201:\n    case 3177:\n    case 3433:\n    case 1641:\n    case 4457:\n    case 2921:\n    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break\n    case 5572:\n    case 6356:\n    case 5844:\n    case 3191:\n    case 6645:\n    case 3005:\n    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,\n    case 6391:\n    case 5879:\n    case 5623:\n    case 6135:\n    case 4599:\n    case 4855:\n    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)\n    case 4215:\n    case 6389:\n    case 5109:\n    case 5365:\n    case 5621:\n    case 3829:\n      return fe + e + e;\n    // appearance, user-select, transform, hyphens, text-size-adjust\n    case 5349:\n    case 4246:\n    case 4810:\n    case 6968:\n    case 2756:\n      return fe + e + dn + e + Ye + e + e;\n    // flex, flex-direction\n    case 6828:\n    case 4268:\n      return fe + e + Ye + e + e;\n    // order\n    case 6165:\n      return fe + e + Ye + \"flex-\" + e + e;\n    // align-items\n    case 5187:\n      return fe + e + de(e, /(\\w+).+(:[^]+)/, fe + \"box-$1$2\" + Ye + \"flex-$1$2\") + e;\n    // align-self\n    case 5443:\n      return fe + e + Ye + \"flex-item-\" + de(e, /flex-|-self/, \"\") + e;\n    // align-content\n    case 4675:\n      return fe + e + Ye + \"flex-line-pack\" + de(e, /align-content|flex-|-self/, \"\") + e;\n    // flex-shrink\n    case 5548:\n      return fe + e + Ye + de(e, \"shrink\", \"negative\") + e;\n    // flex-basis\n    case 5292:\n      return fe + e + Ye + de(e, \"basis\", \"preferred-size\") + e;\n    // flex-grow\n    case 6060:\n      return fe + \"box-\" + de(e, \"-grow\", \"\") + fe + e + Ye + de(e, \"grow\", \"positive\") + e;\n    // transition\n    case 4554:\n      return fe + de(e, /([^-])(transform)/g, \"$1\" + fe + \"$2\") + e;\n    // cursor\n    case 6187:\n      return de(de(de(e, /(zoom-|grab)/, fe + \"$1\"), /(image-set)/, fe + \"$1\"), e, \"\") + e;\n    // background, background-image\n    case 5495:\n    case 3959:\n      return de(e, /(image-set\\([^]*)/, fe + \"$1$`$1\");\n    // justify-content\n    case 4968:\n      return de(de(e, /(.+:)(flex-)?(.*)/, fe + \"box-pack:$3\" + Ye + \"flex-pack:$3\"), /s.+-b[^;]+/, \"justify\") + fe + e + e;\n    // (margin|padding)-inline-(start|end)\n    case 4095:\n    case 3583:\n    case 4068:\n    case 2532:\n      return de(e, /(.+)-inline(.+)/, fe + \"$1$2\") + e;\n    // (min|max)?(width|height|inline-size|block-size)\n    case 8116:\n    case 7059:\n    case 5753:\n    case 5535:\n    case 5445:\n    case 5701:\n    case 4933:\n    case 4677:\n    case 5533:\n    case 5789:\n    case 5021:\n    case 4765:\n      if (mt(e) - 1 - t > 6) switch (Be(e, t + 1)) {\n        // (m)ax-content, (m)in-content\n        case 109:\n          if (Be(e, t + 4) !== 45) break;\n        // (f)ill-available, (f)it-content\n        case 102:\n          return de(e, /(.+:)(.+)-([^]+)/, \"$1\" + fe + \"$2-$3$1\" + dn + (Be(e, t + 3) == 108 ? \"$3\" : \"$2-$3\")) + e;\n        // (s)tretch\n        case 115:\n          return ~oo(e, \"stretch\") ? Ra(de(e, \"stretch\", \"fill-available\"), t) + e : e;\n      }\n      break;\n    // position: sticky\n    case 4949:\n      if (Be(e, t + 1) !== 115) break;\n    // display: (flex|inline-flex)\n    case 6444:\n      switch (Be(e, mt(e) - 3 - (~oo(e, \"!important\") && 10))) {\n        // stic(k)y\n        case 107:\n          return de(e, \":\", \":\" + fe) + e;\n        // (inline-)?fl(e)x\n        case 101:\n          return de(e, /(.+:)([^;!]+)(;|!.+)?/, \"$1\" + fe + (Be(e, 14) === 45 ? \"inline-\" : \"\") + \"box$3$1\" + fe + \"$2$3$1\" + Ye + \"$2box$3\") + e;\n      }\n      break;\n    // writing-mode\n    case 5936:\n      switch (Be(e, t + 11)) {\n        // vertical-l(r)\n        case 114:\n          return fe + e + Ye + de(e, /[svh]\\w+-[tblr]{2}/, \"tb\") + e;\n        // vertical-r(l)\n        case 108:\n          return fe + e + Ye + de(e, /[svh]\\w+-[tblr]{2}/, \"tb-rl\") + e;\n        // horizontal(-)tb\n        case 45:\n          return fe + e + Ye + de(e, /[svh]\\w+-[tblr]{2}/, \"lr\") + e;\n      }\n      return fe + e + Ye + e + e;\n  }\n  return e;\n}\nvar Ac = function(t, r, n, o) {\n  if (t.length > -1 && !t.return) switch (t.type) {\n    case Eo:\n      t.return = Ra(t.value, t.length);\n      break;\n    case Sa:\n      return Xt([dr(t, {\n        value: de(t.value, \"@\", \"@\" + fe)\n      })], o);\n    case So:\n      if (t.length) return mc(t.props, function(i) {\n        switch (pc(i, /(::plac\\w+|:read-\\w+)/)) {\n          // :read-(only|write)\n          case \":read-only\":\n          case \":read-write\":\n            return Xt([dr(t, {\n              props: [de(i, /:(read-\\w+)/, \":\" + dn + \"$1\")]\n            })], o);\n          // :placeholder\n          case \"::placeholder\":\n            return Xt([dr(t, {\n              props: [de(i, /:(plac\\w+)/, \":\" + fe + \"input-$1\")]\n            }), dr(t, {\n              props: [de(i, /:(plac\\w+)/, \":\" + dn + \"$1\")]\n            }), dr(t, {\n              props: [de(i, /:(plac\\w+)/, Ye + \"input-$1\")]\n            })], o);\n        }\n        return \"\";\n      });\n  }\n}, Nc = [Ac], Mc = function(t) {\n  var r = t.key;\n  if (r === \"css\") {\n    var n = document.querySelectorAll(\"style[data-emotion]:not([data-s])\");\n    Array.prototype.forEach.call(n, function(f) {\n      var S = f.getAttribute(\"data-emotion\");\n      S.indexOf(\" \") !== -1 && (document.head.appendChild(f), f.setAttribute(\"data-s\", \"\"));\n    });\n  }\n  var o = t.stylisPlugins || Nc, i = {}, s, c = [];\n  s = t.container || document.head, Array.prototype.forEach.call(\n    // this means we will ignore elements which don't have a space in them which\n    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements\n    document.querySelectorAll('style[data-emotion^=\"' + r + ' \"]'),\n    function(f) {\n      for (var S = f.getAttribute(\"data-emotion\").split(\" \"), E = 1; E < S.length; E++)\n        i[S[E]] = !0;\n      c.push(f);\n    }\n  );\n  var l, u = [Pc, kc];\n  {\n    var p, m = [Cc, wc(function(f) {\n      p.insert(f);\n    })], g = Tc(u.concat(o, m)), x = function(S) {\n      return Xt(Sc(S), g);\n    };\n    l = function(S, E, P, T) {\n      p = P, x(S ? S + \"{\" + E.styles + \"}\" : E.styles), T && (y.inserted[E.name] = !0);\n    };\n  }\n  var y = {\n    key: r,\n    sheet: new sc({\n      key: r,\n      container: s,\n      nonce: t.nonce,\n      speedy: t.speedy,\n      prepend: t.prepend,\n      insertionPoint: t.insertionPoint\n    }),\n    nonce: t.nonce,\n    inserted: i,\n    registered: {},\n    insert: l\n  };\n  return y.sheet.hydrate(c), y;\n}, Hr = { exports: {} }, pe = {};\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar di;\nfunction Ic() {\n  if (di) return pe;\n  di = 1;\n  var e = typeof Symbol == \"function\" && Symbol.for, t = e ? Symbol.for(\"react.element\") : 60103, r = e ? Symbol.for(\"react.portal\") : 60106, n = e ? Symbol.for(\"react.fragment\") : 60107, o = e ? Symbol.for(\"react.strict_mode\") : 60108, i = e ? Symbol.for(\"react.profiler\") : 60114, s = e ? Symbol.for(\"react.provider\") : 60109, c = e ? Symbol.for(\"react.context\") : 60110, l = e ? Symbol.for(\"react.async_mode\") : 60111, u = e ? Symbol.for(\"react.concurrent_mode\") : 60111, p = e ? Symbol.for(\"react.forward_ref\") : 60112, m = e ? Symbol.for(\"react.suspense\") : 60113, g = e ? Symbol.for(\"react.suspense_list\") : 60120, x = e ? Symbol.for(\"react.memo\") : 60115, y = e ? Symbol.for(\"react.lazy\") : 60116, f = e ? Symbol.for(\"react.block\") : 60121, S = e ? Symbol.for(\"react.fundamental\") : 60117, E = e ? Symbol.for(\"react.responder\") : 60118, P = e ? Symbol.for(\"react.scope\") : 60119;\n  function T(h) {\n    if (typeof h == \"object\" && h !== null) {\n      var w = h.$$typeof;\n      switch (w) {\n        case t:\n          switch (h = h.type, h) {\n            case l:\n            case u:\n            case n:\n            case i:\n            case o:\n            case m:\n              return h;\n            default:\n              switch (h = h && h.$$typeof, h) {\n                case c:\n                case p:\n                case y:\n                case x:\n                case s:\n                  return h;\n                default:\n                  return w;\n              }\n          }\n        case r:\n          return w;\n      }\n    }\n  }\n  function b(h) {\n    return T(h) === u;\n  }\n  return pe.AsyncMode = l, pe.ConcurrentMode = u, pe.ContextConsumer = c, pe.ContextProvider = s, pe.Element = t, pe.ForwardRef = p, pe.Fragment = n, pe.Lazy = y, pe.Memo = x, pe.Portal = r, pe.Profiler = i, pe.StrictMode = o, pe.Suspense = m, pe.isAsyncMode = function(h) {\n    return b(h) || T(h) === l;\n  }, pe.isConcurrentMode = b, pe.isContextConsumer = function(h) {\n    return T(h) === c;\n  }, pe.isContextProvider = function(h) {\n    return T(h) === s;\n  }, pe.isElement = function(h) {\n    return typeof h == \"object\" && h !== null && h.$$typeof === t;\n  }, pe.isForwardRef = function(h) {\n    return T(h) === p;\n  }, pe.isFragment = function(h) {\n    return T(h) === n;\n  }, pe.isLazy = function(h) {\n    return T(h) === y;\n  }, pe.isMemo = function(h) {\n    return T(h) === x;\n  }, pe.isPortal = function(h) {\n    return T(h) === r;\n  }, pe.isProfiler = function(h) {\n    return T(h) === i;\n  }, pe.isStrictMode = function(h) {\n    return T(h) === o;\n  }, pe.isSuspense = function(h) {\n    return T(h) === m;\n  }, pe.isValidElementType = function(h) {\n    return typeof h == \"string\" || typeof h == \"function\" || h === n || h === u || h === i || h === o || h === m || h === g || typeof h == \"object\" && h !== null && (h.$$typeof === y || h.$$typeof === x || h.$$typeof === s || h.$$typeof === c || h.$$typeof === p || h.$$typeof === S || h.$$typeof === E || h.$$typeof === P || h.$$typeof === f);\n  }, pe.typeOf = T, pe;\n}\nvar me = {};\n/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar pi;\nfunction _c() {\n  return pi || (pi = 1,  true && function() {\n    var e = typeof Symbol == \"function\" && Symbol.for, t = e ? Symbol.for(\"react.element\") : 60103, r = e ? Symbol.for(\"react.portal\") : 60106, n = e ? Symbol.for(\"react.fragment\") : 60107, o = e ? Symbol.for(\"react.strict_mode\") : 60108, i = e ? Symbol.for(\"react.profiler\") : 60114, s = e ? Symbol.for(\"react.provider\") : 60109, c = e ? Symbol.for(\"react.context\") : 60110, l = e ? Symbol.for(\"react.async_mode\") : 60111, u = e ? Symbol.for(\"react.concurrent_mode\") : 60111, p = e ? Symbol.for(\"react.forward_ref\") : 60112, m = e ? Symbol.for(\"react.suspense\") : 60113, g = e ? Symbol.for(\"react.suspense_list\") : 60120, x = e ? Symbol.for(\"react.memo\") : 60115, y = e ? Symbol.for(\"react.lazy\") : 60116, f = e ? Symbol.for(\"react.block\") : 60121, S = e ? Symbol.for(\"react.fundamental\") : 60117, E = e ? Symbol.for(\"react.responder\") : 60118, P = e ? Symbol.for(\"react.scope\") : 60119;\n    function T(O) {\n      return typeof O == \"string\" || typeof O == \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n      O === n || O === u || O === i || O === o || O === m || O === g || typeof O == \"object\" && O !== null && (O.$$typeof === y || O.$$typeof === x || O.$$typeof === s || O.$$typeof === c || O.$$typeof === p || O.$$typeof === S || O.$$typeof === E || O.$$typeof === P || O.$$typeof === f);\n    }\n    function b(O) {\n      if (typeof O == \"object\" && O !== null) {\n        var ye = O.$$typeof;\n        switch (ye) {\n          case t:\n            var Ee = O.type;\n            switch (Ee) {\n              case l:\n              case u:\n              case n:\n              case i:\n              case o:\n              case m:\n                return Ee;\n              default:\n                var Me = Ee && Ee.$$typeof;\n                switch (Me) {\n                  case c:\n                  case p:\n                  case y:\n                  case x:\n                  case s:\n                    return Me;\n                  default:\n                    return ye;\n                }\n            }\n          case r:\n            return ye;\n        }\n      }\n    }\n    var h = l, w = u, k = c, L = s, B = t, d = p, A = n, D = y, j = x, W = r, z = i, U = o, V = m, te = !1;\n    function F(O) {\n      return te || (te = !0, console.warn(\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\")), R(O) || b(O) === l;\n    }\n    function R(O) {\n      return b(O) === u;\n    }\n    function I(O) {\n      return b(O) === c;\n    }\n    function J(O) {\n      return b(O) === s;\n    }\n    function Q(O) {\n      return typeof O == \"object\" && O !== null && O.$$typeof === t;\n    }\n    function H(O) {\n      return b(O) === p;\n    }\n    function X(O) {\n      return b(O) === n;\n    }\n    function _(O) {\n      return b(O) === y;\n    }\n    function q(O) {\n      return b(O) === x;\n    }\n    function G(O) {\n      return b(O) === r;\n    }\n    function re(O) {\n      return b(O) === i;\n    }\n    function Z(O) {\n      return b(O) === o;\n    }\n    function ae(O) {\n      return b(O) === m;\n    }\n    me.AsyncMode = h, me.ConcurrentMode = w, me.ContextConsumer = k, me.ContextProvider = L, me.Element = B, me.ForwardRef = d, me.Fragment = A, me.Lazy = D, me.Memo = j, me.Portal = W, me.Profiler = z, me.StrictMode = U, me.Suspense = V, me.isAsyncMode = F, me.isConcurrentMode = R, me.isContextConsumer = I, me.isContextProvider = J, me.isElement = Q, me.isForwardRef = H, me.isFragment = X, me.isLazy = _, me.isMemo = q, me.isPortal = G, me.isProfiler = re, me.isStrictMode = Z, me.isSuspense = ae, me.isValidElementType = T, me.typeOf = b;\n  }()), me;\n}\nvar mi;\nfunction jc() {\n  return mi || (mi = 1,  false ? 0 : Hr.exports = _c()), Hr.exports;\n}\nvar Yn, hi;\nfunction Dc() {\n  if (hi) return Yn;\n  hi = 1;\n  var e = jc(), t = {\n    childContextTypes: !0,\n    contextType: !0,\n    contextTypes: !0,\n    defaultProps: !0,\n    displayName: !0,\n    getDefaultProps: !0,\n    getDerivedStateFromError: !0,\n    getDerivedStateFromProps: !0,\n    mixins: !0,\n    propTypes: !0,\n    type: !0\n  }, r = {\n    name: !0,\n    length: !0,\n    prototype: !0,\n    caller: !0,\n    callee: !0,\n    arguments: !0,\n    arity: !0\n  }, n = {\n    $$typeof: !0,\n    render: !0,\n    defaultProps: !0,\n    displayName: !0,\n    propTypes: !0\n  }, o = {\n    $$typeof: !0,\n    compare: !0,\n    defaultProps: !0,\n    displayName: !0,\n    propTypes: !0,\n    type: !0\n  }, i = {};\n  i[e.ForwardRef] = n, i[e.Memo] = o;\n  function s(y) {\n    return e.isMemo(y) ? o : i[y.$$typeof] || t;\n  }\n  var c = Object.defineProperty, l = Object.getOwnPropertyNames, u = Object.getOwnPropertySymbols, p = Object.getOwnPropertyDescriptor, m = Object.getPrototypeOf, g = Object.prototype;\n  function x(y, f, S) {\n    if (typeof f != \"string\") {\n      if (g) {\n        var E = m(f);\n        E && E !== g && x(y, E, S);\n      }\n      var P = l(f);\n      u && (P = P.concat(u(f)));\n      for (var T = s(y), b = s(f), h = 0; h < P.length; ++h) {\n        var w = P[h];\n        if (!r[w] && !(S && S[w]) && !(b && b[w]) && !(T && T[w])) {\n          var k = p(f, w);\n          try {\n            c(y, w, k);\n          } catch {\n          }\n        }\n      }\n    }\n    return y;\n  }\n  return Yn = x, Yn;\n}\nDc();\nvar Lc = !0;\nfunction $a(e, t, r) {\n  var n = \"\";\n  return r.split(\" \").forEach(function(o) {\n    e[o] !== void 0 ? t.push(e[o] + \";\") : o && (n += o + \" \");\n  }), n;\n}\nvar To = function(t, r, n) {\n  var o = t.key + \"-\" + r.name;\n  // we only need to add the styles to the registered cache if the\n  // class name could be used further down\n  // the tree but if it's a string tag, we know it won't\n  // so we don't have to add it to registered cache.\n  // this improves memory usage since we can avoid storing the whole style string\n  (n === !1 || // we need to always store it if we're in compat mode and\n  // in node since emotion-server relies on whether a style is in\n  // the registered cache to know whether a style is global or not\n  // also, note that this check will be dead code eliminated in the browser\n  Lc === !1) && t.registered[o] === void 0 && (t.registered[o] = r.styles);\n}, wo = function(t, r, n) {\n  To(t, r, n);\n  var o = t.key + \"-\" + r.name;\n  if (t.inserted[r.name] === void 0) {\n    var i = r;\n    do\n      t.insert(r === i ? \".\" + o : \"\", i, t.sheet, !0), i = i.next;\n    while (i !== void 0);\n  }\n};\nfunction Bc(e) {\n  for (var t = 0, r, n = 0, o = e.length; o >= 4; ++n, o -= 4)\n    r = e.charCodeAt(n) & 255 | (e.charCodeAt(++n) & 255) << 8 | (e.charCodeAt(++n) & 255) << 16 | (e.charCodeAt(++n) & 255) << 24, r = /* Math.imul(k, m): */\n    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= /* k >>> r: */\n    r >>> 24, t = /* Math.imul(k, m): */\n    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */\n    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);\n  switch (o) {\n    case 3:\n      t ^= (e.charCodeAt(n + 2) & 255) << 16;\n    case 2:\n      t ^= (e.charCodeAt(n + 1) & 255) << 8;\n    case 1:\n      t ^= e.charCodeAt(n) & 255, t = /* Math.imul(h, m): */\n      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);\n  }\n  return t ^= t >>> 13, t = /* Math.imul(h, m): */\n  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);\n}\nvar Vc = {\n  animationIterationCount: 1,\n  aspectRatio: 1,\n  borderImageOutset: 1,\n  borderImageSlice: 1,\n  borderImageWidth: 1,\n  boxFlex: 1,\n  boxFlexGroup: 1,\n  boxOrdinalGroup: 1,\n  columnCount: 1,\n  columns: 1,\n  flex: 1,\n  flexGrow: 1,\n  flexPositive: 1,\n  flexShrink: 1,\n  flexNegative: 1,\n  flexOrder: 1,\n  gridRow: 1,\n  gridRowEnd: 1,\n  gridRowSpan: 1,\n  gridRowStart: 1,\n  gridColumn: 1,\n  gridColumnEnd: 1,\n  gridColumnSpan: 1,\n  gridColumnStart: 1,\n  msGridRow: 1,\n  msGridRowSpan: 1,\n  msGridColumn: 1,\n  msGridColumnSpan: 1,\n  fontWeight: 1,\n  lineHeight: 1,\n  opacity: 1,\n  order: 1,\n  orphans: 1,\n  scale: 1,\n  tabSize: 1,\n  widows: 1,\n  zIndex: 1,\n  zoom: 1,\n  WebkitLineClamp: 1,\n  // SVG-related properties\n  fillOpacity: 1,\n  floodOpacity: 1,\n  stopOpacity: 1,\n  strokeDasharray: 1,\n  strokeDashoffset: 1,\n  strokeMiterlimit: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1\n}, Fc = /[A-Z]|^ms/g, zc = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Pa = function(t) {\n  return t.charCodeAt(1) === 45;\n}, gi = function(t) {\n  return t != null && typeof t != \"boolean\";\n}, Hn = /* @__PURE__ */ Oa(function(e) {\n  return Pa(e) ? e : e.replace(Fc, \"-$&\").toLowerCase();\n}), yi = function(t, r) {\n  switch (t) {\n    case \"animation\":\n    case \"animationName\":\n      if (typeof r == \"string\")\n        return r.replace(zc, function(n, o, i) {\n          return ht = {\n            name: o,\n            styles: i,\n            next: ht\n          }, o;\n        });\n  }\n  return Vc[t] !== 1 && !Pa(t) && typeof r == \"number\" && r !== 0 ? r + \"px\" : r;\n};\nfunction wr(e, t, r) {\n  if (r == null)\n    return \"\";\n  var n = r;\n  if (n.__emotion_styles !== void 0)\n    return n;\n  switch (typeof r) {\n    case \"boolean\":\n      return \"\";\n    case \"object\": {\n      var o = r;\n      if (o.anim === 1)\n        return ht = {\n          name: o.name,\n          styles: o.styles,\n          next: ht\n        }, o.name;\n      var i = r;\n      if (i.styles !== void 0) {\n        var s = i.next;\n        if (s !== void 0)\n          for (; s !== void 0; )\n            ht = {\n              name: s.name,\n              styles: s.styles,\n              next: ht\n            }, s = s.next;\n        var c = i.styles + \";\";\n        return c;\n      }\n      return Wc(e, t, r);\n    }\n    case \"function\": {\n      if (e !== void 0) {\n        var l = ht, u = r(e);\n        return ht = l, wr(e, t, u);\n      }\n      break;\n    }\n  }\n  var p = r;\n  if (t == null)\n    return p;\n  var m = t[p];\n  return m !== void 0 ? m : p;\n}\nfunction Wc(e, t, r) {\n  var n = \"\";\n  if (Array.isArray(r))\n    for (var o = 0; o < r.length; o++)\n      n += wr(e, t, r[o]) + \";\";\n  else\n    for (var i in r) {\n      var s = r[i];\n      if (typeof s != \"object\") {\n        var c = s;\n        t != null && t[c] !== void 0 ? n += i + \"{\" + t[c] + \"}\" : gi(c) && (n += Hn(i) + \":\" + yi(i, c) + \";\");\n      } else if (Array.isArray(s) && typeof s[0] == \"string\" && (t == null || t[s[0]] === void 0))\n        for (var l = 0; l < s.length; l++)\n          gi(s[l]) && (n += Hn(i) + \":\" + yi(i, s[l]) + \";\");\n      else {\n        var u = wr(e, t, s);\n        switch (i) {\n          case \"animation\":\n          case \"animationName\": {\n            n += Hn(i) + \":\" + u + \";\";\n            break;\n          }\n          default:\n            n += i + \"{\" + u + \"}\";\n        }\n      }\n    }\n  return n;\n}\nvar bi = /label:\\s*([^\\s;{]+)\\s*(;|$)/g, ht;\nfunction Nr(e, t, r) {\n  if (e.length === 1 && typeof e[0] == \"object\" && e[0] !== null && e[0].styles !== void 0)\n    return e[0];\n  var n = !0, o = \"\";\n  ht = void 0;\n  var i = e[0];\n  if (i == null || i.raw === void 0)\n    n = !1, o += wr(r, t, i);\n  else {\n    var s = i;\n    o += s[0];\n  }\n  for (var c = 1; c < e.length; c++)\n    if (o += wr(r, t, e[c]), n) {\n      var l = i;\n      o += l[c];\n    }\n  bi.lastIndex = 0;\n  for (var u = \"\", p; (p = bi.exec(o)) !== null; )\n    u += \"-\" + p[1];\n  var m = Bc(o) + u;\n  return {\n    name: m,\n    styles: o,\n    next: ht\n  };\n}\nvar Uc = function(t) {\n  return t();\n}, ka = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ? react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect : !1, Aa = ka || Uc, vi = ka || react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect, Na = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(\n  // we're doing this to avoid preconstruct's dead code elimination in this one case\n  // because this module is primarily intended for the browser and node\n  // but it's also required in react native and similar environments sometimes\n  // and we could have a special build just for that\n  // but this is much easier and the native packages\n  // might use a different theme context in the future anyway\n  typeof HTMLElement < \"u\" ? /* @__PURE__ */ Mc({\n    key: \"css\"\n  }) : null\n);\nNa.Provider;\nvar Oo = function(t) {\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(r, n) {\n    var o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Na);\n    return t(r, o, n);\n  });\n}, Mr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext({}), Ro = {}.hasOwnProperty, ao = \"__EMOTION_TYPE_PLEASE_DO_NOT_USE__\", Yc = function(t, r) {\n  var n = {};\n  for (var o in r)\n    Ro.call(r, o) && (n[o] = r[o]);\n  return n[ao] = t, n;\n}, Hc = function(t) {\n  var r = t.cache, n = t.serialized, o = t.isStringTag;\n  return To(r, n, o), Aa(function() {\n    return wo(r, n, o);\n  }), null;\n}, qc = /* @__PURE__ */ Oo(function(e, t, r) {\n  var n = e.css;\n  typeof n == \"string\" && t.registered[n] !== void 0 && (n = t.registered[n]);\n  var o = e[ao], i = [n], s = \"\";\n  typeof e.className == \"string\" ? s = $a(t.registered, i, e.className) : e.className != null && (s = e.className + \" \");\n  var c = Nr(i, void 0, react__WEBPACK_IMPORTED_MODULE_0__.useContext(Mr));\n  s += t.key + \"-\" + c.name;\n  var l = {};\n  for (var u in e)\n    Ro.call(e, u) && u !== \"css\" && u !== ao && (l[u] = e[u]);\n  return l.className = s, r && (l.ref = r), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Hc, {\n    cache: t,\n    serialized: c,\n    isStringTag: typeof o == \"string\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(o, l));\n}), Gc = qc, Kc = function(t, r) {\n  var n = arguments;\n  if (r == null || !Ro.call(r, \"css\"))\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(void 0, n);\n  var o = n.length, i = new Array(o);\n  i[0] = Gc, i[1] = Yc(t, r);\n  for (var s = 2; s < o; s++)\n    i[s] = n[s];\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(null, i);\n};\n(function(e) {\n  var t;\n  t || (t = e.JSX || (e.JSX = {}));\n})(Kc);\nvar Xc = /* @__PURE__ */ Oo(function(e, t) {\n  var r = e.styles, n = Nr([r], void 0, react__WEBPACK_IMPORTED_MODULE_0__.useContext(Mr)), o = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  return vi(function() {\n    var i = t.key + \"-global\", s = new t.sheet.constructor({\n      key: i,\n      nonce: t.sheet.nonce,\n      container: t.sheet.container,\n      speedy: t.sheet.isSpeedy\n    }), c = !1, l = document.querySelector('style[data-emotion=\"' + i + \" \" + n.name + '\"]');\n    return t.sheet.tags.length && (s.before = t.sheet.tags[0]), l !== null && (c = !0, l.setAttribute(\"data-emotion\", i), s.hydrate([l])), o.current = [s, c], function() {\n      s.flush();\n    };\n  }, [t]), vi(function() {\n    var i = o.current, s = i[0], c = i[1];\n    if (c) {\n      i[1] = !1;\n      return;\n    }\n    if (n.next !== void 0 && wo(t, n.next, !0), s.tags.length) {\n      var l = s.tags[s.tags.length - 1].nextElementSibling;\n      s.before = l, s.flush();\n    }\n    t.insert(\"\", n, s, !1);\n  }, [t, n.name]), null;\n});\nfunction $o() {\n  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)\n    t[r] = arguments[r];\n  return Nr(t);\n}\nfunction Ir() {\n  var e = $o.apply(void 0, arguments), t = \"animation-\" + e.name;\n  return {\n    name: t,\n    styles: \"@keyframes \" + t + \"{\" + e.styles + \"}\",\n    anim: 1,\n    toString: function() {\n      return \"_EMO_\" + this.name + \"_\" + this.styles + \"_EMO_\";\n    }\n  };\n}\nvar Jc = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, Qc = /* @__PURE__ */ Oa(\n  function(e) {\n    return Jc.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;\n  }\n  /* Z+1 */\n), Zc = Qc, el = function(t) {\n  return t !== \"theme\";\n}, xi = function(t) {\n  return typeof t == \"string\" && // 96 is one less than the char code\n  // for \"a\" so this is checking that\n  // it's a lowercase character\n  t.charCodeAt(0) > 96 ? Zc : el;\n}, Si = function(t, r, n) {\n  var o;\n  if (r) {\n    var i = r.shouldForwardProp;\n    o = t.__emotion_forwardProp && i ? function(s) {\n      return t.__emotion_forwardProp(s) && i(s);\n    } : i;\n  }\n  return typeof o != \"function\" && n && (o = t.__emotion_forwardProp), o;\n}, tl = function(t) {\n  var r = t.cache, n = t.serialized, o = t.isStringTag;\n  return To(r, n, o), Aa(function() {\n    return wo(r, n, o);\n  }), null;\n}, rl = function e(t, r) {\n  var n = t.__emotion_real === t, o = n && t.__emotion_base || t, i, s;\n  r !== void 0 && (i = r.label, s = r.target);\n  var c = Si(t, r, n), l = c || xi(o), u = !l(\"as\");\n  return function() {\n    var p = arguments, m = n && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];\n    if (i !== void 0 && m.push(\"label:\" + i + \";\"), p[0] == null || p[0].raw === void 0)\n      m.push.apply(m, p);\n    else {\n      var g = p[0];\n      m.push(g[0]);\n      for (var x = p.length, y = 1; y < x; y++)\n        m.push(p[y], g[y]);\n    }\n    var f = Oo(function(S, E, P) {\n      var T = u && S.as || o, b = \"\", h = [], w = S;\n      if (S.theme == null) {\n        w = {};\n        for (var k in S)\n          w[k] = S[k];\n        w.theme = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Mr);\n      }\n      typeof S.className == \"string\" ? b = $a(E.registered, h, S.className) : S.className != null && (b = S.className + \" \");\n      var L = Nr(m.concat(h), E.registered, w);\n      b += E.key + \"-\" + L.name, s !== void 0 && (b += \" \" + s);\n      var B = u && c === void 0 ? xi(T) : l, d = {};\n      for (var A in S)\n        u && A === \"as\" || B(A) && (d[A] = S[A]);\n      return d.className = b, P && (d.ref = P), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(tl, {\n        cache: E,\n        serialized: L,\n        isStringTag: typeof T == \"string\"\n      }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(T, d));\n    });\n    return f.displayName = i !== void 0 ? i : \"Styled(\" + (typeof o == \"string\" ? o : o.displayName || o.name || \"Component\") + \")\", f.defaultProps = t.defaultProps, f.__emotion_real = f, f.__emotion_base = o, f.__emotion_styles = m, f.__emotion_forwardProp = c, Object.defineProperty(f, \"toString\", {\n      value: function() {\n        return \".\" + s;\n      }\n    }), f.withComponent = function(S, E) {\n      var P = e(S, fn({}, r, E, {\n        shouldForwardProp: Si(f, E, !0)\n      }));\n      return P.apply(void 0, m);\n    }, f;\n  };\n}, nl = [\n  \"a\",\n  \"abbr\",\n  \"address\",\n  \"area\",\n  \"article\",\n  \"aside\",\n  \"audio\",\n  \"b\",\n  \"base\",\n  \"bdi\",\n  \"bdo\",\n  \"big\",\n  \"blockquote\",\n  \"body\",\n  \"br\",\n  \"button\",\n  \"canvas\",\n  \"caption\",\n  \"cite\",\n  \"code\",\n  \"col\",\n  \"colgroup\",\n  \"data\",\n  \"datalist\",\n  \"dd\",\n  \"del\",\n  \"details\",\n  \"dfn\",\n  \"dialog\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"em\",\n  \"embed\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"footer\",\n  \"form\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"head\",\n  \"header\",\n  \"hgroup\",\n  \"hr\",\n  \"html\",\n  \"i\",\n  \"iframe\",\n  \"img\",\n  \"input\",\n  \"ins\",\n  \"kbd\",\n  \"keygen\",\n  \"label\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"map\",\n  \"mark\",\n  \"marquee\",\n  \"menu\",\n  \"menuitem\",\n  \"meta\",\n  \"meter\",\n  \"nav\",\n  \"noscript\",\n  \"object\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"p\",\n  \"param\",\n  \"picture\",\n  \"pre\",\n  \"progress\",\n  \"q\",\n  \"rp\",\n  \"rt\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"script\",\n  \"section\",\n  \"select\",\n  \"small\",\n  \"source\",\n  \"span\",\n  \"strong\",\n  \"style\",\n  \"sub\",\n  \"summary\",\n  \"sup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"textarea\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"time\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"u\",\n  \"ul\",\n  \"var\",\n  \"video\",\n  \"wbr\",\n  // SVG\n  \"circle\",\n  \"clipPath\",\n  \"defs\",\n  \"ellipse\",\n  \"foreignObject\",\n  \"g\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"mask\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"stop\",\n  \"svg\",\n  \"text\",\n  \"tspan\"\n], so = rl.bind(null);\nnl.forEach(function(e) {\n  so[e] = so(e);\n});\nvar qr = { exports: {} }, Gr = { exports: {} }, he = {};\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Ei;\nfunction ol() {\n  if (Ei) return he;\n  Ei = 1;\n  var e = typeof Symbol == \"function\" && Symbol.for, t = e ? Symbol.for(\"react.element\") : 60103, r = e ? Symbol.for(\"react.portal\") : 60106, n = e ? Symbol.for(\"react.fragment\") : 60107, o = e ? Symbol.for(\"react.strict_mode\") : 60108, i = e ? Symbol.for(\"react.profiler\") : 60114, s = e ? Symbol.for(\"react.provider\") : 60109, c = e ? Symbol.for(\"react.context\") : 60110, l = e ? Symbol.for(\"react.async_mode\") : 60111, u = e ? Symbol.for(\"react.concurrent_mode\") : 60111, p = e ? Symbol.for(\"react.forward_ref\") : 60112, m = e ? Symbol.for(\"react.suspense\") : 60113, g = e ? Symbol.for(\"react.suspense_list\") : 60120, x = e ? Symbol.for(\"react.memo\") : 60115, y = e ? Symbol.for(\"react.lazy\") : 60116, f = e ? Symbol.for(\"react.block\") : 60121, S = e ? Symbol.for(\"react.fundamental\") : 60117, E = e ? Symbol.for(\"react.responder\") : 60118, P = e ? Symbol.for(\"react.scope\") : 60119;\n  function T(h) {\n    if (typeof h == \"object\" && h !== null) {\n      var w = h.$$typeof;\n      switch (w) {\n        case t:\n          switch (h = h.type, h) {\n            case l:\n            case u:\n            case n:\n            case i:\n            case o:\n            case m:\n              return h;\n            default:\n              switch (h = h && h.$$typeof, h) {\n                case c:\n                case p:\n                case y:\n                case x:\n                case s:\n                  return h;\n                default:\n                  return w;\n              }\n          }\n        case r:\n          return w;\n      }\n    }\n  }\n  function b(h) {\n    return T(h) === u;\n  }\n  return he.AsyncMode = l, he.ConcurrentMode = u, he.ContextConsumer = c, he.ContextProvider = s, he.Element = t, he.ForwardRef = p, he.Fragment = n, he.Lazy = y, he.Memo = x, he.Portal = r, he.Profiler = i, he.StrictMode = o, he.Suspense = m, he.isAsyncMode = function(h) {\n    return b(h) || T(h) === l;\n  }, he.isConcurrentMode = b, he.isContextConsumer = function(h) {\n    return T(h) === c;\n  }, he.isContextProvider = function(h) {\n    return T(h) === s;\n  }, he.isElement = function(h) {\n    return typeof h == \"object\" && h !== null && h.$$typeof === t;\n  }, he.isForwardRef = function(h) {\n    return T(h) === p;\n  }, he.isFragment = function(h) {\n    return T(h) === n;\n  }, he.isLazy = function(h) {\n    return T(h) === y;\n  }, he.isMemo = function(h) {\n    return T(h) === x;\n  }, he.isPortal = function(h) {\n    return T(h) === r;\n  }, he.isProfiler = function(h) {\n    return T(h) === i;\n  }, he.isStrictMode = function(h) {\n    return T(h) === o;\n  }, he.isSuspense = function(h) {\n    return T(h) === m;\n  }, he.isValidElementType = function(h) {\n    return typeof h == \"string\" || typeof h == \"function\" || h === n || h === u || h === i || h === o || h === m || h === g || typeof h == \"object\" && h !== null && (h.$$typeof === y || h.$$typeof === x || h.$$typeof === s || h.$$typeof === c || h.$$typeof === p || h.$$typeof === S || h.$$typeof === E || h.$$typeof === P || h.$$typeof === f);\n  }, he.typeOf = T, he;\n}\nvar ge = {};\n/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Ci;\nfunction il() {\n  return Ci || (Ci = 1,  true && function() {\n    var e = typeof Symbol == \"function\" && Symbol.for, t = e ? Symbol.for(\"react.element\") : 60103, r = e ? Symbol.for(\"react.portal\") : 60106, n = e ? Symbol.for(\"react.fragment\") : 60107, o = e ? Symbol.for(\"react.strict_mode\") : 60108, i = e ? Symbol.for(\"react.profiler\") : 60114, s = e ? Symbol.for(\"react.provider\") : 60109, c = e ? Symbol.for(\"react.context\") : 60110, l = e ? Symbol.for(\"react.async_mode\") : 60111, u = e ? Symbol.for(\"react.concurrent_mode\") : 60111, p = e ? Symbol.for(\"react.forward_ref\") : 60112, m = e ? Symbol.for(\"react.suspense\") : 60113, g = e ? Symbol.for(\"react.suspense_list\") : 60120, x = e ? Symbol.for(\"react.memo\") : 60115, y = e ? Symbol.for(\"react.lazy\") : 60116, f = e ? Symbol.for(\"react.block\") : 60121, S = e ? Symbol.for(\"react.fundamental\") : 60117, E = e ? Symbol.for(\"react.responder\") : 60118, P = e ? Symbol.for(\"react.scope\") : 60119;\n    function T(O) {\n      return typeof O == \"string\" || typeof O == \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n      O === n || O === u || O === i || O === o || O === m || O === g || typeof O == \"object\" && O !== null && (O.$$typeof === y || O.$$typeof === x || O.$$typeof === s || O.$$typeof === c || O.$$typeof === p || O.$$typeof === S || O.$$typeof === E || O.$$typeof === P || O.$$typeof === f);\n    }\n    function b(O) {\n      if (typeof O == \"object\" && O !== null) {\n        var ye = O.$$typeof;\n        switch (ye) {\n          case t:\n            var Ee = O.type;\n            switch (Ee) {\n              case l:\n              case u:\n              case n:\n              case i:\n              case o:\n              case m:\n                return Ee;\n              default:\n                var Me = Ee && Ee.$$typeof;\n                switch (Me) {\n                  case c:\n                  case p:\n                  case y:\n                  case x:\n                  case s:\n                    return Me;\n                  default:\n                    return ye;\n                }\n            }\n          case r:\n            return ye;\n        }\n      }\n    }\n    var h = l, w = u, k = c, L = s, B = t, d = p, A = n, D = y, j = x, W = r, z = i, U = o, V = m, te = !1;\n    function F(O) {\n      return te || (te = !0, console.warn(\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\")), R(O) || b(O) === l;\n    }\n    function R(O) {\n      return b(O) === u;\n    }\n    function I(O) {\n      return b(O) === c;\n    }\n    function J(O) {\n      return b(O) === s;\n    }\n    function Q(O) {\n      return typeof O == \"object\" && O !== null && O.$$typeof === t;\n    }\n    function H(O) {\n      return b(O) === p;\n    }\n    function X(O) {\n      return b(O) === n;\n    }\n    function _(O) {\n      return b(O) === y;\n    }\n    function q(O) {\n      return b(O) === x;\n    }\n    function G(O) {\n      return b(O) === r;\n    }\n    function re(O) {\n      return b(O) === i;\n    }\n    function Z(O) {\n      return b(O) === o;\n    }\n    function ae(O) {\n      return b(O) === m;\n    }\n    ge.AsyncMode = h, ge.ConcurrentMode = w, ge.ContextConsumer = k, ge.ContextProvider = L, ge.Element = B, ge.ForwardRef = d, ge.Fragment = A, ge.Lazy = D, ge.Memo = j, ge.Portal = W, ge.Profiler = z, ge.StrictMode = U, ge.Suspense = V, ge.isAsyncMode = F, ge.isConcurrentMode = R, ge.isContextConsumer = I, ge.isContextProvider = J, ge.isElement = Q, ge.isForwardRef = H, ge.isFragment = X, ge.isLazy = _, ge.isMemo = q, ge.isPortal = G, ge.isProfiler = re, ge.isStrictMode = Z, ge.isSuspense = ae, ge.isValidElementType = T, ge.typeOf = b;\n  }()), ge;\n}\nvar Ti;\nfunction Ma() {\n  return Ti || (Ti = 1,  false ? 0 : Gr.exports = il()), Gr.exports;\n}\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar qn, wi;\nfunction al() {\n  if (wi) return qn;\n  wi = 1;\n  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable;\n  function n(i) {\n    if (i == null)\n      throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n    return Object(i);\n  }\n  function o() {\n    try {\n      if (!Object.assign)\n        return !1;\n      var i = new String(\"abc\");\n      if (i[5] = \"de\", Object.getOwnPropertyNames(i)[0] === \"5\")\n        return !1;\n      for (var s = {}, c = 0; c < 10; c++)\n        s[\"_\" + String.fromCharCode(c)] = c;\n      var l = Object.getOwnPropertyNames(s).map(function(p) {\n        return s[p];\n      });\n      if (l.join(\"\") !== \"0123456789\")\n        return !1;\n      var u = {};\n      return \"abcdefghijklmnopqrst\".split(\"\").forEach(function(p) {\n        u[p] = p;\n      }), Object.keys(Object.assign({}, u)).join(\"\") === \"abcdefghijklmnopqrst\";\n    } catch {\n      return !1;\n    }\n  }\n  return qn = o() ? Object.assign : function(i, s) {\n    for (var c, l = n(i), u, p = 1; p < arguments.length; p++) {\n      c = Object(arguments[p]);\n      for (var m in c)\n        t.call(c, m) && (l[m] = c[m]);\n      if (e) {\n        u = e(c);\n        for (var g = 0; g < u.length; g++)\n          r.call(c, u[g]) && (l[u[g]] = c[u[g]]);\n      }\n    }\n    return l;\n  }, qn;\n}\nvar Gn, Oi;\nfunction Po() {\n  if (Oi) return Gn;\n  Oi = 1;\n  var e = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n  return Gn = e, Gn;\n}\nvar Kn, Ri;\nfunction Ia() {\n  return Ri || (Ri = 1, Kn = Function.call.bind(Object.prototype.hasOwnProperty)), Kn;\n}\nvar Xn, $i;\nfunction sl() {\n  if ($i) return Xn;\n  $i = 1;\n  var e = function() {\n  };\n  if (true) {\n    var t = /* @__PURE__ */ Po(), r = {}, n = /* @__PURE__ */ Ia();\n    e = function(i) {\n      var s = \"Warning: \" + i;\n      typeof console < \"u\" && console.error(s);\n      try {\n        throw new Error(s);\n      } catch {\n      }\n    };\n  }\n  function o(i, s, c, l, u) {\n    if (true) {\n      for (var p in i)\n        if (n(i, p)) {\n          var m;\n          try {\n            if (typeof i[p] != \"function\") {\n              var g = Error(\n                (l || \"React class\") + \": \" + c + \" type `\" + p + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof i[p] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\"\n              );\n              throw g.name = \"Invariant Violation\", g;\n            }\n            m = i[p](s, p, l, c, null, t);\n          } catch (y) {\n            m = y;\n          }\n          if (m && !(m instanceof Error) && e(\n            (l || \"React class\") + \": type specification of \" + c + \" `\" + p + \"` is invalid; the type checker function must return `null` or an `Error` but returned a \" + typeof m + \". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\"\n          ), m instanceof Error && !(m.message in r)) {\n            r[m.message] = !0;\n            var x = u ? u() : \"\";\n            e(\n              \"Failed \" + c + \" type: \" + m.message + (x ?? \"\")\n            );\n          }\n        }\n    }\n  }\n  return o.resetWarningCache = function() {\n     true && (r = {});\n  }, Xn = o, Xn;\n}\nvar Jn, Pi;\nfunction cl() {\n  if (Pi) return Jn;\n  Pi = 1;\n  var e = Ma(), t = al(), r = /* @__PURE__ */ Po(), n = /* @__PURE__ */ Ia(), o = /* @__PURE__ */ sl(), i = function() {\n  };\n   true && (i = function(c) {\n    var l = \"Warning: \" + c;\n    typeof console < \"u\" && console.error(l);\n    try {\n      throw new Error(l);\n    } catch {\n    }\n  });\n  function s() {\n    return null;\n  }\n  return Jn = function(c, l) {\n    var u = typeof Symbol == \"function\" && Symbol.iterator, p = \"@@iterator\";\n    function m(R) {\n      var I = R && (u && R[u] || R[p]);\n      if (typeof I == \"function\")\n        return I;\n    }\n    var g = \"<<anonymous>>\", x = {\n      array: E(\"array\"),\n      bigint: E(\"bigint\"),\n      bool: E(\"boolean\"),\n      func: E(\"function\"),\n      number: E(\"number\"),\n      object: E(\"object\"),\n      string: E(\"string\"),\n      symbol: E(\"symbol\"),\n      any: P(),\n      arrayOf: T,\n      element: b(),\n      elementType: h(),\n      instanceOf: w,\n      node: d(),\n      objectOf: L,\n      oneOf: k,\n      oneOfType: B,\n      shape: D,\n      exact: j\n    };\n    function y(R, I) {\n      return R === I ? R !== 0 || 1 / R === 1 / I : R !== R && I !== I;\n    }\n    function f(R, I) {\n      this.message = R, this.data = I && typeof I == \"object\" ? I : {}, this.stack = \"\";\n    }\n    f.prototype = Error.prototype;\n    function S(R) {\n      if (true)\n        var I = {}, J = 0;\n      function Q(X, _, q, G, re, Z, ae) {\n        if (G = G || g, Z = Z || q, ae !== r) {\n          if (l) {\n            var O = new Error(\n              \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types\"\n            );\n            throw O.name = \"Invariant Violation\", O;\n          } else if ( true && typeof console < \"u\") {\n            var ye = G + \":\" + q;\n            !I[ye] && // Avoid spamming the console because they are often not actionable except for lib authors\n            J < 3 && (i(\n              \"You are manually calling a React.PropTypes validation function for the `\" + Z + \"` prop on `\" + G + \"`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\"\n            ), I[ye] = !0, J++);\n          }\n        }\n        return _[q] == null ? X ? _[q] === null ? new f(\"The \" + re + \" `\" + Z + \"` is marked as required \" + (\"in `\" + G + \"`, but its value is `null`.\")) : new f(\"The \" + re + \" `\" + Z + \"` is marked as required in \" + (\"`\" + G + \"`, but its value is `undefined`.\")) : null : R(_, q, G, re, Z);\n      }\n      var H = Q.bind(null, !1);\n      return H.isRequired = Q.bind(null, !0), H;\n    }\n    function E(R) {\n      function I(J, Q, H, X, _, q) {\n        var G = J[Q], re = U(G);\n        if (re !== R) {\n          var Z = V(G);\n          return new f(\n            \"Invalid \" + X + \" `\" + _ + \"` of type \" + (\"`\" + Z + \"` supplied to `\" + H + \"`, expected \") + (\"`\" + R + \"`.\"),\n            { expectedType: R }\n          );\n        }\n        return null;\n      }\n      return S(I);\n    }\n    function P() {\n      return S(s);\n    }\n    function T(R) {\n      function I(J, Q, H, X, _) {\n        if (typeof R != \"function\")\n          return new f(\"Property `\" + _ + \"` of component `\" + H + \"` has invalid PropType notation inside arrayOf.\");\n        var q = J[Q];\n        if (!Array.isArray(q)) {\n          var G = U(q);\n          return new f(\"Invalid \" + X + \" `\" + _ + \"` of type \" + (\"`\" + G + \"` supplied to `\" + H + \"`, expected an array.\"));\n        }\n        for (var re = 0; re < q.length; re++) {\n          var Z = R(q, re, H, X, _ + \"[\" + re + \"]\", r);\n          if (Z instanceof Error)\n            return Z;\n        }\n        return null;\n      }\n      return S(I);\n    }\n    function b() {\n      function R(I, J, Q, H, X) {\n        var _ = I[J];\n        if (!c(_)) {\n          var q = U(_);\n          return new f(\"Invalid \" + H + \" `\" + X + \"` of type \" + (\"`\" + q + \"` supplied to `\" + Q + \"`, expected a single ReactElement.\"));\n        }\n        return null;\n      }\n      return S(R);\n    }\n    function h() {\n      function R(I, J, Q, H, X) {\n        var _ = I[J];\n        if (!e.isValidElementType(_)) {\n          var q = U(_);\n          return new f(\"Invalid \" + H + \" `\" + X + \"` of type \" + (\"`\" + q + \"` supplied to `\" + Q + \"`, expected a single ReactElement type.\"));\n        }\n        return null;\n      }\n      return S(R);\n    }\n    function w(R) {\n      function I(J, Q, H, X, _) {\n        if (!(J[Q] instanceof R)) {\n          var q = R.name || g, G = F(J[Q]);\n          return new f(\"Invalid \" + X + \" `\" + _ + \"` of type \" + (\"`\" + G + \"` supplied to `\" + H + \"`, expected \") + (\"instance of `\" + q + \"`.\"));\n        }\n        return null;\n      }\n      return S(I);\n    }\n    function k(R) {\n      if (!Array.isArray(R))\n        return  true && (arguments.length > 1 ? i(\n          \"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\"\n        ) : i(\"Invalid argument supplied to oneOf, expected an array.\")), s;\n      function I(J, Q, H, X, _) {\n        for (var q = J[Q], G = 0; G < R.length; G++)\n          if (y(q, R[G]))\n            return null;\n        var re = JSON.stringify(R, function(ae, O) {\n          var ye = V(O);\n          return ye === \"symbol\" ? String(O) : O;\n        });\n        return new f(\"Invalid \" + X + \" `\" + _ + \"` of value `\" + String(q) + \"` \" + (\"supplied to `\" + H + \"`, expected one of \" + re + \".\"));\n      }\n      return S(I);\n    }\n    function L(R) {\n      function I(J, Q, H, X, _) {\n        if (typeof R != \"function\")\n          return new f(\"Property `\" + _ + \"` of component `\" + H + \"` has invalid PropType notation inside objectOf.\");\n        var q = J[Q], G = U(q);\n        if (G !== \"object\")\n          return new f(\"Invalid \" + X + \" `\" + _ + \"` of type \" + (\"`\" + G + \"` supplied to `\" + H + \"`, expected an object.\"));\n        for (var re in q)\n          if (n(q, re)) {\n            var Z = R(q, re, H, X, _ + \".\" + re, r);\n            if (Z instanceof Error)\n              return Z;\n          }\n        return null;\n      }\n      return S(I);\n    }\n    function B(R) {\n      if (!Array.isArray(R))\n        return  true && i(\"Invalid argument supplied to oneOfType, expected an instance of array.\"), s;\n      for (var I = 0; I < R.length; I++) {\n        var J = R[I];\n        if (typeof J != \"function\")\n          return i(\n            \"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \" + te(J) + \" at index \" + I + \".\"\n          ), s;\n      }\n      function Q(H, X, _, q, G) {\n        for (var re = [], Z = 0; Z < R.length; Z++) {\n          var ae = R[Z], O = ae(H, X, _, q, G, r);\n          if (O == null)\n            return null;\n          O.data && n(O.data, \"expectedType\") && re.push(O.data.expectedType);\n        }\n        var ye = re.length > 0 ? \", expected one of type [\" + re.join(\", \") + \"]\" : \"\";\n        return new f(\"Invalid \" + q + \" `\" + G + \"` supplied to \" + (\"`\" + _ + \"`\" + ye + \".\"));\n      }\n      return S(Q);\n    }\n    function d() {\n      function R(I, J, Q, H, X) {\n        return W(I[J]) ? null : new f(\"Invalid \" + H + \" `\" + X + \"` supplied to \" + (\"`\" + Q + \"`, expected a ReactNode.\"));\n      }\n      return S(R);\n    }\n    function A(R, I, J, Q, H) {\n      return new f(\n        (R || \"React class\") + \": \" + I + \" type `\" + J + \".\" + Q + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + H + \"`.\"\n      );\n    }\n    function D(R) {\n      function I(J, Q, H, X, _) {\n        var q = J[Q], G = U(q);\n        if (G !== \"object\")\n          return new f(\"Invalid \" + X + \" `\" + _ + \"` of type `\" + G + \"` \" + (\"supplied to `\" + H + \"`, expected `object`.\"));\n        for (var re in R) {\n          var Z = R[re];\n          if (typeof Z != \"function\")\n            return A(H, X, _, re, V(Z));\n          var ae = Z(q, re, H, X, _ + \".\" + re, r);\n          if (ae)\n            return ae;\n        }\n        return null;\n      }\n      return S(I);\n    }\n    function j(R) {\n      function I(J, Q, H, X, _) {\n        var q = J[Q], G = U(q);\n        if (G !== \"object\")\n          return new f(\"Invalid \" + X + \" `\" + _ + \"` of type `\" + G + \"` \" + (\"supplied to `\" + H + \"`, expected `object`.\"));\n        var re = t({}, J[Q], R);\n        for (var Z in re) {\n          var ae = R[Z];\n          if (n(R, Z) && typeof ae != \"function\")\n            return A(H, X, _, Z, V(ae));\n          if (!ae)\n            return new f(\n              \"Invalid \" + X + \" `\" + _ + \"` key `\" + Z + \"` supplied to `\" + H + \"`.\\nBad object: \" + JSON.stringify(J[Q], null, \"  \") + `\nValid keys: ` + JSON.stringify(Object.keys(R), null, \"  \")\n            );\n          var O = ae(q, Z, H, X, _ + \".\" + Z, r);\n          if (O)\n            return O;\n        }\n        return null;\n      }\n      return S(I);\n    }\n    function W(R) {\n      switch (typeof R) {\n        case \"number\":\n        case \"string\":\n        case \"undefined\":\n          return !0;\n        case \"boolean\":\n          return !R;\n        case \"object\":\n          if (Array.isArray(R))\n            return R.every(W);\n          if (R === null || c(R))\n            return !0;\n          var I = m(R);\n          if (I) {\n            var J = I.call(R), Q;\n            if (I !== R.entries) {\n              for (; !(Q = J.next()).done; )\n                if (!W(Q.value))\n                  return !1;\n            } else\n              for (; !(Q = J.next()).done; ) {\n                var H = Q.value;\n                if (H && !W(H[1]))\n                  return !1;\n              }\n          } else\n            return !1;\n          return !0;\n        default:\n          return !1;\n      }\n    }\n    function z(R, I) {\n      return R === \"symbol\" ? !0 : I ? I[\"@@toStringTag\"] === \"Symbol\" || typeof Symbol == \"function\" && I instanceof Symbol : !1;\n    }\n    function U(R) {\n      var I = typeof R;\n      return Array.isArray(R) ? \"array\" : R instanceof RegExp ? \"object\" : z(I, R) ? \"symbol\" : I;\n    }\n    function V(R) {\n      if (typeof R > \"u\" || R === null)\n        return \"\" + R;\n      var I = U(R);\n      if (I === \"object\") {\n        if (R instanceof Date)\n          return \"date\";\n        if (R instanceof RegExp)\n          return \"regexp\";\n      }\n      return I;\n    }\n    function te(R) {\n      var I = V(R);\n      switch (I) {\n        case \"array\":\n        case \"object\":\n          return \"an \" + I;\n        case \"boolean\":\n        case \"date\":\n        case \"regexp\":\n          return \"a \" + I;\n        default:\n          return I;\n      }\n    }\n    function F(R) {\n      return !R.constructor || !R.constructor.name ? g : R.constructor.name;\n    }\n    return x.checkPropTypes = o, x.resetWarningCache = o.resetWarningCache, x.PropTypes = x, x;\n  }, Jn;\n}\nvar Qn, ki;\nfunction ll() {\n  if (ki) return Qn;\n  ki = 1;\n  var e = /* @__PURE__ */ Po();\n  function t() {\n  }\n  function r() {\n  }\n  return r.resetWarningCache = t, Qn = function() {\n    function n(s, c, l, u, p, m) {\n      if (m !== e) {\n        var g = new Error(\n          \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\"\n        );\n        throw g.name = \"Invariant Violation\", g;\n      }\n    }\n    n.isRequired = n;\n    function o() {\n      return n;\n    }\n    var i = {\n      array: n,\n      bigint: n,\n      bool: n,\n      func: n,\n      number: n,\n      object: n,\n      string: n,\n      symbol: n,\n      any: n,\n      arrayOf: o,\n      element: n,\n      elementType: n,\n      instanceOf: o,\n      node: n,\n      objectOf: o,\n      oneOf: o,\n      oneOfType: o,\n      shape: o,\n      exact: o,\n      checkPropTypes: r,\n      resetWarningCache: t\n    };\n    return i.PropTypes = i, i;\n  }, Qn;\n}\nvar Ai;\nfunction ul() {\n  if (Ai) return qr.exports;\n  if (Ai = 1, \"development\" !== \"production\") {\n    var e = Ma(), t = !0;\n    qr.exports = /* @__PURE__ */ cl()(e.isElement, t);\n  } else\n    qr.exports = /* @__PURE__ */ ll()();\n  return qr.exports;\n}\nvar fl = /* @__PURE__ */ ul();\nconst a = /* @__PURE__ */ ec(fl);\nfunction dl(e) {\n  return e == null || Object.keys(e).length === 0;\n}\nfunction _a(e) {\n  const {\n    styles: t,\n    defaultTheme: r = {}\n  } = e, n = typeof t == \"function\" ? (o) => t(dl(o) ? r : o) : t;\n  return /* @__PURE__ */ N.jsx(Xc, {\n    styles: n\n  });\n}\n true && (_a.propTypes = {\n  defaultTheme: a.object,\n  styles: a.oneOfType([a.array, a.string, a.object, a.func])\n});\n/**\n * @mui/styled-engine v6.4.0\n *\n * @license MIT\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nfunction ja(e, t) {\n  const r = so(e, t);\n  return  true ? (...n) => {\n    const o = typeof e == \"string\" ? `\"${e}\"` : \"component\";\n    return n.length === 0 ? console.error([`MUI: Seems like you called \\`styled(${o})()\\` without a \\`style\\` argument.`, 'You must provide a `styles` argument: `styled(\"div\")(styleYouForgotToPass)`.'].join(`\n`)) : n.some((i) => i === void 0) && console.error(`MUI: the styled(${o})(...args) API requires all its args to be defined.`), r(...n);\n  } : 0;\n}\nfunction pl(e, t) {\n  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));\n}\nconst Ni = [];\nfunction Mi(e) {\n  return Ni[0] = e, Nr(Ni);\n}\nvar Kr = { exports: {} }, xe = {};\n/**\n * @license React\n * react-is.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Ii;\nfunction ml() {\n  if (Ii) return xe;\n  Ii = 1;\n  var e = Symbol.for(\"react.transitional.element\"), t = Symbol.for(\"react.portal\"), r = Symbol.for(\"react.fragment\"), n = Symbol.for(\"react.strict_mode\"), o = Symbol.for(\"react.profiler\"), i = Symbol.for(\"react.consumer\"), s = Symbol.for(\"react.context\"), c = Symbol.for(\"react.forward_ref\"), l = Symbol.for(\"react.suspense\"), u = Symbol.for(\"react.suspense_list\"), p = Symbol.for(\"react.memo\"), m = Symbol.for(\"react.lazy\"), g = Symbol.for(\"react.offscreen\"), x = Symbol.for(\"react.client.reference\");\n  function y(f) {\n    if (typeof f == \"object\" && f !== null) {\n      var S = f.$$typeof;\n      switch (S) {\n        case e:\n          switch (f = f.type, f) {\n            case r:\n            case o:\n            case n:\n            case l:\n            case u:\n              return f;\n            default:\n              switch (f = f && f.$$typeof, f) {\n                case s:\n                case c:\n                case m:\n                case p:\n                  return f;\n                case i:\n                  return f;\n                default:\n                  return S;\n              }\n          }\n        case t:\n          return S;\n      }\n    }\n  }\n  return xe.ContextConsumer = i, xe.ContextProvider = s, xe.Element = e, xe.ForwardRef = c, xe.Fragment = r, xe.Lazy = m, xe.Memo = p, xe.Portal = t, xe.Profiler = o, xe.StrictMode = n, xe.Suspense = l, xe.SuspenseList = u, xe.isContextConsumer = function(f) {\n    return y(f) === i;\n  }, xe.isContextProvider = function(f) {\n    return y(f) === s;\n  }, xe.isElement = function(f) {\n    return typeof f == \"object\" && f !== null && f.$$typeof === e;\n  }, xe.isForwardRef = function(f) {\n    return y(f) === c;\n  }, xe.isFragment = function(f) {\n    return y(f) === r;\n  }, xe.isLazy = function(f) {\n    return y(f) === m;\n  }, xe.isMemo = function(f) {\n    return y(f) === p;\n  }, xe.isPortal = function(f) {\n    return y(f) === t;\n  }, xe.isProfiler = function(f) {\n    return y(f) === o;\n  }, xe.isStrictMode = function(f) {\n    return y(f) === n;\n  }, xe.isSuspense = function(f) {\n    return y(f) === l;\n  }, xe.isSuspenseList = function(f) {\n    return y(f) === u;\n  }, xe.isValidElementType = function(f) {\n    return typeof f == \"string\" || typeof f == \"function\" || f === r || f === o || f === n || f === l || f === u || f === g || typeof f == \"object\" && f !== null && (f.$$typeof === m || f.$$typeof === p || f.$$typeof === s || f.$$typeof === i || f.$$typeof === c || f.$$typeof === x || f.getModuleId !== void 0);\n  }, xe.typeOf = y, xe;\n}\nvar Se = {};\n/**\n * @license React\n * react-is.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar _i;\nfunction hl() {\n  return _i || (_i = 1,  true && function() {\n    function e(f) {\n      if (typeof f == \"object\" && f !== null) {\n        var S = f.$$typeof;\n        switch (S) {\n          case t:\n            switch (f = f.type, f) {\n              case n:\n              case i:\n              case o:\n              case u:\n              case p:\n                return f;\n              default:\n                switch (f = f && f.$$typeof, f) {\n                  case c:\n                  case l:\n                  case g:\n                  case m:\n                    return f;\n                  case s:\n                    return f;\n                  default:\n                    return S;\n                }\n            }\n          case r:\n            return S;\n        }\n      }\n    }\n    var t = Symbol.for(\"react.transitional.element\"), r = Symbol.for(\"react.portal\"), n = Symbol.for(\"react.fragment\"), o = Symbol.for(\"react.strict_mode\"), i = Symbol.for(\"react.profiler\"), s = Symbol.for(\"react.consumer\"), c = Symbol.for(\"react.context\"), l = Symbol.for(\"react.forward_ref\"), u = Symbol.for(\"react.suspense\"), p = Symbol.for(\"react.suspense_list\"), m = Symbol.for(\"react.memo\"), g = Symbol.for(\"react.lazy\"), x = Symbol.for(\"react.offscreen\"), y = Symbol.for(\"react.client.reference\");\n    Se.ContextConsumer = s, Se.ContextProvider = c, Se.Element = t, Se.ForwardRef = l, Se.Fragment = n, Se.Lazy = g, Se.Memo = m, Se.Portal = r, Se.Profiler = i, Se.StrictMode = o, Se.Suspense = u, Se.SuspenseList = p, Se.isContextConsumer = function(f) {\n      return e(f) === s;\n    }, Se.isContextProvider = function(f) {\n      return e(f) === c;\n    }, Se.isElement = function(f) {\n      return typeof f == \"object\" && f !== null && f.$$typeof === t;\n    }, Se.isForwardRef = function(f) {\n      return e(f) === l;\n    }, Se.isFragment = function(f) {\n      return e(f) === n;\n    }, Se.isLazy = function(f) {\n      return e(f) === g;\n    }, Se.isMemo = function(f) {\n      return e(f) === m;\n    }, Se.isPortal = function(f) {\n      return e(f) === r;\n    }, Se.isProfiler = function(f) {\n      return e(f) === i;\n    }, Se.isStrictMode = function(f) {\n      return e(f) === o;\n    }, Se.isSuspense = function(f) {\n      return e(f) === u;\n    }, Se.isSuspenseList = function(f) {\n      return e(f) === p;\n    }, Se.isValidElementType = function(f) {\n      return typeof f == \"string\" || typeof f == \"function\" || f === n || f === i || f === o || f === u || f === p || f === x || typeof f == \"object\" && f !== null && (f.$$typeof === g || f.$$typeof === m || f.$$typeof === c || f.$$typeof === s || f.$$typeof === l || f.$$typeof === y || f.getModuleId !== void 0);\n    }, Se.typeOf = e;\n  }()), Se;\n}\nvar ji;\nfunction gl() {\n  return ji || (ji = 1,  false ? 0 : Kr.exports = /* @__PURE__ */ hl()), Kr.exports;\n}\nvar pn = /* @__PURE__ */ gl();\nfunction gt(e) {\n  if (typeof e != \"object\" || e === null)\n    return !1;\n  const t = Object.getPrototypeOf(e);\n  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);\n}\nfunction Da(e) {\n  if (/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(e) || pn.isValidElementType(e) || !gt(e))\n    return e;\n  const t = {};\n  return Object.keys(e).forEach((r) => {\n    t[r] = Da(e[r]);\n  }), t;\n}\nfunction tt(e, t, r = {\n  clone: !0\n}) {\n  const n = r.clone ? {\n    ...e\n  } : e;\n  return gt(e) && gt(t) && Object.keys(t).forEach((o) => {\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(t[o]) || pn.isValidElementType(t[o]) ? n[o] = t[o] : gt(t[o]) && // Avoid prototype pollution\n    Object.prototype.hasOwnProperty.call(e, o) && gt(e[o]) ? n[o] = tt(e[o], t[o], r) : r.clone ? n[o] = gt(t[o]) ? Da(t[o]) : t[o] : n[o] = t[o];\n  }), n;\n}\nconst yl = (e) => {\n  const t = Object.keys(e).map((r) => ({\n    key: r,\n    val: e[r]\n  })) || [];\n  return t.sort((r, n) => r.val - n.val), t.reduce((r, n) => ({\n    ...r,\n    [n.key]: n.val\n  }), {});\n};\nfunction bl(e) {\n  const {\n    // The breakpoint **start** at this value.\n    // For instance with the first breakpoint xs: [xs, sm).\n    values: t = {\n      xs: 0,\n      // phone\n      sm: 600,\n      // tablet\n      md: 900,\n      // small laptop\n      lg: 1200,\n      // desktop\n      xl: 1536\n      // large screen\n    },\n    unit: r = \"px\",\n    step: n = 5,\n    ...o\n  } = e, i = yl(t), s = Object.keys(i);\n  function c(g) {\n    return `@media (min-width:${typeof t[g] == \"number\" ? t[g] : g}${r})`;\n  }\n  function l(g) {\n    return `@media (max-width:${(typeof t[g] == \"number\" ? t[g] : g) - n / 100}${r})`;\n  }\n  function u(g, x) {\n    const y = s.indexOf(x);\n    return `@media (min-width:${typeof t[g] == \"number\" ? t[g] : g}${r}) and (max-width:${(y !== -1 && typeof t[s[y]] == \"number\" ? t[s[y]] : x) - n / 100}${r})`;\n  }\n  function p(g) {\n    return s.indexOf(g) + 1 < s.length ? u(g, s[s.indexOf(g) + 1]) : c(g);\n  }\n  function m(g) {\n    const x = s.indexOf(g);\n    return x === 0 ? c(s[1]) : x === s.length - 1 ? l(s[x]) : u(g, s[s.indexOf(g) + 1]).replace(\"@media\", \"@media not all and\");\n  }\n  return {\n    keys: s,\n    values: i,\n    up: c,\n    down: l,\n    between: u,\n    only: p,\n    not: m,\n    unit: r,\n    ...o\n  };\n}\nfunction vl(e, t) {\n  if (!e.containerQueries)\n    return t;\n  const r = Object.keys(t).filter((n) => n.startsWith(\"@container\")).sort((n, o) => {\n    var s, c;\n    const i = /min-width:\\s*([0-9.]+)/;\n    return +(((s = n.match(i)) == null ? void 0 : s[1]) || 0) - +(((c = o.match(i)) == null ? void 0 : c[1]) || 0);\n  });\n  return r.length ? r.reduce((n, o) => {\n    const i = t[o];\n    return delete n[o], n[o] = i, n;\n  }, {\n    ...t\n  }) : t;\n}\nfunction xl(e, t) {\n  return t === \"@\" || t.startsWith(\"@\") && (e.some((r) => t.startsWith(`@${r}`)) || !!t.match(/^@\\d/));\n}\nfunction Sl(e, t) {\n  const r = t.match(/^@([^/]+)?\\/?(.+)?$/);\n  if (!r) {\n    if (true)\n      throw new Error( true ? `MUI: The provided shorthand ${`(${t})`} is invalid. The format should be \\`@<breakpoint | number>\\` or \\`@<breakpoint | number>/<container>\\`.\nFor example, \\`@sm\\` or \\`@600\\` or \\`@40rem/sidebar\\`.` : 0);\n    return null;\n  }\n  const [, n, o] = r, i = Number.isNaN(+n) ? n || 0 : +n;\n  return e.containerQueries(o).up(i);\n}\nfunction El(e) {\n  const t = (i, s) => i.replace(\"@media\", s ? `@container ${s}` : \"@container\");\n  function r(i, s) {\n    i.up = (...c) => t(e.breakpoints.up(...c), s), i.down = (...c) => t(e.breakpoints.down(...c), s), i.between = (...c) => t(e.breakpoints.between(...c), s), i.only = (...c) => t(e.breakpoints.only(...c), s), i.not = (...c) => {\n      const l = t(e.breakpoints.not(...c), s);\n      return l.includes(\"not all and\") ? l.replace(\"not all and \", \"\").replace(\"min-width:\", \"width<\").replace(\"max-width:\", \"width>\").replace(\"and\", \"or\") : l;\n    };\n  }\n  const n = {}, o = (i) => (r(n, i), n);\n  return r(o), {\n    ...e,\n    containerQueries: o\n  };\n}\nconst Cl = {\n  borderRadius: 4\n}, Mt =  true ? a.oneOfType([a.number, a.string, a.object, a.array]) : 0;\nfunction vr(e, t) {\n  return t ? tt(e, t, {\n    clone: !1\n    // No need to clone deep, it's way faster.\n  }) : e;\n}\nconst kn = {\n  xs: 0,\n  // phone\n  sm: 600,\n  // tablet\n  md: 900,\n  // small laptop\n  lg: 1200,\n  // desktop\n  xl: 1536\n  // large screen\n}, Di = {\n  // Sorted ASC by size. That's important.\n  // It can't be configured as it's used statically for propTypes.\n  keys: [\"xs\", \"sm\", \"md\", \"lg\", \"xl\"],\n  up: (e) => `@media (min-width:${kn[e]}px)`\n}, Tl = {\n  containerQueries: (e) => ({\n    up: (t) => {\n      let r = typeof t == \"number\" ? t : kn[t] || t;\n      return typeof r == \"number\" && (r = `${r}px`), e ? `@container ${e} (min-width:${r})` : `@container (min-width:${r})`;\n    }\n  })\n};\nfunction Ot(e, t, r) {\n  const n = e.theme || {};\n  if (Array.isArray(t)) {\n    const i = n.breakpoints || Di;\n    return t.reduce((s, c, l) => (s[i.up(i.keys[l])] = r(t[l]), s), {});\n  }\n  if (typeof t == \"object\") {\n    const i = n.breakpoints || Di;\n    return Object.keys(t).reduce((s, c) => {\n      if (xl(i.keys, c)) {\n        const l = Sl(n.containerQueries ? n : Tl, c);\n        l && (s[l] = r(t[c], c));\n      } else if (Object.keys(i.values || kn).includes(c)) {\n        const l = i.up(c);\n        s[l] = r(t[c], c);\n      } else {\n        const l = c;\n        s[l] = t[l];\n      }\n      return s;\n    }, {});\n  }\n  return r(t);\n}\nfunction wl(e = {}) {\n  var r;\n  return ((r = e.keys) == null ? void 0 : r.reduce((n, o) => {\n    const i = e.up(o);\n    return n[i] = {}, n;\n  }, {})) || {};\n}\nfunction Ol(e, t) {\n  return e.reduce((r, n) => {\n    const o = r[n];\n    return (!o || Object.keys(o).length === 0) && delete r[n], r;\n  }, t);\n}\nfunction ee(e) {\n  if (typeof e != \"string\")\n    throw new Error( true ? \"MUI: `capitalize(string)` expects a string argument.\" : 0);\n  return e.charAt(0).toUpperCase() + e.slice(1);\n}\nfunction An(e, t, r = !0) {\n  if (!t || typeof t != \"string\")\n    return null;\n  if (e && e.vars && r) {\n    const n = `vars.${t}`.split(\".\").reduce((o, i) => o && o[i] ? o[i] : null, e);\n    if (n != null)\n      return n;\n  }\n  return t.split(\".\").reduce((n, o) => n && n[o] != null ? n[o] : null, e);\n}\nfunction mn(e, t, r, n = r) {\n  let o;\n  return typeof e == \"function\" ? o = e(r) : Array.isArray(e) ? o = e[r] || n : o = An(e, r) || n, t && (o = t(o, n, e)), o;\n}\nfunction _e(e) {\n  const {\n    prop: t,\n    cssProperty: r = e.prop,\n    themeKey: n,\n    transform: o\n  } = e, i = (s) => {\n    if (s[t] == null)\n      return null;\n    const c = s[t], l = s.theme, u = An(l, n) || {};\n    return Ot(s, c, (m) => {\n      let g = mn(u, o, m);\n      return m === g && typeof m == \"string\" && (g = mn(u, o, `${t}${m === \"default\" ? \"\" : ee(m)}`, m)), r === !1 ? g : {\n        [r]: g\n      };\n    });\n  };\n  return i.propTypes =  true ? {\n    [t]: Mt\n  } : 0, i.filterProps = [t], i;\n}\nfunction Rl(e) {\n  const t = {};\n  return (r) => (t[r] === void 0 && (t[r] = e(r)), t[r]);\n}\nconst $l = {\n  m: \"margin\",\n  p: \"padding\"\n}, Pl = {\n  t: \"Top\",\n  r: \"Right\",\n  b: \"Bottom\",\n  l: \"Left\",\n  x: [\"Left\", \"Right\"],\n  y: [\"Top\", \"Bottom\"]\n}, Li = {\n  marginX: \"mx\",\n  marginY: \"my\",\n  paddingX: \"px\",\n  paddingY: \"py\"\n}, kl = Rl((e) => {\n  if (e.length > 2)\n    if (Li[e])\n      e = Li[e];\n    else\n      return [e];\n  const [t, r] = e.split(\"\"), n = $l[t], o = Pl[r] || \"\";\n  return Array.isArray(o) ? o.map((i) => n + i) : [n + o];\n}), Nn = [\"m\", \"mt\", \"mr\", \"mb\", \"ml\", \"mx\", \"my\", \"margin\", \"marginTop\", \"marginRight\", \"marginBottom\", \"marginLeft\", \"marginX\", \"marginY\", \"marginInline\", \"marginInlineStart\", \"marginInlineEnd\", \"marginBlock\", \"marginBlockStart\", \"marginBlockEnd\"], Mn = [\"p\", \"pt\", \"pr\", \"pb\", \"pl\", \"px\", \"py\", \"padding\", \"paddingTop\", \"paddingRight\", \"paddingBottom\", \"paddingLeft\", \"paddingX\", \"paddingY\", \"paddingInline\", \"paddingInlineStart\", \"paddingInlineEnd\", \"paddingBlock\", \"paddingBlockStart\", \"paddingBlockEnd\"], Al = [...Nn, ...Mn];\nfunction _r(e, t, r, n) {\n  const o = An(e, t, !0) ?? r;\n  return typeof o == \"number\" || typeof o == \"string\" ? (i) => typeof i == \"string\" ? i : ( true && typeof i != \"number\" && console.error(`MUI: Expected ${n} argument to be a number or a string, got ${i}.`), typeof o == \"string\" ? `calc(${i} * ${o})` : o * i) : Array.isArray(o) ? (i) => {\n    if (typeof i == \"string\")\n      return i;\n    const s = Math.abs(i);\n     true && (Number.isInteger(s) ? s > o.length - 1 && console.error([`MUI: The value provided (${s}) overflows.`, `The supported values are: ${JSON.stringify(o)}.`, `${s} > ${o.length - 1}, you need to add the missing values.`].join(`\n`)) : console.error([`MUI: The \\`theme.${t}\\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \\`theme.${t}\\` as a number.`].join(`\n`)));\n    const c = o[s];\n    return i >= 0 ? c : typeof c == \"number\" ? -c : `-${c}`;\n  } : typeof o == \"function\" ? o : ( true && console.error([`MUI: The \\`theme.${t}\\` value (${o}) is invalid.`, \"It should be a number, an array or a function.\"].join(`\n`)), () => {\n  });\n}\nfunction ko(e) {\n  return _r(e, \"spacing\", 8, \"spacing\");\n}\nfunction jr(e, t) {\n  return typeof t == \"string\" || t == null ? t : e(t);\n}\nfunction Nl(e, t) {\n  return (r) => e.reduce((n, o) => (n[o] = jr(t, r), n), {});\n}\nfunction Ml(e, t, r, n) {\n  if (!t.includes(r))\n    return null;\n  const o = kl(r), i = Nl(o, n), s = e[r];\n  return Ot(e, s, i);\n}\nfunction La(e, t) {\n  const r = ko(e.theme);\n  return Object.keys(e).map((n) => Ml(e, t, n, r)).reduce(vr, {});\n}\nfunction ke(e) {\n  return La(e, Nn);\n}\nke.propTypes =  true ? Nn.reduce((e, t) => (e[t] = Mt, e), {}) : 0;\nke.filterProps = Nn;\nfunction Ae(e) {\n  return La(e, Mn);\n}\nAe.propTypes =  true ? Mn.reduce((e, t) => (e[t] = Mt, e), {}) : 0;\nAe.filterProps = Mn;\n true && Al.reduce((e, t) => (e[t] = Mt, e), {});\nfunction Ba(e = 8, t = ko({\n  spacing: e\n})) {\n  if (e.mui)\n    return e;\n  const r = (...n) => ( true && (n.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${n.length}`)), (n.length === 0 ? [1] : n).map((i) => {\n    const s = t(i);\n    return typeof s == \"number\" ? `${s}px` : s;\n  }).join(\" \"));\n  return r.mui = !0, r;\n}\nfunction In(...e) {\n  const t = e.reduce((n, o) => (o.filterProps.forEach((i) => {\n    n[i] = o;\n  }), n), {}), r = (n) => Object.keys(n).reduce((o, i) => t[i] ? vr(o, t[i](n)) : o, {});\n  return r.propTypes =  true ? e.reduce((n, o) => Object.assign(n, o.propTypes), {}) : 0, r.filterProps = e.reduce((n, o) => n.concat(o.filterProps), []), r;\n}\nfunction ot(e) {\n  return typeof e != \"number\" ? e : `${e}px solid`;\n}\nfunction lt(e, t) {\n  return _e({\n    prop: e,\n    themeKey: \"borders\",\n    transform: t\n  });\n}\nconst Il = lt(\"border\", ot), _l = lt(\"borderTop\", ot), jl = lt(\"borderRight\", ot), Dl = lt(\"borderBottom\", ot), Ll = lt(\"borderLeft\", ot), Bl = lt(\"borderColor\"), Vl = lt(\"borderTopColor\"), Fl = lt(\"borderRightColor\"), zl = lt(\"borderBottomColor\"), Wl = lt(\"borderLeftColor\"), Ul = lt(\"outline\", ot), Yl = lt(\"outlineColor\"), _n = (e) => {\n  if (e.borderRadius !== void 0 && e.borderRadius !== null) {\n    const t = _r(e.theme, \"shape.borderRadius\", 4, \"borderRadius\"), r = (n) => ({\n      borderRadius: jr(t, n)\n    });\n    return Ot(e, e.borderRadius, r);\n  }\n  return null;\n};\n_n.propTypes =  true ? {\n  borderRadius: Mt\n} : 0;\n_n.filterProps = [\"borderRadius\"];\nIn(Il, _l, jl, Dl, Ll, Bl, Vl, Fl, zl, Wl, _n, Ul, Yl);\nconst jn = (e) => {\n  if (e.gap !== void 0 && e.gap !== null) {\n    const t = _r(e.theme, \"spacing\", 8, \"gap\"), r = (n) => ({\n      gap: jr(t, n)\n    });\n    return Ot(e, e.gap, r);\n  }\n  return null;\n};\njn.propTypes =  true ? {\n  gap: Mt\n} : 0;\njn.filterProps = [\"gap\"];\nconst Dn = (e) => {\n  if (e.columnGap !== void 0 && e.columnGap !== null) {\n    const t = _r(e.theme, \"spacing\", 8, \"columnGap\"), r = (n) => ({\n      columnGap: jr(t, n)\n    });\n    return Ot(e, e.columnGap, r);\n  }\n  return null;\n};\nDn.propTypes =  true ? {\n  columnGap: Mt\n} : 0;\nDn.filterProps = [\"columnGap\"];\nconst Ln = (e) => {\n  if (e.rowGap !== void 0 && e.rowGap !== null) {\n    const t = _r(e.theme, \"spacing\", 8, \"rowGap\"), r = (n) => ({\n      rowGap: jr(t, n)\n    });\n    return Ot(e, e.rowGap, r);\n  }\n  return null;\n};\nLn.propTypes =  true ? {\n  rowGap: Mt\n} : 0;\nLn.filterProps = [\"rowGap\"];\nconst Hl = _e({\n  prop: \"gridColumn\"\n}), ql = _e({\n  prop: \"gridRow\"\n}), Gl = _e({\n  prop: \"gridAutoFlow\"\n}), Kl = _e({\n  prop: \"gridAutoColumns\"\n}), Xl = _e({\n  prop: \"gridAutoRows\"\n}), Jl = _e({\n  prop: \"gridTemplateColumns\"\n}), Ql = _e({\n  prop: \"gridTemplateRows\"\n}), Zl = _e({\n  prop: \"gridTemplateAreas\"\n}), eu = _e({\n  prop: \"gridArea\"\n});\nIn(jn, Dn, Ln, Hl, ql, Gl, Kl, Xl, Jl, Ql, Zl, eu);\nfunction Jt(e, t) {\n  return t === \"grey\" ? t : e;\n}\nconst tu = _e({\n  prop: \"color\",\n  themeKey: \"palette\",\n  transform: Jt\n}), ru = _e({\n  prop: \"bgcolor\",\n  cssProperty: \"backgroundColor\",\n  themeKey: \"palette\",\n  transform: Jt\n}), nu = _e({\n  prop: \"backgroundColor\",\n  themeKey: \"palette\",\n  transform: Jt\n});\nIn(tu, ru, nu);\nfunction Ze(e) {\n  return e <= 1 && e !== 0 ? `${e * 100}%` : e;\n}\nconst ou = _e({\n  prop: \"width\",\n  transform: Ze\n}), Ao = (e) => {\n  if (e.maxWidth !== void 0 && e.maxWidth !== null) {\n    const t = (r) => {\n      var o, i, s, c, l;\n      const n = ((s = (i = (o = e.theme) == null ? void 0 : o.breakpoints) == null ? void 0 : i.values) == null ? void 0 : s[r]) || kn[r];\n      return n ? ((l = (c = e.theme) == null ? void 0 : c.breakpoints) == null ? void 0 : l.unit) !== \"px\" ? {\n        maxWidth: `${n}${e.theme.breakpoints.unit}`\n      } : {\n        maxWidth: n\n      } : {\n        maxWidth: Ze(r)\n      };\n    };\n    return Ot(e, e.maxWidth, t);\n  }\n  return null;\n};\nAo.filterProps = [\"maxWidth\"];\nconst iu = _e({\n  prop: \"minWidth\",\n  transform: Ze\n}), au = _e({\n  prop: \"height\",\n  transform: Ze\n}), su = _e({\n  prop: \"maxHeight\",\n  transform: Ze\n}), cu = _e({\n  prop: \"minHeight\",\n  transform: Ze\n});\n_e({\n  prop: \"size\",\n  cssProperty: \"width\",\n  transform: Ze\n});\n_e({\n  prop: \"size\",\n  cssProperty: \"height\",\n  transform: Ze\n});\nconst lu = _e({\n  prop: \"boxSizing\"\n});\nIn(ou, Ao, iu, au, su, cu, lu);\nconst Dr = {\n  // borders\n  border: {\n    themeKey: \"borders\",\n    transform: ot\n  },\n  borderTop: {\n    themeKey: \"borders\",\n    transform: ot\n  },\n  borderRight: {\n    themeKey: \"borders\",\n    transform: ot\n  },\n  borderBottom: {\n    themeKey: \"borders\",\n    transform: ot\n  },\n  borderLeft: {\n    themeKey: \"borders\",\n    transform: ot\n  },\n  borderColor: {\n    themeKey: \"palette\"\n  },\n  borderTopColor: {\n    themeKey: \"palette\"\n  },\n  borderRightColor: {\n    themeKey: \"palette\"\n  },\n  borderBottomColor: {\n    themeKey: \"palette\"\n  },\n  borderLeftColor: {\n    themeKey: \"palette\"\n  },\n  outline: {\n    themeKey: \"borders\",\n    transform: ot\n  },\n  outlineColor: {\n    themeKey: \"palette\"\n  },\n  borderRadius: {\n    themeKey: \"shape.borderRadius\",\n    style: _n\n  },\n  // palette\n  color: {\n    themeKey: \"palette\",\n    transform: Jt\n  },\n  bgcolor: {\n    themeKey: \"palette\",\n    cssProperty: \"backgroundColor\",\n    transform: Jt\n  },\n  backgroundColor: {\n    themeKey: \"palette\",\n    transform: Jt\n  },\n  // spacing\n  p: {\n    style: Ae\n  },\n  pt: {\n    style: Ae\n  },\n  pr: {\n    style: Ae\n  },\n  pb: {\n    style: Ae\n  },\n  pl: {\n    style: Ae\n  },\n  px: {\n    style: Ae\n  },\n  py: {\n    style: Ae\n  },\n  padding: {\n    style: Ae\n  },\n  paddingTop: {\n    style: Ae\n  },\n  paddingRight: {\n    style: Ae\n  },\n  paddingBottom: {\n    style: Ae\n  },\n  paddingLeft: {\n    style: Ae\n  },\n  paddingX: {\n    style: Ae\n  },\n  paddingY: {\n    style: Ae\n  },\n  paddingInline: {\n    style: Ae\n  },\n  paddingInlineStart: {\n    style: Ae\n  },\n  paddingInlineEnd: {\n    style: Ae\n  },\n  paddingBlock: {\n    style: Ae\n  },\n  paddingBlockStart: {\n    style: Ae\n  },\n  paddingBlockEnd: {\n    style: Ae\n  },\n  m: {\n    style: ke\n  },\n  mt: {\n    style: ke\n  },\n  mr: {\n    style: ke\n  },\n  mb: {\n    style: ke\n  },\n  ml: {\n    style: ke\n  },\n  mx: {\n    style: ke\n  },\n  my: {\n    style: ke\n  },\n  margin: {\n    style: ke\n  },\n  marginTop: {\n    style: ke\n  },\n  marginRight: {\n    style: ke\n  },\n  marginBottom: {\n    style: ke\n  },\n  marginLeft: {\n    style: ke\n  },\n  marginX: {\n    style: ke\n  },\n  marginY: {\n    style: ke\n  },\n  marginInline: {\n    style: ke\n  },\n  marginInlineStart: {\n    style: ke\n  },\n  marginInlineEnd: {\n    style: ke\n  },\n  marginBlock: {\n    style: ke\n  },\n  marginBlockStart: {\n    style: ke\n  },\n  marginBlockEnd: {\n    style: ke\n  },\n  // display\n  displayPrint: {\n    cssProperty: !1,\n    transform: (e) => ({\n      \"@media print\": {\n        display: e\n      }\n    })\n  },\n  display: {},\n  overflow: {},\n  textOverflow: {},\n  visibility: {},\n  whiteSpace: {},\n  // flexbox\n  flexBasis: {},\n  flexDirection: {},\n  flexWrap: {},\n  justifyContent: {},\n  alignItems: {},\n  alignContent: {},\n  order: {},\n  flex: {},\n  flexGrow: {},\n  flexShrink: {},\n  alignSelf: {},\n  justifyItems: {},\n  justifySelf: {},\n  // grid\n  gap: {\n    style: jn\n  },\n  rowGap: {\n    style: Ln\n  },\n  columnGap: {\n    style: Dn\n  },\n  gridColumn: {},\n  gridRow: {},\n  gridAutoFlow: {},\n  gridAutoColumns: {},\n  gridAutoRows: {},\n  gridTemplateColumns: {},\n  gridTemplateRows: {},\n  gridTemplateAreas: {},\n  gridArea: {},\n  // positions\n  position: {},\n  zIndex: {\n    themeKey: \"zIndex\"\n  },\n  top: {},\n  right: {},\n  bottom: {},\n  left: {},\n  // shadows\n  boxShadow: {\n    themeKey: \"shadows\"\n  },\n  // sizing\n  width: {\n    transform: Ze\n  },\n  maxWidth: {\n    style: Ao\n  },\n  minWidth: {\n    transform: Ze\n  },\n  height: {\n    transform: Ze\n  },\n  maxHeight: {\n    transform: Ze\n  },\n  minHeight: {\n    transform: Ze\n  },\n  boxSizing: {},\n  // typography\n  font: {\n    themeKey: \"font\"\n  },\n  fontFamily: {\n    themeKey: \"typography\"\n  },\n  fontSize: {\n    themeKey: \"typography\"\n  },\n  fontStyle: {\n    themeKey: \"typography\"\n  },\n  fontWeight: {\n    themeKey: \"typography\"\n  },\n  letterSpacing: {},\n  textTransform: {},\n  lineHeight: {},\n  textAlign: {},\n  typography: {\n    cssProperty: !1,\n    themeKey: \"typography\"\n  }\n};\nfunction uu(...e) {\n  const t = e.reduce((n, o) => n.concat(Object.keys(o)), []), r = new Set(t);\n  return e.every((n) => r.size === Object.keys(n).length);\n}\nfunction fu(e, t) {\n  return typeof e == \"function\" ? e(t) : e;\n}\nfunction du() {\n  function e(r, n, o, i) {\n    const s = {\n      [r]: n,\n      theme: o\n    }, c = i[r];\n    if (!c)\n      return {\n        [r]: n\n      };\n    const {\n      cssProperty: l = r,\n      themeKey: u,\n      transform: p,\n      style: m\n    } = c;\n    if (n == null)\n      return null;\n    if (u === \"typography\" && n === \"inherit\")\n      return {\n        [r]: n\n      };\n    const g = An(o, u) || {};\n    return m ? m(s) : Ot(s, n, (y) => {\n      let f = mn(g, p, y);\n      return y === f && typeof y == \"string\" && (f = mn(g, p, `${r}${y === \"default\" ? \"\" : ee(y)}`, y)), l === !1 ? f : {\n        [l]: f\n      };\n    });\n  }\n  function t(r) {\n    const {\n      sx: n,\n      theme: o = {}\n    } = r || {};\n    if (!n)\n      return null;\n    const i = o.unstable_sxConfig ?? Dr;\n    function s(c) {\n      let l = c;\n      if (typeof c == \"function\")\n        l = c(o);\n      else if (typeof c != \"object\")\n        return c;\n      if (!l)\n        return null;\n      const u = wl(o.breakpoints), p = Object.keys(u);\n      let m = u;\n      return Object.keys(l).forEach((g) => {\n        const x = fu(l[g], o);\n        if (x != null)\n          if (typeof x == \"object\")\n            if (i[g])\n              m = vr(m, e(g, x, o, i));\n            else {\n              const y = Ot({\n                theme: o\n              }, x, (f) => ({\n                [g]: f\n              }));\n              uu(y, x) ? m[g] = t({\n                sx: x,\n                theme: o\n              }) : m = vr(m, y);\n            }\n          else\n            m = vr(m, e(g, x, o, i));\n      }), vl(o, Ol(p, m));\n    }\n    return Array.isArray(n) ? n.map(s) : s(n);\n  }\n  return t;\n}\nconst At = du();\nAt.filterProps = [\"sx\"];\nfunction pu(e, t) {\n  var n;\n  const r = this;\n  if (r.vars) {\n    if (!((n = r.colorSchemes) != null && n[e]) || typeof r.getColorSchemeSelector != \"function\")\n      return {};\n    let o = r.getColorSchemeSelector(e);\n    return o === \"&\" ? t : ((o.includes(\"data-\") || o.includes(\".\")) && (o = `*:where(${o.replace(/\\s*&$/, \"\")}) &`), {\n      [o]: t\n    });\n  }\n  return r.palette.mode === e ? t : {};\n}\nfunction No(e = {}, ...t) {\n  const {\n    breakpoints: r = {},\n    palette: n = {},\n    spacing: o,\n    shape: i = {},\n    ...s\n  } = e, c = bl(r), l = Ba(o);\n  let u = tt({\n    breakpoints: c,\n    direction: \"ltr\",\n    components: {},\n    // Inject component definitions.\n    palette: {\n      mode: \"light\",\n      ...n\n    },\n    spacing: l,\n    shape: {\n      ...Cl,\n      ...i\n    }\n  }, s);\n  return u = El(u), u.applyStyles = pu, u = t.reduce((p, m) => tt(p, m), u), u.unstable_sxConfig = {\n    ...Dr,\n    ...s == null ? void 0 : s.unstable_sxConfig\n  }, u.unstable_sx = function(m) {\n    return At({\n      sx: m,\n      theme: this\n    });\n  }, u;\n}\nfunction mu(e) {\n  return Object.keys(e).length === 0;\n}\nfunction Va(e = null) {\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Mr);\n  return !t || mu(t) ? e : t;\n}\nconst hu = No();\nfunction Fa(e = hu) {\n  return Va(e);\n}\nconst gu = (e) => {\n  var n;\n  const t = {\n    systemProps: {},\n    otherProps: {}\n  }, r = ((n = e == null ? void 0 : e.theme) == null ? void 0 : n.unstable_sxConfig) ?? Dr;\n  return Object.keys(e).forEach((o) => {\n    r[o] ? t.systemProps[o] = e[o] : t.otherProps[o] = e[o];\n  }), t;\n};\nfunction za(e) {\n  const {\n    sx: t,\n    ...r\n  } = e, {\n    systemProps: n,\n    otherProps: o\n  } = gu(r);\n  let i;\n  return Array.isArray(t) ? i = [n, ...t] : typeof t == \"function\" ? i = (...s) => {\n    const c = t(...s);\n    return gt(c) ? {\n      ...n,\n      ...c\n    } : n;\n  } : i = {\n    ...n,\n    ...t\n  }, {\n    ...o,\n    sx: i\n  };\n}\nconst Bi = (e) => e, yu = () => {\n  let e = Bi;\n  return {\n    configure(t) {\n      e = t;\n    },\n    generate(t) {\n      return e(t);\n    },\n    reset() {\n      e = Bi;\n    }\n  };\n}, Wa = yu();\nfunction Ua(e) {\n  var t, r, n = \"\";\n  if (typeof e == \"string\" || typeof e == \"number\") n += e;\n  else if (typeof e == \"object\") if (Array.isArray(e)) {\n    var o = e.length;\n    for (t = 0; t < o; t++) e[t] && (r = Ua(e[t])) && (n && (n += \" \"), n += r);\n  } else for (r in e) e[r] && (n && (n += \" \"), n += r);\n  return n;\n}\nfunction se() {\n  for (var e, t, r = 0, n = \"\", o = arguments.length; r < o; r++) (e = arguments[r]) && (t = Ua(e)) && (n && (n += \" \"), n += t);\n  return n;\n}\nfunction bu(e = {}) {\n  const {\n    themeId: t,\n    defaultTheme: r,\n    defaultClassName: n = \"MuiBox-root\",\n    generateClassName: o\n  } = e, i = ja(\"div\", {\n    shouldForwardProp: (c) => c !== \"theme\" && c !== \"sx\" && c !== \"as\"\n  })(At);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(l, u) {\n    const p = Fa(r), {\n      className: m,\n      component: g = \"div\",\n      ...x\n    } = za(l);\n    return /* @__PURE__ */ N.jsx(i, {\n      as: g,\n      ref: u,\n      className: se(m, o ? o(n) : n),\n      theme: t && p[t] || p,\n      ...x\n    });\n  });\n}\nconst vu = {\n  active: \"active\",\n  checked: \"checked\",\n  completed: \"completed\",\n  disabled: \"disabled\",\n  error: \"error\",\n  expanded: \"expanded\",\n  focused: \"focused\",\n  focusVisible: \"focusVisible\",\n  open: \"open\",\n  readOnly: \"readOnly\",\n  required: \"required\",\n  selected: \"selected\"\n};\nfunction Ve(e, t, r = \"Mui\") {\n  const n = vu[t];\n  return n ? `${r}-${n}` : `${Wa.generate(e)}-${t}`;\n}\nfunction Fe(e, t, r = \"Mui\") {\n  const n = {};\n  return t.forEach((o) => {\n    n[o] = Ve(e, o, r);\n  }), n;\n}\nfunction Ya(e, t = \"\") {\n  return e.displayName || e.name || t;\n}\nfunction Vi(e, t, r) {\n  const n = Ya(t);\n  return e.displayName || (n !== \"\" ? `${r}(${n})` : r);\n}\nfunction xu(e) {\n  if (e != null) {\n    if (typeof e == \"string\")\n      return e;\n    if (typeof e == \"function\")\n      return Ya(e, \"Component\");\n    if (typeof e == \"object\")\n      switch (e.$$typeof) {\n        case pn.ForwardRef:\n          return Vi(e, e.render, \"ForwardRef\");\n        case pn.Memo:\n          return Vi(e, e.type, \"memo\");\n        default:\n          return;\n      }\n  }\n}\nfunction Ha(e) {\n  const {\n    variants: t,\n    ...r\n  } = e, n = {\n    variants: t,\n    style: Mi(r),\n    isProcessed: !0\n  };\n  return n.style === r || t && t.forEach((o) => {\n    typeof o.style != \"function\" && (o.style = Mi(o.style));\n  }), n;\n}\nconst Su = No();\nfunction Zn(e) {\n  return e !== \"ownerState\" && e !== \"theme\" && e !== \"sx\" && e !== \"as\";\n}\nfunction Eu(e) {\n  return e ? (t, r) => r[e] : null;\n}\nfunction Cu(e, t, r) {\n  e.theme = Ru(e.theme) ? r : e.theme[t] || e.theme;\n}\nfunction ln(e, t) {\n  const r = typeof t == \"function\" ? t(e) : t;\n  if (Array.isArray(r))\n    return r.flatMap((n) => ln(e, n));\n  if (Array.isArray(r == null ? void 0 : r.variants)) {\n    let n;\n    if (r.isProcessed)\n      n = r.style;\n    else {\n      const {\n        variants: o,\n        ...i\n      } = r;\n      n = i;\n    }\n    return qa(e, r.variants, [n]);\n  }\n  return r != null && r.isProcessed ? r.style : r;\n}\nfunction qa(e, t, r = []) {\n  var o;\n  let n;\n  e: for (let i = 0; i < t.length; i += 1) {\n    const s = t[i];\n    if (typeof s.props == \"function\") {\n      if (n ?? (n = {\n        ...e,\n        ...e.ownerState,\n        ownerState: e.ownerState\n      }), !s.props(n))\n        continue;\n    } else\n      for (const c in s.props)\n        if (e[c] !== s.props[c] && ((o = e.ownerState) == null ? void 0 : o[c]) !== s.props[c])\n          continue e;\n    typeof s.style == \"function\" ? (n ?? (n = {\n      ...e,\n      ...e.ownerState,\n      ownerState: e.ownerState\n    }), r.push(s.style(n))) : r.push(s.style);\n  }\n  return r;\n}\nfunction Tu(e = {}) {\n  const {\n    themeId: t,\n    defaultTheme: r = Su,\n    rootShouldForwardProp: n = Zn,\n    slotShouldForwardProp: o = Zn\n  } = e;\n  function i(c) {\n    Cu(c, t, r);\n  }\n  return (c, l = {}) => {\n    pl(c, (h) => h.filter((w) => w !== At));\n    const {\n      name: u,\n      slot: p,\n      skipVariantsResolver: m,\n      skipSx: g,\n      // TODO v6: remove `lowercaseFirstLetter()` in the next major release\n      // For more details: https://github.com/mui/material-ui/pull/37908\n      overridesResolver: x = Eu(Ga(p)),\n      ...y\n    } = l, f = m !== void 0 ? m : (\n      // TODO v6: remove `Root` in the next major release\n      // For more details: https://github.com/mui/material-ui/pull/37908\n      p && p !== \"Root\" && p !== \"root\" || !1\n    ), S = g || !1;\n    let E = Zn;\n    p === \"Root\" || p === \"root\" ? E = n : p ? E = o : $u(c) && (E = void 0);\n    const P = ja(c, {\n      shouldForwardProp: E,\n      label: Ou(u, p),\n      ...y\n    }), T = (h) => {\n      if (typeof h == \"function\" && h.__emotion_real !== h)\n        return function(k) {\n          return ln(k, h);\n        };\n      if (gt(h)) {\n        const w = Ha(h);\n        return w.variants ? function(L) {\n          return ln(L, w);\n        } : w.style;\n      }\n      return h;\n    }, b = (...h) => {\n      const w = [], k = h.map(T), L = [];\n      if (w.push(i), u && x && L.push(function(D) {\n        var U, V;\n        const W = (V = (U = D.theme.components) == null ? void 0 : U[u]) == null ? void 0 : V.styleOverrides;\n        if (!W)\n          return null;\n        const z = {};\n        for (const te in W)\n          z[te] = ln(D, W[te]);\n        return x(D, z);\n      }), u && !f && L.push(function(D) {\n        var z, U;\n        const j = D.theme, W = (U = (z = j == null ? void 0 : j.components) == null ? void 0 : z[u]) == null ? void 0 : U.variants;\n        return W ? qa(D, W) : null;\n      }), S || L.push(At), Array.isArray(k[0])) {\n        const A = k.shift(), D = new Array(w.length).fill(\"\"), j = new Array(L.length).fill(\"\");\n        let W;\n        W = [...D, ...A, ...j], W.raw = [...D, ...A.raw, ...j], w.unshift(W);\n      }\n      const B = [...w, ...k, ...L], d = P(...B);\n      return c.muiName && (d.muiName = c.muiName),  true && (d.displayName = wu(u, p, c)), d;\n    };\n    return P.withConfig && (b.withConfig = P.withConfig), b;\n  };\n}\nfunction wu(e, t, r) {\n  return e ? `${e}${ee(t || \"\")}` : `Styled(${xu(r)})`;\n}\nfunction Ou(e, t) {\n  let r;\n  return  true && e && (r = `${e}-${Ga(t || \"Root\")}`), r;\n}\nfunction Ru(e) {\n  for (const t in e)\n    return !1;\n  return !0;\n}\nfunction $u(e) {\n  return typeof e == \"string\" && // 96 is one less than the char code\n  // for \"a\" so this is checking that\n  // it's a lowercase character\n  e.charCodeAt(0) > 96;\n}\nfunction Ga(e) {\n  return e && e.charAt(0).toLowerCase() + e.slice(1);\n}\nfunction co(e, t) {\n  const r = {\n    ...t\n  };\n  for (const n in e)\n    if (Object.prototype.hasOwnProperty.call(e, n)) {\n      const o = n;\n      if (o === \"components\" || o === \"slots\")\n        r[o] = {\n          ...e[o],\n          ...r[o]\n        };\n      else if (o === \"componentsProps\" || o === \"slotProps\") {\n        const i = e[o], s = t[o];\n        if (!s)\n          r[o] = i || {};\n        else if (!i)\n          r[o] = s;\n        else {\n          r[o] = {\n            ...s\n          };\n          for (const c in i)\n            if (Object.prototype.hasOwnProperty.call(i, c)) {\n              const l = c;\n              r[o][l] = co(i[l], s[l]);\n            }\n        }\n      } else r[o] === void 0 && (r[o] = e[o]);\n    }\n  return r;\n}\nconst Ft = typeof window < \"u\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction Pu(e, t = Number.MIN_SAFE_INTEGER, r = Number.MAX_SAFE_INTEGER) {\n  return Math.max(t, Math.min(e, r));\n}\nfunction Mo(e, t = 0, r = 1) {\n  return  true && (e < t || e > r) && console.error(`MUI: The value provided ${e} is out of range [${t}, ${r}].`), Pu(e, t, r);\n}\nfunction ku(e) {\n  e = e.slice(1);\n  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, \"g\");\n  let r = e.match(t);\n  return r && r[0].length === 1 && (r = r.map((n) => n + n)),  true && e.length !== e.trim().length && console.error(`MUI: The color: \"${e}\" is invalid. Make sure the color input doesn't contain leading/trailing space.`), r ? `rgb${r.length === 4 ? \"a\" : \"\"}(${r.map((n, o) => o < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3).join(\", \")})` : \"\";\n}\nfunction Nt(e) {\n  if (e.type)\n    return e;\n  if (e.charAt(0) === \"#\")\n    return Nt(ku(e));\n  const t = e.indexOf(\"(\"), r = e.substring(0, t);\n  if (![\"rgb\", \"rgba\", \"hsl\", \"hsla\", \"color\"].includes(r))\n    throw new Error( true ? `MUI: Unsupported \\`${e}\\` color.\nThe following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : 0);\n  let n = e.substring(t + 1, e.length - 1), o;\n  if (r === \"color\") {\n    if (n = n.split(\" \"), o = n.shift(), n.length === 4 && n[3].charAt(0) === \"/\" && (n[3] = n[3].slice(1)), ![\"srgb\", \"display-p3\", \"a98-rgb\", \"prophoto-rgb\", \"rec-2020\"].includes(o))\n      throw new Error( true ? `MUI: unsupported \\`${o}\\` color space.\nThe following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : 0);\n  } else\n    n = n.split(\",\");\n  return n = n.map((i) => parseFloat(i)), {\n    type: r,\n    values: n,\n    colorSpace: o\n  };\n}\nconst Au = (e) => {\n  const t = Nt(e);\n  return t.values.slice(0, 3).map((r, n) => t.type.includes(\"hsl\") && n !== 0 ? `${r}%` : r).join(\" \");\n}, gr = (e, t) => {\n  try {\n    return Au(e);\n  } catch {\n    return t && \"development\" !== \"production\" && console.warn(t), e;\n  }\n};\nfunction Bn(e) {\n  const {\n    type: t,\n    colorSpace: r\n  } = e;\n  let {\n    values: n\n  } = e;\n  return t.includes(\"rgb\") ? n = n.map((o, i) => i < 3 ? parseInt(o, 10) : o) : t.includes(\"hsl\") && (n[1] = `${n[1]}%`, n[2] = `${n[2]}%`), t.includes(\"color\") ? n = `${r} ${n.join(\" \")}` : n = `${n.join(\", \")}`, `${t}(${n})`;\n}\nfunction Ka(e) {\n  e = Nt(e);\n  const {\n    values: t\n  } = e, r = t[0], n = t[1] / 100, o = t[2] / 100, i = n * Math.min(o, 1 - o), s = (u, p = (u + r / 30) % 12) => o - i * Math.max(Math.min(p - 3, 9 - p, 1), -1);\n  let c = \"rgb\";\n  const l = [Math.round(s(0) * 255), Math.round(s(8) * 255), Math.round(s(4) * 255)];\n  return e.type === \"hsla\" && (c += \"a\", l.push(t[3])), Bn({\n    type: c,\n    values: l\n  });\n}\nfunction lo(e) {\n  e = Nt(e);\n  let t = e.type === \"hsl\" || e.type === \"hsla\" ? Nt(Ka(e)).values : e.values;\n  return t = t.map((r) => (e.type !== \"color\" && (r /= 255), r <= 0.03928 ? r / 12.92 : ((r + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));\n}\nfunction Fi(e, t) {\n  const r = lo(e), n = lo(t);\n  return (Math.max(r, n) + 0.05) / (Math.min(r, n) + 0.05);\n}\nfunction De(e, t) {\n  return e = Nt(e), t = Mo(t), (e.type === \"rgb\" || e.type === \"hsl\") && (e.type += \"a\"), e.type === \"color\" ? e.values[3] = `/${t}` : e.values[3] = t, Bn(e);\n}\nfunction Xr(e, t, r) {\n  try {\n    return De(e, t);\n  } catch {\n    return e;\n  }\n}\nfunction Io(e, t) {\n  if (e = Nt(e), t = Mo(t), e.type.includes(\"hsl\"))\n    e.values[2] *= 1 - t;\n  else if (e.type.includes(\"rgb\") || e.type.includes(\"color\"))\n    for (let r = 0; r < 3; r += 1)\n      e.values[r] *= 1 - t;\n  return Bn(e);\n}\nfunction Ce(e, t, r) {\n  try {\n    return Io(e, t);\n  } catch {\n    return e;\n  }\n}\nfunction _o(e, t) {\n  if (e = Nt(e), t = Mo(t), e.type.includes(\"hsl\"))\n    e.values[2] += (100 - e.values[2]) * t;\n  else if (e.type.includes(\"rgb\"))\n    for (let r = 0; r < 3; r += 1)\n      e.values[r] += (255 - e.values[r]) * t;\n  else if (e.type.includes(\"color\"))\n    for (let r = 0; r < 3; r += 1)\n      e.values[r] += (1 - e.values[r]) * t;\n  return Bn(e);\n}\nfunction Te(e, t, r) {\n  try {\n    return _o(e, t);\n  } catch {\n    return e;\n  }\n}\nfunction Nu(e, t = 0.15) {\n  return lo(e) > 0.5 ? Io(e, t) : _o(e, t);\n}\nfunction Jr(e, t, r) {\n  try {\n    return Nu(e, t);\n  } catch {\n    return e;\n  }\n}\nfunction ar(e, t) {\n  return  false ? 0 : function(...n) {\n    return e(...n) || t(...n);\n  };\n}\nfunction Mu(e) {\n  const {\n    prototype: t = {}\n  } = e;\n  return !!t.isReactComponent;\n}\nfunction Xa(e, t, r, n, o) {\n  const i = e[t], s = o || t;\n  if (i == null || // When server-side rendering React doesn't warn either.\n  // This is not an accurate check for SSR.\n  // This is only in place for Emotion compat.\n  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.\n  typeof window > \"u\")\n    return null;\n  let c;\n  const l = i.type;\n  return typeof l == \"function\" && !Mu(l) && (c = \"Did you accidentally use a plain function component for an element instead?\"), c !== void 0 ? new Error(`Invalid ${n} \\`${s}\\` supplied to \\`${r}\\`. Expected an element that can hold a ref. ${c} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;\n}\nconst jo = ar(a.element, Xa);\njo.isRequired = ar(a.element.isRequired, Xa);\nfunction Iu(e) {\n  const {\n    prototype: t = {}\n  } = e;\n  return !!t.isReactComponent;\n}\nfunction _u(e, t, r, n, o) {\n  const i = e[t], s = o || t;\n  if (i == null || // When server-side rendering React doesn't warn either.\n  // This is not an accurate check for SSR.\n  // This is only in place for emotion compat.\n  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.\n  typeof window > \"u\")\n    return null;\n  let c;\n  return typeof i == \"function\" && !Iu(i) && (c = \"Did you accidentally provide a plain function component instead?\"), c !== void 0 ? new Error(`Invalid ${n} \\`${s}\\` supplied to \\`${r}\\`. Expected an element type that can hold a ref. ${c} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;\n}\nconst Ja = ar(a.elementType, _u), ju = \"exact-prop: \";\nfunction Do(e) {\n  return  false ? 0 : {\n    ...e,\n    [ju]: (t) => {\n      const r = Object.keys(t).filter((n) => !e.hasOwnProperty(n));\n      return r.length > 0 ? new Error(`The following props are not supported: ${r.map((n) => `\\`${n}\\``).join(\", \")}. Please remove them.`) : null;\n    }\n  };\n}\nfunction Or(e, t, r, n, o) {\n  if (false)\n    {}\n  const i = e[t], s = o || t;\n  return i == null ? null : i && i.nodeType !== 1 ? new Error(`Invalid ${n} \\`${s}\\` supplied to \\`${r}\\`. Expected an HTMLElement.`) : null;\n}\nconst Lo = a.oneOfType([a.func, a.object]);\nfunction zi(e) {\n  return e && e.ownerDocument || document;\n}\nfunction uo(e, t) {\n  typeof e == \"function\" ? e(t) : e && (e.current = t);\n}\nlet Wi = 0;\nfunction Du(e) {\n  const [t, r] = react__WEBPACK_IMPORTED_MODULE_0__.useState(e), n = e || t;\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    t == null && (Wi += 1, r(`mui-${Wi}`));\n  }, [t]), n;\n}\nconst Lu = {\n  .../*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))\n}, Ui = Lu.useId;\nfunction Qa(e) {\n  if (Ui !== void 0) {\n    const t = Ui();\n    return e ?? t;\n  }\n  return Du(e);\n}\nfunction Bu(e, t, r, n, o) {\n  if (false)\n    {}\n  const i = o || t;\n  return typeof e[t] < \"u\" ? new Error(`The prop \\`${i}\\` is not supported. Please remove it.`) : null;\n}\nfunction Vu({\n  controlled: e,\n  default: t,\n  name: r,\n  state: n = \"value\"\n}) {\n  const {\n    current: o\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useRef(e !== void 0), [i, s] = react__WEBPACK_IMPORTED_MODULE_0__.useState(t), c = o ? e : i;\n  if (true) {\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      o !== (e !== void 0) && console.error([`MUI: A component is changing the ${o ? \"\" : \"un\"}controlled ${n} state of ${r} to be ${o ? \"un\" : \"\"}controlled.`, \"Elements should not switch from uncontrolled to controlled (or vice versa).\", `Decide between using a controlled or uncontrolled ${r} element for the lifetime of the component.`, \"The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.\", \"More info: https://fb.me/react-controlled-components\"].join(`\n`));\n    }, [n, r, e]);\n    const {\n      current: u\n    } = react__WEBPACK_IMPORTED_MODULE_0__.useRef(t);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      !o && !Object.is(u, t) && console.error([`MUI: A component is changing the default ${n} state of an uncontrolled ${r} after being initialized. To suppress this warning opt to use a controlled ${r}.`].join(`\n`));\n    }, [JSON.stringify(t)]);\n  }\n  const l = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((u) => {\n    o || s(u);\n  }, []);\n  return [c, l];\n}\nfunction Qt(e) {\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useRef(e);\n  return Ft(() => {\n    t.current = e;\n  }), react__WEBPACK_IMPORTED_MODULE_0__.useRef((...r) => (\n    // @ts-expect-error hide `this`\n    (0, t.current)(...r)\n  )).current;\n}\nfunction at(...e) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => e.every((t) => t == null) ? null : (t) => {\n    e.forEach((r) => {\n      uo(r, t);\n    });\n  }, e);\n}\nconst Yi = {};\nfunction Za(e, t) {\n  const r = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Yi);\n  return r.current === Yi && (r.current = e(t)), r;\n}\nconst Fu = [];\nfunction zu(e) {\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(e, Fu);\n}\nclass Vn {\n  constructor() {\n    cr(this, \"currentId\", null);\n    cr(this, \"clear\", () => {\n      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);\n    });\n    cr(this, \"disposeEffect\", () => this.clear);\n  }\n  static create() {\n    return new Vn();\n  }\n  /**\n   * Executes `fn` after `delay`, clearing any previously scheduled call.\n   */\n  start(t, r) {\n    this.clear(), this.currentId = setTimeout(() => {\n      this.currentId = null, r();\n    }, t);\n  }\n}\nfunction Dt() {\n  const e = Za(Vn.create).current;\n  return zu(e.disposeEffect), e;\n}\nfunction hn(e) {\n  try {\n    return e.matches(\":focus-visible\");\n  } catch {\n     true && !/jsdom/.test(window.navigator.userAgent) && console.warn([\"MUI: The `:focus-visible` pseudo class is not supported in this browser.\", \"Some components rely on this feature to work properly.\"].join(`\n`));\n  }\n  return !1;\n}\nfunction Ge(e, t, r = void 0) {\n  const n = {};\n  for (const o in e) {\n    const i = e[o];\n    let s = \"\", c = !0;\n    for (let l = 0; l < i.length; l += 1) {\n      const u = i[l];\n      u && (s += (c === !0 ? \"\" : \" \") + t(u), c = !1, r && r[u] && (s += \" \" + r[u]));\n    }\n    n[o] = s;\n  }\n  return n;\n}\nfunction Wu(e) {\n  return typeof e == \"string\";\n}\nfunction es(e, t, r) {\n  return e === void 0 || Wu(e) ? t : {\n    ...t,\n    ownerState: {\n      ...t.ownerState,\n      ...r\n    }\n  };\n}\nfunction Uu(e, t = []) {\n  if (e === void 0)\n    return {};\n  const r = {};\n  return Object.keys(e).filter((n) => n.match(/^on[A-Z]/) && typeof e[n] == \"function\" && !t.includes(n)).forEach((n) => {\n    r[n] = e[n];\n  }), r;\n}\nfunction Hi(e) {\n  if (e === void 0)\n    return {};\n  const t = {};\n  return Object.keys(e).filter((r) => !(r.match(/^on[A-Z]/) && typeof e[r] == \"function\")).forEach((r) => {\n    t[r] = e[r];\n  }), t;\n}\nfunction ts(e) {\n  const {\n    getSlotProps: t,\n    additionalProps: r,\n    externalSlotProps: n,\n    externalForwardedProps: o,\n    className: i\n  } = e;\n  if (!t) {\n    const x = se(r == null ? void 0 : r.className, i, o == null ? void 0 : o.className, n == null ? void 0 : n.className), y = {\n      ...r == null ? void 0 : r.style,\n      ...o == null ? void 0 : o.style,\n      ...n == null ? void 0 : n.style\n    }, f = {\n      ...r,\n      ...o,\n      ...n\n    };\n    return x.length > 0 && (f.className = x), Object.keys(y).length > 0 && (f.style = y), {\n      props: f,\n      internalRef: void 0\n    };\n  }\n  const s = Uu({\n    ...o,\n    ...n\n  }), c = Hi(n), l = Hi(o), u = t(s), p = se(u == null ? void 0 : u.className, r == null ? void 0 : r.className, i, o == null ? void 0 : o.className, n == null ? void 0 : n.className), m = {\n    ...u == null ? void 0 : u.style,\n    ...r == null ? void 0 : r.style,\n    ...o == null ? void 0 : o.style,\n    ...n == null ? void 0 : n.style\n  }, g = {\n    ...u,\n    ...r,\n    ...l,\n    ...c\n  };\n  return p.length > 0 && (g.className = p), Object.keys(m).length > 0 && (g.style = m), {\n    props: g,\n    internalRef: u.ref\n  };\n}\nfunction rs(e, t, r) {\n  return typeof e == \"function\" ? e(t, r) : e;\n}\nfunction Yu(e) {\n  var m;\n  const {\n    elementType: t,\n    externalSlotProps: r,\n    ownerState: n,\n    skipResolvingSlotProps: o = !1,\n    ...i\n  } = e, s = o ? {} : rs(r, n), {\n    props: c,\n    internalRef: l\n  } = ts({\n    ...i,\n    externalSlotProps: s\n  }), u = at(l, s == null ? void 0 : s.ref, (m = e.additionalProps) == null ? void 0 : m.ref);\n  return es(t, {\n    ...c,\n    ref: u\n  }, n);\n}\nfunction Bo(e) {\n  var t;\n  return parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version, 10) >= 19 ? ((t = e == null ? void 0 : e.props) == null ? void 0 : t.ref) || null : (e == null ? void 0 : e.ref) || null;\n}\nconst Vo = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n true && (Vo.displayName = \"ThemeContext\");\nfunction Fo() {\n  const e = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Vo);\n  return  true && react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(e), e;\n}\nconst Hu = typeof Symbol == \"function\" && Symbol.for, qu = Hu ? Symbol.for(\"mui.nested\") : \"__THEME_NESTED__\";\nfunction Gu(e, t) {\n  if (typeof t == \"function\") {\n    const r = t(e);\n    return  true && (r || console.error([\"MUI: You should return an object from your theme function, i.e.\", \"<ThemeProvider theme={() => ({})} />\"].join(`\n`))), r;\n  }\n  return {\n    ...e,\n    ...t\n  };\n}\nfunction gn(e) {\n  const {\n    children: t,\n    theme: r\n  } = e, n = Fo();\n   true && n === null && typeof r == \"function\" && console.error([\"MUI: You are providing a theme function prop to the ThemeProvider component:\", \"<ThemeProvider theme={outerTheme => outerTheme} />\", \"\", \"However, no outer theme is present.\", \"Make sure a theme is already injected higher in the React tree or provide a theme object.\"].join(`\n`));\n  const o = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const i = n === null ? {\n      ...r\n    } : Gu(n, r);\n    return i != null && (i[qu] = n !== null), i;\n  }, [r, n]);\n  return /* @__PURE__ */ N.jsx(Vo.Provider, {\n    value: o,\n    children: t\n  });\n}\n true && (gn.propTypes = {\n  /**\n   * Your component tree.\n   */\n  children: a.node,\n  /**\n   * A theme object. You can provide a function to extend the outer theme.\n   */\n  theme: a.oneOfType([a.object, a.func]).isRequired\n});\n true && (gn.propTypes = Do(gn.propTypes));\nconst ns = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext();\nfunction os({\n  value: e,\n  ...t\n}) {\n  return /* @__PURE__ */ N.jsx(ns.Provider, {\n    value: e ?? !0,\n    ...t\n  });\n}\n true && (os.propTypes = {\n  children: a.node,\n  value: a.bool\n});\nconst is = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(ns) ?? !1, as = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nfunction ss({\n  value: e,\n  children: t\n}) {\n  return /* @__PURE__ */ N.jsx(as.Provider, {\n    value: e,\n    children: t\n  });\n}\n true && (ss.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //  To update them, edit the TypeScript types and run `pnpm proptypes`. \n  // \n  /**\n   * @ignore\n   */\n  children: a.node,\n  /**\n   * @ignore\n   */\n  value: a.object\n});\nfunction Ku(e) {\n  const {\n    theme: t,\n    name: r,\n    props: n\n  } = e;\n  if (!t || !t.components || !t.components[r])\n    return n;\n  const o = t.components[r];\n  return o.defaultProps ? co(o.defaultProps, n) : !o.styleOverrides && !o.variants ? co(o, n) : n;\n}\nfunction Xu({\n  props: e,\n  name: t\n}) {\n  const r = react__WEBPACK_IMPORTED_MODULE_0__.useContext(as);\n  return Ku({\n    props: e,\n    name: t,\n    theme: {\n      components: r\n    }\n  });\n}\nconst qi = {};\nfunction Gi(e, t, r, n = !1) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const o = e && t[e] || t;\n    if (typeof r == \"function\") {\n      const i = r(o), s = e ? {\n        ...t,\n        [e]: i\n      } : i;\n      return n ? () => s : s;\n    }\n    return e ? {\n      ...t,\n      [e]: r\n    } : {\n      ...t,\n      ...r\n    };\n  }, [e, t, r, n]);\n}\nfunction Rr(e) {\n  const {\n    children: t,\n    theme: r,\n    themeId: n\n  } = e, o = Va(qi), i = Fo() || qi;\n   true && (o === null && typeof r == \"function\" || n && o && !o[n] && typeof r == \"function\") && console.error([\"MUI: You are providing a theme function prop to the ThemeProvider component:\", \"<ThemeProvider theme={outerTheme => outerTheme} />\", \"\", \"However, no outer theme is present.\", \"Make sure a theme is already injected higher in the React tree or provide a theme object.\"].join(`\n`));\n  const s = Gi(n, o, r), c = Gi(n, i, r, !0), l = (n ? s[n] : s).direction === \"rtl\";\n  return /* @__PURE__ */ N.jsx(gn, {\n    theme: c,\n    children: /* @__PURE__ */ N.jsx(Mr.Provider, {\n      value: s,\n      children: /* @__PURE__ */ N.jsx(os, {\n        value: l,\n        children: /* @__PURE__ */ N.jsx(ss, {\n          value: n ? s[n].components : s.components,\n          children: t\n        })\n      })\n    })\n  });\n}\n true && (Rr.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Your component tree.\n   */\n  children: a.node,\n  /**\n   * A theme object. You can provide a function to extend the outer theme.\n   */\n  theme: a.oneOfType([a.func, a.object]).isRequired,\n  /**\n   * The design system's unique id for getting the corresponded theme when there are multiple design systems.\n   */\n  themeId: a.string\n});\n true && (Rr.propTypes = Do(Rr.propTypes));\nconst Ki = {\n  theme: void 0\n};\nfunction Ju(e) {\n  let t, r;\n  return function(o) {\n    let i = t;\n    return (i === void 0 || o.theme !== r) && (Ki.theme = o.theme, i = Ha(e(Ki)), t = i, r = o.theme), i;\n  };\n}\nconst zo = \"mode\", Wo = \"color-scheme\", Qu = \"data-color-scheme\";\nfunction Zu(e) {\n  const {\n    defaultMode: t = \"system\",\n    defaultLightColorScheme: r = \"light\",\n    defaultDarkColorScheme: n = \"dark\",\n    modeStorageKey: o = zo,\n    colorSchemeStorageKey: i = Wo,\n    attribute: s = Qu,\n    colorSchemeNode: c = \"document.documentElement\",\n    nonce: l\n  } = e;\n  let u = \"\", p = s;\n  if (s === \"class\" && (p = \".%s\"), s === \"data\" && (p = \"[data-%s]\"), p.startsWith(\".\")) {\n    const g = p.substring(1);\n    u += `${c}.classList.remove('${g}'.replace('%s', light), '${g}'.replace('%s', dark));\n      ${c}.classList.add('${g}'.replace('%s', colorScheme));`;\n  }\n  const m = p.match(/\\[([^\\]]+)\\]/);\n  if (m) {\n    const [g, x] = m[1].split(\"=\");\n    x || (u += `${c}.removeAttribute('${g}'.replace('%s', light));\n      ${c}.removeAttribute('${g}'.replace('%s', dark));`), u += `\n      ${c}.setAttribute('${g}'.replace('%s', colorScheme), ${x ? `${x}.replace('%s', colorScheme)` : '\"\"'});`;\n  } else\n    u += `${c}.setAttribute('${p}', colorScheme);`;\n  return /* @__PURE__ */ N.jsx(\"script\", {\n    suppressHydrationWarning: !0,\n    nonce: typeof window > \"u\" ? l : \"\",\n    dangerouslySetInnerHTML: {\n      __html: `(function() {\ntry {\n  let colorScheme = '';\n  const mode = localStorage.getItem('${o}') || '${t}';\n  const dark = localStorage.getItem('${i}-dark') || '${n}';\n  const light = localStorage.getItem('${i}-light') || '${r}';\n  if (mode === 'system') {\n    // handle system mode\n    const mql = window.matchMedia('(prefers-color-scheme: dark)');\n    if (mql.matches) {\n      colorScheme = dark\n    } else {\n      colorScheme = light\n    }\n  }\n  if (mode === 'light') {\n    colorScheme = light;\n  }\n  if (mode === 'dark') {\n    colorScheme = dark;\n  }\n  if (colorScheme) {\n    ${u}\n  }\n} catch(e){}})();`\n    }\n  }, \"mui-color-scheme-init\");\n}\nfunction Xi(e) {\n  if (typeof window < \"u\" && typeof window.matchMedia == \"function\" && e === \"system\")\n    return window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n}\nfunction cs(e, t) {\n  if (e.mode === \"light\" || e.mode === \"system\" && e.systemMode === \"light\")\n    return t(\"light\");\n  if (e.mode === \"dark\" || e.mode === \"system\" && e.systemMode === \"dark\")\n    return t(\"dark\");\n}\nfunction ef(e) {\n  return cs(e, (t) => {\n    if (t === \"light\")\n      return e.lightColorScheme;\n    if (t === \"dark\")\n      return e.darkColorScheme;\n  });\n}\nfunction eo(e, t) {\n  if (typeof window > \"u\")\n    return;\n  let r;\n  try {\n    r = localStorage.getItem(e) || void 0, r || localStorage.setItem(e, t);\n  } catch {\n  }\n  return r || t;\n}\nfunction tf(e) {\n  const {\n    defaultMode: t = \"light\",\n    defaultLightColorScheme: r,\n    defaultDarkColorScheme: n,\n    supportedColorSchemes: o = [],\n    modeStorageKey: i = zo,\n    colorSchemeStorageKey: s = Wo,\n    storageWindow: c = typeof window > \"u\" ? void 0 : window,\n    noSsr: l = !1\n  } = e, u = o.join(\",\"), p = o.length > 1, [m, g] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {\n    const b = eo(i, t), h = eo(`${s}-light`, r), w = eo(`${s}-dark`, n);\n    return {\n      mode: b,\n      systemMode: Xi(b),\n      lightColorScheme: h,\n      darkColorScheme: w\n    };\n  }), [x, y] = react__WEBPACK_IMPORTED_MODULE_0__.useState(l || !p);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    y(!0);\n  }, []);\n  const f = ef(m), S = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((b) => {\n    g((h) => {\n      if (b === h.mode)\n        return h;\n      const w = b ?? t;\n      try {\n        localStorage.setItem(i, w);\n      } catch {\n      }\n      return {\n        ...h,\n        mode: w,\n        systemMode: Xi(w)\n      };\n    });\n  }, [i, t]), E = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((b) => {\n    b ? typeof b == \"string\" ? b && !u.includes(b) ? console.error(`\\`${b}\\` does not exist in \\`theme.colorSchemes\\`.`) : g((h) => {\n      const w = {\n        ...h\n      };\n      return cs(h, (k) => {\n        try {\n          localStorage.setItem(`${s}-${k}`, b);\n        } catch {\n        }\n        k === \"light\" && (w.lightColorScheme = b), k === \"dark\" && (w.darkColorScheme = b);\n      }), w;\n    }) : g((h) => {\n      const w = {\n        ...h\n      }, k = b.light === null ? r : b.light, L = b.dark === null ? n : b.dark;\n      if (k)\n        if (!u.includes(k))\n          console.error(`\\`${k}\\` does not exist in \\`theme.colorSchemes\\`.`);\n        else {\n          w.lightColorScheme = k;\n          try {\n            localStorage.setItem(`${s}-light`, k);\n          } catch {\n          }\n        }\n      if (L)\n        if (!u.includes(L))\n          console.error(`\\`${L}\\` does not exist in \\`theme.colorSchemes\\`.`);\n        else {\n          w.darkColorScheme = L;\n          try {\n            localStorage.setItem(`${s}-dark`, L);\n          } catch {\n          }\n        }\n      return w;\n    }) : g((h) => {\n      try {\n        localStorage.setItem(`${s}-light`, r), localStorage.setItem(`${s}-dark`, n);\n      } catch {\n      }\n      return {\n        ...h,\n        lightColorScheme: r,\n        darkColorScheme: n\n      };\n    });\n  }, [u, s, r, n]), P = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((b) => {\n    m.mode === \"system\" && g((h) => {\n      const w = b != null && b.matches ? \"dark\" : \"light\";\n      return h.systemMode === w ? h : {\n        ...h,\n        systemMode: w\n      };\n    });\n  }, [m.mode]), T = react__WEBPACK_IMPORTED_MODULE_0__.useRef(P);\n  return T.current = P, react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (typeof window.matchMedia != \"function\" || !p)\n      return;\n    const b = (...w) => T.current(...w), h = window.matchMedia(\"(prefers-color-scheme: dark)\");\n    return h.addListener(b), b(h), () => {\n      h.removeListener(b);\n    };\n  }, [p]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (c && p) {\n      const b = (h) => {\n        const w = h.newValue;\n        typeof h.key == \"string\" && h.key.startsWith(s) && (!w || u.match(w)) && (h.key.endsWith(\"light\") && E({\n          light: w\n        }), h.key.endsWith(\"dark\") && E({\n          dark: w\n        })), h.key === i && (!w || [\"light\", \"dark\", \"system\"].includes(w)) && S(w || t);\n      };\n      return c.addEventListener(\"storage\", b), () => {\n        c.removeEventListener(\"storage\", b);\n      };\n    }\n  }, [E, S, i, s, u, t, c, p]), {\n    ...m,\n    mode: x ? m.mode : void 0,\n    systemMode: x ? m.systemMode : void 0,\n    colorScheme: x ? f : void 0,\n    setMode: S,\n    setColorScheme: E\n  };\n}\nconst rf = \"*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\nfunction nf(e) {\n  const {\n    themeId: t,\n    /**\n     * This `theme` object needs to follow a certain structure to\n     * be used correctly by the finel `CssVarsProvider`. It should have a\n     * `colorSchemes` key with the light and dark (and any other) palette.\n     * It should also ideally have a vars object created using `prepareCssVars`.\n     */\n    theme: r = {},\n    modeStorageKey: n = zo,\n    colorSchemeStorageKey: o = Wo,\n    disableTransitionOnChange: i = !1,\n    defaultColorScheme: s,\n    resolveTheme: c\n  } = e, l = {\n    allColorSchemes: [],\n    colorScheme: void 0,\n    darkColorScheme: void 0,\n    lightColorScheme: void 0,\n    mode: void 0,\n    setColorScheme: () => {\n    },\n    setMode: () => {\n    },\n    systemMode: void 0\n  }, u = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\n   true && (u.displayName = \"ColorSchemeContext\");\n  const p = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(u) || l, m = {}, g = {};\n  function x(E) {\n    var Y, oe, Re, ue;\n    const {\n      children: P,\n      theme: T,\n      modeStorageKey: b = n,\n      colorSchemeStorageKey: h = o,\n      disableTransitionOnChange: w = i,\n      storageWindow: k = typeof window > \"u\" ? void 0 : window,\n      documentNode: L = typeof document > \"u\" ? void 0 : document,\n      colorSchemeNode: B = typeof document > \"u\" ? void 0 : document.documentElement,\n      disableNestedContext: d = !1,\n      disableStyleSheetGeneration: A = !1,\n      defaultMode: D = \"system\",\n      noSsr: j\n    } = E, W = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!1), z = Fo(), U = react__WEBPACK_IMPORTED_MODULE_0__.useContext(u), V = !!U && !d, te = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => T || (typeof r == \"function\" ? r() : r), [T]), F = te[t], R = F || te, {\n      colorSchemes: I = m,\n      components: J = g,\n      cssVarPrefix: Q\n    } = R, H = Object.keys(I).filter((K) => !!I[K]).join(\",\"), X = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => H.split(\",\"), [H]), _ = typeof s == \"string\" ? s : s.light, q = typeof s == \"string\" ? s : s.dark, G = I[_] && I[q] ? D : ((oe = (Y = I[R.defaultColorScheme]) == null ? void 0 : Y.palette) == null ? void 0 : oe.mode) || ((Re = R.palette) == null ? void 0 : Re.mode), {\n      mode: re,\n      setMode: Z,\n      systemMode: ae,\n      lightColorScheme: O,\n      darkColorScheme: ye,\n      colorScheme: Ee,\n      setColorScheme: Me\n    } = tf({\n      supportedColorSchemes: X,\n      defaultLightColorScheme: _,\n      defaultDarkColorScheme: q,\n      modeStorageKey: b,\n      colorSchemeStorageKey: h,\n      defaultMode: G,\n      storageWindow: k,\n      noSsr: j\n    });\n    let Qe = re, ve = Ee;\n    V && (Qe = U.mode, ve = U.colorScheme);\n    const Pe = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n      var Oe;\n      const K = ve || R.defaultColorScheme, be = ((Oe = R.generateThemeVars) == null ? void 0 : Oe.call(R)) || R.vars, we = {\n        ...R,\n        components: J,\n        colorSchemes: I,\n        cssVarPrefix: Q,\n        vars: be\n      };\n      if (typeof we.generateSpacing == \"function\" && (we.spacing = we.generateSpacing()), K) {\n        const ce = I[K];\n        ce && typeof ce == \"object\" && Object.keys(ce).forEach((Ie) => {\n          ce[Ie] && typeof ce[Ie] == \"object\" ? we[Ie] = {\n            ...we[Ie],\n            ...ce[Ie]\n          } : we[Ie] = ce[Ie];\n        });\n      }\n      return c ? c(we) : we;\n    }, [R, ve, J, I, Q]), ze = R.colorSchemeSelector;\n    Ft(() => {\n      if (ve && B && ze && ze !== \"media\") {\n        const K = ze;\n        let be = ze;\n        if (K === \"class\" && (be = \".%s\"), K === \"data\" && (be = \"[data-%s]\"), K != null && K.startsWith(\"data-\") && !K.includes(\"%s\") && (be = `[${K}=\"%s\"]`), be.startsWith(\".\"))\n          B.classList.remove(...X.map((we) => be.substring(1).replace(\"%s\", we))), B.classList.add(be.substring(1).replace(\"%s\", ve));\n        else {\n          const we = be.replace(\"%s\", ve).match(/\\[([^\\]]+)\\]/);\n          if (we) {\n            const [Oe, ce] = we[1].split(\"=\");\n            ce || X.forEach((Ie) => {\n              B.removeAttribute(Oe.replace(ve, Ie));\n            }), B.setAttribute(Oe, ce ? ce.replace(/\"|'/g, \"\") : \"\");\n          } else\n            B.setAttribute(be, ve);\n        }\n      }\n    }, [ve, ze, B, X]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      let K;\n      if (w && W.current && L) {\n        const be = L.createElement(\"style\");\n        be.appendChild(L.createTextNode(rf)), L.head.appendChild(be), window.getComputedStyle(L.body), K = setTimeout(() => {\n          L.head.removeChild(be);\n        }, 1);\n      }\n      return () => {\n        clearTimeout(K);\n      };\n    }, [ve, w, L]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => (W.current = !0, () => {\n      W.current = !1;\n    }), []);\n    const Le = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      allColorSchemes: X,\n      colorScheme: ve,\n      darkColorScheme: ye,\n      lightColorScheme: O,\n      mode: Qe,\n      setColorScheme: Me,\n      setMode:  false ? 0 : (K) => {\n        Pe.colorSchemeSelector === \"media\" && console.error([\"MUI: The `setMode` function has no effect if `colorSchemeSelector` is `media` (`media` is the default value).\", \"To toggle the mode manually, please configure `colorSchemeSelector` to use a class or data attribute.\", \"To learn more, visit https://mui.com/material-ui/customization/css-theme-variables/configuration/#toggling-dark-mode-manually\"].join(`\n`)), Z(K);\n      },\n      systemMode: ae\n    }), [X, ve, ye, O, Qe, Me, Z, ae, Pe.colorSchemeSelector]);\n    let v = !0;\n    (A || R.cssVariables === !1 || V && (z == null ? void 0 : z.cssVarPrefix) === Q) && (v = !1);\n    const M = /* @__PURE__ */ N.jsxs(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n      children: [/* @__PURE__ */ N.jsx(Rr, {\n        themeId: F ? t : void 0,\n        theme: Pe,\n        children: P\n      }), v && /* @__PURE__ */ N.jsx(_a, {\n        styles: ((ue = Pe.generateStyleSheets) == null ? void 0 : ue.call(Pe)) || []\n      })]\n    });\n    return V ? M : /* @__PURE__ */ N.jsx(u.Provider, {\n      value: Le,\n      children: M\n    });\n  }\n   true && (x.propTypes = {\n    /**\n     * The component tree.\n     */\n    children: a.node,\n    /**\n     * The node used to attach the color-scheme attribute\n     */\n    colorSchemeNode: a.any,\n    /**\n     * localStorage key used to store `colorScheme`\n     */\n    colorSchemeStorageKey: a.string,\n    /**\n     * The default mode when the storage is empty,\n     * require the theme to have `colorSchemes` with light and dark.\n     */\n    defaultMode: a.string,\n    /**\n     * If `true`, the provider creates its own context and generate stylesheet as if it is a root `CssVarsProvider`.\n     */\n    disableNestedContext: a.bool,\n    /**\n     * If `true`, the style sheet won't be generated.\n     *\n     * This is useful for controlling nested CssVarsProvider behavior.\n     */\n    disableStyleSheetGeneration: a.bool,\n    /**\n     * Disable CSS transitions when switching between modes or color schemes.\n     */\n    disableTransitionOnChange: a.bool,\n    /**\n     * The document to attach the attribute to.\n     */\n    documentNode: a.any,\n    /**\n     * The key in the local storage used to store current color scheme.\n     */\n    modeStorageKey: a.string,\n    /**\n     * If `true`, the mode will be the same value as the storage without an extra rerendering after the hydration.\n     * You should use this option in conjuction with `InitColorSchemeScript` component.\n     */\n    noSsr: a.bool,\n    /**\n     * The window that attaches the 'storage' event listener.\n     * @default window\n     */\n    storageWindow: a.any,\n    /**\n     * The calculated theme object that will be passed through context.\n     */\n    theme: a.object\n  });\n  const y = typeof s == \"string\" ? s : s.light, f = typeof s == \"string\" ? s : s.dark;\n  return {\n    CssVarsProvider: x,\n    useColorScheme: p,\n    getInitColorSchemeScript: (E) => Zu({\n      colorSchemeStorageKey: o,\n      defaultLightColorScheme: y,\n      defaultDarkColorScheme: f,\n      modeStorageKey: n,\n      ...E\n    })\n  };\n}\nfunction of(e = \"\") {\n  function t(...n) {\n    if (!n.length)\n      return \"\";\n    const o = n[0];\n    return typeof o == \"string\" && !o.match(/(#|\\(|\\)|(-?(\\d*\\.)?\\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\\d*\\.)?\\d+)$|(\\d+ \\d+ \\d+)/) ? `, var(--${e ? `${e}-` : \"\"}${o}${t(...n.slice(1))})` : `, ${o}`;\n  }\n  return (n, ...o) => `var(--${e ? `${e}-` : \"\"}${n}${t(...o)})`;\n}\nconst Ji = (e, t, r, n = []) => {\n  let o = e;\n  t.forEach((i, s) => {\n    s === t.length - 1 ? Array.isArray(o) ? o[Number(i)] = r : o && typeof o == \"object\" && (o[i] = r) : o && typeof o == \"object\" && (o[i] || (o[i] = n.includes(i) ? [] : {}), o = o[i]);\n  });\n}, af = (e, t, r) => {\n  function n(o, i = [], s = []) {\n    Object.entries(o).forEach(([c, l]) => {\n      (!r || !r([...i, c])) && l != null && (typeof l == \"object\" && Object.keys(l).length > 0 ? n(l, [...i, c], Array.isArray(l) ? [...s, c] : s) : t([...i, c], l, s));\n    });\n  }\n  n(e);\n}, sf = (e, t) => typeof t == \"number\" ? [\"lineHeight\", \"fontWeight\", \"opacity\", \"zIndex\"].some((n) => e.includes(n)) || e[e.length - 1].toLowerCase().includes(\"opacity\") ? t : `${t}px` : t;\nfunction to(e, t) {\n  const {\n    prefix: r,\n    shouldSkipGeneratingVar: n\n  } = t || {}, o = {}, i = {}, s = {};\n  return af(\n    e,\n    (c, l, u) => {\n      if ((typeof l == \"string\" || typeof l == \"number\") && (!n || !n(c, l))) {\n        const p = `--${r ? `${r}-` : \"\"}${c.join(\"-\")}`, m = sf(c, l);\n        Object.assign(o, {\n          [p]: m\n        }), Ji(i, c, `var(${p})`, u), Ji(s, c, `var(${p}, ${m})`, u);\n      }\n    },\n    (c) => c[0] === \"vars\"\n    // skip 'vars/*' paths\n  ), {\n    css: o,\n    vars: i,\n    varsWithDefaults: s\n  };\n}\nfunction cf(e, t = {}) {\n  const {\n    getSelector: r = S,\n    disableCssColorScheme: n,\n    colorSchemeSelector: o\n  } = t, {\n    colorSchemes: i = {},\n    components: s,\n    defaultColorScheme: c = \"light\",\n    ...l\n  } = e, {\n    vars: u,\n    css: p,\n    varsWithDefaults: m\n  } = to(l, t);\n  let g = m;\n  const x = {}, {\n    [c]: y,\n    ...f\n  } = i;\n  if (Object.entries(f || {}).forEach(([T, b]) => {\n    const {\n      vars: h,\n      css: w,\n      varsWithDefaults: k\n    } = to(b, t);\n    g = tt(g, k), x[T] = {\n      css: w,\n      vars: h\n    };\n  }), y) {\n    const {\n      css: T,\n      vars: b,\n      varsWithDefaults: h\n    } = to(y, t);\n    g = tt(g, h), x[c] = {\n      css: T,\n      vars: b\n    };\n  }\n  function S(T, b) {\n    var w, k;\n    let h = o;\n    if (o === \"class\" && (h = \".%s\"), o === \"data\" && (h = \"[data-%s]\"), o != null && o.startsWith(\"data-\") && !o.includes(\"%s\") && (h = `[${o}=\"%s\"]`), T) {\n      if (h === \"media\")\n        return e.defaultColorScheme === T ? \":root\" : {\n          [`@media (prefers-color-scheme: ${((k = (w = i[T]) == null ? void 0 : w.palette) == null ? void 0 : k.mode) || T})`]: {\n            \":root\": b\n          }\n        };\n      if (h)\n        return e.defaultColorScheme === T ? `:root, ${h.replace(\"%s\", String(T))}` : h.replace(\"%s\", String(T));\n    }\n    return \":root\";\n  }\n  return {\n    vars: g,\n    generateThemeVars: () => {\n      let T = {\n        ...u\n      };\n      return Object.entries(x).forEach(([, {\n        vars: b\n      }]) => {\n        T = tt(T, b);\n      }), T;\n    },\n    generateStyleSheets: () => {\n      var L, B;\n      const T = [], b = e.defaultColorScheme || \"light\";\n      function h(d, A) {\n        Object.keys(A).length && T.push(typeof d == \"string\" ? {\n          [d]: {\n            ...A\n          }\n        } : d);\n      }\n      h(r(void 0, {\n        ...p\n      }), p);\n      const {\n        [b]: w,\n        ...k\n      } = x;\n      if (w) {\n        const {\n          css: d\n        } = w, A = (B = (L = i[b]) == null ? void 0 : L.palette) == null ? void 0 : B.mode, D = !n && A ? {\n          colorScheme: A,\n          ...d\n        } : {\n          ...d\n        };\n        h(r(b, {\n          ...D\n        }), D);\n      }\n      return Object.entries(k).forEach(([d, {\n        css: A\n      }]) => {\n        var W, z;\n        const D = (z = (W = i[d]) == null ? void 0 : W.palette) == null ? void 0 : z.mode, j = !n && D ? {\n          colorScheme: D,\n          ...A\n        } : {\n          ...A\n        };\n        h(r(d, {\n          ...j\n        }), j);\n      }), T;\n    }\n  };\n}\nfunction lf(e) {\n  return function(r) {\n    return e === \"media\" ? ( true && r !== \"light\" && r !== \"dark\" && console.error(`MUI: @media (prefers-color-scheme) supports only 'light' or 'dark', but receive '${r}'.`), `@media (prefers-color-scheme: ${r})`) : e ? e.startsWith(\"data-\") && !e.includes(\"%s\") ? `[${e}=\"${r}\"] &` : e === \"class\" ? `.${r} &` : e === \"data\" ? `[data-${r}] &` : `${e.replace(\"%s\", r)} &` : \"&\";\n  };\n}\nfunction ls() {\n  return {\n    // The colors used to style the text.\n    text: {\n      // The most important text.\n      primary: \"rgba(0, 0, 0, 0.87)\",\n      // Secondary text.\n      secondary: \"rgba(0, 0, 0, 0.6)\",\n      // Disabled text have even lower visual prominence.\n      disabled: \"rgba(0, 0, 0, 0.38)\"\n    },\n    // The color used to divide different elements.\n    divider: \"rgba(0, 0, 0, 0.12)\",\n    // The background colors used to style the surfaces.\n    // Consistency between these values is important.\n    background: {\n      paper: Er.white,\n      default: Er.white\n    },\n    // The colors used to style the action elements.\n    action: {\n      // The color of an active action like an icon button.\n      active: \"rgba(0, 0, 0, 0.54)\",\n      // The color of an hovered action.\n      hover: \"rgba(0, 0, 0, 0.04)\",\n      hoverOpacity: 0.04,\n      // The color of a selected action.\n      selected: \"rgba(0, 0, 0, 0.08)\",\n      selectedOpacity: 0.08,\n      // The color of a disabled action.\n      disabled: \"rgba(0, 0, 0, 0.26)\",\n      // The background color of a disabled action.\n      disabledBackground: \"rgba(0, 0, 0, 0.12)\",\n      disabledOpacity: 0.38,\n      focus: \"rgba(0, 0, 0, 0.12)\",\n      focusOpacity: 0.12,\n      activatedOpacity: 0.12\n    }\n  };\n}\nconst uf = ls();\nfunction us() {\n  return {\n    text: {\n      primary: Er.white,\n      secondary: \"rgba(255, 255, 255, 0.7)\",\n      disabled: \"rgba(255, 255, 255, 0.5)\",\n      icon: \"rgba(255, 255, 255, 0.5)\"\n    },\n    divider: \"rgba(255, 255, 255, 0.12)\",\n    background: {\n      paper: \"#121212\",\n      default: \"#121212\"\n    },\n    action: {\n      active: Er.white,\n      hover: \"rgba(255, 255, 255, 0.08)\",\n      hoverOpacity: 0.08,\n      selected: \"rgba(255, 255, 255, 0.16)\",\n      selectedOpacity: 0.16,\n      disabled: \"rgba(255, 255, 255, 0.3)\",\n      disabledBackground: \"rgba(255, 255, 255, 0.12)\",\n      disabledOpacity: 0.38,\n      focus: \"rgba(255, 255, 255, 0.12)\",\n      focusOpacity: 0.12,\n      activatedOpacity: 0.24\n    }\n  };\n}\nconst Qi = us();\nfunction Zi(e, t, r, n) {\n  const o = n.light || n, i = n.dark || n * 1.5;\n  e[t] || (e.hasOwnProperty(r) ? e[t] = e[r] : t === \"light\" ? e.light = _o(e.main, o) : t === \"dark\" && (e.dark = Io(e.main, i)));\n}\nfunction ff(e = \"light\") {\n  return e === \"dark\" ? {\n    main: Yt[200],\n    light: Yt[50],\n    dark: Yt[400]\n  } : {\n    main: Yt[700],\n    light: Yt[400],\n    dark: Yt[800]\n  };\n}\nfunction df(e = \"light\") {\n  return e === \"dark\" ? {\n    main: Ut[200],\n    light: Ut[50],\n    dark: Ut[400]\n  } : {\n    main: Ut[500],\n    light: Ut[300],\n    dark: Ut[700]\n  };\n}\nfunction pf(e = \"light\") {\n  return e === \"dark\" ? {\n    main: Wt[500],\n    light: Wt[300],\n    dark: Wt[700]\n  } : {\n    main: Wt[700],\n    light: Wt[400],\n    dark: Wt[800]\n  };\n}\nfunction mf(e = \"light\") {\n  return e === \"dark\" ? {\n    main: Ht[400],\n    light: Ht[300],\n    dark: Ht[700]\n  } : {\n    main: Ht[700],\n    light: Ht[500],\n    dark: Ht[900]\n  };\n}\nfunction hf(e = \"light\") {\n  return e === \"dark\" ? {\n    main: qt[400],\n    light: qt[300],\n    dark: qt[700]\n  } : {\n    main: qt[800],\n    light: qt[500],\n    dark: qt[900]\n  };\n}\nfunction gf(e = \"light\") {\n  return e === \"dark\" ? {\n    main: fr[400],\n    light: fr[300],\n    dark: fr[700]\n  } : {\n    main: \"#ed6c02\",\n    // closest to orange[800] that pass 3:1.\n    light: fr[500],\n    dark: fr[900]\n  };\n}\nfunction Uo(e) {\n  const {\n    mode: t = \"light\",\n    contrastThreshold: r = 3,\n    tonalOffset: n = 0.2,\n    ...o\n  } = e, i = e.primary || ff(t), s = e.secondary || df(t), c = e.error || pf(t), l = e.info || mf(t), u = e.success || hf(t), p = e.warning || gf(t);\n  function m(f) {\n    const S = Fi(f, Qi.text.primary) >= r ? Qi.text.primary : uf.text.primary;\n    if (true) {\n      const E = Fi(f, S);\n      E < 3 && console.error([`MUI: The contrast ratio of ${E}:1 for ${S} on ${f}`, \"falls below the WCAG recommended absolute minimum contrast ratio of 3:1.\", \"https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast\"].join(`\n`));\n    }\n    return S;\n  }\n  const g = ({\n    color: f,\n    name: S,\n    mainShade: E = 500,\n    lightShade: P = 300,\n    darkShade: T = 700\n  }) => {\n    if (f = {\n      ...f\n    }, !f.main && f[E] && (f.main = f[E]), !f.hasOwnProperty(\"main\"))\n      throw new Error( true ? `MUI: The color${S ? ` (${S})` : \"\"} provided to augmentColor(color) is invalid.\nThe color object needs to have a \\`main\\` property or a \\`${E}\\` property.` : 0);\n    if (typeof f.main != \"string\")\n      throw new Error( true ? `MUI: The color${S ? ` (${S})` : \"\"} provided to augmentColor(color) is invalid.\n\\`color.main\\` should be a string, but \\`${JSON.stringify(f.main)}\\` was provided instead.\n\nDid you intend to use one of the following approaches?\n\nimport { green } from \"@mui/material/colors\";\n\nconst theme1 = createTheme({ palette: {\n  primary: green,\n} });\n\nconst theme2 = createTheme({ palette: {\n  primary: { main: green[500] },\n} });` : 0);\n    return Zi(f, \"light\", P, n), Zi(f, \"dark\", T, n), f.contrastText || (f.contrastText = m(f.main)), f;\n  };\n  let x;\n  return t === \"light\" ? x = ls() : t === \"dark\" && (x = us()),  true && (x || console.error(`MUI: The palette mode \\`${t}\\` is not supported.`)), tt({\n    // A collection of common colors.\n    common: {\n      ...Er\n    },\n    // prevent mutable object.\n    // The palette mode, can be light or dark.\n    mode: t,\n    // The colors used to represent primary interface elements for a user.\n    primary: g({\n      color: i,\n      name: \"primary\"\n    }),\n    // The colors used to represent secondary interface elements for a user.\n    secondary: g({\n      color: s,\n      name: \"secondary\",\n      mainShade: \"A400\",\n      lightShade: \"A200\",\n      darkShade: \"A700\"\n    }),\n    // The colors used to represent interface elements that the user should be made aware of.\n    error: g({\n      color: c,\n      name: \"error\"\n    }),\n    // The colors used to represent potentially dangerous actions or important messages.\n    warning: g({\n      color: p,\n      name: \"warning\"\n    }),\n    // The colors used to present information to the user that is neutral and not necessarily important.\n    info: g({\n      color: l,\n      name: \"info\"\n    }),\n    // The colors used to indicate the successful completion of an action that user triggered.\n    success: g({\n      color: u,\n      name: \"success\"\n    }),\n    // The grey colors.\n    grey: oc,\n    // Used by `getContrastText()` to maximize the contrast between\n    // the background and the text.\n    contrastThreshold: r,\n    // Takes a background color and returns the text color that maximizes the contrast.\n    getContrastText: m,\n    // Generate a rich color object.\n    augmentColor: g,\n    // Used by the functions below to shift a color's luminance by approximately\n    // two indexes within its tonal palette.\n    // E.g., shift from Red 500 to Red 300 or Red 700.\n    tonalOffset: n,\n    // The light and dark mode object.\n    ...x\n  }, o);\n}\nfunction yf(e) {\n  const t = {};\n  return Object.entries(e).forEach((n) => {\n    const [o, i] = n;\n    typeof i == \"object\" && (t[o] = `${i.fontStyle ? `${i.fontStyle} ` : \"\"}${i.fontVariant ? `${i.fontVariant} ` : \"\"}${i.fontWeight ? `${i.fontWeight} ` : \"\"}${i.fontStretch ? `${i.fontStretch} ` : \"\"}${i.fontSize || \"\"}${i.lineHeight ? `/${i.lineHeight} ` : \"\"}${i.fontFamily || \"\"}`);\n  }), t;\n}\nfunction bf(e, t) {\n  return {\n    toolbar: {\n      minHeight: 56,\n      [e.up(\"xs\")]: {\n        \"@media (orientation: landscape)\": {\n          minHeight: 48\n        }\n      },\n      [e.up(\"sm\")]: {\n        minHeight: 64\n      }\n    },\n    ...t\n  };\n}\nfunction vf(e) {\n  return Math.round(e * 1e5) / 1e5;\n}\nconst ea = {\n  textTransform: \"uppercase\"\n}, ta = '\"Roboto\", \"Helvetica\", \"Arial\", sans-serif';\nfunction fs(e, t) {\n  const {\n    fontFamily: r = ta,\n    // The default font size of the Material Specification.\n    fontSize: n = 14,\n    // px\n    fontWeightLight: o = 300,\n    fontWeightRegular: i = 400,\n    fontWeightMedium: s = 500,\n    fontWeightBold: c = 700,\n    // Tell MUI what's the font-size on the html element.\n    // 16px is the default font-size used by browsers.\n    htmlFontSize: l = 16,\n    // Apply the CSS properties to all the variants.\n    allVariants: u,\n    pxToRem: p,\n    ...m\n  } = typeof t == \"function\" ? t(e) : t;\n   true && (typeof n != \"number\" && console.error(\"MUI: `fontSize` is required to be a number.\"), typeof l != \"number\" && console.error(\"MUI: `htmlFontSize` is required to be a number.\"));\n  const g = n / 14, x = p || ((S) => `${S / l * g}rem`), y = (S, E, P, T, b) => ({\n    fontFamily: r,\n    fontWeight: S,\n    fontSize: x(E),\n    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/\n    lineHeight: P,\n    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing\n    // across font-families can cause issues with the kerning.\n    ...r === ta ? {\n      letterSpacing: `${vf(T / E)}em`\n    } : {},\n    ...b,\n    ...u\n  }), f = {\n    h1: y(o, 96, 1.167, -1.5),\n    h2: y(o, 60, 1.2, -0.5),\n    h3: y(i, 48, 1.167, 0),\n    h4: y(i, 34, 1.235, 0.25),\n    h5: y(i, 24, 1.334, 0),\n    h6: y(s, 20, 1.6, 0.15),\n    subtitle1: y(i, 16, 1.75, 0.15),\n    subtitle2: y(s, 14, 1.57, 0.1),\n    body1: y(i, 16, 1.5, 0.15),\n    body2: y(i, 14, 1.43, 0.15),\n    button: y(s, 14, 1.75, 0.4, ea),\n    caption: y(i, 12, 1.66, 0.4),\n    overline: y(i, 12, 2.66, 1, ea),\n    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.\n    inherit: {\n      fontFamily: \"inherit\",\n      fontWeight: \"inherit\",\n      fontSize: \"inherit\",\n      lineHeight: \"inherit\",\n      letterSpacing: \"inherit\"\n    }\n  };\n  return tt({\n    htmlFontSize: l,\n    pxToRem: x,\n    fontFamily: r,\n    fontSize: n,\n    fontWeightLight: o,\n    fontWeightRegular: i,\n    fontWeightMedium: s,\n    fontWeightBold: c,\n    ...f\n  }, m, {\n    clone: !1\n    // No need to clone deep\n  });\n}\nconst xf = 0.2, Sf = 0.14, Ef = 0.12;\nfunction $e(...e) {\n  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${xf})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${Sf})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${Ef})`].join(\",\");\n}\nconst Cf = [\"none\", $e(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), $e(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), $e(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), $e(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), $e(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), $e(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), $e(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), $e(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), $e(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), $e(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), $e(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), $e(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), $e(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), $e(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), $e(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), $e(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), $e(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), $e(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), $e(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), $e(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), $e(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), $e(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), $e(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), $e(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], Tf = {\n  // This is the most common easing curve.\n  easeInOut: \"cubic-bezier(0.4, 0, 0.2, 1)\",\n  // Objects enter the screen at full velocity from off-screen and\n  // slowly decelerate to a resting point.\n  easeOut: \"cubic-bezier(0.0, 0, 0.2, 1)\",\n  // Objects leave the screen at full velocity. They do not decelerate when off-screen.\n  easeIn: \"cubic-bezier(0.4, 0, 1, 1)\",\n  // The sharp curve is used by objects that may return to the screen at any time.\n  sharp: \"cubic-bezier(0.4, 0, 0.6, 1)\"\n}, ds = {\n  shortest: 150,\n  shorter: 200,\n  short: 250,\n  // most basic recommended timing\n  standard: 300,\n  // this is to be used in complex animations\n  complex: 375,\n  // recommended when something is entering screen\n  enteringScreen: 225,\n  // recommended when something is leaving screen\n  leavingScreen: 195\n};\nfunction ra(e) {\n  return `${Math.round(e)}ms`;\n}\nfunction wf(e) {\n  if (!e)\n    return 0;\n  const t = e / 36;\n  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);\n}\nfunction Of(e) {\n  const t = {\n    ...Tf,\n    ...e.easing\n  }, r = {\n    ...ds,\n    ...e.duration\n  };\n  return {\n    getAutoHeightDuration: wf,\n    create: (o = [\"all\"], i = {}) => {\n      const {\n        duration: s = r.standard,\n        easing: c = t.easeInOut,\n        delay: l = 0,\n        ...u\n      } = i;\n      if (true) {\n        const p = (g) => typeof g == \"string\", m = (g) => !Number.isNaN(parseFloat(g));\n        !p(o) && !Array.isArray(o) && console.error('MUI: Argument \"props\" must be a string or Array.'), !m(s) && !p(s) && console.error(`MUI: Argument \"duration\" must be a number or a string but found ${s}.`), p(c) || console.error('MUI: Argument \"easing\" must be a string.'), !m(l) && !p(l) && console.error('MUI: Argument \"delay\" must be a number or a string.'), typeof i != \"object\" && console.error([\"MUI: Secong argument of transition.create must be an object.\", \"Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`\"].join(`\n`)), Object.keys(u).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(u).join(\",\")}].`);\n      }\n      return (Array.isArray(o) ? o : [o]).map((p) => `${p} ${typeof s == \"string\" ? s : ra(s)} ${c} ${typeof l == \"string\" ? l : ra(l)}`).join(\",\");\n    },\n    ...e,\n    easing: t,\n    duration: r\n  };\n}\nconst Rf = {\n  mobileStepper: 1e3,\n  fab: 1050,\n  speedDial: 1050,\n  appBar: 1100,\n  drawer: 1200,\n  modal: 1300,\n  snackbar: 1400,\n  tooltip: 1500\n};\nfunction $f(e) {\n  return gt(e) || typeof e > \"u\" || typeof e == \"string\" || typeof e == \"boolean\" || typeof e == \"number\" || Array.isArray(e);\n}\nfunction ps(e = {}) {\n  const t = {\n    ...e\n  };\n  function r(n) {\n    const o = Object.entries(n);\n    for (let i = 0; i < o.length; i++) {\n      const [s, c] = o[i];\n      !$f(c) || s.startsWith(\"unstable_\") ? delete n[s] : gt(c) && (n[s] = {\n        ...c\n      }, r(n[s]));\n    }\n  }\n  return r(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';\n\nconst theme = ${JSON.stringify(t, null, 2)};\n\ntheme.breakpoints = createBreakpoints(theme.breakpoints || {});\ntheme.transitions = createTransitions(theme.transitions || {});\n\nexport default theme;`;\n}\nfunction fo(e = {}, ...t) {\n  const {\n    breakpoints: r,\n    mixins: n = {},\n    spacing: o,\n    palette: i = {},\n    transitions: s = {},\n    typography: c = {},\n    shape: l,\n    ...u\n  } = e;\n  if (e.vars)\n    throw new Error( true ? \"MUI: `vars` is a private field used for CSS variables support.\\nPlease use another name.\" : 0);\n  const p = Uo(i), m = No(e);\n  let g = tt(m, {\n    mixins: bf(m.breakpoints, n),\n    palette: p,\n    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.\n    shadows: Cf.slice(),\n    typography: fs(p, c),\n    transitions: Of(s),\n    zIndex: {\n      ...Rf\n    }\n  });\n  if (g = tt(g, u), g = t.reduce((x, y) => tt(x, y), g), \"development\" !== \"production\") {\n    const x = [\"active\", \"checked\", \"completed\", \"disabled\", \"error\", \"expanded\", \"focused\", \"focusVisible\", \"required\", \"selected\"], y = (f, S) => {\n      let E;\n      for (E in f) {\n        const P = f[E];\n        if (x.includes(E) && Object.keys(P).length > 0) {\n          if (true) {\n            const T = Ve(\"\", E);\n            console.error([`MUI: The \\`${S}\\` component increases the CSS specificity of the \\`${E}\\` internal state.`, \"You can not override it like this: \", JSON.stringify(f, null, 2), \"\", `Instead, you need to use the '&.${T}' syntax:`, JSON.stringify({\n              root: {\n                [`&.${T}`]: P\n              }\n            }, null, 2), \"\", \"https://mui.com/r/state-classes-guide\"].join(`\n`));\n          }\n          f[E] = {};\n        }\n      }\n    };\n    Object.keys(g.components).forEach((f) => {\n      const S = g.components[f].styleOverrides;\n      S && f.startsWith(\"Mui\") && y(S, f);\n    });\n  }\n  return g.unstable_sxConfig = {\n    ...Dr,\n    ...u == null ? void 0 : u.unstable_sxConfig\n  }, g.unstable_sx = function(y) {\n    return At({\n      sx: y,\n      theme: this\n    });\n  }, g.toRuntimeSource = ps, g;\n}\nfunction Pf(e) {\n  let t;\n  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;\n}\nconst kf = [...Array(25)].map((e, t) => {\n  if (t === 0)\n    return \"none\";\n  const r = Pf(t);\n  return `linear-gradient(rgba(255 255 255 / ${r}), rgba(255 255 255 / ${r}))`;\n});\nfunction ms(e) {\n  return {\n    inputPlaceholder: e === \"dark\" ? 0.5 : 0.42,\n    inputUnderline: e === \"dark\" ? 0.7 : 0.42,\n    switchTrackDisabled: e === \"dark\" ? 0.2 : 0.12,\n    switchTrack: e === \"dark\" ? 0.3 : 0.38\n  };\n}\nfunction hs(e) {\n  return e === \"dark\" ? kf : [];\n}\nfunction Af(e) {\n  const {\n    palette: t = {\n      mode: \"light\"\n    },\n    // need to cast to avoid module augmentation test\n    opacity: r,\n    overlays: n,\n    ...o\n  } = e, i = Uo(t);\n  return {\n    palette: i,\n    opacity: {\n      ...ms(i.mode),\n      ...r\n    },\n    overlays: n || hs(i.mode),\n    ...o\n  };\n}\nfunction Nf(e) {\n  var t;\n  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig\n  e[0] === \"palette\" && !!((t = e[1]) != null && t.match(/(mode|contrastThreshold|tonalOffset)/));\n}\nconst Mf = (e) => [...[...Array(25)].map((t, r) => `--${e ? `${e}-` : \"\"}overlays-${r}`), `--${e ? `${e}-` : \"\"}palette-AppBar-darkBg`, `--${e ? `${e}-` : \"\"}palette-AppBar-darkColor`], If = (e) => (t, r) => {\n  const n = e.rootSelector || \":root\", o = e.colorSchemeSelector;\n  let i = o;\n  if (o === \"class\" && (i = \".%s\"), o === \"data\" && (i = \"[data-%s]\"), o != null && o.startsWith(\"data-\") && !o.includes(\"%s\") && (i = `[${o}=\"%s\"]`), e.defaultColorScheme === t) {\n    if (t === \"dark\") {\n      const s = {};\n      return Mf(e.cssVarPrefix).forEach((c) => {\n        s[c] = r[c], delete r[c];\n      }), i === \"media\" ? {\n        [n]: r,\n        \"@media (prefers-color-scheme: dark)\": {\n          [n]: s\n        }\n      } : i ? {\n        [i.replace(\"%s\", t)]: s,\n        [`${n}, ${i.replace(\"%s\", t)}`]: r\n      } : {\n        [n]: {\n          ...r,\n          ...s\n        }\n      };\n    }\n    if (i && i !== \"media\")\n      return `${n}, ${i.replace(\"%s\", String(t))}`;\n  } else if (t) {\n    if (i === \"media\")\n      return {\n        [`@media (prefers-color-scheme: ${String(t)})`]: {\n          [n]: r\n        }\n      };\n    if (i)\n      return i.replace(\"%s\", String(t));\n  }\n  return n;\n};\nfunction _f(e, t) {\n  t.forEach((r) => {\n    e[r] || (e[r] = {});\n  });\n}\nfunction $(e, t, r) {\n  !e[t] && r && (e[t] = r);\n}\nfunction yr(e) {\n  return typeof e != \"string\" || !e.startsWith(\"hsl\") ? e : Ka(e);\n}\nfunction Ct(e, t) {\n  `${t}Channel` in e || (e[`${t}Channel`] = gr(yr(e[t]), `MUI: Can't create \\`palette.${t}Channel\\` because \\`palette.${t}\\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().\nTo suppress this warning, you need to explicitly provide the \\`palette.${t}Channel\\` as a string (in rgb format, for example \"12 12 12\") or undefined if you want to remove the channel token.`));\n}\nfunction jf(e) {\n  return typeof e == \"number\" ? `${e}px` : typeof e == \"string\" || typeof e == \"function\" || Array.isArray(e) ? e : \"8px\";\n}\nconst pt = (e) => {\n  try {\n    return e();\n  } catch {\n  }\n}, Df = (e = \"mui\") => of(e);\nfunction ro(e, t, r, n) {\n  if (!t)\n    return;\n  t = t === !0 ? {} : t;\n  const o = n === \"dark\" ? \"dark\" : \"light\";\n  if (!r) {\n    e[n] = Af({\n      ...t,\n      palette: {\n        mode: o,\n        ...t == null ? void 0 : t.palette\n      }\n    });\n    return;\n  }\n  const {\n    palette: i,\n    ...s\n  } = fo({\n    ...r,\n    palette: {\n      mode: o,\n      ...t == null ? void 0 : t.palette\n    }\n  });\n  return e[n] = {\n    ...t,\n    palette: i,\n    opacity: {\n      ...ms(o),\n      ...t == null ? void 0 : t.opacity\n    },\n    overlays: (t == null ? void 0 : t.overlays) || hs(o)\n  }, s;\n}\nfunction Lf(e = {}, ...t) {\n  const {\n    colorSchemes: r = {\n      light: !0\n    },\n    defaultColorScheme: n,\n    disableCssColorScheme: o = !1,\n    cssVarPrefix: i = \"mui\",\n    shouldSkipGeneratingVar: s = Nf,\n    colorSchemeSelector: c = r.light && r.dark ? \"media\" : void 0,\n    rootSelector: l = \":root\",\n    ...u\n  } = e, p = Object.keys(r)[0], m = n || (r.light && p !== \"light\" ? \"light\" : p), g = Df(i), {\n    [m]: x,\n    light: y,\n    dark: f,\n    ...S\n  } = r, E = {\n    ...S\n  };\n  let P = x;\n  if ((m === \"dark\" && !(\"dark\" in r) || m === \"light\" && !(\"light\" in r)) && (P = !0), !P)\n    throw new Error( true ? `MUI: The \\`colorSchemes.${m}\\` option is either missing or invalid.` : 0);\n  const T = ro(E, P, u, m);\n  y && !E.light && ro(E, y, void 0, \"light\"), f && !E.dark && ro(E, f, void 0, \"dark\");\n  let b = {\n    defaultColorScheme: m,\n    ...T,\n    cssVarPrefix: i,\n    colorSchemeSelector: c,\n    rootSelector: l,\n    getCssVar: g,\n    colorSchemes: E,\n    font: {\n      ...yf(T.typography),\n      ...T.font\n    },\n    spacing: jf(u.spacing)\n  };\n  Object.keys(b.colorSchemes).forEach((B) => {\n    const d = b.colorSchemes[B].palette, A = (D) => {\n      const j = D.split(\"-\"), W = j[1], z = j[2];\n      return g(D, d[W][z]);\n    };\n    if (d.mode === \"light\" && ($(d.common, \"background\", \"#fff\"), $(d.common, \"onBackground\", \"#000\")), d.mode === \"dark\" && ($(d.common, \"background\", \"#000\"), $(d.common, \"onBackground\", \"#fff\")), _f(d, [\"Alert\", \"AppBar\", \"Avatar\", \"Button\", \"Chip\", \"FilledInput\", \"LinearProgress\", \"Skeleton\", \"Slider\", \"SnackbarContent\", \"SpeedDialAction\", \"StepConnector\", \"StepContent\", \"Switch\", \"TableCell\", \"Tooltip\"]), d.mode === \"light\") {\n      $(d.Alert, \"errorColor\", Ce(d.error.light, 0.6)), $(d.Alert, \"infoColor\", Ce(d.info.light, 0.6)), $(d.Alert, \"successColor\", Ce(d.success.light, 0.6)), $(d.Alert, \"warningColor\", Ce(d.warning.light, 0.6)), $(d.Alert, \"errorFilledBg\", A(\"palette-error-main\")), $(d.Alert, \"infoFilledBg\", A(\"palette-info-main\")), $(d.Alert, \"successFilledBg\", A(\"palette-success-main\")), $(d.Alert, \"warningFilledBg\", A(\"palette-warning-main\")), $(d.Alert, \"errorFilledColor\", pt(() => d.getContrastText(d.error.main))), $(d.Alert, \"infoFilledColor\", pt(() => d.getContrastText(d.info.main))), $(d.Alert, \"successFilledColor\", pt(() => d.getContrastText(d.success.main))), $(d.Alert, \"warningFilledColor\", pt(() => d.getContrastText(d.warning.main))), $(d.Alert, \"errorStandardBg\", Te(d.error.light, 0.9)), $(d.Alert, \"infoStandardBg\", Te(d.info.light, 0.9)), $(d.Alert, \"successStandardBg\", Te(d.success.light, 0.9)), $(d.Alert, \"warningStandardBg\", Te(d.warning.light, 0.9)), $(d.Alert, \"errorIconColor\", A(\"palette-error-main\")), $(d.Alert, \"infoIconColor\", A(\"palette-info-main\")), $(d.Alert, \"successIconColor\", A(\"palette-success-main\")), $(d.Alert, \"warningIconColor\", A(\"palette-warning-main\")), $(d.AppBar, \"defaultBg\", A(\"palette-grey-100\")), $(d.Avatar, \"defaultBg\", A(\"palette-grey-400\")), $(d.Button, \"inheritContainedBg\", A(\"palette-grey-300\")), $(d.Button, \"inheritContainedHoverBg\", A(\"palette-grey-A100\")), $(d.Chip, \"defaultBorder\", A(\"palette-grey-400\")), $(d.Chip, \"defaultAvatarColor\", A(\"palette-grey-700\")), $(d.Chip, \"defaultIconColor\", A(\"palette-grey-700\")), $(d.FilledInput, \"bg\", \"rgba(0, 0, 0, 0.06)\"), $(d.FilledInput, \"hoverBg\", \"rgba(0, 0, 0, 0.09)\"), $(d.FilledInput, \"disabledBg\", \"rgba(0, 0, 0, 0.12)\"), $(d.LinearProgress, \"primaryBg\", Te(d.primary.main, 0.62)), $(d.LinearProgress, \"secondaryBg\", Te(d.secondary.main, 0.62)), $(d.LinearProgress, \"errorBg\", Te(d.error.main, 0.62)), $(d.LinearProgress, \"infoBg\", Te(d.info.main, 0.62)), $(d.LinearProgress, \"successBg\", Te(d.success.main, 0.62)), $(d.LinearProgress, \"warningBg\", Te(d.warning.main, 0.62)), $(d.Skeleton, \"bg\", `rgba(${A(\"palette-text-primaryChannel\")} / 0.11)`), $(d.Slider, \"primaryTrack\", Te(d.primary.main, 0.62)), $(d.Slider, \"secondaryTrack\", Te(d.secondary.main, 0.62)), $(d.Slider, \"errorTrack\", Te(d.error.main, 0.62)), $(d.Slider, \"infoTrack\", Te(d.info.main, 0.62)), $(d.Slider, \"successTrack\", Te(d.success.main, 0.62)), $(d.Slider, \"warningTrack\", Te(d.warning.main, 0.62));\n      const D = Jr(d.background.default, 0.8);\n      $(d.SnackbarContent, \"bg\", D), $(d.SnackbarContent, \"color\", pt(() => d.getContrastText(D))), $(d.SpeedDialAction, \"fabHoverBg\", Jr(d.background.paper, 0.15)), $(d.StepConnector, \"border\", A(\"palette-grey-400\")), $(d.StepContent, \"border\", A(\"palette-grey-400\")), $(d.Switch, \"defaultColor\", A(\"palette-common-white\")), $(d.Switch, \"defaultDisabledColor\", A(\"palette-grey-100\")), $(d.Switch, \"primaryDisabledColor\", Te(d.primary.main, 0.62)), $(d.Switch, \"secondaryDisabledColor\", Te(d.secondary.main, 0.62)), $(d.Switch, \"errorDisabledColor\", Te(d.error.main, 0.62)), $(d.Switch, \"infoDisabledColor\", Te(d.info.main, 0.62)), $(d.Switch, \"successDisabledColor\", Te(d.success.main, 0.62)), $(d.Switch, \"warningDisabledColor\", Te(d.warning.main, 0.62)), $(d.TableCell, \"border\", Te(Xr(d.divider, 1), 0.88)), $(d.Tooltip, \"bg\", Xr(d.grey[700], 0.92));\n    }\n    if (d.mode === \"dark\") {\n      $(d.Alert, \"errorColor\", Te(d.error.light, 0.6)), $(d.Alert, \"infoColor\", Te(d.info.light, 0.6)), $(d.Alert, \"successColor\", Te(d.success.light, 0.6)), $(d.Alert, \"warningColor\", Te(d.warning.light, 0.6)), $(d.Alert, \"errorFilledBg\", A(\"palette-error-dark\")), $(d.Alert, \"infoFilledBg\", A(\"palette-info-dark\")), $(d.Alert, \"successFilledBg\", A(\"palette-success-dark\")), $(d.Alert, \"warningFilledBg\", A(\"palette-warning-dark\")), $(d.Alert, \"errorFilledColor\", pt(() => d.getContrastText(d.error.dark))), $(d.Alert, \"infoFilledColor\", pt(() => d.getContrastText(d.info.dark))), $(d.Alert, \"successFilledColor\", pt(() => d.getContrastText(d.success.dark))), $(d.Alert, \"warningFilledColor\", pt(() => d.getContrastText(d.warning.dark))), $(d.Alert, \"errorStandardBg\", Ce(d.error.light, 0.9)), $(d.Alert, \"infoStandardBg\", Ce(d.info.light, 0.9)), $(d.Alert, \"successStandardBg\", Ce(d.success.light, 0.9)), $(d.Alert, \"warningStandardBg\", Ce(d.warning.light, 0.9)), $(d.Alert, \"errorIconColor\", A(\"palette-error-main\")), $(d.Alert, \"infoIconColor\", A(\"palette-info-main\")), $(d.Alert, \"successIconColor\", A(\"palette-success-main\")), $(d.Alert, \"warningIconColor\", A(\"palette-warning-main\")), $(d.AppBar, \"defaultBg\", A(\"palette-grey-900\")), $(d.AppBar, \"darkBg\", A(\"palette-background-paper\")), $(d.AppBar, \"darkColor\", A(\"palette-text-primary\")), $(d.Avatar, \"defaultBg\", A(\"palette-grey-600\")), $(d.Button, \"inheritContainedBg\", A(\"palette-grey-800\")), $(d.Button, \"inheritContainedHoverBg\", A(\"palette-grey-700\")), $(d.Chip, \"defaultBorder\", A(\"palette-grey-700\")), $(d.Chip, \"defaultAvatarColor\", A(\"palette-grey-300\")), $(d.Chip, \"defaultIconColor\", A(\"palette-grey-300\")), $(d.FilledInput, \"bg\", \"rgba(255, 255, 255, 0.09)\"), $(d.FilledInput, \"hoverBg\", \"rgba(255, 255, 255, 0.13)\"), $(d.FilledInput, \"disabledBg\", \"rgba(255, 255, 255, 0.12)\"), $(d.LinearProgress, \"primaryBg\", Ce(d.primary.main, 0.5)), $(d.LinearProgress, \"secondaryBg\", Ce(d.secondary.main, 0.5)), $(d.LinearProgress, \"errorBg\", Ce(d.error.main, 0.5)), $(d.LinearProgress, \"infoBg\", Ce(d.info.main, 0.5)), $(d.LinearProgress, \"successBg\", Ce(d.success.main, 0.5)), $(d.LinearProgress, \"warningBg\", Ce(d.warning.main, 0.5)), $(d.Skeleton, \"bg\", `rgba(${A(\"palette-text-primaryChannel\")} / 0.13)`), $(d.Slider, \"primaryTrack\", Ce(d.primary.main, 0.5)), $(d.Slider, \"secondaryTrack\", Ce(d.secondary.main, 0.5)), $(d.Slider, \"errorTrack\", Ce(d.error.main, 0.5)), $(d.Slider, \"infoTrack\", Ce(d.info.main, 0.5)), $(d.Slider, \"successTrack\", Ce(d.success.main, 0.5)), $(d.Slider, \"warningTrack\", Ce(d.warning.main, 0.5));\n      const D = Jr(d.background.default, 0.98);\n      $(d.SnackbarContent, \"bg\", D), $(d.SnackbarContent, \"color\", pt(() => d.getContrastText(D))), $(d.SpeedDialAction, \"fabHoverBg\", Jr(d.background.paper, 0.15)), $(d.StepConnector, \"border\", A(\"palette-grey-600\")), $(d.StepContent, \"border\", A(\"palette-grey-600\")), $(d.Switch, \"defaultColor\", A(\"palette-grey-300\")), $(d.Switch, \"defaultDisabledColor\", A(\"palette-grey-600\")), $(d.Switch, \"primaryDisabledColor\", Ce(d.primary.main, 0.55)), $(d.Switch, \"secondaryDisabledColor\", Ce(d.secondary.main, 0.55)), $(d.Switch, \"errorDisabledColor\", Ce(d.error.main, 0.55)), $(d.Switch, \"infoDisabledColor\", Ce(d.info.main, 0.55)), $(d.Switch, \"successDisabledColor\", Ce(d.success.main, 0.55)), $(d.Switch, \"warningDisabledColor\", Ce(d.warning.main, 0.55)), $(d.TableCell, \"border\", Ce(Xr(d.divider, 1), 0.68)), $(d.Tooltip, \"bg\", Xr(d.grey[700], 0.92));\n    }\n    Ct(d.background, \"default\"), Ct(d.background, \"paper\"), Ct(d.common, \"background\"), Ct(d.common, \"onBackground\"), Ct(d, \"divider\"), Object.keys(d).forEach((D) => {\n      const j = d[D];\n      D !== \"tonalOffset\" && j && typeof j == \"object\" && (j.main && $(d[D], \"mainChannel\", gr(yr(j.main))), j.light && $(d[D], \"lightChannel\", gr(yr(j.light))), j.dark && $(d[D], \"darkChannel\", gr(yr(j.dark))), j.contrastText && $(d[D], \"contrastTextChannel\", gr(yr(j.contrastText))), D === \"text\" && (Ct(d[D], \"primary\"), Ct(d[D], \"secondary\")), D === \"action\" && (j.active && Ct(d[D], \"active\"), j.selected && Ct(d[D], \"selected\")));\n    });\n  }), b = t.reduce((B, d) => tt(B, d), b);\n  const h = {\n    prefix: i,\n    disableCssColorScheme: o,\n    shouldSkipGeneratingVar: s,\n    getSelector: If(b)\n  }, {\n    vars: w,\n    generateThemeVars: k,\n    generateStyleSheets: L\n  } = cf(b, h);\n  return b.vars = w, Object.entries(b.colorSchemes[b.defaultColorScheme]).forEach(([B, d]) => {\n    b[B] = d;\n  }), b.generateThemeVars = k, b.generateStyleSheets = L, b.generateSpacing = function() {\n    return Ba(u.spacing, ko(this));\n  }, b.getColorSchemeSelector = lf(c), b.spacing = b.generateSpacing(), b.shouldSkipGeneratingVar = s, b.unstable_sxConfig = {\n    ...Dr,\n    ...u == null ? void 0 : u.unstable_sxConfig\n  }, b.unstable_sx = function(d) {\n    return At({\n      sx: d,\n      theme: this\n    });\n  }, b.toRuntimeSource = ps, b;\n}\nfunction na(e, t, r) {\n  e.colorSchemes && r && (e.colorSchemes[t] = {\n    ...r !== !0 && r,\n    palette: Uo({\n      ...r === !0 ? {} : r.palette,\n      mode: t\n    })\n    // cast type to skip module augmentation test\n  });\n}\nfunction Fn(e = {}, ...t) {\n  const {\n    palette: r,\n    cssVariables: n = !1,\n    colorSchemes: o = r ? void 0 : {\n      light: !0\n    },\n    defaultColorScheme: i = r == null ? void 0 : r.mode,\n    ...s\n  } = e, c = i || \"light\", l = o == null ? void 0 : o[c], u = {\n    ...o,\n    ...r ? {\n      [c]: {\n        ...typeof l != \"boolean\" && l,\n        palette: r\n      }\n    } : void 0\n  };\n  if (n === !1) {\n    if (!(\"colorSchemes\" in e))\n      return fo(e, ...t);\n    let p = r;\n    \"palette\" in e || u[c] && (u[c] !== !0 ? p = u[c].palette : c === \"dark\" && (p = {\n      mode: \"dark\"\n    }));\n    const m = fo({\n      ...e,\n      palette: p\n    }, ...t);\n    return m.defaultColorScheme = c, m.colorSchemes = u, m.palette.mode === \"light\" && (m.colorSchemes.light = {\n      ...u.light !== !0 && u.light,\n      palette: m.palette\n    }, na(m, \"dark\", u.dark)), m.palette.mode === \"dark\" && (m.colorSchemes.dark = {\n      ...u.dark !== !0 && u.dark,\n      palette: m.palette\n    }, na(m, \"light\", u.light)), m;\n  }\n  return !r && !(\"light\" in u) && c === \"light\" && (u.light = !0), Lf({\n    ...s,\n    colorSchemes: u,\n    defaultColorScheme: c,\n    ...typeof n != \"boolean\" && n\n  }, ...t);\n}\nconst gs = Fn();\nfunction Lr() {\n  const e = Fa(gs);\n  return  true && react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(e), e[wt] || e;\n}\nfunction Bf(e) {\n  return e !== \"ownerState\" && e !== \"theme\" && e !== \"sx\" && e !== \"as\";\n}\nconst ys = (e) => Bf(e) && e !== \"classes\", le = Tu({\n  themeId: wt,\n  defaultTheme: gs,\n  rootShouldForwardProp: ys\n});\nfunction oa({\n  theme: e,\n  ...t\n}) {\n  const r = wt in e ? e[wt] : void 0;\n  return /* @__PURE__ */ N.jsx(Rr, {\n    ...t,\n    themeId: r ? wt : void 0,\n    theme: r || e\n  });\n}\nconst Qr = {\n  attribute: \"data-mui-color-scheme\",\n  colorSchemeStorageKey: \"mui-color-scheme\",\n  defaultLightColorScheme: \"light\",\n  defaultDarkColorScheme: \"dark\",\n  modeStorageKey: \"mui-mode\"\n}, {\n  CssVarsProvider: Vf,\n  useColorScheme: zm,\n  getInitColorSchemeScript: Wm\n} = nf({\n  themeId: wt,\n  // @ts-ignore ignore module augmentation tests\n  theme: () => Fn({\n    cssVariables: !0\n  }),\n  colorSchemeStorageKey: Qr.colorSchemeStorageKey,\n  modeStorageKey: Qr.modeStorageKey,\n  defaultColorScheme: {\n    light: Qr.defaultLightColorScheme,\n    dark: Qr.defaultDarkColorScheme\n  },\n  resolveTheme: (e) => {\n    const t = {\n      ...e,\n      typography: fs(e.palette, e.typography)\n    };\n    return t.unstable_sx = function(n) {\n      return At({\n        sx: n,\n        theme: this\n      });\n    }, t;\n  }\n}), Ff = Vf;\nfunction zf({\n  theme: e,\n  ...t\n}) {\n  return typeof e == \"function\" ? /* @__PURE__ */ N.jsx(oa, {\n    theme: e,\n    ...t\n  }) : \"colorSchemes\" in (wt in e ? e[wt] : e) ? /* @__PURE__ */ N.jsx(Ff, {\n    theme: e,\n    ...t\n  }) : /* @__PURE__ */ N.jsx(oa, {\n    theme: e,\n    ...t\n  });\n}\nfunction Wf() {\n  return za;\n}\nconst qe = Ju;\n true && (a.node, a.object.isRequired);\nfunction He(e) {\n  return Xu(e);\n}\nfunction Uf(e) {\n  return Ve(\"MuiSvgIcon\", e);\n}\nFe(\"MuiSvgIcon\", [\"root\", \"colorPrimary\", \"colorSecondary\", \"colorAction\", \"colorError\", \"colorDisabled\", \"fontSizeInherit\", \"fontSizeSmall\", \"fontSizeMedium\", \"fontSizeLarge\"]);\nconst Yf = (e) => {\n  const {\n    color: t,\n    fontSize: r,\n    classes: n\n  } = e, o = {\n    root: [\"root\", t !== \"inherit\" && `color${ee(t)}`, `fontSize${ee(r)}`]\n  };\n  return Ge(o, Uf, n);\n}, Hf = le(\"svg\", {\n  name: \"MuiSvgIcon\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, r.color !== \"inherit\" && t[`color${ee(r.color)}`], t[`fontSize${ee(r.fontSize)}`]];\n  }\n})(qe(({\n  theme: e\n}) => {\n  var t, r, n, o, i, s, c, l, u, p, m, g, x, y;\n  return {\n    userSelect: \"none\",\n    width: \"1em\",\n    height: \"1em\",\n    display: \"inline-block\",\n    flexShrink: 0,\n    transition: (o = (t = e.transitions) == null ? void 0 : t.create) == null ? void 0 : o.call(t, \"fill\", {\n      duration: (n = (r = (e.vars ?? e).transitions) == null ? void 0 : r.duration) == null ? void 0 : n.shorter\n    }),\n    variants: [\n      {\n        props: (f) => !f.hasSvgAsChild,\n        style: {\n          // the <svg> will define the property that has `currentColor`\n          // for example heroicons uses fill=\"none\" and stroke=\"currentColor\"\n          fill: \"currentColor\"\n        }\n      },\n      {\n        props: {\n          fontSize: \"inherit\"\n        },\n        style: {\n          fontSize: \"inherit\"\n        }\n      },\n      {\n        props: {\n          fontSize: \"small\"\n        },\n        style: {\n          fontSize: ((s = (i = e.typography) == null ? void 0 : i.pxToRem) == null ? void 0 : s.call(i, 20)) || \"1.25rem\"\n        }\n      },\n      {\n        props: {\n          fontSize: \"medium\"\n        },\n        style: {\n          fontSize: ((l = (c = e.typography) == null ? void 0 : c.pxToRem) == null ? void 0 : l.call(c, 24)) || \"1.5rem\"\n        }\n      },\n      {\n        props: {\n          fontSize: \"large\"\n        },\n        style: {\n          fontSize: ((p = (u = e.typography) == null ? void 0 : u.pxToRem) == null ? void 0 : p.call(u, 35)) || \"2.1875rem\"\n        }\n      },\n      // TODO v5 deprecate color prop, v6 remove for sx\n      ...Object.entries((e.vars ?? e).palette).filter(([, f]) => f && f.main).map(([f]) => {\n        var S, E;\n        return {\n          props: {\n            color: f\n          },\n          style: {\n            color: (E = (S = (e.vars ?? e).palette) == null ? void 0 : S[f]) == null ? void 0 : E.main\n          }\n        };\n      }),\n      {\n        props: {\n          color: \"action\"\n        },\n        style: {\n          color: (g = (m = (e.vars ?? e).palette) == null ? void 0 : m.action) == null ? void 0 : g.active\n        }\n      },\n      {\n        props: {\n          color: \"disabled\"\n        },\n        style: {\n          color: (y = (x = (e.vars ?? e).palette) == null ? void 0 : x.action) == null ? void 0 : y.disabled\n        }\n      },\n      {\n        props: {\n          color: \"inherit\"\n        },\n        style: {\n          color: void 0\n        }\n      }\n    ]\n  };\n})), yn = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiSvgIcon\"\n  }), {\n    children: o,\n    className: i,\n    color: s = \"inherit\",\n    component: c = \"svg\",\n    fontSize: l = \"medium\",\n    htmlColor: u,\n    inheritViewBox: p = !1,\n    titleAccess: m,\n    viewBox: g = \"0 0 24 24\",\n    ...x\n  } = n, y = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(o) && o.type === \"svg\", f = {\n    ...n,\n    color: s,\n    component: c,\n    fontSize: l,\n    instanceFontSize: t.fontSize,\n    inheritViewBox: p,\n    viewBox: g,\n    hasSvgAsChild: y\n  }, S = {};\n  p || (S.viewBox = g);\n  const E = Yf(f);\n  return /* @__PURE__ */ N.jsxs(Hf, {\n    as: c,\n    className: se(E.root, i),\n    focusable: \"false\",\n    color: u,\n    \"aria-hidden\": m ? void 0 : !0,\n    role: m ? \"img\" : void 0,\n    ref: r,\n    ...S,\n    ...x,\n    ...y && o.props,\n    ownerState: f,\n    children: [y ? o.props.children : o, m ? /* @__PURE__ */ N.jsx(\"title\", {\n      children: m\n    }) : null]\n  });\n});\n true && (yn.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Node passed into the SVG element.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.\n   * @default 'inherit'\n   */\n  color: a.oneOfType([a.oneOf([\"inherit\", \"action\", \"disabled\", \"primary\", \"secondary\", \"error\", \"info\", \"success\", \"warning\"]), a.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.\n   * @default 'medium'\n   */\n  fontSize: a.oneOfType([a.oneOf([\"inherit\", \"large\", \"medium\", \"small\"]), a.string]),\n  /**\n   * Applies a color attribute to the SVG element.\n   */\n  htmlColor: a.string,\n  /**\n   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`\n   * prop will be ignored.\n   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that\n   * `component`'s viewBox to the root node.\n   * @default false\n   */\n  inheritViewBox: a.bool,\n  /**\n   * The shape-rendering attribute. The behavior of the different options is described on the\n   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).\n   * If you are having issues with blurry icons you should investigate this prop.\n   */\n  shapeRendering: a.string,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * Provides a human-readable title for the element that contains it.\n   * https://www.w3.org/TR/SVG-access/#Equivalent\n   */\n  titleAccess: a.string,\n  /**\n   * Allows you to redefine what the coordinates without units mean inside an SVG element.\n   * For example, if the SVG element is 500 (width) by 200 (height),\n   * and you pass viewBox=\"0 0 50 20\",\n   * this means that the coordinates inside the SVG will go from the top left corner (0,0)\n   * to bottom right (50,20) and each unit will be worth 10px.\n   * @default '0 0 24 24'\n   */\n  viewBox: a.string\n});\nyn.muiName = \"SvgIcon\";\nfunction sr(e, t) {\n  function r(n, o) {\n    return /* @__PURE__ */ N.jsx(yn, {\n      \"data-testid\": `${t}Icon`,\n      ref: o,\n      ...n,\n      children: e\n    });\n  }\n  return  true && (r.displayName = `${t}Icon`), r.muiName = yn.muiName, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.memo(/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(r));\n}\nfunction bs(e, t) {\n  if (e == null) return {};\n  var r = {};\n  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {\n    if (t.includes(n)) continue;\n    r[n] = e[n];\n  }\n  return r;\n}\nfunction po(e, t) {\n  return po = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {\n    return r.__proto__ = n, r;\n  }, po(e, t);\n}\nfunction vs(e, t) {\n  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, po(e, t);\n}\nconst ia = {\n  disabled: !1\n};\nvar qf =  true ? a.oneOfType([a.number, a.shape({\n  enter: a.number,\n  exit: a.number,\n  appear: a.number\n}).isRequired]) : 0;\n true && a.oneOfType([a.string, a.shape({\n  enter: a.string,\n  exit: a.string,\n  active: a.string\n}), a.shape({\n  enter: a.string,\n  enterDone: a.string,\n  enterActive: a.string,\n  exit: a.string,\n  exitDone: a.string,\n  exitActive: a.string\n})]);\nconst bn = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar Gf = function(t) {\n  return t.scrollTop;\n}, br = \"unmounted\", _t = \"exited\", jt = \"entering\", Kt = \"entered\", mo = \"exiting\", Et = /* @__PURE__ */ function(e) {\n  vs(t, e);\n  function t(n, o) {\n    var i;\n    i = e.call(this, n, o) || this;\n    var s = o, c = s && !s.isMounting ? n.enter : n.appear, l;\n    return i.appearStatus = null, n.in ? c ? (l = _t, i.appearStatus = jt) : l = Kt : n.unmountOnExit || n.mountOnEnter ? l = br : l = _t, i.state = {\n      status: l\n    }, i.nextCallback = null, i;\n  }\n  t.getDerivedStateFromProps = function(o, i) {\n    var s = o.in;\n    return s && i.status === br ? {\n      status: _t\n    } : null;\n  };\n  var r = t.prototype;\n  return r.componentDidMount = function() {\n    this.updateStatus(!0, this.appearStatus);\n  }, r.componentDidUpdate = function(o) {\n    var i = null;\n    if (o !== this.props) {\n      var s = this.state.status;\n      this.props.in ? s !== jt && s !== Kt && (i = jt) : (s === jt || s === Kt) && (i = mo);\n    }\n    this.updateStatus(!1, i);\n  }, r.componentWillUnmount = function() {\n    this.cancelNextCallback();\n  }, r.getTimeouts = function() {\n    var o = this.props.timeout, i, s, c;\n    return i = s = c = o, o != null && typeof o != \"number\" && (i = o.exit, s = o.enter, c = o.appear !== void 0 ? o.appear : s), {\n      exit: i,\n      enter: s,\n      appear: c\n    };\n  }, r.updateStatus = function(o, i) {\n    if (o === void 0 && (o = !1), i !== null)\n      if (this.cancelNextCallback(), i === jt) {\n        if (this.props.unmountOnExit || this.props.mountOnEnter) {\n          var s = this.props.nodeRef ? this.props.nodeRef.current : react_dom__WEBPACK_IMPORTED_MODULE_1__.findDOMNode(this);\n          s && Gf(s);\n        }\n        this.performEnter(o);\n      } else\n        this.performExit();\n    else this.props.unmountOnExit && this.state.status === _t && this.setState({\n      status: br\n    });\n  }, r.performEnter = function(o) {\n    var i = this, s = this.props.enter, c = this.context ? this.context.isMounting : o, l = this.props.nodeRef ? [c] : [react_dom__WEBPACK_IMPORTED_MODULE_1__.findDOMNode(this), c], u = l[0], p = l[1], m = this.getTimeouts(), g = c ? m.appear : m.enter;\n    if (!o && !s || ia.disabled) {\n      this.safeSetState({\n        status: Kt\n      }, function() {\n        i.props.onEntered(u);\n      });\n      return;\n    }\n    this.props.onEnter(u, p), this.safeSetState({\n      status: jt\n    }, function() {\n      i.props.onEntering(u, p), i.onTransitionEnd(g, function() {\n        i.safeSetState({\n          status: Kt\n        }, function() {\n          i.props.onEntered(u, p);\n        });\n      });\n    });\n  }, r.performExit = function() {\n    var o = this, i = this.props.exit, s = this.getTimeouts(), c = this.props.nodeRef ? void 0 : react_dom__WEBPACK_IMPORTED_MODULE_1__.findDOMNode(this);\n    if (!i || ia.disabled) {\n      this.safeSetState({\n        status: _t\n      }, function() {\n        o.props.onExited(c);\n      });\n      return;\n    }\n    this.props.onExit(c), this.safeSetState({\n      status: mo\n    }, function() {\n      o.props.onExiting(c), o.onTransitionEnd(s.exit, function() {\n        o.safeSetState({\n          status: _t\n        }, function() {\n          o.props.onExited(c);\n        });\n      });\n    });\n  }, r.cancelNextCallback = function() {\n    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);\n  }, r.safeSetState = function(o, i) {\n    i = this.setNextCallback(i), this.setState(o, i);\n  }, r.setNextCallback = function(o) {\n    var i = this, s = !0;\n    return this.nextCallback = function(c) {\n      s && (s = !1, i.nextCallback = null, o(c));\n    }, this.nextCallback.cancel = function() {\n      s = !1;\n    }, this.nextCallback;\n  }, r.onTransitionEnd = function(o, i) {\n    this.setNextCallback(i);\n    var s = this.props.nodeRef ? this.props.nodeRef.current : react_dom__WEBPACK_IMPORTED_MODULE_1__.findDOMNode(this), c = o == null && !this.props.addEndListener;\n    if (!s || c) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n    if (this.props.addEndListener) {\n      var l = this.props.nodeRef ? [this.nextCallback] : [s, this.nextCallback], u = l[0], p = l[1];\n      this.props.addEndListener(u, p);\n    }\n    o != null && setTimeout(this.nextCallback, o);\n  }, r.render = function() {\n    var o = this.state.status;\n    if (o === br)\n      return null;\n    var i = this.props, s = i.children;\n    i.in, i.mountOnEnter, i.unmountOnExit, i.appear, i.enter, i.exit, i.timeout, i.addEndListener, i.onEnter, i.onEntering, i.onEntered, i.onExit, i.onExiting, i.onExited, i.nodeRef;\n    var c = bs(i, [\"children\", \"in\", \"mountOnEnter\", \"unmountOnExit\", \"appear\", \"enter\", \"exit\", \"timeout\", \"addEndListener\", \"onEnter\", \"onEntering\", \"onEntered\", \"onExit\", \"onExiting\", \"onExited\", \"nodeRef\"]);\n    return (\n      // allows for nested Transitions\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(bn.Provider, {\n        value: null\n      }, typeof s == \"function\" ? s(o, c) : react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(react__WEBPACK_IMPORTED_MODULE_0__.Children.only(s), c))\n    );\n  }, t;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nEt.contextType = bn;\nEt.propTypes =  true ? {\n  /**\n   * A React reference to DOM element that need to transition:\n   * https://stackoverflow.com/a/51127130/4671932\n   *\n   *   - When `nodeRef` prop is used, `node` is not passed to callback functions\n   *      (e.g. `onEnter`) because user already has direct access to the node.\n   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new\n   *     `nodeRef` need to be provided to `Transition` with changed `key` prop\n   *     (see\n   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).\n   */\n  nodeRef: a.shape({\n    current: typeof Element > \"u\" ? a.any : function(e, t, r, n, o, i) {\n      var s = e[t];\n      return a.instanceOf(s && \"ownerDocument\" in s ? s.ownerDocument.defaultView.Element : Element)(e, t, r, n, o, i);\n    }\n  }),\n  /**\n   * A `function` child can be used instead of a React element. This function is\n   * called with the current transition status (`'entering'`, `'entered'`,\n   * `'exiting'`, `'exited'`), which can be used to apply context\n   * specific props to a component.\n   *\n   * ```jsx\n   * <Transition in={this.state.in} timeout={150}>\n   *   {state => (\n   *     <MyComponent className={`fade fade-${state}`} />\n   *   )}\n   * </Transition>\n   * ```\n   */\n  children: a.oneOfType([a.func.isRequired, a.element.isRequired]).isRequired,\n  /**\n   * Show the component; triggers the enter or exit states\n   */\n  in: a.bool,\n  /**\n   * By default the child component is mounted immediately along with\n   * the parent `Transition` component. If you want to \"lazy mount\" the component on the\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\n   * mounted, even on \"exited\", unless you also specify `unmountOnExit`.\n   */\n  mountOnEnter: a.bool,\n  /**\n   * By default the child component stays mounted after it reaches the `'exited'` state.\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\n   */\n  unmountOnExit: a.bool,\n  /**\n   * By default the child component does not perform the enter transition when\n   * it first mounts, regardless of the value of `in`. If you want this\n   * behavior, set both `appear` and `in` to `true`.\n   *\n   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop\n   * > only adds an additional enter transition. However, in the\n   * > `<CSSTransition>` component that first enter transition does result in\n   * > additional `.appear-*` classes, that way you can choose to style it\n   * > differently.\n   */\n  appear: a.bool,\n  /**\n   * Enable or disable enter transitions.\n   */\n  enter: a.bool,\n  /**\n   * Enable or disable exit transitions.\n   */\n  exit: a.bool,\n  /**\n   * The duration of the transition, in milliseconds.\n   * Required unless `addEndListener` is provided.\n   *\n   * You may specify a single timeout for all transitions:\n   *\n   * ```jsx\n   * timeout={500}\n   * ```\n   *\n   * or individually:\n   *\n   * ```jsx\n   * timeout={{\n   *  appear: 500,\n   *  enter: 300,\n   *  exit: 500,\n   * }}\n   * ```\n   *\n   * - `appear` defaults to the value of `enter`\n   * - `enter` defaults to `0`\n   * - `exit` defaults to `0`\n   *\n   * @type {number | { enter?: number, exit?: number, appear?: number }}\n   */\n  timeout: function(t) {\n    var r = qf;\n    t.addEndListener || (r = r.isRequired);\n    for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)\n      o[i - 1] = arguments[i];\n    return r.apply(void 0, [t].concat(o));\n  },\n  /**\n   * Add a custom transition end trigger. Called with the transitioning\n   * DOM node and a `done` callback. Allows for more fine grained transition end\n   * logic. Timeouts are still used as a fallback if provided.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * ```jsx\n   * addEndListener={(node, done) => {\n   *   // use the css transitionend event to mark the finish of a transition\n   *   node.addEventListener('transitionend', done, false);\n   * }}\n   * ```\n   */\n  addEndListener: a.func,\n  /**\n   * Callback fired before the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEnter: a.func,\n  /**\n   * Callback fired after the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: a.func,\n  /**\n   * Callback fired after the \"entered\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEntered: a.func,\n  /**\n   * Callback fired before the \"exiting\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExit: a.func,\n  /**\n   * Callback fired after the \"exiting\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExiting: a.func,\n  /**\n   * Callback fired after the \"exited\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExited: a.func\n} : 0;\nfunction Gt() {\n}\nEt.defaultProps = {\n  in: !1,\n  mountOnEnter: !1,\n  unmountOnExit: !1,\n  appear: !1,\n  enter: !0,\n  exit: !0,\n  onEnter: Gt,\n  onEntering: Gt,\n  onEntered: Gt,\n  onExit: Gt,\n  onExiting: Gt,\n  onExited: Gt\n};\nEt.UNMOUNTED = br;\nEt.EXITED = _t;\nEt.ENTERING = jt;\nEt.ENTERED = Kt;\nEt.EXITING = mo;\nfunction Kf(e) {\n  if (e === void 0) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction Yo(e, t) {\n  var r = function(i) {\n    return t && (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(i) ? t(i) : i;\n  }, n = /* @__PURE__ */ Object.create(null);\n  return e && react__WEBPACK_IMPORTED_MODULE_0__.Children.map(e, function(o) {\n    return o;\n  }).forEach(function(o) {\n    n[o.key] = r(o);\n  }), n;\n}\nfunction Xf(e, t) {\n  e = e || {}, t = t || {};\n  function r(p) {\n    return p in t ? t[p] : e[p];\n  }\n  var n = /* @__PURE__ */ Object.create(null), o = [];\n  for (var i in e)\n    i in t ? o.length && (n[i] = o, o = []) : o.push(i);\n  var s, c = {};\n  for (var l in t) {\n    if (n[l])\n      for (s = 0; s < n[l].length; s++) {\n        var u = n[l][s];\n        c[n[l][s]] = r(u);\n      }\n    c[l] = r(l);\n  }\n  for (s = 0; s < o.length; s++)\n    c[o[s]] = r(o[s]);\n  return c;\n}\nfunction Lt(e, t, r) {\n  return r[t] != null ? r[t] : e.props[t];\n}\nfunction Jf(e, t) {\n  return Yo(e.children, function(r) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(r, {\n      onExited: t.bind(null, r),\n      in: !0,\n      appear: Lt(r, \"appear\", e),\n      enter: Lt(r, \"enter\", e),\n      exit: Lt(r, \"exit\", e)\n    });\n  });\n}\nfunction Qf(e, t, r) {\n  var n = Yo(e.children), o = Xf(t, n);\n  return Object.keys(o).forEach(function(i) {\n    var s = o[i];\n    if ((0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(s)) {\n      var c = i in t, l = i in n, u = t[i], p = (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(u) && !u.props.in;\n      l && (!c || p) ? o[i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(s, {\n        onExited: r.bind(null, s),\n        in: !0,\n        exit: Lt(s, \"exit\", e),\n        enter: Lt(s, \"enter\", e)\n      }) : !l && c && !p ? o[i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(s, {\n        in: !1\n      }) : l && c && (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(u) && (o[i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(s, {\n        onExited: r.bind(null, s),\n        in: u.props.in,\n        exit: Lt(s, \"exit\", e),\n        enter: Lt(s, \"enter\", e)\n      }));\n    }\n  }), o;\n}\nvar Zf = Object.values || function(e) {\n  return Object.keys(e).map(function(t) {\n    return e[t];\n  });\n}, ed = {\n  component: \"div\",\n  childFactory: function(t) {\n    return t;\n  }\n}, Ho = /* @__PURE__ */ function(e) {\n  vs(t, e);\n  function t(n, o) {\n    var i;\n    i = e.call(this, n, o) || this;\n    var s = i.handleExited.bind(Kf(i));\n    return i.state = {\n      contextValue: {\n        isMounting: !0\n      },\n      handleExited: s,\n      firstRender: !0\n    }, i;\n  }\n  var r = t.prototype;\n  return r.componentDidMount = function() {\n    this.mounted = !0, this.setState({\n      contextValue: {\n        isMounting: !1\n      }\n    });\n  }, r.componentWillUnmount = function() {\n    this.mounted = !1;\n  }, t.getDerivedStateFromProps = function(o, i) {\n    var s = i.children, c = i.handleExited, l = i.firstRender;\n    return {\n      children: l ? Jf(o, c) : Qf(o, s, c),\n      firstRender: !1\n    };\n  }, r.handleExited = function(o, i) {\n    var s = Yo(this.props.children);\n    o.key in s || (o.props.onExited && o.props.onExited(i), this.mounted && this.setState(function(c) {\n      var l = fn({}, c.children);\n      return delete l[o.key], {\n        children: l\n      };\n    }));\n  }, r.render = function() {\n    var o = this.props, i = o.component, s = o.childFactory, c = bs(o, [\"component\", \"childFactory\"]), l = this.state.contextValue, u = Zf(this.state.children).map(s);\n    return delete c.appear, delete c.enter, delete c.exit, i === null ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(bn.Provider, {\n      value: l\n    }, u) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(bn.Provider, {\n      value: l\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(i, c, u));\n  }, t;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nHo.propTypes =  true ? {\n  /**\n   * `<TransitionGroup>` renders a `<div>` by default. You can change this\n   * behavior by providing a `component` prop.\n   * If you use React v16+ and would like to avoid a wrapping `<div>` element\n   * you can pass in `component={null}`. This is useful if the wrapping div\n   * borks your css styles.\n   */\n  component: a.any,\n  /**\n   * A set of `<Transition>` components, that are toggled `in` and out as they\n   * leave. the `<TransitionGroup>` will inject specific transition props, so\n   * remember to spread them through if you are wrapping the `<Transition>` as\n   * with our `<Fade>` example.\n   *\n   * While this component is meant for multiple `Transition` or `CSSTransition`\n   * children, sometimes you may want to have a single transition child with\n   * content that you want to be transitioned out and in when you change it\n   * (e.g. routes, images etc.) In that case you can change the `key` prop of\n   * the transition child as you change its content, this will cause\n   * `TransitionGroup` to transition the child out and back in.\n   */\n  children: a.node,\n  /**\n   * A convenience prop that enables or disables appear animations\n   * for all children. Note that specifying this will override any defaults set\n   * on individual children Transitions.\n   */\n  appear: a.bool,\n  /**\n   * A convenience prop that enables or disables enter animations\n   * for all children. Note that specifying this will override any defaults set\n   * on individual children Transitions.\n   */\n  enter: a.bool,\n  /**\n   * A convenience prop that enables or disables exit animations\n   * for all children. Note that specifying this will override any defaults set\n   * on individual children Transitions.\n   */\n  exit: a.bool,\n  /**\n   * You may need to apply reactive updates to a child as it is exiting.\n   * This is generally done by using `cloneElement` however in the case of an exiting\n   * child the element has already been removed and not accessible to the consumer.\n   *\n   * If you do need to update a child as it leaves you can provide a `childFactory`\n   * to wrap every child, even the ones that are leaving.\n   *\n   * @type Function(child: ReactElement) -> ReactElement\n   */\n  childFactory: a.func\n} : 0;\nHo.defaultProps = ed;\nconst td = (e) => e.scrollTop;\nfunction vn(e, t) {\n  const {\n    timeout: r,\n    easing: n,\n    style: o = {}\n  } = e;\n  return {\n    duration: o.transitionDuration ?? (typeof r == \"number\" ? r : r[t.mode] || 0),\n    easing: o.transitionTimingFunction ?? (typeof n == \"object\" ? n[t.mode] : n),\n    delay: o.transitionDelay\n  };\n}\nfunction rd(e) {\n  return Ve(\"MuiCollapse\", e);\n}\nFe(\"MuiCollapse\", [\"root\", \"horizontal\", \"vertical\", \"entered\", \"hidden\", \"wrapper\", \"wrapperInner\"]);\nconst nd = (e) => {\n  const {\n    orientation: t,\n    classes: r\n  } = e, n = {\n    root: [\"root\", `${t}`],\n    entered: [\"entered\"],\n    hidden: [\"hidden\"],\n    wrapper: [\"wrapper\", `${t}`],\n    wrapperInner: [\"wrapperInner\", `${t}`]\n  };\n  return Ge(n, rd, r);\n}, od = le(\"div\", {\n  name: \"MuiCollapse\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, t[r.orientation], r.state === \"entered\" && t.entered, r.state === \"exited\" && !r.in && r.collapsedSize === \"0px\" && t.hidden];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  height: 0,\n  overflow: \"hidden\",\n  transition: e.transitions.create(\"height\"),\n  variants: [{\n    props: {\n      orientation: \"horizontal\"\n    },\n    style: {\n      height: \"auto\",\n      width: 0,\n      transition: e.transitions.create(\"width\")\n    }\n  }, {\n    props: {\n      state: \"entered\"\n    },\n    style: {\n      height: \"auto\",\n      overflow: \"visible\"\n    }\n  }, {\n    props: {\n      state: \"entered\",\n      orientation: \"horizontal\"\n    },\n    style: {\n      width: \"auto\"\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.state === \"exited\" && !t.in && t.collapsedSize === \"0px\",\n    style: {\n      visibility: \"hidden\"\n    }\n  }]\n}))), id = le(\"div\", {\n  name: \"MuiCollapse\",\n  slot: \"Wrapper\",\n  overridesResolver: (e, t) => t.wrapper\n})({\n  // Hack to get children with a negative margin to not falsify the height computation.\n  display: \"flex\",\n  width: \"100%\",\n  variants: [{\n    props: {\n      orientation: \"horizontal\"\n    },\n    style: {\n      width: \"auto\",\n      height: \"100%\"\n    }\n  }]\n}), ad = le(\"div\", {\n  name: \"MuiCollapse\",\n  slot: \"WrapperInner\",\n  overridesResolver: (e, t) => t.wrapperInner\n})({\n  width: \"100%\",\n  variants: [{\n    props: {\n      orientation: \"horizontal\"\n    },\n    style: {\n      width: \"auto\",\n      height: \"100%\"\n    }\n  }]\n}), xn = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiCollapse\"\n  }), {\n    addEndListener: o,\n    children: i,\n    className: s,\n    collapsedSize: c = \"0px\",\n    component: l,\n    easing: u,\n    in: p,\n    onEnter: m,\n    onEntered: g,\n    onEntering: x,\n    onExit: y,\n    onExited: f,\n    onExiting: S,\n    orientation: E = \"vertical\",\n    style: P,\n    timeout: T = ds.standard,\n    // eslint-disable-next-line react/prop-types\n    TransitionComponent: b = Et,\n    ...h\n  } = n, w = {\n    ...n,\n    orientation: E,\n    collapsedSize: c\n  }, k = nd(w), L = Lr(), B = Dt(), d = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), A = react__WEBPACK_IMPORTED_MODULE_0__.useRef(), D = typeof c == \"number\" ? `${c}px` : c, j = E === \"horizontal\", W = j ? \"width\" : \"height\", z = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), U = at(r, z), V = (_) => (q) => {\n    if (_) {\n      const G = z.current;\n      q === void 0 ? _(G) : _(G, q);\n    }\n  }, te = () => d.current ? d.current[j ? \"clientWidth\" : \"clientHeight\"] : 0, F = V((_, q) => {\n    d.current && j && (d.current.style.position = \"absolute\"), _.style[W] = D, m && m(_, q);\n  }), R = V((_, q) => {\n    const G = te();\n    d.current && j && (d.current.style.position = \"\");\n    const {\n      duration: re,\n      easing: Z\n    } = vn({\n      style: P,\n      timeout: T,\n      easing: u\n    }, {\n      mode: \"enter\"\n    });\n    if (T === \"auto\") {\n      const ae = L.transitions.getAutoHeightDuration(G);\n      _.style.transitionDuration = `${ae}ms`, A.current = ae;\n    } else\n      _.style.transitionDuration = typeof re == \"string\" ? re : `${re}ms`;\n    _.style[W] = `${G}px`, _.style.transitionTimingFunction = Z, x && x(_, q);\n  }), I = V((_, q) => {\n    _.style[W] = \"auto\", g && g(_, q);\n  }), J = V((_) => {\n    _.style[W] = `${te()}px`, y && y(_);\n  }), Q = V(f), H = V((_) => {\n    const q = te(), {\n      duration: G,\n      easing: re\n    } = vn({\n      style: P,\n      timeout: T,\n      easing: u\n    }, {\n      mode: \"exit\"\n    });\n    if (T === \"auto\") {\n      const Z = L.transitions.getAutoHeightDuration(q);\n      _.style.transitionDuration = `${Z}ms`, A.current = Z;\n    } else\n      _.style.transitionDuration = typeof G == \"string\" ? G : `${G}ms`;\n    _.style[W] = D, _.style.transitionTimingFunction = re, S && S(_);\n  }), X = (_) => {\n    T === \"auto\" && B.start(A.current || 0, _), o && o(z.current, _);\n  };\n  return /* @__PURE__ */ N.jsx(b, {\n    in: p,\n    onEnter: F,\n    onEntered: I,\n    onEntering: R,\n    onExit: J,\n    onExited: Q,\n    onExiting: H,\n    addEndListener: X,\n    nodeRef: z,\n    timeout: T === \"auto\" ? null : T,\n    ...h,\n    children: (_, {\n      ownerState: q,\n      ...G\n    }) => /* @__PURE__ */ N.jsx(od, {\n      as: l,\n      className: se(k.root, s, {\n        entered: k.entered,\n        exited: !p && D === \"0px\" && k.hidden\n      }[_]),\n      style: {\n        [j ? \"minWidth\" : \"minHeight\"]: D,\n        ...P\n      },\n      ref: U,\n      ownerState: {\n        ...w,\n        state: _\n      },\n      ...G,\n      children: /* @__PURE__ */ N.jsx(id, {\n        ownerState: {\n          ...w,\n          state: _\n        },\n        className: k.wrapper,\n        ref: d,\n        children: /* @__PURE__ */ N.jsx(ad, {\n          ownerState: {\n            ...w,\n            state: _\n          },\n          className: k.wrapperInner,\n          children: i\n        })\n      })\n    })\n  });\n});\n true && (xn.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Add a custom transition end trigger. Called with the transitioning DOM\n   * node and a done callback. Allows for more fine grained transition end\n   * logic. Note: Timeouts are still used as a fallback if provided.\n   */\n  addEndListener: a.func,\n  /**\n   * The content node to be collapsed.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The width (horizontal) or height (vertical) of the container when collapsed.\n   * @default '0px'\n   */\n  collapsedSize: a.oneOfType([a.number, a.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: Ja,\n  /**\n   * The transition timing function.\n   * You may specify a single easing or a object containing enter and exit values.\n   */\n  easing: a.oneOfType([a.shape({\n    enter: a.string,\n    exit: a.string\n  }), a.string]),\n  /**\n   * If `true`, the component will transition in.\n   */\n  in: a.bool,\n  /**\n   * @ignore\n   */\n  onEnter: a.func,\n  /**\n   * @ignore\n   */\n  onEntered: a.func,\n  /**\n   * @ignore\n   */\n  onEntering: a.func,\n  /**\n   * @ignore\n   */\n  onExit: a.func,\n  /**\n   * @ignore\n   */\n  onExited: a.func,\n  /**\n   * @ignore\n   */\n  onExiting: a.func,\n  /**\n   * The transition orientation.\n   * @default 'vertical'\n   */\n  orientation: a.oneOf([\"horizontal\", \"vertical\"]),\n  /**\n   * @ignore\n   */\n  style: a.object,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   *\n   * Set to 'auto' to automatically calculate transition time based on height.\n   * @default duration.standard\n   */\n  timeout: a.oneOfType([a.oneOf([\"auto\"]), a.number, a.shape({\n    appear: a.number,\n    enter: a.number,\n    exit: a.number\n  })])\n});\nxn && (xn.muiSupportAuto = !0);\nfunction Bt(e, t) {\n  const {\n    className: r,\n    elementType: n,\n    ownerState: o,\n    externalForwardedProps: i,\n    internalForwardedProps: s,\n    shouldForwardComponentProp: c = !1,\n    ...l\n  } = t, {\n    component: u,\n    slots: p = {\n      [e]: void 0\n    },\n    slotProps: m = {\n      [e]: void 0\n    },\n    ...g\n  } = i, x = p[e] || n, y = rs(m[e], o), {\n    props: {\n      component: f,\n      ...S\n    },\n    internalRef: E\n  } = ts({\n    className: r,\n    ...l,\n    externalForwardedProps: e === \"root\" ? g : void 0,\n    externalSlotProps: y\n  }), P = at(E, y == null ? void 0 : y.ref, t.ref), T = e === \"root\" ? f || u : f, b = es(x, {\n    ...e === \"root\" && !u && !p[e] && s,\n    ...e !== \"root\" && !p[e] && s,\n    ...S,\n    ...T && !c && {\n      as: T\n    },\n    ...T && c && {\n      component: T\n    },\n    ref: P\n  }, o);\n  return [x, b];\n}\nclass Sn {\n  constructor() {\n    cr(this, \"mountEffect\", () => {\n      this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());\n    });\n    this.ref = {\n      current: null\n    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;\n  }\n  /** React ref to the ripple instance */\n  /** If the ripple component should be mounted */\n  /** Promise that resolves when the ripple component is mounted */\n  /** If the ripple component has been mounted */\n  /** React state hook setter */\n  static create() {\n    return new Sn();\n  }\n  static use() {\n    const t = Za(Sn.create).current, [r, n] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1);\n    return t.shouldMount = r, t.setShouldMount = n, react__WEBPACK_IMPORTED_MODULE_0__.useEffect(t.mountEffect, [r]), t;\n  }\n  mount() {\n    return this.mounted || (this.mounted = cd(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;\n  }\n  /* Ripple API */\n  start(...t) {\n    this.mount().then(() => {\n      var r;\n      return (r = this.ref.current) == null ? void 0 : r.start(...t);\n    });\n  }\n  stop(...t) {\n    this.mount().then(() => {\n      var r;\n      return (r = this.ref.current) == null ? void 0 : r.stop(...t);\n    });\n  }\n  pulsate(...t) {\n    this.mount().then(() => {\n      var r;\n      return (r = this.ref.current) == null ? void 0 : r.pulsate(...t);\n    });\n  }\n}\nfunction sd() {\n  return Sn.use();\n}\nfunction cd() {\n  let e, t;\n  const r = new Promise((n, o) => {\n    e = n, t = o;\n  });\n  return r.resolve = e, r.reject = t, r;\n}\nfunction xs(e) {\n  const {\n    className: t,\n    classes: r,\n    pulsate: n = !1,\n    rippleX: o,\n    rippleY: i,\n    rippleSize: s,\n    in: c,\n    onExited: l,\n    timeout: u\n  } = e, [p, m] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1), g = se(t, r.ripple, r.rippleVisible, n && r.ripplePulsate), x = {\n    width: s,\n    height: s,\n    top: -(s / 2) + i,\n    left: -(s / 2) + o\n  }, y = se(r.child, p && r.childLeaving, n && r.childPulsate);\n  return !c && !p && m(!0), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!c && l != null) {\n      const f = setTimeout(l, u);\n      return () => {\n        clearTimeout(f);\n      };\n    }\n  }, [l, c, u]), /* @__PURE__ */ N.jsx(\"span\", {\n    className: g,\n    style: x,\n    children: /* @__PURE__ */ N.jsx(\"span\", {\n      className: y\n    })\n  });\n}\n true && (xs.propTypes = {\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object.isRequired,\n  className: a.string,\n  /**\n   * @ignore - injected from TransitionGroup\n   */\n  in: a.bool,\n  /**\n   * @ignore - injected from TransitionGroup\n   */\n  onExited: a.func,\n  /**\n   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.\n   */\n  pulsate: a.bool,\n  /**\n   * Diameter of the ripple.\n   */\n  rippleSize: a.number,\n  /**\n   * Horizontal position of the ripple center.\n   */\n  rippleX: a.number,\n  /**\n   * Vertical position of the ripple center.\n   */\n  rippleY: a.number,\n  /**\n   * exit delay\n   */\n  timeout: a.number.isRequired\n});\nconst nt = Fe(\"MuiTouchRipple\", [\"root\", \"ripple\", \"rippleVisible\", \"ripplePulsate\", \"child\", \"childLeaving\", \"childPulsate\"]), ho = 550, ld = 80, ud = Ir`\n  0% {\n    transform: scale(0);\n    opacity: 0.1;\n  }\n\n  100% {\n    transform: scale(1);\n    opacity: 0.3;\n  }\n`, fd = Ir`\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n`, dd = Ir`\n  0% {\n    transform: scale(1);\n  }\n\n  50% {\n    transform: scale(0.92);\n  }\n\n  100% {\n    transform: scale(1);\n  }\n`, pd = le(\"span\", {\n  name: \"MuiTouchRipple\",\n  slot: \"Root\"\n})({\n  overflow: \"hidden\",\n  pointerEvents: \"none\",\n  position: \"absolute\",\n  zIndex: 0,\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n  borderRadius: \"inherit\"\n}), md = le(xs, {\n  name: \"MuiTouchRipple\",\n  slot: \"Ripple\"\n})`\n  opacity: 0;\n  position: absolute;\n\n  &.${nt.rippleVisible} {\n    opacity: 0.3;\n    transform: scale(1);\n    animation-name: ${ud};\n    animation-duration: ${ho}ms;\n    animation-timing-function: ${({\n  theme: e\n}) => e.transitions.easing.easeInOut};\n  }\n\n  &.${nt.ripplePulsate} {\n    animation-duration: ${({\n  theme: e\n}) => e.transitions.duration.shorter}ms;\n  }\n\n  & .${nt.child} {\n    opacity: 1;\n    display: block;\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    background-color: currentColor;\n  }\n\n  & .${nt.childLeaving} {\n    opacity: 0;\n    animation-name: ${fd};\n    animation-duration: ${ho}ms;\n    animation-timing-function: ${({\n  theme: e\n}) => e.transitions.easing.easeInOut};\n  }\n\n  & .${nt.childPulsate} {\n    position: absolute;\n    /* @noflip */\n    left: 0px;\n    top: 0;\n    animation-name: ${dd};\n    animation-duration: 2500ms;\n    animation-timing-function: ${({\n  theme: e\n}) => e.transitions.easing.easeInOut};\n    animation-iteration-count: infinite;\n    animation-delay: 200ms;\n  }\n`, Ss = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiTouchRipple\"\n  }), {\n    center: o = !1,\n    classes: i = {},\n    className: s,\n    ...c\n  } = n, [l, u] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]), p = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0), m = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    m.current && (m.current(), m.current = null);\n  }, [l]);\n  const g = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!1), x = Dt(), y = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), f = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), S = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((b) => {\n    const {\n      pulsate: h,\n      rippleX: w,\n      rippleY: k,\n      rippleSize: L,\n      cb: B\n    } = b;\n    u((d) => [...d, /* @__PURE__ */ N.jsx(md, {\n      classes: {\n        ripple: se(i.ripple, nt.ripple),\n        rippleVisible: se(i.rippleVisible, nt.rippleVisible),\n        ripplePulsate: se(i.ripplePulsate, nt.ripplePulsate),\n        child: se(i.child, nt.child),\n        childLeaving: se(i.childLeaving, nt.childLeaving),\n        childPulsate: se(i.childPulsate, nt.childPulsate)\n      },\n      timeout: ho,\n      pulsate: h,\n      rippleX: w,\n      rippleY: k,\n      rippleSize: L\n    }, p.current)]), p.current += 1, m.current = B;\n  }, [i]), E = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((b = {}, h = {}, w = () => {\n  }) => {\n    const {\n      pulsate: k = !1,\n      center: L = o || h.pulsate,\n      fakeElement: B = !1\n      // For test purposes\n    } = h;\n    if ((b == null ? void 0 : b.type) === \"mousedown\" && g.current) {\n      g.current = !1;\n      return;\n    }\n    (b == null ? void 0 : b.type) === \"touchstart\" && (g.current = !0);\n    const d = B ? null : f.current, A = d ? d.getBoundingClientRect() : {\n      width: 0,\n      height: 0,\n      left: 0,\n      top: 0\n    };\n    let D, j, W;\n    if (L || b === void 0 || b.clientX === 0 && b.clientY === 0 || !b.clientX && !b.touches)\n      D = Math.round(A.width / 2), j = Math.round(A.height / 2);\n    else {\n      const {\n        clientX: z,\n        clientY: U\n      } = b.touches && b.touches.length > 0 ? b.touches[0] : b;\n      D = Math.round(z - A.left), j = Math.round(U - A.top);\n    }\n    if (L)\n      W = Math.sqrt((2 * A.width ** 2 + A.height ** 2) / 3), W % 2 === 0 && (W += 1);\n    else {\n      const z = Math.max(Math.abs((d ? d.clientWidth : 0) - D), D) * 2 + 2, U = Math.max(Math.abs((d ? d.clientHeight : 0) - j), j) * 2 + 2;\n      W = Math.sqrt(z ** 2 + U ** 2);\n    }\n    b != null && b.touches ? y.current === null && (y.current = () => {\n      S({\n        pulsate: k,\n        rippleX: D,\n        rippleY: j,\n        rippleSize: W,\n        cb: w\n      });\n    }, x.start(ld, () => {\n      y.current && (y.current(), y.current = null);\n    })) : S({\n      pulsate: k,\n      rippleX: D,\n      rippleY: j,\n      rippleSize: W,\n      cb: w\n    });\n  }, [o, S, x]), P = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    E({}, {\n      pulsate: !0\n    });\n  }, [E]), T = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((b, h) => {\n    if (x.clear(), (b == null ? void 0 : b.type) === \"touchend\" && y.current) {\n      y.current(), y.current = null, x.start(0, () => {\n        T(b, h);\n      });\n      return;\n    }\n    y.current = null, u((w) => w.length > 0 ? w.slice(1) : w), m.current = h;\n  }, [x]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(r, () => ({\n    pulsate: P,\n    start: E,\n    stop: T\n  }), [P, E, T]), /* @__PURE__ */ N.jsx(pd, {\n    className: se(nt.root, i.root, s),\n    ref: f,\n    ...c,\n    children: /* @__PURE__ */ N.jsx(Ho, {\n      component: null,\n      exit: !0,\n      children: l\n    })\n  });\n});\n true && (Ss.propTypes = {\n  /**\n   * If `true`, the ripple starts at the center of the component\n   * rather than at the point of interaction.\n   */\n  center: a.bool,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string\n});\nfunction hd(e) {\n  return Ve(\"MuiButtonBase\", e);\n}\nconst gd = Fe(\"MuiButtonBase\", [\"root\", \"disabled\", \"focusVisible\"]), yd = (e) => {\n  const {\n    disabled: t,\n    focusVisible: r,\n    focusVisibleClassName: n,\n    classes: o\n  } = e, s = Ge({\n    root: [\"root\", t && \"disabled\", r && \"focusVisible\"]\n  }, hd, o);\n  return r && n && (s.root += ` ${n}`), s;\n}, bd = le(\"button\", {\n  name: \"MuiButtonBase\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => t.root\n})({\n  display: \"inline-flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  position: \"relative\",\n  boxSizing: \"border-box\",\n  WebkitTapHighlightColor: \"transparent\",\n  backgroundColor: \"transparent\",\n  // Reset default value\n  // We disable the focus ring for mouse, touch and keyboard users.\n  outline: 0,\n  border: 0,\n  margin: 0,\n  // Remove the margin in Safari\n  borderRadius: 0,\n  padding: 0,\n  // Remove the padding in Firefox\n  cursor: \"pointer\",\n  userSelect: \"none\",\n  verticalAlign: \"middle\",\n  MozAppearance: \"none\",\n  // Reset\n  WebkitAppearance: \"none\",\n  // Reset\n  textDecoration: \"none\",\n  // So we take precedent over the style of a native <a /> element.\n  color: \"inherit\",\n  \"&::-moz-focus-inner\": {\n    borderStyle: \"none\"\n    // Remove Firefox dotted outline.\n  },\n  [`&.${gd.disabled}`]: {\n    pointerEvents: \"none\",\n    // Disable link interactions\n    cursor: \"default\"\n  },\n  \"@media print\": {\n    colorAdjust: \"exact\"\n  }\n}), $r = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiButtonBase\"\n  }), {\n    action: o,\n    centerRipple: i = !1,\n    children: s,\n    className: c,\n    component: l = \"button\",\n    disabled: u = !1,\n    disableRipple: p = !1,\n    disableTouchRipple: m = !1,\n    focusRipple: g = !1,\n    focusVisibleClassName: x,\n    LinkComponent: y = \"a\",\n    onBlur: f,\n    onClick: S,\n    onContextMenu: E,\n    onDragLeave: P,\n    onFocus: T,\n    onFocusVisible: b,\n    onKeyDown: h,\n    onKeyUp: w,\n    onMouseDown: k,\n    onMouseLeave: L,\n    onMouseUp: B,\n    onTouchEnd: d,\n    onTouchMove: A,\n    onTouchStart: D,\n    tabIndex: j = 0,\n    TouchRippleProps: W,\n    touchRippleRef: z,\n    type: U,\n    ...V\n  } = n, te = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), F = sd(), R = at(F.ref, z), [I, J] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1);\n  u && I && J(!1), react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(o, () => ({\n    focusVisible: () => {\n      J(!0), te.current.focus();\n    }\n  }), []);\n  const Q = F.shouldMount && !p && !u;\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    I && g && !p && F.pulsate();\n  }, [p, g, I, F]);\n  const H = Tt(F, \"start\", k, m), X = Tt(F, \"stop\", E, m), _ = Tt(F, \"stop\", P, m), q = Tt(F, \"stop\", B, m), G = Tt(F, \"stop\", (M) => {\n    I && M.preventDefault(), L && L(M);\n  }, m), re = Tt(F, \"start\", D, m), Z = Tt(F, \"stop\", d, m), ae = Tt(F, \"stop\", A, m), O = Tt(F, \"stop\", (M) => {\n    hn(M.target) || J(!1), f && f(M);\n  }, !1), ye = Qt((M) => {\n    te.current || (te.current = M.currentTarget), hn(M.target) && (J(!0), b && b(M)), T && T(M);\n  }), Ee = () => {\n    const M = te.current;\n    return l && l !== \"button\" && !(M.tagName === \"A\" && M.href);\n  }, Me = Qt((M) => {\n    g && !M.repeat && I && M.key === \" \" && F.stop(M, () => {\n      F.start(M);\n    }), M.target === M.currentTarget && Ee() && M.key === \" \" && M.preventDefault(), h && h(M), M.target === M.currentTarget && Ee() && M.key === \"Enter\" && !u && (M.preventDefault(), S && S(M));\n  }), Qe = Qt((M) => {\n    g && M.key === \" \" && I && !M.defaultPrevented && F.stop(M, () => {\n      F.pulsate(M);\n    }), w && w(M), S && M.target === M.currentTarget && Ee() && M.key === \" \" && !M.defaultPrevented && S(M);\n  });\n  let ve = l;\n  ve === \"button\" && (V.href || V.to) && (ve = y);\n  const Pe = {};\n  ve === \"button\" ? (Pe.type = U === void 0 ? \"button\" : U, Pe.disabled = u) : (!V.href && !V.to && (Pe.role = \"button\"), u && (Pe[\"aria-disabled\"] = u));\n  const ze = at(r, te), Le = {\n    ...n,\n    centerRipple: i,\n    component: l,\n    disabled: u,\n    disableRipple: p,\n    disableTouchRipple: m,\n    focusRipple: g,\n    tabIndex: j,\n    focusVisible: I\n  }, v = yd(Le);\n  return /* @__PURE__ */ N.jsxs(bd, {\n    as: ve,\n    className: se(v.root, c),\n    ownerState: Le,\n    onBlur: O,\n    onClick: S,\n    onContextMenu: X,\n    onFocus: ye,\n    onKeyDown: Me,\n    onKeyUp: Qe,\n    onMouseDown: H,\n    onMouseLeave: G,\n    onMouseUp: q,\n    onDragLeave: _,\n    onTouchEnd: Z,\n    onTouchMove: ae,\n    onTouchStart: re,\n    ref: ze,\n    tabIndex: u ? -1 : j,\n    type: U,\n    ...Pe,\n    ...V,\n    children: [s, Q ? /* @__PURE__ */ N.jsx(Ss, {\n      ref: R,\n      center: i,\n      ...W\n    }) : null]\n  });\n});\nfunction Tt(e, t, r, n = !1) {\n  return Qt((o) => (r && r(o), n || e[t](o), !0));\n}\n true && ($r.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * A ref for imperative actions.\n   * It currently only supports `focusVisible()` action.\n   */\n  action: Lo,\n  /**\n   * If `true`, the ripples are centered.\n   * They won't start at the cursor interaction position.\n   * @default false\n   */\n  centerRipple: a.bool,\n  /**\n   * The content of the component.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: Ja,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: a.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   *\n   *  Without a ripple there is no styling for :focus-visible by default. Be sure\n   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.\n   * @default false\n   */\n  disableRipple: a.bool,\n  /**\n   * If `true`, the touch ripple effect is disabled.\n   * @default false\n   */\n  disableTouchRipple: a.bool,\n  /**\n   * If `true`, the base button will have a keyboard focus ripple.\n   * @default false\n   */\n  focusRipple: a.bool,\n  /**\n   * This prop can help identify which element has keyboard focus.\n   * The class name will be applied when the element gains the focus through keyboard interaction.\n   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).\n   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).\n   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components\n   * if needed.\n   */\n  focusVisibleClassName: a.string,\n  /**\n   * @ignore\n   */\n  href: a.any,\n  /**\n   * The component used to render a link when the `href` prop is provided.\n   * @default 'a'\n   */\n  LinkComponent: a.elementType,\n  /**\n   * @ignore\n   */\n  onBlur: a.func,\n  /**\n   * @ignore\n   */\n  onClick: a.func,\n  /**\n   * @ignore\n   */\n  onContextMenu: a.func,\n  /**\n   * @ignore\n   */\n  onDragLeave: a.func,\n  /**\n   * @ignore\n   */\n  onFocus: a.func,\n  /**\n   * Callback fired when the component is focused with a keyboard.\n   * We trigger a `onFocus` callback too.\n   */\n  onFocusVisible: a.func,\n  /**\n   * @ignore\n   */\n  onKeyDown: a.func,\n  /**\n   * @ignore\n   */\n  onKeyUp: a.func,\n  /**\n   * @ignore\n   */\n  onMouseDown: a.func,\n  /**\n   * @ignore\n   */\n  onMouseLeave: a.func,\n  /**\n   * @ignore\n   */\n  onMouseUp: a.func,\n  /**\n   * @ignore\n   */\n  onTouchEnd: a.func,\n  /**\n   * @ignore\n   */\n  onTouchMove: a.func,\n  /**\n   * @ignore\n   */\n  onTouchStart: a.func,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * @default 0\n   */\n  tabIndex: a.number,\n  /**\n   * Props applied to the `TouchRipple` element.\n   */\n  TouchRippleProps: a.object,\n  /**\n   * A ref that points to the `TouchRipple` element.\n   */\n  touchRippleRef: a.oneOfType([a.func, a.shape({\n    current: a.shape({\n      pulsate: a.func.isRequired,\n      start: a.func.isRequired,\n      stop: a.func.isRequired\n    })\n  })]),\n  /**\n   * @ignore\n   */\n  type: a.oneOfType([a.oneOf([\"button\", \"reset\", \"submit\"]), a.string])\n});\nfunction vd(e) {\n  return typeof e.main == \"string\";\n}\nfunction xd(e, t = []) {\n  if (!vd(e))\n    return !1;\n  for (const r of t)\n    if (!e.hasOwnProperty(r) || typeof e[r] != \"string\")\n      return !1;\n  return !0;\n}\nfunction Pt(e = []) {\n  return ([, t]) => t && xd(t, e);\n}\nfunction Sd(e) {\n  return Ve(\"MuiCircularProgress\", e);\n}\nFe(\"MuiCircularProgress\", [\"root\", \"determinate\", \"indeterminate\", \"colorPrimary\", \"colorSecondary\", \"svg\", \"circle\", \"circleDeterminate\", \"circleIndeterminate\", \"circleDisableShrink\"]);\nconst $t = 44, go = Ir`\n  0% {\n    transform: rotate(0deg);\n  }\n\n  100% {\n    transform: rotate(360deg);\n  }\n`, yo = Ir`\n  0% {\n    stroke-dasharray: 1px, 200px;\n    stroke-dashoffset: 0;\n  }\n\n  50% {\n    stroke-dasharray: 100px, 200px;\n    stroke-dashoffset: -15px;\n  }\n\n  100% {\n    stroke-dasharray: 1px, 200px;\n    stroke-dashoffset: -126px;\n  }\n`, Ed = typeof go != \"string\" ? $o`\n        animation: ${go} 1.4s linear infinite;\n      ` : null, Cd = typeof yo != \"string\" ? $o`\n        animation: ${yo} 1.4s ease-in-out infinite;\n      ` : null, Td = (e) => {\n  const {\n    classes: t,\n    variant: r,\n    color: n,\n    disableShrink: o\n  } = e, i = {\n    root: [\"root\", r, `color${ee(n)}`],\n    svg: [\"svg\"],\n    circle: [\"circle\", `circle${ee(r)}`, o && \"circleDisableShrink\"]\n  };\n  return Ge(i, Sd, t);\n}, wd = le(\"span\", {\n  name: \"MuiCircularProgress\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, t[r.variant], t[`color${ee(r.color)}`]];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  display: \"inline-block\",\n  variants: [{\n    props: {\n      variant: \"determinate\"\n    },\n    style: {\n      transition: e.transitions.create(\"transform\")\n    }\n  }, {\n    props: {\n      variant: \"indeterminate\"\n    },\n    style: Ed || {\n      animation: `${go} 1.4s linear infinite`\n    }\n  }, ...Object.entries(e.palette).filter(Pt()).map(([t]) => ({\n    props: {\n      color: t\n    },\n    style: {\n      color: (e.vars || e).palette[t].main\n    }\n  }))]\n}))), Od = le(\"svg\", {\n  name: \"MuiCircularProgress\",\n  slot: \"Svg\",\n  overridesResolver: (e, t) => t.svg\n})({\n  display: \"block\"\n  // Keeps the progress centered\n}), Rd = le(\"circle\", {\n  name: \"MuiCircularProgress\",\n  slot: \"Circle\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.circle, t[`circle${ee(r.variant)}`], r.disableShrink && t.circleDisableShrink];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  stroke: \"currentColor\",\n  variants: [{\n    props: {\n      variant: \"determinate\"\n    },\n    style: {\n      transition: e.transitions.create(\"stroke-dashoffset\")\n    }\n  }, {\n    props: {\n      variant: \"indeterminate\"\n    },\n    style: {\n      // Some default value that looks fine waiting for the animation to kicks in.\n      strokeDasharray: \"80px, 200px\",\n      strokeDashoffset: 0\n      // Add the unit to fix a Edge 16 and below bug.\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.variant === \"indeterminate\" && !t.disableShrink,\n    style: Cd || {\n      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.\n      animation: `${yo} 1.4s ease-in-out infinite`\n    }\n  }]\n}))), Es = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiCircularProgress\"\n  }), {\n    className: o,\n    color: i = \"primary\",\n    disableShrink: s = !1,\n    size: c = 40,\n    style: l,\n    thickness: u = 3.6,\n    value: p = 0,\n    variant: m = \"indeterminate\",\n    ...g\n  } = n, x = {\n    ...n,\n    color: i,\n    disableShrink: s,\n    size: c,\n    thickness: u,\n    value: p,\n    variant: m\n  }, y = Td(x), f = {}, S = {}, E = {};\n  if (m === \"determinate\") {\n    const P = 2 * Math.PI * (($t - u) / 2);\n    f.strokeDasharray = P.toFixed(3), E[\"aria-valuenow\"] = Math.round(p), f.strokeDashoffset = `${((100 - p) / 100 * P).toFixed(3)}px`, S.transform = \"rotate(-90deg)\";\n  }\n  return /* @__PURE__ */ N.jsx(wd, {\n    className: se(y.root, o),\n    style: {\n      width: c,\n      height: c,\n      ...S,\n      ...l\n    },\n    ownerState: x,\n    ref: r,\n    role: \"progressbar\",\n    ...E,\n    ...g,\n    children: /* @__PURE__ */ N.jsx(Od, {\n      className: y.svg,\n      ownerState: x,\n      viewBox: `${$t / 2} ${$t / 2} ${$t} ${$t}`,\n      children: /* @__PURE__ */ N.jsx(Rd, {\n        className: y.circle,\n        style: f,\n        ownerState: x,\n        cx: $t,\n        cy: $t,\n        r: ($t - u) / 2,\n        fill: \"none\",\n        strokeWidth: u\n      })\n    })\n  });\n});\n true && (Es.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'primary'\n   */\n  color: a.oneOfType([a.oneOf([\"inherit\", \"primary\", \"secondary\", \"error\", \"info\", \"success\", \"warning\"]), a.string]),\n  /**\n   * If `true`, the shrink animation is disabled.\n   * This only works if variant is `indeterminate`.\n   * @default false\n   */\n  disableShrink: ar(a.bool, (e) => e.disableShrink && e.variant && e.variant !== \"indeterminate\" ? new Error(\"MUI: You have provided the `disableShrink` prop with a variant other than `indeterminate`. This will have no effect.\") : null),\n  /**\n   * The size of the component.\n   * If using a number, the pixel unit is assumed.\n   * If using a string, you need to provide the CSS unit, for example '3rem'.\n   * @default 40\n   */\n  size: a.oneOfType([a.number, a.string]),\n  /**\n   * @ignore\n   */\n  style: a.object,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * The thickness of the circle.\n   * @default 3.6\n   */\n  thickness: a.number,\n  /**\n   * The value of the progress indicator for the determinate variant.\n   * Value between 0 and 100.\n   * @default 0\n   */\n  value: a.number,\n  /**\n   * The variant to use.\n   * Use indeterminate when there is no progress value.\n   * @default 'indeterminate'\n   */\n  variant: a.oneOf([\"determinate\", \"indeterminate\"])\n});\nfunction $d(e) {\n  return Ve(\"MuiIconButton\", e);\n}\nconst aa = Fe(\"MuiIconButton\", [\"root\", \"disabled\", \"colorInherit\", \"colorPrimary\", \"colorSecondary\", \"colorError\", \"colorInfo\", \"colorSuccess\", \"colorWarning\", \"edgeStart\", \"edgeEnd\", \"sizeSmall\", \"sizeMedium\", \"sizeLarge\", \"loading\", \"loadingIndicator\", \"loadingWrapper\"]), Pd = (e) => {\n  const {\n    classes: t,\n    disabled: r,\n    color: n,\n    edge: o,\n    size: i,\n    loading: s\n  } = e, c = {\n    root: [\"root\", s && \"loading\", r && \"disabled\", n !== \"default\" && `color${ee(n)}`, o && `edge${ee(o)}`, `size${ee(i)}`],\n    loadingIndicator: [\"loadingIndicator\"],\n    loadingWrapper: [\"loadingWrapper\"]\n  };\n  return Ge(c, $d, t);\n}, kd = le($r, {\n  name: \"MuiIconButton\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, r.loading && t.loading, r.color !== \"default\" && t[`color${ee(r.color)}`], r.edge && t[`edge${ee(r.edge)}`], t[`size${ee(r.size)}`]];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  textAlign: \"center\",\n  flex: \"0 0 auto\",\n  fontSize: e.typography.pxToRem(24),\n  padding: 8,\n  borderRadius: \"50%\",\n  color: (e.vars || e).palette.action.active,\n  transition: e.transitions.create(\"background-color\", {\n    duration: e.transitions.duration.shortest\n  }),\n  variants: [{\n    props: (t) => !t.disableRipple,\n    style: {\n      \"--IconButton-hoverBg\": e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : De(e.palette.action.active, e.palette.action.hoverOpacity),\n      \"&:hover\": {\n        backgroundColor: \"var(--IconButton-hoverBg)\",\n        // Reset on touch devices, it doesn't add specificity\n        \"@media (hover: none)\": {\n          backgroundColor: \"transparent\"\n        }\n      }\n    }\n  }, {\n    props: {\n      edge: \"start\"\n    },\n    style: {\n      marginLeft: -12\n    }\n  }, {\n    props: {\n      edge: \"start\",\n      size: \"small\"\n    },\n    style: {\n      marginLeft: -3\n    }\n  }, {\n    props: {\n      edge: \"end\"\n    },\n    style: {\n      marginRight: -12\n    }\n  }, {\n    props: {\n      edge: \"end\",\n      size: \"small\"\n    },\n    style: {\n      marginRight: -3\n    }\n  }]\n})), qe(({\n  theme: e\n}) => ({\n  variants: [{\n    props: {\n      color: \"inherit\"\n    },\n    style: {\n      color: \"inherit\"\n    }\n  }, ...Object.entries(e.palette).filter(Pt()).map(([t]) => ({\n    props: {\n      color: t\n    },\n    style: {\n      color: (e.vars || e).palette[t].main\n    }\n  })), ...Object.entries(e.palette).filter(Pt()).map(([t]) => ({\n    props: {\n      color: t\n    },\n    style: {\n      \"--IconButton-hoverBg\": e.vars ? `rgba(${(e.vars || e).palette[t].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : De((e.vars || e).palette[t].main, e.palette.action.hoverOpacity)\n    }\n  })), {\n    props: {\n      size: \"small\"\n    },\n    style: {\n      padding: 5,\n      fontSize: e.typography.pxToRem(18)\n    }\n  }, {\n    props: {\n      size: \"large\"\n    },\n    style: {\n      padding: 12,\n      fontSize: e.typography.pxToRem(28)\n    }\n  }],\n  [`&.${aa.disabled}`]: {\n    backgroundColor: \"transparent\",\n    color: (e.vars || e).palette.action.disabled\n  },\n  [`&.${aa.loading}`]: {\n    color: \"transparent\"\n  }\n}))), Ad = le(\"span\", {\n  name: \"MuiIconButton\",\n  slot: \"LoadingIndicator\",\n  overridesResolver: (e, t) => t.loadingIndicator\n})(({\n  theme: e\n}) => ({\n  display: \"none\",\n  position: \"absolute\",\n  visibility: \"visible\",\n  top: \"50%\",\n  left: \"50%\",\n  transform: \"translate(-50%, -50%)\",\n  color: (e.vars || e).palette.action.disabled,\n  variants: [{\n    props: {\n      loading: !0\n    },\n    style: {\n      display: \"flex\"\n    }\n  }]\n})), Cs = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiIconButton\"\n  }), {\n    edge: o = !1,\n    children: i,\n    className: s,\n    color: c = \"default\",\n    disabled: l = !1,\n    disableFocusRipple: u = !1,\n    size: p = \"medium\",\n    id: m,\n    loading: g = null,\n    loadingIndicator: x,\n    ...y\n  } = n, f = Qa(m), S = x ?? /* @__PURE__ */ N.jsx(Es, {\n    \"aria-labelledby\": f,\n    color: \"inherit\",\n    size: 16\n  }), E = {\n    ...n,\n    edge: o,\n    color: c,\n    disabled: l,\n    disableFocusRipple: u,\n    loading: g,\n    loadingIndicator: S,\n    size: p\n  }, P = Pd(E);\n  return /* @__PURE__ */ N.jsxs(kd, {\n    id: f,\n    className: se(P.root, s),\n    centerRipple: !0,\n    focusRipple: !u,\n    disabled: l || g,\n    ref: r,\n    ...y,\n    ownerState: E,\n    children: [typeof g == \"boolean\" && // use plain HTML span to minimize the runtime overhead\n    /* @__PURE__ */ N.jsx(\"span\", {\n      className: P.loadingWrapper,\n      style: {\n        display: \"contents\"\n      },\n      children: /* @__PURE__ */ N.jsx(Ad, {\n        className: P.loadingIndicator,\n        ownerState: E,\n        children: g && S\n      })\n    }), i]\n  });\n});\n true && (Cs.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The icon to display.\n   */\n  children: ar(a.node, (e) => react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(e.children).some((r) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(r) && r.props.onClick) ? new Error([\"MUI: You are providing an onClick event listener to a child of a button element.\", \"Prefer applying it to the IconButton directly.\", \"This guarantees that the whole <button> will be responsive to click events.\"].join(`\n`)) : null),\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'default'\n   */\n  color: a.oneOfType([a.oneOf([\"inherit\", \"default\", \"primary\", \"secondary\", \"error\", \"info\", \"success\", \"warning\"]), a.string]),\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: a.bool,\n  /**\n   * If `true`, the  keyboard focus ripple is disabled.\n   * @default false\n   */\n  disableFocusRipple: a.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   *\n   *  Without a ripple there is no styling for :focus-visible by default. Be sure\n   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.\n   * @default false\n   */\n  disableRipple: a.bool,\n  /**\n   * If given, uses a negative margin to counteract the padding on one\n   * side (this is often helpful for aligning the left or right\n   * side of the icon with content above or below, without ruining the border\n   * size and shape).\n   * @default false\n   */\n  edge: a.oneOf([\"end\", \"start\", !1]),\n  /**\n   * @ignore\n   */\n  id: a.string,\n  /**\n   * If `true`, the loading indicator is visible and the button is disabled.\n   * If `true | false`, the loading wrapper is always rendered before the children to prevent [Google Translation Crash](https://github.com/mui/material-ui/issues/27853).\n   * @default null\n   */\n  loading: a.bool,\n  /**\n   * Element placed before the children if the button is in loading state.\n   * The node should contain an element with `role=\"progressbar\"` with an accessible name.\n   * By default, it renders a `CircularProgress` that is labeled by the button itself.\n   * @default <CircularProgress color=\"inherit\" size={16} />\n   */\n  loadingIndicator: a.node,\n  /**\n   * The size of the component.\n   * `small` is equivalent to the dense button styling.\n   * @default 'medium'\n   */\n  size: a.oneOfType([a.oneOf([\"small\", \"medium\", \"large\"]), a.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nfunction Nd(e) {\n  return Ve(\"MuiTypography\", e);\n}\nconst sa = Fe(\"MuiTypography\", [\"root\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"subtitle1\", \"subtitle2\", \"body1\", \"body2\", \"inherit\", \"button\", \"caption\", \"overline\", \"alignLeft\", \"alignRight\", \"alignCenter\", \"alignJustify\", \"noWrap\", \"gutterBottom\", \"paragraph\"]), Md = {\n  primary: !0,\n  secondary: !0,\n  error: !0,\n  info: !0,\n  success: !0,\n  warning: !0,\n  textPrimary: !0,\n  textSecondary: !0,\n  textDisabled: !0\n}, Id = Wf(), _d = (e) => {\n  const {\n    align: t,\n    gutterBottom: r,\n    noWrap: n,\n    paragraph: o,\n    variant: i,\n    classes: s\n  } = e, c = {\n    root: [\"root\", i, e.align !== \"inherit\" && `align${ee(t)}`, r && \"gutterBottom\", n && \"noWrap\", o && \"paragraph\"]\n  };\n  return Ge(c, Nd, s);\n}, jd = le(\"span\", {\n  name: \"MuiTypography\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, r.variant && t[r.variant], r.align !== \"inherit\" && t[`align${ee(r.align)}`], r.noWrap && t.noWrap, r.gutterBottom && t.gutterBottom, r.paragraph && t.paragraph];\n  }\n})(qe(({\n  theme: e\n}) => {\n  var t;\n  return {\n    margin: 0,\n    variants: [{\n      props: {\n        variant: \"inherit\"\n      },\n      style: {\n        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.\n        font: \"inherit\",\n        lineHeight: \"inherit\",\n        letterSpacing: \"inherit\"\n      }\n    }, ...Object.entries(e.typography).filter(([r, n]) => r !== \"inherit\" && n && typeof n == \"object\").map(([r, n]) => ({\n      props: {\n        variant: r\n      },\n      style: n\n    })), ...Object.entries(e.palette).filter(Pt()).map(([r]) => ({\n      props: {\n        color: r\n      },\n      style: {\n        color: (e.vars || e).palette[r].main\n      }\n    })), ...Object.entries(((t = e.palette) == null ? void 0 : t.text) || {}).filter(([, r]) => typeof r == \"string\").map(([r]) => ({\n      props: {\n        color: `text${ee(r)}`\n      },\n      style: {\n        color: (e.vars || e).palette.text[r]\n      }\n    })), {\n      props: ({\n        ownerState: r\n      }) => r.align !== \"inherit\",\n      style: {\n        textAlign: \"var(--Typography-textAlign)\"\n      }\n    }, {\n      props: ({\n        ownerState: r\n      }) => r.noWrap,\n      style: {\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        whiteSpace: \"nowrap\"\n      }\n    }, {\n      props: ({\n        ownerState: r\n      }) => r.gutterBottom,\n      style: {\n        marginBottom: \"0.35em\"\n      }\n    }, {\n      props: ({\n        ownerState: r\n      }) => r.paragraph,\n      style: {\n        marginBottom: 16\n      }\n    }]\n  };\n})), ca = {\n  h1: \"h1\",\n  h2: \"h2\",\n  h3: \"h3\",\n  h4: \"h4\",\n  h5: \"h5\",\n  h6: \"h6\",\n  subtitle1: \"h6\",\n  subtitle2: \"h6\",\n  body1: \"p\",\n  body2: \"p\",\n  inherit: \"p\"\n}, bt = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const {\n    color: n,\n    ...o\n  } = He({\n    props: t,\n    name: \"MuiTypography\"\n  }), i = !Md[n], s = Id({\n    ...o,\n    ...i && {\n      color: n\n    }\n  }), {\n    align: c = \"inherit\",\n    className: l,\n    component: u,\n    gutterBottom: p = !1,\n    noWrap: m = !1,\n    paragraph: g = !1,\n    variant: x = \"body1\",\n    variantMapping: y = ca,\n    ...f\n  } = s, S = {\n    ...s,\n    align: c,\n    color: n,\n    className: l,\n    component: u,\n    gutterBottom: p,\n    noWrap: m,\n    paragraph: g,\n    variant: x,\n    variantMapping: y\n  }, E = u || (g ? \"p\" : y[x] || ca[x]) || \"span\", P = _d(S);\n  return /* @__PURE__ */ N.jsx(jd, {\n    as: E,\n    ref: r,\n    className: se(P.root, l),\n    ...f,\n    ownerState: S,\n    style: {\n      ...c !== \"inherit\" && {\n        \"--Typography-textAlign\": c\n      },\n      ...f.style\n    }\n  });\n});\n true && (bt.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Set the text-align on the component.\n   * @default 'inherit'\n   */\n  align: a.oneOf([\"center\", \"inherit\", \"justify\", \"left\", \"right\"]),\n  /**\n   * The content of the component.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   */\n  color: a.oneOfType([a.oneOf([\"primary\", \"secondary\", \"success\", \"error\", \"info\", \"warning\", \"textPrimary\", \"textSecondary\", \"textDisabled\"]), a.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * If `true`, the text will have a bottom margin.\n   * @default false\n   */\n  gutterBottom: a.bool,\n  /**\n   * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.\n   *\n   * Note that text overflow can only happen with block or inline-block level elements\n   * (the element needs to have a width in order to overflow).\n   * @default false\n   */\n  noWrap: a.bool,\n  /**\n   * If `true`, the element will be a paragraph element.\n   * @default false\n   * @deprecated Use the `component` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  paragraph: a.bool,\n  /**\n   * @ignore\n   */\n  style: a.object,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * Applies the theme typography styles.\n   * @default 'body1'\n   */\n  variant: a.oneOfType([a.oneOf([\"body1\", \"body2\", \"button\", \"caption\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"inherit\", \"overline\", \"subtitle1\", \"subtitle2\"]), a.string]),\n  /**\n   * The component maps the variant prop to a range of different HTML element types.\n   * For instance, subtitle1 to `<h6>`.\n   * If you wish to change that mapping, you can provide your own.\n   * Alternatively, you can use the `component` prop.\n   * @default {\n   *   h1: 'h1',\n   *   h2: 'h2',\n   *   h3: 'h3',\n   *   h4: 'h4',\n   *   h5: 'h5',\n   *   h6: 'h6',\n   *   subtitle1: 'h6',\n   *   subtitle2: 'h6',\n   *   body1: 'p',\n   *   body2: 'p',\n   *   inherit: 'p',\n   * }\n   */\n  variantMapping: a.object\n});\nvar Ke = \"top\", st = \"bottom\", ct = \"right\", Xe = \"left\", qo = \"auto\", Br = [Ke, st, ct, Xe], er = \"start\", Pr = \"end\", Dd = \"clippingParents\", Ts = \"viewport\", pr = \"popper\", Ld = \"reference\", la = /* @__PURE__ */ Br.reduce(function(e, t) {\n  return e.concat([t + \"-\" + er, t + \"-\" + Pr]);\n}, []), ws = /* @__PURE__ */ [].concat(Br, [qo]).reduce(function(e, t) {\n  return e.concat([t, t + \"-\" + er, t + \"-\" + Pr]);\n}, []), Bd = \"beforeRead\", Vd = \"read\", Fd = \"afterRead\", zd = \"beforeMain\", Wd = \"main\", Ud = \"afterMain\", Yd = \"beforeWrite\", Hd = \"write\", qd = \"afterWrite\", Gd = [Bd, Vd, Fd, zd, Wd, Ud, Yd, Hd, qd];\nfunction St(e) {\n  return e ? (e.nodeName || \"\").toLowerCase() : null;\n}\nfunction rt(e) {\n  if (e == null)\n    return window;\n  if (e.toString() !== \"[object Window]\") {\n    var t = e.ownerDocument;\n    return t && t.defaultView || window;\n  }\n  return e;\n}\nfunction zt(e) {\n  var t = rt(e).Element;\n  return e instanceof t || e instanceof Element;\n}\nfunction it(e) {\n  var t = rt(e).HTMLElement;\n  return e instanceof t || e instanceof HTMLElement;\n}\nfunction Go(e) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var t = rt(e).ShadowRoot;\n  return e instanceof t || e instanceof ShadowRoot;\n}\nfunction Kd(e) {\n  var t = e.state;\n  Object.keys(t.elements).forEach(function(r) {\n    var n = t.styles[r] || {}, o = t.attributes[r] || {}, i = t.elements[r];\n    !it(i) || !St(i) || (Object.assign(i.style, n), Object.keys(o).forEach(function(s) {\n      var c = o[s];\n      c === !1 ? i.removeAttribute(s) : i.setAttribute(s, c === !0 ? \"\" : c);\n    }));\n  });\n}\nfunction Xd(e) {\n  var t = e.state, r = {\n    popper: {\n      position: t.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow), function() {\n    Object.keys(t.elements).forEach(function(n) {\n      var o = t.elements[n], i = t.attributes[n] || {}, s = Object.keys(t.styles.hasOwnProperty(n) ? t.styles[n] : r[n]), c = s.reduce(function(l, u) {\n        return l[u] = \"\", l;\n      }, {});\n      !it(o) || !St(o) || (Object.assign(o.style, c), Object.keys(i).forEach(function(l) {\n        o.removeAttribute(l);\n      }));\n    });\n  };\n}\nconst Jd = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: Kd,\n  effect: Xd,\n  requires: [\"computeStyles\"]\n};\nfunction xt(e) {\n  return e.split(\"-\")[0];\n}\nvar Vt = Math.max, En = Math.min, tr = Math.round;\nfunction bo() {\n  var e = navigator.userAgentData;\n  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {\n    return t.brand + \"/\" + t.version;\n  }).join(\" \") : navigator.userAgent;\n}\nfunction Os() {\n  return !/^((?!chrome|android).)*safari/i.test(bo());\n}\nfunction rr(e, t, r) {\n  t === void 0 && (t = !1), r === void 0 && (r = !1);\n  var n = e.getBoundingClientRect(), o = 1, i = 1;\n  t && it(e) && (o = e.offsetWidth > 0 && tr(n.width) / e.offsetWidth || 1, i = e.offsetHeight > 0 && tr(n.height) / e.offsetHeight || 1);\n  var s = zt(e) ? rt(e) : window, c = s.visualViewport, l = !Os() && r, u = (n.left + (l && c ? c.offsetLeft : 0)) / o, p = (n.top + (l && c ? c.offsetTop : 0)) / i, m = n.width / o, g = n.height / i;\n  return {\n    width: m,\n    height: g,\n    top: p,\n    right: u + m,\n    bottom: p + g,\n    left: u,\n    x: u,\n    y: p\n  };\n}\nfunction Ko(e) {\n  var t = rr(e), r = e.offsetWidth, n = e.offsetHeight;\n  return Math.abs(t.width - r) <= 1 && (r = t.width), Math.abs(t.height - n) <= 1 && (n = t.height), {\n    x: e.offsetLeft,\n    y: e.offsetTop,\n    width: r,\n    height: n\n  };\n}\nfunction Rs(e, t) {\n  var r = t.getRootNode && t.getRootNode();\n  if (e.contains(t))\n    return !0;\n  if (r && Go(r)) {\n    var n = t;\n    do {\n      if (n && e.isSameNode(n))\n        return !0;\n      n = n.parentNode || n.host;\n    } while (n);\n  }\n  return !1;\n}\nfunction Rt(e) {\n  return rt(e).getComputedStyle(e);\n}\nfunction Qd(e) {\n  return [\"table\", \"td\", \"th\"].indexOf(St(e)) >= 0;\n}\nfunction It(e) {\n  return ((zt(e) ? e.ownerDocument : (\n    // $FlowFixMe[prop-missing]\n    e.document\n  )) || window.document).documentElement;\n}\nfunction zn(e) {\n  return St(e) === \"html\" ? e : (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    e.parentNode || // DOM Element detected\n    (Go(e) ? e.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    It(e)\n  );\n}\nfunction ua(e) {\n  return !it(e) || // https://github.com/popperjs/popper-core/issues/837\n  Rt(e).position === \"fixed\" ? null : e.offsetParent;\n}\nfunction Zd(e) {\n  var t = /firefox/i.test(bo()), r = /Trident/i.test(bo());\n  if (r && it(e)) {\n    var n = Rt(e);\n    if (n.position === \"fixed\")\n      return null;\n  }\n  var o = zn(e);\n  for (Go(o) && (o = o.host); it(o) && [\"html\", \"body\"].indexOf(St(o)) < 0; ) {\n    var i = Rt(o);\n    if (i.transform !== \"none\" || i.perspective !== \"none\" || i.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(i.willChange) !== -1 || t && i.willChange === \"filter\" || t && i.filter && i.filter !== \"none\")\n      return o;\n    o = o.parentNode;\n  }\n  return null;\n}\nfunction Vr(e) {\n  for (var t = rt(e), r = ua(e); r && Qd(r) && Rt(r).position === \"static\"; )\n    r = ua(r);\n  return r && (St(r) === \"html\" || St(r) === \"body\" && Rt(r).position === \"static\") ? t : r || Zd(e) || t;\n}\nfunction Xo(e) {\n  return [\"top\", \"bottom\"].indexOf(e) >= 0 ? \"x\" : \"y\";\n}\nfunction xr(e, t, r) {\n  return Vt(e, En(t, r));\n}\nfunction ep(e, t, r) {\n  var n = xr(e, t, r);\n  return n > r ? r : n;\n}\nfunction $s() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction Ps(e) {\n  return Object.assign({}, $s(), e);\n}\nfunction ks(e, t) {\n  return t.reduce(function(r, n) {\n    return r[n] = e, r;\n  }, {});\n}\nvar tp = function(t, r) {\n  return t = typeof t == \"function\" ? t(Object.assign({}, r.rects, {\n    placement: r.placement\n  })) : t, Ps(typeof t != \"number\" ? t : ks(t, Br));\n};\nfunction rp(e) {\n  var t, r = e.state, n = e.name, o = e.options, i = r.elements.arrow, s = r.modifiersData.popperOffsets, c = xt(r.placement), l = Xo(c), u = [Xe, ct].indexOf(c) >= 0, p = u ? \"height\" : \"width\";\n  if (!(!i || !s)) {\n    var m = tp(o.padding, r), g = Ko(i), x = l === \"y\" ? Ke : Xe, y = l === \"y\" ? st : ct, f = r.rects.reference[p] + r.rects.reference[l] - s[l] - r.rects.popper[p], S = s[l] - r.rects.reference[l], E = Vr(i), P = E ? l === \"y\" ? E.clientHeight || 0 : E.clientWidth || 0 : 0, T = f / 2 - S / 2, b = m[x], h = P - g[p] - m[y], w = P / 2 - g[p] / 2 + T, k = xr(b, w, h), L = l;\n    r.modifiersData[n] = (t = {}, t[L] = k, t.centerOffset = k - w, t);\n  }\n}\nfunction np(e) {\n  var t = e.state, r = e.options, n = r.element, o = n === void 0 ? \"[data-popper-arrow]\" : n;\n  o != null && (typeof o == \"string\" && (o = t.elements.popper.querySelector(o), !o) || Rs(t.elements.popper, o) && (t.elements.arrow = o));\n}\nconst op = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: rp,\n  effect: np,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction nr(e) {\n  return e.split(\"-\")[1];\n}\nvar ip = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction ap(e, t) {\n  var r = e.x, n = e.y, o = t.devicePixelRatio || 1;\n  return {\n    x: tr(r * o) / o || 0,\n    y: tr(n * o) / o || 0\n  };\n}\nfunction fa(e) {\n  var t, r = e.popper, n = e.popperRect, o = e.placement, i = e.variation, s = e.offsets, c = e.position, l = e.gpuAcceleration, u = e.adaptive, p = e.roundOffsets, m = e.isFixed, g = s.x, x = g === void 0 ? 0 : g, y = s.y, f = y === void 0 ? 0 : y, S = typeof p == \"function\" ? p({\n    x,\n    y: f\n  }) : {\n    x,\n    y: f\n  };\n  x = S.x, f = S.y;\n  var E = s.hasOwnProperty(\"x\"), P = s.hasOwnProperty(\"y\"), T = Xe, b = Ke, h = window;\n  if (u) {\n    var w = Vr(r), k = \"clientHeight\", L = \"clientWidth\";\n    if (w === rt(r) && (w = It(r), Rt(w).position !== \"static\" && c === \"absolute\" && (k = \"scrollHeight\", L = \"scrollWidth\")), w = w, o === Ke || (o === Xe || o === ct) && i === Pr) {\n      b = st;\n      var B = m && w === h && h.visualViewport ? h.visualViewport.height : (\n        // $FlowFixMe[prop-missing]\n        w[k]\n      );\n      f -= B - n.height, f *= l ? 1 : -1;\n    }\n    if (o === Xe || (o === Ke || o === st) && i === Pr) {\n      T = ct;\n      var d = m && w === h && h.visualViewport ? h.visualViewport.width : (\n        // $FlowFixMe[prop-missing]\n        w[L]\n      );\n      x -= d - n.width, x *= l ? 1 : -1;\n    }\n  }\n  var A = Object.assign({\n    position: c\n  }, u && ip), D = p === !0 ? ap({\n    x,\n    y: f\n  }, rt(r)) : {\n    x,\n    y: f\n  };\n  if (x = D.x, f = D.y, l) {\n    var j;\n    return Object.assign({}, A, (j = {}, j[b] = P ? \"0\" : \"\", j[T] = E ? \"0\" : \"\", j.transform = (h.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + f + \"px)\" : \"translate3d(\" + x + \"px, \" + f + \"px, 0)\", j));\n  }\n  return Object.assign({}, A, (t = {}, t[b] = P ? f + \"px\" : \"\", t[T] = E ? x + \"px\" : \"\", t.transform = \"\", t));\n}\nfunction sp(e) {\n  var t = e.state, r = e.options, n = r.gpuAcceleration, o = n === void 0 ? !0 : n, i = r.adaptive, s = i === void 0 ? !0 : i, c = r.roundOffsets, l = c === void 0 ? !0 : c, u = {\n    placement: xt(t.placement),\n    variation: nr(t.placement),\n    popper: t.elements.popper,\n    popperRect: t.rects.popper,\n    gpuAcceleration: o,\n    isFixed: t.options.strategy === \"fixed\"\n  };\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, fa(Object.assign({}, u, {\n    offsets: t.modifiersData.popperOffsets,\n    position: t.options.strategy,\n    adaptive: s,\n    roundOffsets: l\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, fa(Object.assign({}, u, {\n    offsets: t.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets: l\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-placement\": t.placement\n  });\n}\nconst cp = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: sp,\n  data: {}\n};\nvar Zr = {\n  passive: !0\n};\nfunction lp(e) {\n  var t = e.state, r = e.instance, n = e.options, o = n.scroll, i = o === void 0 ? !0 : o, s = n.resize, c = s === void 0 ? !0 : s, l = rt(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n  return i && u.forEach(function(p) {\n    p.addEventListener(\"scroll\", r.update, Zr);\n  }), c && l.addEventListener(\"resize\", r.update, Zr), function() {\n    i && u.forEach(function(p) {\n      p.removeEventListener(\"scroll\", r.update, Zr);\n    }), c && l.removeEventListener(\"resize\", r.update, Zr);\n  };\n}\nconst up = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect: lp,\n  data: {}\n};\nvar fp = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction un(e) {\n  return e.replace(/left|right|bottom|top/g, function(t) {\n    return fp[t];\n  });\n}\nvar dp = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction da(e) {\n  return e.replace(/start|end/g, function(t) {\n    return dp[t];\n  });\n}\nfunction Jo(e) {\n  var t = rt(e), r = t.pageXOffset, n = t.pageYOffset;\n  return {\n    scrollLeft: r,\n    scrollTop: n\n  };\n}\nfunction Qo(e) {\n  return rr(It(e)).left + Jo(e).scrollLeft;\n}\nfunction pp(e, t) {\n  var r = rt(e), n = It(e), o = r.visualViewport, i = n.clientWidth, s = n.clientHeight, c = 0, l = 0;\n  if (o) {\n    i = o.width, s = o.height;\n    var u = Os();\n    (u || !u && t === \"fixed\") && (c = o.offsetLeft, l = o.offsetTop);\n  }\n  return {\n    width: i,\n    height: s,\n    x: c + Qo(e),\n    y: l\n  };\n}\nfunction mp(e) {\n  var t, r = It(e), n = Jo(e), o = (t = e.ownerDocument) == null ? void 0 : t.body, i = Vt(r.scrollWidth, r.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), s = Vt(r.scrollHeight, r.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), c = -n.scrollLeft + Qo(e), l = -n.scrollTop;\n  return Rt(o || r).direction === \"rtl\" && (c += Vt(r.clientWidth, o ? o.clientWidth : 0) - i), {\n    width: i,\n    height: s,\n    x: c,\n    y: l\n  };\n}\nfunction Zo(e) {\n  var t = Rt(e), r = t.overflow, n = t.overflowX, o = t.overflowY;\n  return /auto|scroll|overlay|hidden/.test(r + o + n);\n}\nfunction As(e) {\n  return [\"html\", \"body\", \"#document\"].indexOf(St(e)) >= 0 ? e.ownerDocument.body : it(e) && Zo(e) ? e : As(zn(e));\n}\nfunction Sr(e, t) {\n  var r;\n  t === void 0 && (t = []);\n  var n = As(e), o = n === ((r = e.ownerDocument) == null ? void 0 : r.body), i = rt(n), s = o ? [i].concat(i.visualViewport || [], Zo(n) ? n : []) : n, c = t.concat(s);\n  return o ? c : (\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    c.concat(Sr(zn(s)))\n  );\n}\nfunction vo(e) {\n  return Object.assign({}, e, {\n    left: e.x,\n    top: e.y,\n    right: e.x + e.width,\n    bottom: e.y + e.height\n  });\n}\nfunction hp(e, t) {\n  var r = rr(e, !1, t === \"fixed\");\n  return r.top = r.top + e.clientTop, r.left = r.left + e.clientLeft, r.bottom = r.top + e.clientHeight, r.right = r.left + e.clientWidth, r.width = e.clientWidth, r.height = e.clientHeight, r.x = r.left, r.y = r.top, r;\n}\nfunction pa(e, t, r) {\n  return t === Ts ? vo(pp(e, r)) : zt(t) ? hp(t, r) : vo(mp(It(e)));\n}\nfunction gp(e) {\n  var t = Sr(zn(e)), r = [\"absolute\", \"fixed\"].indexOf(Rt(e).position) >= 0, n = r && it(e) ? Vr(e) : e;\n  return zt(n) ? t.filter(function(o) {\n    return zt(o) && Rs(o, n) && St(o) !== \"body\";\n  }) : [];\n}\nfunction yp(e, t, r, n) {\n  var o = t === \"clippingParents\" ? gp(e) : [].concat(t), i = [].concat(o, [r]), s = i[0], c = i.reduce(function(l, u) {\n    var p = pa(e, u, n);\n    return l.top = Vt(p.top, l.top), l.right = En(p.right, l.right), l.bottom = En(p.bottom, l.bottom), l.left = Vt(p.left, l.left), l;\n  }, pa(e, s, n));\n  return c.width = c.right - c.left, c.height = c.bottom - c.top, c.x = c.left, c.y = c.top, c;\n}\nfunction Ns(e) {\n  var t = e.reference, r = e.element, n = e.placement, o = n ? xt(n) : null, i = n ? nr(n) : null, s = t.x + t.width / 2 - r.width / 2, c = t.y + t.height / 2 - r.height / 2, l;\n  switch (o) {\n    case Ke:\n      l = {\n        x: s,\n        y: t.y - r.height\n      };\n      break;\n    case st:\n      l = {\n        x: s,\n        y: t.y + t.height\n      };\n      break;\n    case ct:\n      l = {\n        x: t.x + t.width,\n        y: c\n      };\n      break;\n    case Xe:\n      l = {\n        x: t.x - r.width,\n        y: c\n      };\n      break;\n    default:\n      l = {\n        x: t.x,\n        y: t.y\n      };\n  }\n  var u = o ? Xo(o) : null;\n  if (u != null) {\n    var p = u === \"y\" ? \"height\" : \"width\";\n    switch (i) {\n      case er:\n        l[u] = l[u] - (t[p] / 2 - r[p] / 2);\n        break;\n      case Pr:\n        l[u] = l[u] + (t[p] / 2 - r[p] / 2);\n        break;\n    }\n  }\n  return l;\n}\nfunction kr(e, t) {\n  t === void 0 && (t = {});\n  var r = t, n = r.placement, o = n === void 0 ? e.placement : n, i = r.strategy, s = i === void 0 ? e.strategy : i, c = r.boundary, l = c === void 0 ? Dd : c, u = r.rootBoundary, p = u === void 0 ? Ts : u, m = r.elementContext, g = m === void 0 ? pr : m, x = r.altBoundary, y = x === void 0 ? !1 : x, f = r.padding, S = f === void 0 ? 0 : f, E = Ps(typeof S != \"number\" ? S : ks(S, Br)), P = g === pr ? Ld : pr, T = e.rects.popper, b = e.elements[y ? P : g], h = yp(zt(b) ? b : b.contextElement || It(e.elements.popper), l, p, s), w = rr(e.elements.reference), k = Ns({\n    reference: w,\n    element: T,\n    strategy: \"absolute\",\n    placement: o\n  }), L = vo(Object.assign({}, T, k)), B = g === pr ? L : w, d = {\n    top: h.top - B.top + E.top,\n    bottom: B.bottom - h.bottom + E.bottom,\n    left: h.left - B.left + E.left,\n    right: B.right - h.right + E.right\n  }, A = e.modifiersData.offset;\n  if (g === pr && A) {\n    var D = A[o];\n    Object.keys(d).forEach(function(j) {\n      var W = [ct, st].indexOf(j) >= 0 ? 1 : -1, z = [Ke, st].indexOf(j) >= 0 ? \"y\" : \"x\";\n      d[j] += D[z] * W;\n    });\n  }\n  return d;\n}\nfunction bp(e, t) {\n  t === void 0 && (t = {});\n  var r = t, n = r.placement, o = r.boundary, i = r.rootBoundary, s = r.padding, c = r.flipVariations, l = r.allowedAutoPlacements, u = l === void 0 ? ws : l, p = nr(n), m = p ? c ? la : la.filter(function(y) {\n    return nr(y) === p;\n  }) : Br, g = m.filter(function(y) {\n    return u.indexOf(y) >= 0;\n  });\n  g.length === 0 && (g = m);\n  var x = g.reduce(function(y, f) {\n    return y[f] = kr(e, {\n      placement: f,\n      boundary: o,\n      rootBoundary: i,\n      padding: s\n    })[xt(f)], y;\n  }, {});\n  return Object.keys(x).sort(function(y, f) {\n    return x[y] - x[f];\n  });\n}\nfunction vp(e) {\n  if (xt(e) === qo)\n    return [];\n  var t = un(e);\n  return [da(e), t, da(t)];\n}\nfunction xp(e) {\n  var t = e.state, r = e.options, n = e.name;\n  if (!t.modifiersData[n]._skip) {\n    for (var o = r.mainAxis, i = o === void 0 ? !0 : o, s = r.altAxis, c = s === void 0 ? !0 : s, l = r.fallbackPlacements, u = r.padding, p = r.boundary, m = r.rootBoundary, g = r.altBoundary, x = r.flipVariations, y = x === void 0 ? !0 : x, f = r.allowedAutoPlacements, S = t.options.placement, E = xt(S), P = E === S, T = l || (P || !y ? [un(S)] : vp(S)), b = [S].concat(T).reduce(function(H, X) {\n      return H.concat(xt(X) === qo ? bp(t, {\n        placement: X,\n        boundary: p,\n        rootBoundary: m,\n        padding: u,\n        flipVariations: y,\n        allowedAutoPlacements: f\n      }) : X);\n    }, []), h = t.rects.reference, w = t.rects.popper, k = /* @__PURE__ */ new Map(), L = !0, B = b[0], d = 0; d < b.length; d++) {\n      var A = b[d], D = xt(A), j = nr(A) === er, W = [Ke, st].indexOf(D) >= 0, z = W ? \"width\" : \"height\", U = kr(t, {\n        placement: A,\n        boundary: p,\n        rootBoundary: m,\n        altBoundary: g,\n        padding: u\n      }), V = W ? j ? ct : Xe : j ? st : Ke;\n      h[z] > w[z] && (V = un(V));\n      var te = un(V), F = [];\n      if (i && F.push(U[D] <= 0), c && F.push(U[V] <= 0, U[te] <= 0), F.every(function(H) {\n        return H;\n      })) {\n        B = A, L = !1;\n        break;\n      }\n      k.set(A, F);\n    }\n    if (L)\n      for (var R = y ? 3 : 1, I = function(X) {\n        var _ = b.find(function(q) {\n          var G = k.get(q);\n          if (G)\n            return G.slice(0, X).every(function(re) {\n              return re;\n            });\n        });\n        if (_)\n          return B = _, \"break\";\n      }, J = R; J > 0; J--) {\n        var Q = I(J);\n        if (Q === \"break\") break;\n      }\n    t.placement !== B && (t.modifiersData[n]._skip = !0, t.placement = B, t.reset = !0);\n  }\n}\nconst Sp = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: xp,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\nfunction ma(e, t, r) {\n  return r === void 0 && (r = {\n    x: 0,\n    y: 0\n  }), {\n    top: e.top - t.height - r.y,\n    right: e.right - t.width + r.x,\n    bottom: e.bottom - t.height + r.y,\n    left: e.left - t.width - r.x\n  };\n}\nfunction ha(e) {\n  return [Ke, ct, st, Xe].some(function(t) {\n    return e[t] >= 0;\n  });\n}\nfunction Ep(e) {\n  var t = e.state, r = e.name, n = t.rects.reference, o = t.rects.popper, i = t.modifiersData.preventOverflow, s = kr(t, {\n    elementContext: \"reference\"\n  }), c = kr(t, {\n    altBoundary: !0\n  }), l = ma(s, n), u = ma(c, o, i), p = ha(l), m = ha(u);\n  t.modifiersData[r] = {\n    referenceClippingOffsets: l,\n    popperEscapeOffsets: u,\n    isReferenceHidden: p,\n    hasPopperEscaped: m\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-reference-hidden\": p,\n    \"data-popper-escaped\": m\n  });\n}\nconst Cp = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: Ep\n};\nfunction Tp(e, t, r) {\n  var n = xt(e), o = [Xe, Ke].indexOf(n) >= 0 ? -1 : 1, i = typeof r == \"function\" ? r(Object.assign({}, t, {\n    placement: e\n  })) : r, s = i[0], c = i[1];\n  return s = s || 0, c = (c || 0) * o, [Xe, ct].indexOf(n) >= 0 ? {\n    x: c,\n    y: s\n  } : {\n    x: s,\n    y: c\n  };\n}\nfunction wp(e) {\n  var t = e.state, r = e.options, n = e.name, o = r.offset, i = o === void 0 ? [0, 0] : o, s = ws.reduce(function(p, m) {\n    return p[m] = Tp(m, t.rects, i), p;\n  }, {}), c = s[t.placement], l = c.x, u = c.y;\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += u), t.modifiersData[n] = s;\n}\nconst Op = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: wp\n};\nfunction Rp(e) {\n  var t = e.state, r = e.name;\n  t.modifiersData[r] = Ns({\n    reference: t.rects.reference,\n    element: t.rects.popper,\n    strategy: \"absolute\",\n    placement: t.placement\n  });\n}\nconst $p = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: Rp,\n  data: {}\n};\nfunction Pp(e) {\n  return e === \"x\" ? \"y\" : \"x\";\n}\nfunction kp(e) {\n  var t = e.state, r = e.options, n = e.name, o = r.mainAxis, i = o === void 0 ? !0 : o, s = r.altAxis, c = s === void 0 ? !1 : s, l = r.boundary, u = r.rootBoundary, p = r.altBoundary, m = r.padding, g = r.tether, x = g === void 0 ? !0 : g, y = r.tetherOffset, f = y === void 0 ? 0 : y, S = kr(t, {\n    boundary: l,\n    rootBoundary: u,\n    padding: m,\n    altBoundary: p\n  }), E = xt(t.placement), P = nr(t.placement), T = !P, b = Xo(E), h = Pp(b), w = t.modifiersData.popperOffsets, k = t.rects.reference, L = t.rects.popper, B = typeof f == \"function\" ? f(Object.assign({}, t.rects, {\n    placement: t.placement\n  })) : f, d = typeof B == \"number\" ? {\n    mainAxis: B,\n    altAxis: B\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, B), A = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, D = {\n    x: 0,\n    y: 0\n  };\n  if (w) {\n    if (i) {\n      var j, W = b === \"y\" ? Ke : Xe, z = b === \"y\" ? st : ct, U = b === \"y\" ? \"height\" : \"width\", V = w[b], te = V + S[W], F = V - S[z], R = x ? -L[U] / 2 : 0, I = P === er ? k[U] : L[U], J = P === er ? -L[U] : -k[U], Q = t.elements.arrow, H = x && Q ? Ko(Q) : {\n        width: 0,\n        height: 0\n      }, X = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : $s(), _ = X[W], q = X[z], G = xr(0, k[U], H[U]), re = T ? k[U] / 2 - R - G - _ - d.mainAxis : I - G - _ - d.mainAxis, Z = T ? -k[U] / 2 + R + G + q + d.mainAxis : J + G + q + d.mainAxis, ae = t.elements.arrow && Vr(t.elements.arrow), O = ae ? b === \"y\" ? ae.clientTop || 0 : ae.clientLeft || 0 : 0, ye = (j = A == null ? void 0 : A[b]) != null ? j : 0, Ee = V + re - ye - O, Me = V + Z - ye, Qe = xr(x ? En(te, Ee) : te, V, x ? Vt(F, Me) : F);\n      w[b] = Qe, D[b] = Qe - V;\n    }\n    if (c) {\n      var ve, Pe = b === \"x\" ? Ke : Xe, ze = b === \"x\" ? st : ct, Le = w[h], v = h === \"y\" ? \"height\" : \"width\", M = Le + S[Pe], Y = Le - S[ze], oe = [Ke, Xe].indexOf(E) !== -1, Re = (ve = A == null ? void 0 : A[h]) != null ? ve : 0, ue = oe ? M : Le - k[v] - L[v] - Re + d.altAxis, K = oe ? Le + k[v] + L[v] - Re - d.altAxis : Y, be = x && oe ? ep(ue, Le, K) : xr(x ? ue : M, Le, x ? K : Y);\n      w[h] = be, D[h] = be - Le;\n    }\n    t.modifiersData[n] = D;\n  }\n}\nconst Ap = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: kp,\n  requiresIfExists: [\"offset\"]\n};\nfunction Np(e) {\n  return {\n    scrollLeft: e.scrollLeft,\n    scrollTop: e.scrollTop\n  };\n}\nfunction Mp(e) {\n  return e === rt(e) || !it(e) ? Jo(e) : Np(e);\n}\nfunction Ip(e) {\n  var t = e.getBoundingClientRect(), r = tr(t.width) / e.offsetWidth || 1, n = tr(t.height) / e.offsetHeight || 1;\n  return r !== 1 || n !== 1;\n}\nfunction _p(e, t, r) {\n  r === void 0 && (r = !1);\n  var n = it(t), o = it(t) && Ip(t), i = It(t), s = rr(e, o, r), c = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, l = {\n    x: 0,\n    y: 0\n  };\n  return (n || !n && !r) && ((St(t) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n  Zo(i)) && (c = Mp(t)), it(t) ? (l = rr(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : i && (l.x = Qo(i))), {\n    x: s.left + c.scrollLeft - l.x,\n    y: s.top + c.scrollTop - l.y,\n    width: s.width,\n    height: s.height\n  };\n}\nfunction jp(e) {\n  var t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), n = [];\n  e.forEach(function(i) {\n    t.set(i.name, i);\n  });\n  function o(i) {\n    r.add(i.name);\n    var s = [].concat(i.requires || [], i.requiresIfExists || []);\n    s.forEach(function(c) {\n      if (!r.has(c)) {\n        var l = t.get(c);\n        l && o(l);\n      }\n    }), n.push(i);\n  }\n  return e.forEach(function(i) {\n    r.has(i.name) || o(i);\n  }), n;\n}\nfunction Dp(e) {\n  var t = jp(e);\n  return Gd.reduce(function(r, n) {\n    return r.concat(t.filter(function(o) {\n      return o.phase === n;\n    }));\n  }, []);\n}\nfunction Lp(e) {\n  var t;\n  return function() {\n    return t || (t = new Promise(function(r) {\n      Promise.resolve().then(function() {\n        t = void 0, r(e());\n      });\n    })), t;\n  };\n}\nfunction Bp(e) {\n  var t = e.reduce(function(r, n) {\n    var o = r[n.name];\n    return r[n.name] = o ? Object.assign({}, o, n, {\n      options: Object.assign({}, o.options, n.options),\n      data: Object.assign({}, o.data, n.data)\n    }) : n, r;\n  }, {});\n  return Object.keys(t).map(function(r) {\n    return t[r];\n  });\n}\nvar ga = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction ya() {\n  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)\n    t[r] = arguments[r];\n  return !t.some(function(n) {\n    return !(n && typeof n.getBoundingClientRect == \"function\");\n  });\n}\nfunction Vp(e) {\n  e === void 0 && (e = {});\n  var t = e, r = t.defaultModifiers, n = r === void 0 ? [] : r, o = t.defaultOptions, i = o === void 0 ? ga : o;\n  return function(c, l, u) {\n    u === void 0 && (u = i);\n    var p = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, ga, i),\n      modifiersData: {},\n      elements: {\n        reference: c,\n        popper: l\n      },\n      attributes: {},\n      styles: {}\n    }, m = [], g = !1, x = {\n      state: p,\n      setOptions: function(E) {\n        var P = typeof E == \"function\" ? E(p.options) : E;\n        f(), p.options = Object.assign({}, i, p.options, P), p.scrollParents = {\n          reference: zt(c) ? Sr(c) : c.contextElement ? Sr(c.contextElement) : [],\n          popper: Sr(l)\n        };\n        var T = Dp(Bp([].concat(n, p.options.modifiers)));\n        return p.orderedModifiers = T.filter(function(b) {\n          return b.enabled;\n        }), y(), x.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function() {\n        if (!g) {\n          var E = p.elements, P = E.reference, T = E.popper;\n          if (ya(P, T)) {\n            p.rects = {\n              reference: _p(P, Vr(T), p.options.strategy === \"fixed\"),\n              popper: Ko(T)\n            }, p.reset = !1, p.placement = p.options.placement, p.orderedModifiers.forEach(function(d) {\n              return p.modifiersData[d.name] = Object.assign({}, d.data);\n            });\n            for (var b = 0; b < p.orderedModifiers.length; b++) {\n              if (p.reset === !0) {\n                p.reset = !1, b = -1;\n                continue;\n              }\n              var h = p.orderedModifiers[b], w = h.fn, k = h.options, L = k === void 0 ? {} : k, B = h.name;\n              typeof w == \"function\" && (p = w({\n                state: p,\n                options: L,\n                name: B,\n                instance: x\n              }) || p);\n            }\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: Lp(function() {\n        return new Promise(function(S) {\n          x.forceUpdate(), S(p);\n        });\n      }),\n      destroy: function() {\n        f(), g = !0;\n      }\n    };\n    if (!ya(c, l))\n      return x;\n    x.setOptions(u).then(function(S) {\n      !g && u.onFirstUpdate && u.onFirstUpdate(S);\n    });\n    function y() {\n      p.orderedModifiers.forEach(function(S) {\n        var E = S.name, P = S.options, T = P === void 0 ? {} : P, b = S.effect;\n        if (typeof b == \"function\") {\n          var h = b({\n            state: p,\n            name: E,\n            instance: x,\n            options: T\n          }), w = function() {\n          };\n          m.push(h || w);\n        }\n      });\n    }\n    function f() {\n      m.forEach(function(S) {\n        return S();\n      }), m = [];\n    }\n    return x;\n  };\n}\nvar Fp = [up, $p, cp, Jd, Op, Sp, Ap, op, Cp], zp = /* @__PURE__ */ Vp({\n  defaultModifiers: Fp\n});\nfunction Wp(e) {\n  return typeof e == \"function\" ? e() : e;\n}\nconst Cn = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const {\n    children: n,\n    container: o,\n    disablePortal: i = !1\n  } = t, [s, c] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), l = at(/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(n) ? Bo(n) : null, r);\n  if (Ft(() => {\n    i || c(Wp(o) || document.body);\n  }, [o, i]), Ft(() => {\n    if (s && !i)\n      return uo(r, s), () => {\n        uo(r, null);\n      };\n  }, [r, s, i]), i) {\n    if (/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(n)) {\n      const u = {\n        ref: l\n      };\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(n, u);\n    }\n    return n;\n  }\n  return s && /* @__PURE__ */ react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(n, s);\n});\n true && (Cn.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //  To update them, edit the TypeScript types and run `pnpm proptypes`. \n  // \n  /**\n   * The children to render into the `container`.\n   */\n  children: a.node,\n  /**\n   * An HTML element or function that returns one.\n   * The `container` will have the portal children appended to it.\n   *\n   * You can also provide a callback, which is called in a React layout effect.\n   * This lets you set the container from a ref, and also makes server-side rendering possible.\n   *\n   * By default, it uses the body of the top-level document object,\n   * so it's simply `document.body` most of the time.\n   */\n  container: a.oneOfType([Or, a.func]),\n  /**\n   * The `children` will be under the DOM hierarchy of the parent component.\n   * @default false\n   */\n  disablePortal: a.bool\n});\n true && (Cn.propTypes = Do(Cn.propTypes));\nfunction Up(e) {\n  return Ve(\"MuiPopper\", e);\n}\nFe(\"MuiPopper\", [\"root\"]);\nfunction Yp(e, t) {\n  if (t === \"ltr\")\n    return e;\n  switch (e) {\n    case \"bottom-end\":\n      return \"bottom-start\";\n    case \"bottom-start\":\n      return \"bottom-end\";\n    case \"top-end\":\n      return \"top-start\";\n    case \"top-start\":\n      return \"top-end\";\n    default:\n      return e;\n  }\n}\nfunction Tn(e) {\n  return typeof e == \"function\" ? e() : e;\n}\nfunction Wn(e) {\n  return e.nodeType !== void 0;\n}\nfunction Hp(e) {\n  return !Wn(e);\n}\nconst qp = (e) => {\n  const {\n    classes: t\n  } = e;\n  return Ge({\n    root: [\"root\"]\n  }, Up, t);\n}, Gp = {}, Kp = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const {\n    anchorEl: n,\n    children: o,\n    direction: i,\n    disablePortal: s,\n    modifiers: c,\n    open: l,\n    placement: u,\n    popperOptions: p,\n    popperRef: m,\n    slotProps: g = {},\n    slots: x = {},\n    TransitionProps: y,\n    // @ts-ignore internal logic\n    ownerState: f,\n    // prevent from spreading to DOM, it can come from the parent component e.g. Select.\n    ...S\n  } = t, E = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), P = at(E, r), T = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), b = at(T, m), h = react__WEBPACK_IMPORTED_MODULE_0__.useRef(b);\n  Ft(() => {\n    h.current = b;\n  }, [b]), react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(m, () => T.current, []);\n  const w = Yp(u, i), [k, L] = react__WEBPACK_IMPORTED_MODULE_0__.useState(w), [B, d] = react__WEBPACK_IMPORTED_MODULE_0__.useState(Tn(n));\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    T.current && T.current.forceUpdate();\n  }), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    n && d(Tn(n));\n  }, [n]), Ft(() => {\n    if (!B || !l)\n      return;\n    const z = (te) => {\n      L(te.placement);\n    };\n    if ( true && B && Wn(B) && B.nodeType === 1) {\n      const te = B.getBoundingClientRect();\n       true && te.top === 0 && te.left === 0 && te.right === 0 && te.bottom === 0 && console.warn([\"MUI: The `anchorEl` prop provided to the component is invalid.\", \"The anchor element should be part of the document layout.\", \"Make sure the element is present in the document or that it's not display none.\"].join(`\n`));\n    }\n    let U = [{\n      name: \"preventOverflow\",\n      options: {\n        altBoundary: s\n      }\n    }, {\n      name: \"flip\",\n      options: {\n        altBoundary: s\n      }\n    }, {\n      name: \"onUpdate\",\n      enabled: !0,\n      phase: \"afterWrite\",\n      fn: ({\n        state: te\n      }) => {\n        z(te);\n      }\n    }];\n    c != null && (U = U.concat(c)), p && p.modifiers != null && (U = U.concat(p.modifiers));\n    const V = zp(B, E.current, {\n      placement: w,\n      ...p,\n      modifiers: U\n    });\n    return h.current(V), () => {\n      V.destroy(), h.current(null);\n    };\n  }, [B, s, c, l, p, w]);\n  const A = {\n    placement: k\n  };\n  y !== null && (A.TransitionProps = y);\n  const D = qp(t), j = x.root ?? \"div\", W = Yu({\n    elementType: j,\n    externalSlotProps: g.root,\n    externalForwardedProps: S,\n    additionalProps: {\n      role: \"tooltip\",\n      ref: P\n    },\n    ownerState: t,\n    className: D.root\n  });\n  return /* @__PURE__ */ N.jsx(j, {\n    ...W,\n    children: typeof o == \"function\" ? o(A) : o\n  });\n}), Ms = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const {\n    anchorEl: n,\n    children: o,\n    container: i,\n    direction: s = \"ltr\",\n    disablePortal: c = !1,\n    keepMounted: l = !1,\n    modifiers: u,\n    open: p,\n    placement: m = \"bottom\",\n    popperOptions: g = Gp,\n    popperRef: x,\n    style: y,\n    transition: f = !1,\n    slotProps: S = {},\n    slots: E = {},\n    ...P\n  } = t, [T, b] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!0), h = () => {\n    b(!1);\n  }, w = () => {\n    b(!0);\n  };\n  if (!l && !p && (!f || T))\n    return null;\n  let k;\n  if (i)\n    k = i;\n  else if (n) {\n    const d = Tn(n);\n    k = d && Wn(d) ? zi(d).body : zi(null).body;\n  }\n  const L = !p && l && (!f || T) ? \"none\" : void 0, B = f ? {\n    in: p,\n    onEnter: h,\n    onExited: w\n  } : void 0;\n  return /* @__PURE__ */ N.jsx(Cn, {\n    disablePortal: c,\n    container: k,\n    children: /* @__PURE__ */ N.jsx(Kp, {\n      anchorEl: n,\n      direction: s,\n      disablePortal: c,\n      modifiers: u,\n      ref: r,\n      open: f ? !T : p,\n      placement: m,\n      popperOptions: g,\n      popperRef: x,\n      slotProps: S,\n      slots: E,\n      ...P,\n      style: {\n        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.\n        position: \"fixed\",\n        // Fix Popper.js display issue\n        top: 0,\n        left: 0,\n        display: L,\n        ...y\n      },\n      TransitionProps: B,\n      children: o\n    })\n  });\n});\n true && (Ms.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //  To update them, edit the TypeScript types and run `pnpm proptypes`. \n  // \n  /**\n   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),\n   * or a function that returns either.\n   * It's used to set the position of the popper.\n   * The return value will passed as the reference object of the Popper instance.\n   */\n  anchorEl: ar(a.oneOfType([Or, a.object, a.func]), (e) => {\n    if (e.open) {\n      const t = Tn(e.anchorEl);\n      if (t && Wn(t) && t.nodeType === 1) {\n        const r = t.getBoundingClientRect();\n        if ( true && r.top === 0 && r.left === 0 && r.right === 0 && r.bottom === 0)\n          return new Error([\"MUI: The `anchorEl` prop provided to the component is invalid.\", \"The anchor element should be part of the document layout.\", \"Make sure the element is present in the document or that it's not display none.\"].join(`\n`));\n      } else if (!t || typeof t.getBoundingClientRect != \"function\" || Hp(t) && t.contextElement != null && t.contextElement.nodeType !== 1)\n        return new Error([\"MUI: The `anchorEl` prop provided to the component is invalid.\", \"It should be an HTML element instance or a virtualElement \", \"(https://popper.js.org/docs/v2/virtual-elements/).\"].join(`\n`));\n    }\n    return null;\n  }),\n  /**\n   * Popper render function or node.\n   */\n  children: a.oneOfType([a.node, a.func]),\n  /**\n   * An HTML element or function that returns one.\n   * The `container` will have the portal children appended to it.\n   *\n   * You can also provide a callback, which is called in a React layout effect.\n   * This lets you set the container from a ref, and also makes server-side rendering possible.\n   *\n   * By default, it uses the body of the top-level document object,\n   * so it's simply `document.body` most of the time.\n   */\n  container: a.oneOfType([Or, a.func]),\n  /**\n   * Direction of the text.\n   * @default 'ltr'\n   */\n  direction: a.oneOf([\"ltr\", \"rtl\"]),\n  /**\n   * The `children` will be under the DOM hierarchy of the parent component.\n   * @default false\n   */\n  disablePortal: a.bool,\n  /**\n   * Always keep the children in the DOM.\n   * This prop can be useful in SEO situation or\n   * when you want to maximize the responsiveness of the Popper.\n   * @default false\n   */\n  keepMounted: a.bool,\n  /**\n   * Popper.js is based on a \"plugin-like\" architecture,\n   * most of its features are fully encapsulated \"modifiers\".\n   *\n   * A modifier is a function that is called each time Popper.js needs to\n   * compute the position of the popper.\n   * For this reason, modifiers should be very performant to avoid bottlenecks.\n   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).\n   */\n  modifiers: a.arrayOf(a.shape({\n    data: a.object,\n    effect: a.func,\n    enabled: a.bool,\n    fn: a.func,\n    name: a.any,\n    options: a.object,\n    phase: a.oneOf([\"afterMain\", \"afterRead\", \"afterWrite\", \"beforeMain\", \"beforeRead\", \"beforeWrite\", \"main\", \"read\", \"write\"]),\n    requires: a.arrayOf(a.string),\n    requiresIfExists: a.arrayOf(a.string)\n  })),\n  /**\n   * If `true`, the component is shown.\n   */\n  open: a.bool.isRequired,\n  /**\n   * Popper placement.\n   * @default 'bottom'\n   */\n  placement: a.oneOf([\"auto-end\", \"auto-start\", \"auto\", \"bottom-end\", \"bottom-start\", \"bottom\", \"left-end\", \"left-start\", \"left\", \"right-end\", \"right-start\", \"right\", \"top-end\", \"top-start\", \"top\"]),\n  /**\n   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.\n   * @default {}\n   */\n  popperOptions: a.shape({\n    modifiers: a.array,\n    onFirstUpdate: a.func,\n    placement: a.oneOf([\"auto-end\", \"auto-start\", \"auto\", \"bottom-end\", \"bottom-start\", \"bottom\", \"left-end\", \"left-start\", \"left\", \"right-end\", \"right-start\", \"right\", \"top-end\", \"top-start\", \"top\"]),\n    strategy: a.oneOf([\"absolute\", \"fixed\"])\n  }),\n  /**\n   * A ref that points to the used popper instance.\n   */\n  popperRef: Lo,\n  /**\n   * The props used for each slot inside the Popper.\n   * @default {}\n   */\n  slotProps: a.shape({\n    root: a.oneOfType([a.func, a.object])\n  }),\n  /**\n   * The components used for each slot inside the Popper.\n   * Either a string to use a HTML element or a component.\n   * @default {}\n   */\n  slots: a.shape({\n    root: a.elementType\n  }),\n  /**\n   * Help supporting a react-transition-group/Transition component.\n   * @default false\n   */\n  transition: a.bool\n});\nconst Xp = le(Ms, {\n  name: \"MuiPopper\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => t.root\n})({}), ei = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = is(), o = He({\n    props: t,\n    name: \"MuiPopper\"\n  }), {\n    anchorEl: i,\n    component: s,\n    components: c,\n    componentsProps: l,\n    container: u,\n    disablePortal: p,\n    keepMounted: m,\n    modifiers: g,\n    open: x,\n    placement: y,\n    popperOptions: f,\n    popperRef: S,\n    transition: E,\n    slots: P,\n    slotProps: T,\n    ...b\n  } = o, h = (P == null ? void 0 : P.root) ?? (c == null ? void 0 : c.Root), w = {\n    anchorEl: i,\n    container: u,\n    disablePortal: p,\n    keepMounted: m,\n    modifiers: g,\n    open: x,\n    placement: y,\n    popperOptions: f,\n    popperRef: S,\n    transition: E,\n    ...b\n  };\n  return /* @__PURE__ */ N.jsx(Xp, {\n    as: s,\n    direction: n ? \"rtl\" : \"ltr\",\n    slots: {\n      root: h\n    },\n    slotProps: T ?? l,\n    ...w,\n    ref: r\n  });\n});\n true && (ei.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //  To update them, edit the TypeScript types and run `pnpm proptypes`. \n  // \n  /**\n   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),\n   * or a function that returns either.\n   * It's used to set the position of the popper.\n   * The return value will passed as the reference object of the Popper instance.\n   */\n  anchorEl: a.oneOfType([Or, a.object, a.func]),\n  /**\n   * Popper render function or node.\n   */\n  children: a.oneOfType([a.node, a.func]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * The components used for each slot inside the Popper.\n   * Either a string to use a HTML element or a component.\n   *\n   * @deprecated use the `slots` prop instead. This prop will be removed in v7. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).\n   * @default {}\n   */\n  components: a.shape({\n    Root: a.elementType\n  }),\n  /**\n   * The props used for each slot inside the Popper.\n   *\n   * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).\n   * @default {}\n   */\n  componentsProps: a.shape({\n    root: a.oneOfType([a.func, a.object])\n  }),\n  /**\n   * An HTML element or function that returns one.\n   * The `container` will have the portal children appended to it.\n   *\n   * You can also provide a callback, which is called in a React layout effect.\n   * This lets you set the container from a ref, and also makes server-side rendering possible.\n   *\n   * By default, it uses the body of the top-level document object,\n   * so it's simply `document.body` most of the time.\n   */\n  container: a.oneOfType([Or, a.func]),\n  /**\n   * The `children` will be under the DOM hierarchy of the parent component.\n   * @default false\n   */\n  disablePortal: a.bool,\n  /**\n   * Always keep the children in the DOM.\n   * This prop can be useful in SEO situation or\n   * when you want to maximize the responsiveness of the Popper.\n   * @default false\n   */\n  keepMounted: a.bool,\n  /**\n   * Popper.js is based on a \"plugin-like\" architecture,\n   * most of its features are fully encapsulated \"modifiers\".\n   *\n   * A modifier is a function that is called each time Popper.js needs to\n   * compute the position of the popper.\n   * For this reason, modifiers should be very performant to avoid bottlenecks.\n   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).\n   */\n  modifiers: a.arrayOf(a.shape({\n    data: a.object,\n    effect: a.func,\n    enabled: a.bool,\n    fn: a.func,\n    name: a.any,\n    options: a.object,\n    phase: a.oneOf([\"afterMain\", \"afterRead\", \"afterWrite\", \"beforeMain\", \"beforeRead\", \"beforeWrite\", \"main\", \"read\", \"write\"]),\n    requires: a.arrayOf(a.string),\n    requiresIfExists: a.arrayOf(a.string)\n  })),\n  /**\n   * If `true`, the component is shown.\n   */\n  open: a.bool.isRequired,\n  /**\n   * Popper placement.\n   * @default 'bottom'\n   */\n  placement: a.oneOf([\"auto-end\", \"auto-start\", \"auto\", \"bottom-end\", \"bottom-start\", \"bottom\", \"left-end\", \"left-start\", \"left\", \"right-end\", \"right-start\", \"right\", \"top-end\", \"top-start\", \"top\"]),\n  /**\n   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.\n   * @default {}\n   */\n  popperOptions: a.shape({\n    modifiers: a.array,\n    onFirstUpdate: a.func,\n    placement: a.oneOf([\"auto-end\", \"auto-start\", \"auto\", \"bottom-end\", \"bottom-start\", \"bottom\", \"left-end\", \"left-start\", \"left\", \"right-end\", \"right-start\", \"right\", \"top-end\", \"top-start\", \"top\"]),\n    strategy: a.oneOf([\"absolute\", \"fixed\"])\n  }),\n  /**\n   * A ref that points to the used popper instance.\n   */\n  popperRef: Lo,\n  /**\n   * The props used for each slot inside the Popper.\n   * @default {}\n   */\n  slotProps: a.shape({\n    root: a.oneOfType([a.func, a.object])\n  }),\n  /**\n   * The components used for each slot inside the Popper.\n   * Either a string to use a HTML element or a component.\n   * @default {}\n   */\n  slots: a.shape({\n    root: a.elementType\n  }),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * Help supporting a react-transition-group/Transition component.\n   * @default false\n   */\n  transition: a.bool\n});\nfunction Jp(e) {\n  return Ve(\"MuiListSubheader\", e);\n}\nFe(\"MuiListSubheader\", [\"root\", \"colorPrimary\", \"colorInherit\", \"gutters\", \"inset\", \"sticky\"]);\nconst Qp = (e) => {\n  const {\n    classes: t,\n    color: r,\n    disableGutters: n,\n    inset: o,\n    disableSticky: i\n  } = e, s = {\n    root: [\"root\", r !== \"default\" && `color${ee(r)}`, !n && \"gutters\", o && \"inset\", !i && \"sticky\"]\n  };\n  return Ge(s, Jp, t);\n}, Zp = le(\"li\", {\n  name: \"MuiListSubheader\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, r.color !== \"default\" && t[`color${ee(r.color)}`], !r.disableGutters && t.gutters, r.inset && t.inset, !r.disableSticky && t.sticky];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  boxSizing: \"border-box\",\n  lineHeight: \"48px\",\n  listStyle: \"none\",\n  color: (e.vars || e).palette.text.secondary,\n  fontFamily: e.typography.fontFamily,\n  fontWeight: e.typography.fontWeightMedium,\n  fontSize: e.typography.pxToRem(14),\n  variants: [{\n    props: {\n      color: \"primary\"\n    },\n    style: {\n      color: (e.vars || e).palette.primary.main\n    }\n  }, {\n    props: {\n      color: \"inherit\"\n    },\n    style: {\n      color: \"inherit\"\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !t.disableGutters,\n    style: {\n      paddingLeft: 16,\n      paddingRight: 16\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.inset,\n    style: {\n      paddingLeft: 72\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !t.disableSticky,\n    style: {\n      position: \"sticky\",\n      top: 0,\n      zIndex: 1,\n      backgroundColor: (e.vars || e).palette.background.paper\n    }\n  }]\n}))), wn = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiListSubheader\"\n  }), {\n    className: o,\n    color: i = \"default\",\n    component: s = \"li\",\n    disableGutters: c = !1,\n    disableSticky: l = !1,\n    inset: u = !1,\n    ...p\n  } = n, m = {\n    ...n,\n    color: i,\n    component: s,\n    disableGutters: c,\n    disableSticky: l,\n    inset: u\n  }, g = Qp(m);\n  return /* @__PURE__ */ N.jsx(Zp, {\n    as: s,\n    className: se(g.root, o),\n    ref: r,\n    ownerState: m,\n    ...p\n  });\n});\nwn && (wn.muiSkipListHighlight = !0);\n true && (wn.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The content of the component.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The color of the component. It supports those theme colors that make sense for this component.\n   * @default 'default'\n   */\n  color: a.oneOf([\"default\", \"inherit\", \"primary\"]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * If `true`, the List Subheader will not have gutters.\n   * @default false\n   */\n  disableGutters: a.bool,\n  /**\n   * If `true`, the List Subheader will not stick to the top during scroll.\n   * @default false\n   */\n  disableSticky: a.bool,\n  /**\n   * If `true`, the List Subheader is indented.\n   * @default false\n   */\n  inset: a.bool,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nconst em = sr(/* @__PURE__ */ N.jsx(\"path\", {\n  d: \"M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z\"\n}), \"Cancel\");\nfunction tm(e) {\n  return Ve(\"MuiChip\", e);\n}\nconst ie = Fe(\"MuiChip\", [\"root\", \"sizeSmall\", \"sizeMedium\", \"colorDefault\", \"colorError\", \"colorInfo\", \"colorPrimary\", \"colorSecondary\", \"colorSuccess\", \"colorWarning\", \"disabled\", \"clickable\", \"clickableColorPrimary\", \"clickableColorSecondary\", \"deletable\", \"deletableColorPrimary\", \"deletableColorSecondary\", \"outlined\", \"filled\", \"outlinedPrimary\", \"outlinedSecondary\", \"filledPrimary\", \"filledSecondary\", \"avatar\", \"avatarSmall\", \"avatarMedium\", \"avatarColorPrimary\", \"avatarColorSecondary\", \"icon\", \"iconSmall\", \"iconMedium\", \"iconColorPrimary\", \"iconColorSecondary\", \"label\", \"labelSmall\", \"labelMedium\", \"deleteIcon\", \"deleteIconSmall\", \"deleteIconMedium\", \"deleteIconColorPrimary\", \"deleteIconColorSecondary\", \"deleteIconOutlinedColorPrimary\", \"deleteIconOutlinedColorSecondary\", \"deleteIconFilledColorPrimary\", \"deleteIconFilledColorSecondary\", \"focusVisible\"]), rm = (e) => {\n  const {\n    classes: t,\n    disabled: r,\n    size: n,\n    color: o,\n    iconColor: i,\n    onDelete: s,\n    clickable: c,\n    variant: l\n  } = e, u = {\n    root: [\"root\", l, r && \"disabled\", `size${ee(n)}`, `color${ee(o)}`, c && \"clickable\", c && `clickableColor${ee(o)}`, s && \"deletable\", s && `deletableColor${ee(o)}`, `${l}${ee(o)}`],\n    label: [\"label\", `label${ee(n)}`],\n    avatar: [\"avatar\", `avatar${ee(n)}`, `avatarColor${ee(o)}`],\n    icon: [\"icon\", `icon${ee(n)}`, `iconColor${ee(i)}`],\n    deleteIcon: [\"deleteIcon\", `deleteIcon${ee(n)}`, `deleteIconColor${ee(o)}`, `deleteIcon${ee(l)}Color${ee(o)}`]\n  };\n  return Ge(u, tm, t);\n}, nm = le(\"div\", {\n  name: \"MuiChip\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e, {\n      color: n,\n      iconColor: o,\n      clickable: i,\n      onDelete: s,\n      size: c,\n      variant: l\n    } = r;\n    return [{\n      [`& .${ie.avatar}`]: t.avatar\n    }, {\n      [`& .${ie.avatar}`]: t[`avatar${ee(c)}`]\n    }, {\n      [`& .${ie.avatar}`]: t[`avatarColor${ee(n)}`]\n    }, {\n      [`& .${ie.icon}`]: t.icon\n    }, {\n      [`& .${ie.icon}`]: t[`icon${ee(c)}`]\n    }, {\n      [`& .${ie.icon}`]: t[`iconColor${ee(o)}`]\n    }, {\n      [`& .${ie.deleteIcon}`]: t.deleteIcon\n    }, {\n      [`& .${ie.deleteIcon}`]: t[`deleteIcon${ee(c)}`]\n    }, {\n      [`& .${ie.deleteIcon}`]: t[`deleteIconColor${ee(n)}`]\n    }, {\n      [`& .${ie.deleteIcon}`]: t[`deleteIcon${ee(l)}Color${ee(n)}`]\n    }, t.root, t[`size${ee(c)}`], t[`color${ee(n)}`], i && t.clickable, i && n !== \"default\" && t[`clickableColor${ee(n)})`], s && t.deletable, s && n !== \"default\" && t[`deletableColor${ee(n)}`], t[l], t[`${l}${ee(n)}`]];\n  }\n})(qe(({\n  theme: e\n}) => {\n  const t = e.palette.mode === \"light\" ? e.palette.grey[700] : e.palette.grey[300];\n  return {\n    maxWidth: \"100%\",\n    fontFamily: e.typography.fontFamily,\n    fontSize: e.typography.pxToRem(13),\n    display: \"inline-flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    height: 32,\n    color: (e.vars || e).palette.text.primary,\n    backgroundColor: (e.vars || e).palette.action.selected,\n    borderRadius: 32 / 2,\n    whiteSpace: \"nowrap\",\n    transition: e.transitions.create([\"background-color\", \"box-shadow\"]),\n    // reset cursor explicitly in case ButtonBase is used\n    cursor: \"unset\",\n    // We disable the focus ring for mouse, touch and keyboard users.\n    outline: 0,\n    textDecoration: \"none\",\n    border: 0,\n    // Remove `button` border\n    padding: 0,\n    // Remove `button` padding\n    verticalAlign: \"middle\",\n    boxSizing: \"border-box\",\n    [`&.${ie.disabled}`]: {\n      opacity: (e.vars || e).palette.action.disabledOpacity,\n      pointerEvents: \"none\"\n    },\n    [`& .${ie.avatar}`]: {\n      marginLeft: 5,\n      marginRight: -6,\n      width: 24,\n      height: 24,\n      color: e.vars ? e.vars.palette.Chip.defaultAvatarColor : t,\n      fontSize: e.typography.pxToRem(12)\n    },\n    [`& .${ie.avatarColorPrimary}`]: {\n      color: (e.vars || e).palette.primary.contrastText,\n      backgroundColor: (e.vars || e).palette.primary.dark\n    },\n    [`& .${ie.avatarColorSecondary}`]: {\n      color: (e.vars || e).palette.secondary.contrastText,\n      backgroundColor: (e.vars || e).palette.secondary.dark\n    },\n    [`& .${ie.avatarSmall}`]: {\n      marginLeft: 4,\n      marginRight: -4,\n      width: 18,\n      height: 18,\n      fontSize: e.typography.pxToRem(10)\n    },\n    [`& .${ie.icon}`]: {\n      marginLeft: 5,\n      marginRight: -6\n    },\n    [`& .${ie.deleteIcon}`]: {\n      WebkitTapHighlightColor: \"transparent\",\n      color: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.26)` : De(e.palette.text.primary, 0.26),\n      fontSize: 22,\n      cursor: \"pointer\",\n      margin: \"0 5px 0 -6px\",\n      \"&:hover\": {\n        color: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.4)` : De(e.palette.text.primary, 0.4)\n      }\n    },\n    variants: [{\n      props: {\n        size: \"small\"\n      },\n      style: {\n        height: 24,\n        [`& .${ie.icon}`]: {\n          fontSize: 18,\n          marginLeft: 4,\n          marginRight: -4\n        },\n        [`& .${ie.deleteIcon}`]: {\n          fontSize: 16,\n          marginRight: 4,\n          marginLeft: -4\n        }\n      }\n    }, ...Object.entries(e.palette).filter(Pt([\"contrastText\"])).map(([r]) => ({\n      props: {\n        color: r\n      },\n      style: {\n        backgroundColor: (e.vars || e).palette[r].main,\n        color: (e.vars || e).palette[r].contrastText,\n        [`& .${ie.deleteIcon}`]: {\n          color: e.vars ? `rgba(${e.vars.palette[r].contrastTextChannel} / 0.7)` : De(e.palette[r].contrastText, 0.7),\n          \"&:hover, &:active\": {\n            color: (e.vars || e).palette[r].contrastText\n          }\n        }\n      }\n    })), {\n      props: (r) => r.iconColor === r.color,\n      style: {\n        [`& .${ie.icon}`]: {\n          color: e.vars ? e.vars.palette.Chip.defaultIconColor : t\n        }\n      }\n    }, {\n      props: (r) => r.iconColor === r.color && r.color !== \"default\",\n      style: {\n        [`& .${ie.icon}`]: {\n          color: \"inherit\"\n        }\n      }\n    }, {\n      props: {\n        onDelete: !0\n      },\n      style: {\n        [`&.${ie.focusVisible}`]: {\n          backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : De(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)\n        }\n      }\n    }, ...Object.entries(e.palette).filter(Pt([\"dark\"])).map(([r]) => ({\n      props: {\n        color: r,\n        onDelete: !0\n      },\n      style: {\n        [`&.${ie.focusVisible}`]: {\n          background: (e.vars || e).palette[r].dark\n        }\n      }\n    })), {\n      props: {\n        clickable: !0\n      },\n      style: {\n        userSelect: \"none\",\n        WebkitTapHighlightColor: \"transparent\",\n        cursor: \"pointer\",\n        \"&:hover\": {\n          backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : De(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)\n        },\n        [`&.${ie.focusVisible}`]: {\n          backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : De(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)\n        },\n        \"&:active\": {\n          boxShadow: (e.vars || e).shadows[1]\n        }\n      }\n    }, ...Object.entries(e.palette).filter(Pt([\"dark\"])).map(([r]) => ({\n      props: {\n        color: r,\n        clickable: !0\n      },\n      style: {\n        [`&:hover, &.${ie.focusVisible}`]: {\n          backgroundColor: (e.vars || e).palette[r].dark\n        }\n      }\n    })), {\n      props: {\n        variant: \"outlined\"\n      },\n      style: {\n        backgroundColor: \"transparent\",\n        border: e.vars ? `1px solid ${e.vars.palette.Chip.defaultBorder}` : `1px solid ${e.palette.mode === \"light\" ? e.palette.grey[400] : e.palette.grey[700]}`,\n        [`&.${ie.clickable}:hover`]: {\n          backgroundColor: (e.vars || e).palette.action.hover\n        },\n        [`&.${ie.focusVisible}`]: {\n          backgroundColor: (e.vars || e).palette.action.focus\n        },\n        [`& .${ie.avatar}`]: {\n          marginLeft: 4\n        },\n        [`& .${ie.avatarSmall}`]: {\n          marginLeft: 2\n        },\n        [`& .${ie.icon}`]: {\n          marginLeft: 4\n        },\n        [`& .${ie.iconSmall}`]: {\n          marginLeft: 2\n        },\n        [`& .${ie.deleteIcon}`]: {\n          marginRight: 5\n        },\n        [`& .${ie.deleteIconSmall}`]: {\n          marginRight: 3\n        }\n      }\n    }, ...Object.entries(e.palette).filter(Pt()).map(([r]) => ({\n      props: {\n        variant: \"outlined\",\n        color: r\n      },\n      style: {\n        color: (e.vars || e).palette[r].main,\n        border: `1px solid ${e.vars ? `rgba(${e.vars.palette[r].mainChannel} / 0.7)` : De(e.palette[r].main, 0.7)}`,\n        [`&.${ie.clickable}:hover`]: {\n          backgroundColor: e.vars ? `rgba(${e.vars.palette[r].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : De(e.palette[r].main, e.palette.action.hoverOpacity)\n        },\n        [`&.${ie.focusVisible}`]: {\n          backgroundColor: e.vars ? `rgba(${e.vars.palette[r].mainChannel} / ${e.vars.palette.action.focusOpacity})` : De(e.palette[r].main, e.palette.action.focusOpacity)\n        },\n        [`& .${ie.deleteIcon}`]: {\n          color: e.vars ? `rgba(${e.vars.palette[r].mainChannel} / 0.7)` : De(e.palette[r].main, 0.7),\n          \"&:hover, &:active\": {\n            color: (e.vars || e).palette[r].main\n          }\n        }\n      }\n    }))]\n  };\n})), om = le(\"span\", {\n  name: \"MuiChip\",\n  slot: \"Label\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e, {\n      size: n\n    } = r;\n    return [t.label, t[`label${ee(n)}`]];\n  }\n})({\n  overflow: \"hidden\",\n  textOverflow: \"ellipsis\",\n  paddingLeft: 12,\n  paddingRight: 12,\n  whiteSpace: \"nowrap\",\n  variants: [{\n    props: {\n      variant: \"outlined\"\n    },\n    style: {\n      paddingLeft: 11,\n      paddingRight: 11\n    }\n  }, {\n    props: {\n      size: \"small\"\n    },\n    style: {\n      paddingLeft: 8,\n      paddingRight: 8\n    }\n  }, {\n    props: {\n      size: \"small\",\n      variant: \"outlined\"\n    },\n    style: {\n      paddingLeft: 7,\n      paddingRight: 7\n    }\n  }]\n});\nfunction ba(e) {\n  return e.key === \"Backspace\" || e.key === \"Delete\";\n}\nconst Is = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiChip\"\n  }), {\n    avatar: o,\n    className: i,\n    clickable: s,\n    color: c = \"default\",\n    component: l,\n    deleteIcon: u,\n    disabled: p = !1,\n    icon: m,\n    label: g,\n    onClick: x,\n    onDelete: y,\n    onKeyDown: f,\n    onKeyUp: S,\n    size: E = \"medium\",\n    variant: P = \"filled\",\n    tabIndex: T,\n    skipFocusWhenDisabled: b = !1,\n    // TODO v6: Rename to `focusableWhenDisabled`.\n    ...h\n  } = n, w = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), k = at(w, r), L = (F) => {\n    F.stopPropagation(), y && y(F);\n  }, B = (F) => {\n    F.currentTarget === F.target && ba(F) && F.preventDefault(), f && f(F);\n  }, d = (F) => {\n    F.currentTarget === F.target && y && ba(F) && y(F), S && S(F);\n  }, A = s !== !1 && x ? !0 : s, D = A || y ? $r : l || \"div\", j = {\n    ...n,\n    component: D,\n    disabled: p,\n    size: E,\n    color: c,\n    iconColor: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(m) && m.props.color || c,\n    onDelete: !!y,\n    clickable: A,\n    variant: P\n  }, W = rm(j), z = D === $r ? {\n    component: l || \"div\",\n    focusVisibleClassName: W.focusVisible,\n    ...y && {\n      disableRipple: !0\n    }\n  } : {};\n  let U = null;\n  y && (U = u && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(u) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(u, {\n    className: se(u.props.className, W.deleteIcon),\n    onClick: L\n  }) : /* @__PURE__ */ N.jsx(em, {\n    className: se(W.deleteIcon),\n    onClick: L\n  }));\n  let V = null;\n  o && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(o) && (V = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(o, {\n    className: se(W.avatar, o.props.className)\n  }));\n  let te = null;\n  return m && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(m) && (te = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(m, {\n    className: se(W.icon, m.props.className)\n  })),  true && V && te && console.error(\"MUI: The Chip component can not handle the avatar and the icon prop at the same time. Pick one.\"), /* @__PURE__ */ N.jsxs(nm, {\n    as: D,\n    className: se(W.root, i),\n    disabled: A && p ? !0 : void 0,\n    onClick: x,\n    onKeyDown: B,\n    onKeyUp: d,\n    ref: k,\n    tabIndex: b && p ? -1 : T,\n    ownerState: j,\n    ...z,\n    ...h,\n    children: [V || te, /* @__PURE__ */ N.jsx(om, {\n      className: se(W.label),\n      ownerState: j,\n      children: g\n    }), U]\n  });\n});\n true && (Is.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The Avatar element to display.\n   */\n  avatar: a.element,\n  /**\n   * This prop isn't supported.\n   * Use the `component` prop if you need to change the children structure.\n   */\n  children: Bu,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * If `true`, the chip will appear clickable, and will raise when pressed,\n   * even if the onClick prop is not defined.\n   * If `false`, the chip will not appear clickable, even if onClick prop is defined.\n   * This can be used, for example,\n   * along with the component prop to indicate an anchor Chip is clickable.\n   * Note: this controls the UI and does not affect the onClick event.\n   */\n  clickable: a.bool,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'default'\n   */\n  color: a.oneOfType([a.oneOf([\"default\", \"primary\", \"secondary\", \"error\", \"info\", \"success\", \"warning\"]), a.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * Override the default delete icon element. Shown only if `onDelete` is set.\n   */\n  deleteIcon: a.element,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: a.bool,\n  /**\n   * Icon element.\n   */\n  icon: a.element,\n  /**\n   * The content of the component.\n   */\n  label: a.node,\n  /**\n   * @ignore\n   */\n  onClick: a.func,\n  /**\n   * Callback fired when the delete icon is clicked.\n   * If set, the delete icon will be shown.\n   */\n  onDelete: a.func,\n  /**\n   * @ignore\n   */\n  onKeyDown: a.func,\n  /**\n   * @ignore\n   */\n  onKeyUp: a.func,\n  /**\n   * The size of the component.\n   * @default 'medium'\n   */\n  size: a.oneOfType([a.oneOf([\"medium\", \"small\"]), a.string]),\n  /**\n   * If `true`, allows the disabled chip to escape focus.\n   * If `false`, allows the disabled chip to receive focus.\n   * @default false\n   */\n  skipFocusWhenDisabled: a.bool,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * @ignore\n   */\n  tabIndex: a.number,\n  /**\n   * The variant to use.\n   * @default 'filled'\n   */\n  variant: a.oneOfType([a.oneOf([\"filled\", \"outlined\"]), a.string])\n});\nconst im = sr(/* @__PURE__ */ N.jsx(\"path\", {\n  d: \"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\"\n}), \"Person\");\nfunction am(e) {\n  return Ve(\"MuiAvatar\", e);\n}\nFe(\"MuiAvatar\", [\"root\", \"colorDefault\", \"circular\", \"rounded\", \"square\", \"img\", \"fallback\"]);\nconst sm = (e) => {\n  const {\n    classes: t,\n    variant: r,\n    colorDefault: n\n  } = e;\n  return Ge({\n    root: [\"root\", r, n && \"colorDefault\"],\n    img: [\"img\"],\n    fallback: [\"fallback\"]\n  }, am, t);\n}, cm = le(\"div\", {\n  name: \"MuiAvatar\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, t[r.variant], r.colorDefault && t.colorDefault];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  position: \"relative\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  flexShrink: 0,\n  width: 40,\n  height: 40,\n  fontFamily: e.typography.fontFamily,\n  fontSize: e.typography.pxToRem(20),\n  lineHeight: 1,\n  borderRadius: \"50%\",\n  overflow: \"hidden\",\n  userSelect: \"none\",\n  variants: [{\n    props: {\n      variant: \"rounded\"\n    },\n    style: {\n      borderRadius: (e.vars || e).shape.borderRadius\n    }\n  }, {\n    props: {\n      variant: \"square\"\n    },\n    style: {\n      borderRadius: 0\n    }\n  }, {\n    props: {\n      colorDefault: !0\n    },\n    style: {\n      color: (e.vars || e).palette.background.default,\n      ...e.vars ? {\n        backgroundColor: e.vars.palette.Avatar.defaultBg\n      } : {\n        backgroundColor: e.palette.grey[400],\n        ...e.applyStyles(\"dark\", {\n          backgroundColor: e.palette.grey[600]\n        })\n      }\n    }\n  }]\n}))), lm = le(\"img\", {\n  name: \"MuiAvatar\",\n  slot: \"Img\",\n  overridesResolver: (e, t) => t.img\n})({\n  width: \"100%\",\n  height: \"100%\",\n  textAlign: \"center\",\n  // Handle non-square image.\n  objectFit: \"cover\",\n  // Hide alt text.\n  color: \"transparent\",\n  // Hide the image broken icon, only works on Chrome.\n  textIndent: 1e4\n}), um = le(im, {\n  name: \"MuiAvatar\",\n  slot: \"Fallback\",\n  overridesResolver: (e, t) => t.fallback\n})({\n  width: \"75%\",\n  height: \"75%\"\n});\nfunction fm({\n  crossOrigin: e,\n  referrerPolicy: t,\n  src: r,\n  srcSet: n\n}) {\n  const [o, i] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!r && !n)\n      return;\n    i(!1);\n    let s = !0;\n    const c = new Image();\n    return c.onload = () => {\n      s && i(\"loaded\");\n    }, c.onerror = () => {\n      s && i(\"error\");\n    }, c.crossOrigin = e, c.referrerPolicy = t, c.src = r, n && (c.srcset = n), () => {\n      s = !1;\n    };\n  }, [e, t, r, n]), o;\n}\nconst _s = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiAvatar\"\n  }), {\n    alt: o,\n    children: i,\n    className: s,\n    component: c = \"div\",\n    slots: l = {},\n    slotProps: u = {},\n    imgProps: p,\n    sizes: m,\n    src: g,\n    srcSet: x,\n    variant: y = \"circular\",\n    ...f\n  } = n;\n  let S = null;\n  const E = {\n    ...n,\n    component: c,\n    variant: y\n  }, P = fm({\n    ...p,\n    ...typeof u.img == \"function\" ? u.img(E) : u.img,\n    src: g,\n    srcSet: x\n  }), T = g || x, b = T && P !== \"error\";\n  E.colorDefault = !b, delete E.ownerState;\n  const h = sm(E), [w, k] = Bt(\"img\", {\n    className: h.img,\n    elementType: lm,\n    externalForwardedProps: {\n      slots: l,\n      slotProps: {\n        img: {\n          ...p,\n          ...u.img\n        }\n      }\n    },\n    additionalProps: {\n      alt: o,\n      src: g,\n      srcSet: x,\n      sizes: m\n    },\n    ownerState: E\n  });\n  return b ? S = /* @__PURE__ */ N.jsx(w, {\n    ...k\n  }) : i || i === 0 ? S = i : T && o ? S = o[0] : S = /* @__PURE__ */ N.jsx(um, {\n    ownerState: E,\n    className: h.fallback\n  }), /* @__PURE__ */ N.jsx(cm, {\n    as: c,\n    className: se(h.root, s),\n    ref: r,\n    ...f,\n    ownerState: E,\n    children: S\n  });\n});\n true && (_s.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Used in combination with `src` or `srcSet` to\n   * provide an alt attribute for the rendered `img` element.\n   */\n  alt: a.string,\n  /**\n   * Used to render icon or text elements inside the Avatar if `src` is not set.\n   * This can be an element, or just a string.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attributes) applied to the `img` element if the component is used to display an image.\n   * It can be used to listen for the loading error event.\n   * @deprecated Use `slotProps.img` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  imgProps: a.object,\n  /**\n   * The `sizes` attribute for the `img` element.\n   */\n  sizes: a.string,\n  /**\n   * The props used for each slot inside.\n   * @default {}\n   */\n  slotProps: a.shape({\n    img: a.oneOfType([a.func, a.object])\n  }),\n  /**\n   * The components used for each slot inside.\n   * @default {}\n   */\n  slots: a.shape({\n    img: a.elementType\n  }),\n  /**\n   * The `src` attribute for the `img` element.\n   */\n  src: a.string,\n  /**\n   * The `srcSet` attribute for the `img` element.\n   * Use this attribute for responsive image display.\n   */\n  srcSet: a.string,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * The shape of the avatar.\n   * @default 'circular'\n   */\n  variant: a.oneOfType([a.oneOf([\"circular\", \"rounded\", \"square\"]), a.string])\n});\nconst dm = Fe(\"MuiBox\", [\"root\"]), pm = Fn(), dt = bu({\n  themeId: wt,\n  defaultTheme: pm,\n  defaultClassName: dm.root,\n  generateClassName: Wa.generate\n});\n true && (dt.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * @ignore\n   */\n  children: a.node,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nfunction xo(e) {\n  return `scale(${e}, ${e ** 2})`;\n}\nconst mm = {\n  entering: {\n    opacity: 1,\n    transform: xo(1)\n  },\n  entered: {\n    opacity: 1,\n    transform: \"none\"\n  }\n}, no = typeof navigator < \"u\" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\\/)15(.|_)4/i.test(navigator.userAgent), On = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const {\n    addEndListener: n,\n    appear: o = !0,\n    children: i,\n    easing: s,\n    in: c,\n    onEnter: l,\n    onEntered: u,\n    onEntering: p,\n    onExit: m,\n    onExited: g,\n    onExiting: x,\n    style: y,\n    timeout: f = \"auto\",\n    // eslint-disable-next-line react/prop-types\n    TransitionComponent: S = Et,\n    ...E\n  } = t, P = Dt(), T = react__WEBPACK_IMPORTED_MODULE_0__.useRef(), b = Lr(), h = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), w = at(h, Bo(i), r), k = (z) => (U) => {\n    if (z) {\n      const V = h.current;\n      U === void 0 ? z(V) : z(V, U);\n    }\n  }, L = k(p), B = k((z, U) => {\n    td(z);\n    const {\n      duration: V,\n      delay: te,\n      easing: F\n    } = vn({\n      style: y,\n      timeout: f,\n      easing: s\n    }, {\n      mode: \"enter\"\n    });\n    let R;\n    f === \"auto\" ? (R = b.transitions.getAutoHeightDuration(z.clientHeight), T.current = R) : R = V, z.style.transition = [b.transitions.create(\"opacity\", {\n      duration: R,\n      delay: te\n    }), b.transitions.create(\"transform\", {\n      duration: no ? R : R * 0.666,\n      delay: te,\n      easing: F\n    })].join(\",\"), l && l(z, U);\n  }), d = k(u), A = k(x), D = k((z) => {\n    const {\n      duration: U,\n      delay: V,\n      easing: te\n    } = vn({\n      style: y,\n      timeout: f,\n      easing: s\n    }, {\n      mode: \"exit\"\n    });\n    let F;\n    f === \"auto\" ? (F = b.transitions.getAutoHeightDuration(z.clientHeight), T.current = F) : F = U, z.style.transition = [b.transitions.create(\"opacity\", {\n      duration: F,\n      delay: V\n    }), b.transitions.create(\"transform\", {\n      duration: no ? F : F * 0.666,\n      delay: no ? V : V || F * 0.333,\n      easing: te\n    })].join(\",\"), z.style.opacity = 0, z.style.transform = xo(0.75), m && m(z);\n  }), j = k(g), W = (z) => {\n    f === \"auto\" && P.start(T.current || 0, z), n && n(h.current, z);\n  };\n  return /* @__PURE__ */ N.jsx(S, {\n    appear: o,\n    in: c,\n    nodeRef: h,\n    onEnter: B,\n    onEntered: d,\n    onEntering: L,\n    onExit: D,\n    onExited: j,\n    onExiting: A,\n    addEndListener: W,\n    timeout: f === \"auto\" ? null : f,\n    ...E,\n    children: (z, {\n      ownerState: U,\n      ...V\n    }) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(i, {\n      style: {\n        opacity: 0,\n        transform: xo(0.75),\n        visibility: z === \"exited\" && !c ? \"hidden\" : void 0,\n        ...mm[z],\n        ...y,\n        ...i.props.style\n      },\n      ref: w,\n      ...V\n    })\n  });\n});\n true && (On.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Add a custom transition end trigger. Called with the transitioning DOM\n   * node and a done callback. Allows for more fine grained transition end\n   * logic. Note: Timeouts are still used as a fallback if provided.\n   */\n  addEndListener: a.func,\n  /**\n   * Perform the enter transition when it first mounts if `in` is also `true`.\n   * Set this to `false` to disable this behavior.\n   * @default true\n   */\n  appear: a.bool,\n  /**\n   * A single child content element.\n   */\n  children: jo.isRequired,\n  /**\n   * The transition timing function.\n   * You may specify a single easing or a object containing enter and exit values.\n   */\n  easing: a.oneOfType([a.shape({\n    enter: a.string,\n    exit: a.string\n  }), a.string]),\n  /**\n   * If `true`, the component will transition in.\n   */\n  in: a.bool,\n  /**\n   * @ignore\n   */\n  onEnter: a.func,\n  /**\n   * @ignore\n   */\n  onEntered: a.func,\n  /**\n   * @ignore\n   */\n  onEntering: a.func,\n  /**\n   * @ignore\n   */\n  onExit: a.func,\n  /**\n   * @ignore\n   */\n  onExited: a.func,\n  /**\n   * @ignore\n   */\n  onExiting: a.func,\n  /**\n   * @ignore\n   */\n  style: a.object,\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   *\n   * Set to 'auto' to automatically calculate transition time based on height.\n   * @default 'auto'\n   */\n  timeout: a.oneOfType([a.oneOf([\"auto\"]), a.number, a.shape({\n    appear: a.number,\n    enter: a.number,\n    exit: a.number\n  })])\n});\nOn && (On.muiSupportAuto = !0);\nconst or = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext({});\n true && (or.displayName = \"ListContext\");\nfunction hm(e) {\n  return Ve(\"MuiList\", e);\n}\nFe(\"MuiList\", [\"root\", \"padding\", \"dense\", \"subheader\"]);\nconst gm = (e) => {\n  const {\n    classes: t,\n    disablePadding: r,\n    dense: n,\n    subheader: o\n  } = e;\n  return Ge({\n    root: [\"root\", !r && \"padding\", n && \"dense\", o && \"subheader\"]\n  }, hm, t);\n}, ym = le(\"ul\", {\n  name: \"MuiList\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, !r.disablePadding && t.padding, r.dense && t.dense, r.subheader && t.subheader];\n  }\n})({\n  listStyle: \"none\",\n  margin: 0,\n  padding: 0,\n  position: \"relative\",\n  variants: [{\n    props: ({\n      ownerState: e\n    }) => !e.disablePadding,\n    style: {\n      paddingTop: 8,\n      paddingBottom: 8\n    }\n  }, {\n    props: ({\n      ownerState: e\n    }) => e.subheader,\n    style: {\n      paddingTop: 0\n    }\n  }]\n}), ti = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiList\"\n  }), {\n    children: o,\n    className: i,\n    component: s = \"ul\",\n    dense: c = !1,\n    disablePadding: l = !1,\n    subheader: u,\n    ...p\n  } = n, m = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    dense: c\n  }), [c]), g = {\n    ...n,\n    component: s,\n    dense: c,\n    disablePadding: l\n  }, x = gm(g);\n  return /* @__PURE__ */ N.jsx(or.Provider, {\n    value: m,\n    children: /* @__PURE__ */ N.jsxs(ym, {\n      as: s,\n      className: se(x.root, i),\n      ref: r,\n      ownerState: g,\n      ...p,\n      children: [u, o]\n    })\n  });\n});\n true && (ti.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The content of the component.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * If `true`, compact vertical padding designed for keyboard and mouse input is used for\n   * the list and list items.\n   * The prop is available to descendant components as the `dense` context.\n   * @default false\n   */\n  dense: a.bool,\n  /**\n   * If `true`, vertical padding is removed from the list.\n   * @default false\n   */\n  disablePadding: a.bool,\n  /**\n   * The content of the subheader, normally `ListSubheader`.\n   */\n  subheader: a.node,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nfunction bm(e) {\n  return Ve(\"MuiListItemButton\", e);\n}\nconst mr = Fe(\"MuiListItemButton\", [\"root\", \"focusVisible\", \"dense\", \"alignItemsFlexStart\", \"disabled\", \"divider\", \"gutters\", \"selected\"]), vm = (e, t) => {\n  const {\n    ownerState: r\n  } = e;\n  return [t.root, r.dense && t.dense, r.alignItems === \"flex-start\" && t.alignItemsFlexStart, r.divider && t.divider, !r.disableGutters && t.gutters];\n}, xm = (e) => {\n  const {\n    alignItems: t,\n    classes: r,\n    dense: n,\n    disabled: o,\n    disableGutters: i,\n    divider: s,\n    selected: c\n  } = e, u = Ge({\n    root: [\"root\", n && \"dense\", !i && \"gutters\", s && \"divider\", o && \"disabled\", t === \"flex-start\" && \"alignItemsFlexStart\", c && \"selected\"]\n  }, bm, r);\n  return {\n    ...r,\n    ...u\n  };\n}, Sm = le($r, {\n  shouldForwardProp: (e) => ys(e) || e === \"classes\",\n  name: \"MuiListItemButton\",\n  slot: \"Root\",\n  overridesResolver: vm\n})(qe(({\n  theme: e\n}) => ({\n  display: \"flex\",\n  flexGrow: 1,\n  justifyContent: \"flex-start\",\n  alignItems: \"center\",\n  position: \"relative\",\n  textDecoration: \"none\",\n  minWidth: 0,\n  boxSizing: \"border-box\",\n  textAlign: \"left\",\n  paddingTop: 8,\n  paddingBottom: 8,\n  transition: e.transitions.create(\"background-color\", {\n    duration: e.transitions.duration.shortest\n  }),\n  \"&:hover\": {\n    textDecoration: \"none\",\n    backgroundColor: (e.vars || e).palette.action.hover,\n    // Reset on touch devices, it doesn't add specificity\n    \"@media (hover: none)\": {\n      backgroundColor: \"transparent\"\n    }\n  },\n  [`&.${mr.selected}`]: {\n    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : De(e.palette.primary.main, e.palette.action.selectedOpacity),\n    [`&.${mr.focusVisible}`]: {\n      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : De(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)\n    }\n  },\n  [`&.${mr.selected}:hover`]: {\n    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : De(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),\n    // Reset on touch devices, it doesn't add specificity\n    \"@media (hover: none)\": {\n      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : De(e.palette.primary.main, e.palette.action.selectedOpacity)\n    }\n  },\n  [`&.${mr.focusVisible}`]: {\n    backgroundColor: (e.vars || e).palette.action.focus\n  },\n  [`&.${mr.disabled}`]: {\n    opacity: (e.vars || e).palette.action.disabledOpacity\n  },\n  variants: [{\n    props: ({\n      ownerState: t\n    }) => t.divider,\n    style: {\n      borderBottom: `1px solid ${(e.vars || e).palette.divider}`,\n      backgroundClip: \"padding-box\"\n    }\n  }, {\n    props: {\n      alignItems: \"flex-start\"\n    },\n    style: {\n      alignItems: \"flex-start\"\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !t.disableGutters,\n    style: {\n      paddingLeft: 16,\n      paddingRight: 16\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.dense,\n    style: {\n      paddingTop: 4,\n      paddingBottom: 4\n    }\n  }]\n}))), ri = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiListItemButton\"\n  }), {\n    alignItems: o = \"center\",\n    autoFocus: i = !1,\n    component: s = \"div\",\n    children: c,\n    dense: l = !1,\n    disableGutters: u = !1,\n    divider: p = !1,\n    focusVisibleClassName: m,\n    selected: g = !1,\n    className: x,\n    ...y\n  } = n, f = react__WEBPACK_IMPORTED_MODULE_0__.useContext(or), S = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    dense: l || f.dense || !1,\n    alignItems: o,\n    disableGutters: u\n  }), [o, f.dense, l, u]), E = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  Ft(() => {\n    i && (E.current ? E.current.focus() :  true && console.error(\"MUI: Unable to set focus to a ListItemButton whose component has not been rendered.\"));\n  }, [i]);\n  const P = {\n    ...n,\n    alignItems: o,\n    dense: S.dense,\n    disableGutters: u,\n    divider: p,\n    selected: g\n  }, T = xm(P), b = at(E, r);\n  return /* @__PURE__ */ N.jsx(or.Provider, {\n    value: S,\n    children: /* @__PURE__ */ N.jsx(Sm, {\n      ref: b,\n      href: y.href || y.to,\n      component: (y.href || y.to) && s === \"div\" ? \"button\" : s,\n      focusVisibleClassName: se(T.focusVisible, m),\n      ownerState: P,\n      className: se(T.root, x),\n      ...y,\n      classes: T,\n      children: c\n    })\n  });\n});\n true && (ri.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Defines the `align-items` style property.\n   * @default 'center'\n   */\n  alignItems: a.oneOf([\"center\", \"flex-start\"]),\n  /**\n   * If `true`, the list item is focused during the first mount.\n   * Focus will also be triggered if the value changes from false to true.\n   * @default false\n   */\n  autoFocus: a.bool,\n  /**\n   * The content of the component if a `ListItemSecondaryAction` is used it must\n   * be the last child.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * If `true`, compact vertical padding designed for keyboard and mouse input is used.\n   * The prop defaults to the value inherited from the parent List component.\n   * @default false\n   */\n  dense: a.bool,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: a.bool,\n  /**\n   * If `true`, the left and right padding is removed.\n   * @default false\n   */\n  disableGutters: a.bool,\n  /**\n   * If `true`, a 1px light border is added to the bottom of the list item.\n   * @default false\n   */\n  divider: a.bool,\n  /**\n   * This prop can help identify which element has keyboard focus.\n   * The class name will be applied when the element gains the focus through keyboard interaction.\n   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).\n   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).\n   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components\n   * if needed.\n   */\n  focusVisibleClassName: a.string,\n  /**\n   * @ignore\n   */\n  href: a.string,\n  /**\n   * Use to apply selected styling.\n   * @default false\n   */\n  selected: a.bool,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nfunction Em(e) {\n  return Ve(\"MuiListItemIcon\", e);\n}\nFe(\"MuiListItemIcon\", [\"root\", \"alignItemsFlexStart\"]);\nconst Cm = (e) => {\n  const {\n    alignItems: t,\n    classes: r\n  } = e;\n  return Ge({\n    root: [\"root\", t === \"flex-start\" && \"alignItemsFlexStart\"]\n  }, Em, r);\n}, Tm = le(\"div\", {\n  name: \"MuiListItemIcon\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, r.alignItems === \"flex-start\" && t.alignItemsFlexStart];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  minWidth: 56,\n  color: (e.vars || e).palette.action.active,\n  flexShrink: 0,\n  display: \"inline-flex\",\n  variants: [{\n    props: {\n      alignItems: \"flex-start\"\n    },\n    style: {\n      marginTop: 8\n    }\n  }]\n}))), ni = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiListItemIcon\"\n  }), {\n    className: o,\n    ...i\n  } = n, s = react__WEBPACK_IMPORTED_MODULE_0__.useContext(or), c = {\n    ...n,\n    alignItems: s.alignItems\n  }, l = Cm(c);\n  return /* @__PURE__ */ N.jsx(Tm, {\n    className: se(l.root, o),\n    ownerState: c,\n    ref: r,\n    ...i\n  });\n});\n true && (ni.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The content of the component, normally `Icon`, `SvgIcon`,\n   * or a `@mui/icons-material` SVG icon element.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nfunction wm(e) {\n  return Ve(\"MuiListItemText\", e);\n}\nconst en = Fe(\"MuiListItemText\", [\"root\", \"multiline\", \"dense\", \"inset\", \"primary\", \"secondary\"]), Om = (e) => {\n  const {\n    classes: t,\n    inset: r,\n    primary: n,\n    secondary: o,\n    dense: i\n  } = e;\n  return Ge({\n    root: [\"root\", r && \"inset\", i && \"dense\", n && o && \"multiline\"],\n    primary: [\"primary\"],\n    secondary: [\"secondary\"]\n  }, wm, t);\n}, Rm = le(\"div\", {\n  name: \"MuiListItemText\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [{\n      [`& .${en.primary}`]: t.primary\n    }, {\n      [`& .${en.secondary}`]: t.secondary\n    }, t.root, r.inset && t.inset, r.primary && r.secondary && t.multiline, r.dense && t.dense];\n  }\n})({\n  flex: \"1 1 auto\",\n  minWidth: 0,\n  marginTop: 4,\n  marginBottom: 4,\n  [`.${sa.root}:where(& .${en.primary})`]: {\n    display: \"block\"\n  },\n  [`.${sa.root}:where(& .${en.secondary})`]: {\n    display: \"block\"\n  },\n  variants: [{\n    props: ({\n      ownerState: e\n    }) => e.primary && e.secondary,\n    style: {\n      marginTop: 6,\n      marginBottom: 6\n    }\n  }, {\n    props: ({\n      ownerState: e\n    }) => e.inset,\n    style: {\n      paddingLeft: 56\n    }\n  }]\n}), oi = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiListItemText\"\n  }), {\n    children: o,\n    className: i,\n    disableTypography: s = !1,\n    inset: c = !1,\n    primary: l,\n    primaryTypographyProps: u,\n    secondary: p,\n    secondaryTypographyProps: m,\n    slots: g = {},\n    slotProps: x = {},\n    ...y\n  } = n, {\n    dense: f\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(or);\n  let S = l ?? o, E = p;\n  const P = {\n    ...n,\n    disableTypography: s,\n    inset: c,\n    primary: !!S,\n    secondary: !!E,\n    dense: f\n  }, T = Om(P), b = {\n    slots: g,\n    slotProps: {\n      primary: u,\n      secondary: m,\n      ...x\n    }\n  }, [h, w] = Bt(\"primary\", {\n    className: T.primary,\n    elementType: bt,\n    externalForwardedProps: b,\n    ownerState: P\n  }), [k, L] = Bt(\"secondary\", {\n    className: T.secondary,\n    elementType: bt,\n    externalForwardedProps: b,\n    ownerState: P\n  });\n  return S != null && S.type !== bt && !s && (S = /* @__PURE__ */ N.jsx(h, {\n    variant: f ? \"body2\" : \"body1\",\n    component: w != null && w.variant ? void 0 : \"span\",\n    ...w,\n    children: S\n  })), E != null && E.type !== bt && !s && (E = /* @__PURE__ */ N.jsx(k, {\n    variant: \"body2\",\n    color: \"textSecondary\",\n    ...L,\n    children: E\n  })), /* @__PURE__ */ N.jsxs(Rm, {\n    className: se(T.root, i),\n    ownerState: P,\n    ref: r,\n    ...y,\n    children: [S, E]\n  });\n});\n true && (oi.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Alias for the `primary` prop.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * If `true`, the children won't be wrapped by a Typography component.\n   * This can be useful to render an alternative Typography variant by wrapping\n   * the `children` (or `primary`) text, and optional `secondary` text\n   * with the Typography component.\n   * @default false\n   */\n  disableTypography: a.bool,\n  /**\n   * If `true`, the children are indented.\n   * This should be used if there is no left avatar or left icon.\n   * @default false\n   */\n  inset: a.bool,\n  /**\n   * The main content element.\n   */\n  primary: a.node,\n  /**\n   * These props will be forwarded to the primary typography component\n   * (as long as disableTypography is not `true`).\n   * @deprecated Use `slotProps.primary` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  primaryTypographyProps: a.object,\n  /**\n   * The secondary content element.\n   */\n  secondary: a.node,\n  /**\n   * These props will be forwarded to the secondary typography component\n   * (as long as disableTypography is not `true`).\n   * @deprecated Use `slotProps.secondary` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  secondaryTypographyProps: a.object,\n  /**\n   * The props used for each slot inside.\n   * @default {}\n   */\n  slotProps: a.shape({\n    primary: a.oneOfType([a.func, a.object]),\n    secondary: a.oneOfType([a.func, a.object])\n  }),\n  /**\n   * The components used for each slot inside.\n   * @default {}\n   */\n  slots: a.shape({\n    primary: a.elementType,\n    secondary: a.elementType\n  }),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nfunction $m(e) {\n  return Ve(\"MuiTooltip\", e);\n}\nconst Ne = Fe(\"MuiTooltip\", [\"popper\", \"popperInteractive\", \"popperArrow\", \"popperClose\", \"tooltip\", \"tooltipArrow\", \"touch\", \"tooltipPlacementLeft\", \"tooltipPlacementRight\", \"tooltipPlacementTop\", \"tooltipPlacementBottom\", \"arrow\"]);\nfunction Pm(e) {\n  return Math.round(e * 1e5) / 1e5;\n}\nconst km = (e) => {\n  const {\n    classes: t,\n    disableInteractive: r,\n    arrow: n,\n    touch: o,\n    placement: i\n  } = e, s = {\n    popper: [\"popper\", !r && \"popperInteractive\", n && \"popperArrow\"],\n    tooltip: [\"tooltip\", n && \"tooltipArrow\", o && \"touch\", `tooltipPlacement${ee(i.split(\"-\")[0])}`],\n    arrow: [\"arrow\"]\n  };\n  return Ge(s, $m, t);\n}, Am = le(ei, {\n  name: \"MuiTooltip\",\n  slot: \"Popper\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.popper, !r.disableInteractive && t.popperInteractive, r.arrow && t.popperArrow, !r.open && t.popperClose];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  zIndex: (e.vars || e).zIndex.tooltip,\n  pointerEvents: \"none\",\n  variants: [{\n    props: ({\n      ownerState: t\n    }) => !t.disableInteractive,\n    style: {\n      pointerEvents: \"auto\"\n    }\n  }, {\n    props: ({\n      open: t\n    }) => !t,\n    style: {\n      pointerEvents: \"none\"\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.arrow,\n    style: {\n      [`&[data-popper-placement*=\"bottom\"] .${Ne.arrow}`]: {\n        top: 0,\n        marginTop: \"-0.71em\",\n        \"&::before\": {\n          transformOrigin: \"0 100%\"\n        }\n      },\n      [`&[data-popper-placement*=\"top\"] .${Ne.arrow}`]: {\n        bottom: 0,\n        marginBottom: \"-0.71em\",\n        \"&::before\": {\n          transformOrigin: \"100% 0\"\n        }\n      },\n      [`&[data-popper-placement*=\"right\"] .${Ne.arrow}`]: {\n        height: \"1em\",\n        width: \"0.71em\",\n        \"&::before\": {\n          transformOrigin: \"100% 100%\"\n        }\n      },\n      [`&[data-popper-placement*=\"left\"] .${Ne.arrow}`]: {\n        height: \"1em\",\n        width: \"0.71em\",\n        \"&::before\": {\n          transformOrigin: \"0 0\"\n        }\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.arrow && !t.isRtl,\n    style: {\n      [`&[data-popper-placement*=\"right\"] .${Ne.arrow}`]: {\n        left: 0,\n        marginLeft: \"-0.71em\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.arrow && !!t.isRtl,\n    style: {\n      [`&[data-popper-placement*=\"right\"] .${Ne.arrow}`]: {\n        right: 0,\n        marginRight: \"-0.71em\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.arrow && !t.isRtl,\n    style: {\n      [`&[data-popper-placement*=\"left\"] .${Ne.arrow}`]: {\n        right: 0,\n        marginRight: \"-0.71em\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.arrow && !!t.isRtl,\n    style: {\n      [`&[data-popper-placement*=\"left\"] .${Ne.arrow}`]: {\n        left: 0,\n        marginLeft: \"-0.71em\"\n      }\n    }\n  }]\n}))), Nm = le(\"div\", {\n  name: \"MuiTooltip\",\n  slot: \"Tooltip\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.tooltip, r.touch && t.touch, r.arrow && t.tooltipArrow, t[`tooltipPlacement${ee(r.placement.split(\"-\")[0])}`]];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  backgroundColor: e.vars ? e.vars.palette.Tooltip.bg : De(e.palette.grey[700], 0.92),\n  borderRadius: (e.vars || e).shape.borderRadius,\n  color: (e.vars || e).palette.common.white,\n  fontFamily: e.typography.fontFamily,\n  padding: \"4px 8px\",\n  fontSize: e.typography.pxToRem(11),\n  maxWidth: 300,\n  margin: 2,\n  wordWrap: \"break-word\",\n  fontWeight: e.typography.fontWeightMedium,\n  [`.${Ne.popper}[data-popper-placement*=\"left\"] &`]: {\n    transformOrigin: \"right center\"\n  },\n  [`.${Ne.popper}[data-popper-placement*=\"right\"] &`]: {\n    transformOrigin: \"left center\"\n  },\n  [`.${Ne.popper}[data-popper-placement*=\"top\"] &`]: {\n    transformOrigin: \"center bottom\",\n    marginBottom: \"14px\"\n  },\n  [`.${Ne.popper}[data-popper-placement*=\"bottom\"] &`]: {\n    transformOrigin: \"center top\",\n    marginTop: \"14px\"\n  },\n  variants: [{\n    props: ({\n      ownerState: t\n    }) => t.arrow,\n    style: {\n      position: \"relative\",\n      margin: 0\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.touch,\n    style: {\n      padding: \"8px 16px\",\n      fontSize: e.typography.pxToRem(14),\n      lineHeight: `${Pm(16 / 14)}em`,\n      fontWeight: e.typography.fontWeightRegular\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !t.isRtl,\n    style: {\n      [`.${Ne.popper}[data-popper-placement*=\"left\"] &`]: {\n        marginRight: \"14px\"\n      },\n      [`.${Ne.popper}[data-popper-placement*=\"right\"] &`]: {\n        marginLeft: \"14px\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !t.isRtl && t.touch,\n    style: {\n      [`.${Ne.popper}[data-popper-placement*=\"left\"] &`]: {\n        marginRight: \"24px\"\n      },\n      [`.${Ne.popper}[data-popper-placement*=\"right\"] &`]: {\n        marginLeft: \"24px\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !!t.isRtl,\n    style: {\n      [`.${Ne.popper}[data-popper-placement*=\"left\"] &`]: {\n        marginLeft: \"14px\"\n      },\n      [`.${Ne.popper}[data-popper-placement*=\"right\"] &`]: {\n        marginRight: \"14px\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !!t.isRtl && t.touch,\n    style: {\n      [`.${Ne.popper}[data-popper-placement*=\"left\"] &`]: {\n        marginLeft: \"24px\"\n      },\n      [`.${Ne.popper}[data-popper-placement*=\"right\"] &`]: {\n        marginRight: \"24px\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.touch,\n    style: {\n      [`.${Ne.popper}[data-popper-placement*=\"top\"] &`]: {\n        marginBottom: \"24px\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.touch,\n    style: {\n      [`.${Ne.popper}[data-popper-placement*=\"bottom\"] &`]: {\n        marginTop: \"24px\"\n      }\n    }\n  }]\n}))), Mm = le(\"span\", {\n  name: \"MuiTooltip\",\n  slot: \"Arrow\",\n  overridesResolver: (e, t) => t.arrow\n})(qe(({\n  theme: e\n}) => ({\n  overflow: \"hidden\",\n  position: \"absolute\",\n  width: \"1em\",\n  height: \"0.71em\",\n  boxSizing: \"border-box\",\n  color: e.vars ? e.vars.palette.Tooltip.bg : De(e.palette.grey[700], 0.9),\n  \"&::before\": {\n    content: '\"\"',\n    margin: \"auto\",\n    display: \"block\",\n    width: \"100%\",\n    height: \"100%\",\n    backgroundColor: \"currentColor\",\n    transform: \"rotate(45deg)\"\n  }\n})));\nlet tn = !1;\nconst va = new Vn();\nlet hr = {\n  x: 0,\n  y: 0\n};\nfunction rn(e, t) {\n  return (r, ...n) => {\n    t && t(r, ...n), e(r, ...n);\n  };\n}\nconst js = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiTooltip\"\n  }), {\n    arrow: o = !1,\n    children: i,\n    classes: s,\n    components: c = {},\n    componentsProps: l = {},\n    describeChild: u = !1,\n    disableFocusListener: p = !1,\n    disableHoverListener: m = !1,\n    disableInteractive: g = !1,\n    disableTouchListener: x = !1,\n    enterDelay: y = 100,\n    enterNextDelay: f = 0,\n    enterTouchDelay: S = 700,\n    followCursor: E = !1,\n    id: P,\n    leaveDelay: T = 0,\n    leaveTouchDelay: b = 1500,\n    onClose: h,\n    onOpen: w,\n    open: k,\n    placement: L = \"bottom\",\n    PopperComponent: B,\n    PopperProps: d = {},\n    slotProps: A = {},\n    slots: D = {},\n    title: j,\n    TransitionComponent: W,\n    TransitionProps: z,\n    ...U\n  } = n, V = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(i) ? i : /* @__PURE__ */ N.jsx(\"span\", {\n    children: i\n  }), te = Lr(), F = is(), [R, I] = react__WEBPACK_IMPORTED_MODULE_0__.useState(), [J, Q] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), H = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!1), X = g || E, _ = Dt(), q = Dt(), G = Dt(), re = Dt(), [Z, ae] = Vu({\n    controlled: k,\n    default: !1,\n    name: \"Tooltip\",\n    state: \"open\"\n  });\n  let O = Z;\n  if (true) {\n    const {\n      current: ne\n    } = react__WEBPACK_IMPORTED_MODULE_0__.useRef(k !== void 0);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      R && R.disabled && !ne && j !== \"\" && R.tagName.toLowerCase() === \"button\" && console.warn([\"MUI: You are providing a disabled `button` child to the Tooltip component.\", \"A disabled element does not fire events.\", \"Tooltip needs to listen to the child element's events to display the title.\", \"\", \"Add a simple wrapper element, such as a `span`.\"].join(`\n`));\n    }, [j, R, ne]);\n  }\n  const ye = Qa(P), Ee = react__WEBPACK_IMPORTED_MODULE_0__.useRef(), Me = Qt(() => {\n    Ee.current !== void 0 && (document.body.style.WebkitUserSelect = Ee.current, Ee.current = void 0), re.clear();\n  });\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => Me, [Me]);\n  const Qe = (ne) => {\n    va.clear(), tn = !0, ae(!0), w && !O && w(ne);\n  }, ve = Qt(\n    /**\n     * @param {React.SyntheticEvent | Event} event\n     */\n    (ne) => {\n      va.start(800 + T, () => {\n        tn = !1;\n      }), ae(!1), h && O && h(ne), _.start(te.transitions.duration.shortest, () => {\n        H.current = !1;\n      });\n    }\n  ), Pe = (ne) => {\n    H.current && ne.type !== \"touchstart\" || (R && R.removeAttribute(\"title\"), q.clear(), G.clear(), y || tn && f ? q.start(tn ? f : y, () => {\n      Qe(ne);\n    }) : Qe(ne));\n  }, ze = (ne) => {\n    q.clear(), G.start(T, () => {\n      ve(ne);\n    });\n  }, [, Le] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1), v = (ne) => {\n    hn(ne.target) || (Le(!1), ze(ne));\n  }, M = (ne) => {\n    R || I(ne.currentTarget), hn(ne.target) && (Le(!0), Pe(ne));\n  }, Y = (ne) => {\n    H.current = !0;\n    const ft = V.props;\n    ft.onTouchStart && ft.onTouchStart(ne);\n  }, oe = (ne) => {\n    Y(ne), G.clear(), _.clear(), Me(), Ee.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = \"none\", re.start(S, () => {\n      document.body.style.WebkitUserSelect = Ee.current, Pe(ne);\n    });\n  }, Re = (ne) => {\n    V.props.onTouchEnd && V.props.onTouchEnd(ne), Me(), G.start(b, () => {\n      ve(ne);\n    });\n  };\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!O)\n      return;\n    function ne(ft) {\n      ft.key === \"Escape\" && ve(ft);\n    }\n    return document.addEventListener(\"keydown\", ne), () => {\n      document.removeEventListener(\"keydown\", ne);\n    };\n  }, [ve, O]);\n  const ue = at(Bo(V), I, r);\n  !j && j !== 0 && (O = !1);\n  const K = react__WEBPACK_IMPORTED_MODULE_0__.useRef(), be = (ne) => {\n    const ft = V.props;\n    ft.onMouseMove && ft.onMouseMove(ne), hr = {\n      x: ne.clientX,\n      y: ne.clientY\n    }, K.current && K.current.update();\n  }, we = {}, Oe = typeof j == \"string\";\n  u ? (we.title = !O && Oe && !m ? j : null, we[\"aria-describedby\"] = O ? ye : null) : (we[\"aria-label\"] = Oe ? j : null, we[\"aria-labelledby\"] = O && !Oe ? ye : null);\n  const ce = {\n    ...we,\n    ...U,\n    ...V.props,\n    className: se(U.className, V.props.className),\n    onTouchStart: Y,\n    ref: ue,\n    ...E ? {\n      onMouseMove: be\n    } : {}\n  };\n   true && (ce[\"data-mui-internal-clone-element\"] = !0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    R && !R.getAttribute(\"data-mui-internal-clone-element\") && console.error([\"MUI: The `children` component of the Tooltip is not forwarding its props correctly.\", \"Please make sure that props are spread on the same element that the ref is applied to.\"].join(`\n`));\n  }, [R]));\n  const Ie = {};\n  x || (ce.onTouchStart = oe, ce.onTouchEnd = Re), m || (ce.onMouseOver = rn(Pe, ce.onMouseOver), ce.onMouseLeave = rn(ze, ce.onMouseLeave), X || (Ie.onMouseOver = Pe, Ie.onMouseLeave = ze)), p || (ce.onFocus = rn(M, ce.onFocus), ce.onBlur = rn(v, ce.onBlur), X || (Ie.onFocus = M, Ie.onBlur = v)),  true && V.props.title && console.error([\"MUI: You have provided a `title` prop to the child of <Tooltip />.\", `Remove this title prop \\`${V.props.title}\\` or the Tooltip component.`].join(`\n`));\n  const We = {\n    ...n,\n    isRtl: F,\n    arrow: o,\n    disableInteractive: X,\n    placement: L,\n    PopperComponentProp: B,\n    touch: H.current\n  }, Ue = typeof A.popper == \"function\" ? A.popper(We) : A.popper, ut = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    var ft, ii;\n    let ne = [{\n      name: \"arrow\",\n      enabled: !!J,\n      options: {\n        element: J,\n        padding: 4\n      }\n    }];\n    return (ft = d.popperOptions) != null && ft.modifiers && (ne = ne.concat(d.popperOptions.modifiers)), (ii = Ue == null ? void 0 : Ue.popperOptions) != null && ii.modifiers && (ne = ne.concat(Ue.popperOptions.modifiers)), {\n      ...d.popperOptions,\n      ...Ue == null ? void 0 : Ue.popperOptions,\n      modifiers: ne\n    };\n  }, [J, d.popperOptions, Ue == null ? void 0 : Ue.popperOptions]), Un = km(We), Bs = typeof A.transition == \"function\" ? A.transition(We) : A.transition, zr = {\n    slots: {\n      popper: c.Popper,\n      transition: c.Transition ?? W,\n      tooltip: c.Tooltip,\n      arrow: c.Arrow,\n      ...D\n    },\n    slotProps: {\n      arrow: A.arrow ?? l.arrow,\n      popper: {\n        ...d,\n        ...Ue ?? l.popper\n      },\n      // resolvedPopperProps can be spread because it's already an object\n      tooltip: A.tooltip ?? l.tooltip,\n      transition: {\n        ...z,\n        ...Bs ?? l.transition\n      }\n    }\n  }, [Vs, Fs] = Bt(\"popper\", {\n    elementType: Am,\n    externalForwardedProps: zr,\n    ownerState: We,\n    className: se(Un.popper, d == null ? void 0 : d.className)\n  }), [zs, Ws] = Bt(\"transition\", {\n    elementType: On,\n    externalForwardedProps: zr,\n    ownerState: We\n  }), [Us, Ys] = Bt(\"tooltip\", {\n    elementType: Nm,\n    className: Un.tooltip,\n    externalForwardedProps: zr,\n    ownerState: We\n  }), [Hs, qs] = Bt(\"arrow\", {\n    elementType: Mm,\n    className: Un.arrow,\n    externalForwardedProps: zr,\n    ownerState: We,\n    ref: Q\n  });\n  return /* @__PURE__ */ N.jsxs(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: [/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(V, ce), /* @__PURE__ */ N.jsx(Vs, {\n      as: B ?? ei,\n      placement: L,\n      anchorEl: E ? {\n        getBoundingClientRect: () => ({\n          top: hr.y,\n          left: hr.x,\n          right: hr.x,\n          bottom: hr.y,\n          width: 0,\n          height: 0\n        })\n      } : R,\n      popperRef: K,\n      open: R ? O : !1,\n      id: ye,\n      transition: !0,\n      ...Ie,\n      ...Fs,\n      popperOptions: ut,\n      children: ({\n        TransitionProps: ne\n      }) => /* @__PURE__ */ N.jsx(zs, {\n        timeout: te.transitions.duration.shorter,\n        ...ne,\n        ...Ws,\n        children: /* @__PURE__ */ N.jsxs(Us, {\n          ...Ys,\n          children: [j, o ? /* @__PURE__ */ N.jsx(Hs, {\n            ...qs\n          }) : null]\n        })\n      })\n    })]\n  });\n});\n true && (js.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * If `true`, adds an arrow to the tooltip.\n   * @default false\n   */\n  arrow: a.bool,\n  /**\n   * Tooltip reference element.\n   */\n  children: jo.isRequired,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The components used for each slot inside.\n   *\n   * @deprecated use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   *\n   * @default {}\n   */\n  components: a.shape({\n    Arrow: a.elementType,\n    Popper: a.elementType,\n    Tooltip: a.elementType,\n    Transition: a.elementType\n  }),\n  /**\n   * The extra props for the slot components.\n   * You can override the existing props or add new ones.\n   *\n   * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   *\n   * @default {}\n   */\n  componentsProps: a.shape({\n    arrow: a.object,\n    popper: a.object,\n    tooltip: a.object,\n    transition: a.object\n  }),\n  /**\n   * Set to `true` if the `title` acts as an accessible description.\n   * By default the `title` acts as an accessible label for the child.\n   * @default false\n   */\n  describeChild: a.bool,\n  /**\n   * Do not respond to focus-visible events.\n   * @default false\n   */\n  disableFocusListener: a.bool,\n  /**\n   * Do not respond to hover events.\n   * @default false\n   */\n  disableHoverListener: a.bool,\n  /**\n   * Makes a tooltip not interactive, i.e. it will close when the user\n   * hovers over the tooltip before the `leaveDelay` is expired.\n   * @default false\n   */\n  disableInteractive: a.bool,\n  /**\n   * Do not respond to long press touch events.\n   * @default false\n   */\n  disableTouchListener: a.bool,\n  /**\n   * The number of milliseconds to wait before showing the tooltip.\n   * This prop won't impact the enter touch delay (`enterTouchDelay`).\n   * @default 100\n   */\n  enterDelay: a.number,\n  /**\n   * The number of milliseconds to wait before showing the tooltip when one was already recently opened.\n   * @default 0\n   */\n  enterNextDelay: a.number,\n  /**\n   * The number of milliseconds a user must touch the element before showing the tooltip.\n   * @default 700\n   */\n  enterTouchDelay: a.number,\n  /**\n   * If `true`, the tooltip follow the cursor over the wrapped element.\n   * @default false\n   */\n  followCursor: a.bool,\n  /**\n   * This prop is used to help implement the accessibility logic.\n   * If you don't provide this prop. It falls back to a randomly generated id.\n   */\n  id: a.string,\n  /**\n   * The number of milliseconds to wait before hiding the tooltip.\n   * This prop won't impact the leave touch delay (`leaveTouchDelay`).\n   * @default 0\n   */\n  leaveDelay: a.number,\n  /**\n   * The number of milliseconds after the user stops touching an element before hiding the tooltip.\n   * @default 1500\n   */\n  leaveTouchDelay: a.number,\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback.\n   */\n  onClose: a.func,\n  /**\n   * Callback fired when the component requests to be open.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback.\n   */\n  onOpen: a.func,\n  /**\n   * If `true`, the component is shown.\n   */\n  open: a.bool,\n  /**\n   * Tooltip placement.\n   * @default 'bottom'\n   */\n  placement: a.oneOf([\"bottom-end\", \"bottom-start\", \"bottom\", \"left-end\", \"left-start\", \"left\", \"right-end\", \"right-start\", \"right\", \"top-end\", \"top-start\", \"top\"]),\n  /**\n   * The component used for the popper.\n   * @deprecated use the `slots.popper` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  PopperComponent: a.elementType,\n  /**\n   * Props applied to the [`Popper`](https://mui.com/material-ui/api/popper/) element.\n   * @deprecated use the `slotProps.popper` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   * @default {}\n   */\n  PopperProps: a.object,\n  /**\n   * The props used for each slot inside.\n   * @default {}\n   */\n  slotProps: a.shape({\n    arrow: a.oneOfType([a.func, a.object]),\n    popper: a.oneOfType([a.func, a.object]),\n    tooltip: a.oneOfType([a.func, a.object]),\n    transition: a.oneOfType([a.func, a.object])\n  }),\n  /**\n   * The components used for each slot inside.\n   * @default {}\n   */\n  slots: a.shape({\n    arrow: a.elementType,\n    popper: a.elementType,\n    tooltip: a.elementType,\n    transition: a.elementType\n  }),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * Tooltip title. Zero-length titles string, undefined, null and false are never displayed.\n   */\n  title: a.node,\n  /**\n   * The component used for the transition.\n   * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.\n   * @deprecated use the `slots.transition` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  TransitionComponent: a.elementType,\n  /**\n   * Props applied to the transition element.\n   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.\n   * @deprecated use the `slotProps.transition` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   * @default {}\n   */\n  TransitionProps: a.object\n});\nconst Im = sr(/* @__PURE__ */ N.jsx(\"path\", {\n  d: \"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8m0-12.5c-2.49 0-4.5 2.01-4.5 4.5s2.01 4.5 4.5 4.5 4.5-2.01 4.5-4.5-2.01-4.5-4.5-4.5m0 5.5c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1\"\n}), \"AlbumOutlined\"), _m = ({\n  userName: e = \"\",\n  designation: t = \"\",\n  userimg: r = \"\",\n  isCollapse: n = !1,\n  onLogout: o\n}) => {\n  const i = Lr();\n  return /* @__PURE__ */ N.jsx(dt, { children: n ? \"\" : /* @__PURE__ */ N.jsxs(\n    dt,\n    {\n      display: \"flex\",\n      alignItems: \"center\",\n      gap: 2,\n      sx: {\n        m: 3,\n        p: 2,\n        borderRadius: \"8px\",\n        bgcolor: i.palette.secondary.main + 20\n      },\n      children: [\n        /* @__PURE__ */ N.jsx(_s, { alt: \"Remy Sharp\", src: r }),\n        /* @__PURE__ */ N.jsxs(dt, { children: [\n          /* @__PURE__ */ N.jsx(bt, { variant: \"h6\", children: e }),\n          /* @__PURE__ */ N.jsx(bt, { variant: \"caption\", children: t })\n        ] }),\n        /* @__PURE__ */ N.jsx(dt, { sx: { ml: \"auto\" }, onClick: o, children: /* @__PURE__ */ N.jsx(js, { title: \"Logout\", placement: \"top\", children: /* @__PURE__ */ N.jsx(Cs, { color: \"primary\", \"aria-label\": \"logout\", size: \"small\", children: /* @__PURE__ */ N.jsx(Im, {}) }) }) })\n      ]\n    }\n  ) });\n}, Fr = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  width: \"270px\",\n  collapsewidth: \"80px\",\n  textColor: \"#8D939D\",\n  isCollapse: !1,\n  themeColor: \"#5d87ff\"\n});\nlet jm = () => {\n  alert(\"Logout Successfully\");\n};\nconst Um = ({\n  children: e,\n  width: t = \"260px\",\n  collapsewidth: r = \"80px\",\n  textColor: n = \"#2b2b2b\",\n  isCollapse: o = !1,\n  themeColor: i = \"#5d87ff\",\n  themeSecondaryColor: s = \"#49beff\",\n  mode: c = \"light\",\n  direction: l = \"ltr\",\n  userName: u = \"Mathew\",\n  designation: p = \"Designer\",\n  showProfile: m = !0,\n  userimg: g = \"https://bootstrapdemos.adminmart.com/modernize/dist/assets/images/profile/user-1.jpg\",\n  onLogout: x = jm\n}) => {\n  const [y, f] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1), S = o && !y ? r : t, E = Fn({\n    direction: l,\n    palette: {\n      mode: c,\n      primary: {\n        main: i\n      },\n      secondary: {\n        main: s,\n        contrastText: \"#fff\"\n      }\n    }\n  });\n  return c === \"dark\" && (n = \"rgba(255,255,255, 0.9)\"), /* @__PURE__ */ N.jsx(zf, { theme: E, children: /* @__PURE__ */ N.jsx(\n    dt,\n    {\n      dir: l,\n      sx: {\n        width: S,\n        flexShrink: 0,\n        fontFamily: \"inherit\",\n        color: n\n      },\n      children: /* @__PURE__ */ N.jsxs(dt, { sx: { width: S }, children: [\n        /* @__PURE__ */ N.jsx(\n          Fr.Provider,\n          {\n            value: { textColor: n, isCollapse: o, width: t, collapsewidth: r, themeColor: i },\n            children: e\n          }\n        ),\n        m ? /* @__PURE__ */ N.jsx(\n          _m,\n          {\n            userName: u,\n            designation: p,\n            userimg: g,\n            isCollapse: o,\n            onLogout: x\n          }\n        ) : null\n      ] })\n    }\n  ) });\n}, Ym = ({ children: e, subHeading: t = \"menu\" }) => {\n  const r = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Fr);\n  return /* @__PURE__ */ N.jsx(dt, { sx: { px: r.isCollapse ? 2 : 3, pt: 2 }, children: /* @__PURE__ */ N.jsx(\n    ti,\n    {\n      component: \"nav\",\n      subheader: /* @__PURE__ */ N.jsx(\n        wn,\n        {\n          component: \"div\",\n          sx: {\n            paddingY: \"3px\",\n            color: r.textColor,\n            paddingX: \"0px\",\n            lineHeight: \"20px\",\n            fontWeight: \"bold\",\n            fontSize: \"12px\",\n            background: \"transparent\"\n          },\n          children: r.isCollapse ? \"...\" : t\n        }\n      ),\n      children: e\n    }\n  ) });\n}, Dm = sr(/* @__PURE__ */ N.jsx(\"path\", {\n  d: \"m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z\"\n}), \"ExpandLess\"), Lm = sr(/* @__PURE__ */ N.jsx(\"path\", {\n  d: \"M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z\"\n}), \"ExpandMore\"), Ds = sr(/* @__PURE__ */ N.jsx(\"path\", {\n  d: \"M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2m0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8\"\n}), \"CircleOutlined\"), Hm = ({\n  children: e,\n  title: t = \"\",\n  icon: r,\n  borderRadius: n = \"8px\",\n  textFontSize: o = \"14px\",\n  disabled: i = !1\n}) => {\n  const s = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Fr), [c, l] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1), u = () => {\n    l(!c);\n  }, p = le(ri)(() => ({\n    whiteSpace: \"nowrap\",\n    marginBottom: \"2px\",\n    padding: \"10px 12px\",\n    borderRadius: n,\n    color: c ? \"#fff\" : s.textColor,\n    cursor: i ? \"default\" : \"pointer\",\n    opacity: i ? \"0.6\" : \"1\",\n    backgroundColor: c ? s.themeColor : \"\",\n    \".MuiListItemIcon-root\": {\n      color: c ? \"#fff\" : s.textColor\n    },\n    \"&:hover\": {\n      backgroundColor: c ? s.themeColor : s.themeColor + 20,\n      color: c ? \"#fff\" : s.themeColor,\n      \".MuiListItemIcon-root\": {\n        color: c ? \"#fff\" : s.themeColor\n      }\n    }\n  })), m = le(ni)(() => ({\n    display: \"flex\",\n    gap: \"10px\",\n    marginBottom: \"0px\",\n    padding: \"0px\",\n    minWidth: \"30px\",\n    cursor: \"pointer\",\n    color: \"inherit\"\n  }));\n  return /* @__PURE__ */ N.jsxs(dt, { children: [\n    /* @__PURE__ */ N.jsxs(p, { onClick: u, sx: { display: \"flex\", gap: \"15px\" }, children: [\n      /* @__PURE__ */ N.jsx(m, { style: { minWidth: \"0px\" }, children: r || /* @__PURE__ */ N.jsx(Ds, {}) }),\n      !s.isCollapse && /* @__PURE__ */ N.jsxs(N.Fragment, { children: [\n        /* @__PURE__ */ N.jsx(oi, { sx: { my: 0 }, children: /* @__PURE__ */ N.jsx(bt, { fontSize: o, sx: { lineHeight: \"1\" }, variant: \"caption\", children: t }) }),\n        c ? /* @__PURE__ */ N.jsx(Dm, {}) : /* @__PURE__ */ N.jsx(Lm, {})\n      ] })\n    ] }),\n    /* @__PURE__ */ N.jsx(xn, { in: c, timeout: \"auto\", unmountOnExit: !0, children: /* @__PURE__ */ N.jsx(ti, { component: \"div\", disablePadding: !0, children: e }) })\n  ] });\n}, Ls = ({\n  component: e = \"a\",\n  children: t,\n  ...r\n}) => /* @__PURE__ */ N.jsx(e, { ...r, style: { textDecoration: \"none\" }, children: t }), qm = ({\n  children: e,\n  icon: t,\n  component: r,\n  badge: n = !1,\n  link: o = \"/\",\n  badgeColor: i = \"secondary\",\n  badgeContent: s = \"6\",\n  badgeTextColor: c = \"#fff\",\n  textFontSize: l = \"14px\",\n  borderRadius: u = \"8px\",\n  disabled: p = !1,\n  badgeType: m = \"filled\",\n  target: g = \"\",\n  isSelected: x = !1\n}) => {\n  const y = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Fr), f = Lr(), S = le(ri)(() => ({\n    whiteSpace: \"nowrap\",\n    marginBottom: \"2px\",\n    padding: \"10px 12px\",\n    width: \"100%\",\n    textAlign: f.direction === \"ltr\" ? \"left\" : \"right\",\n    borderRadius: u,\n    color: y.textColor,\n    cursor: p ? \"default\" : \"pointer\",\n    opacity: p ? \"0.6\" : \"1\",\n    \".MuiListItemIcon-root\": {\n      color: y.textColor\n    },\n    \"&:hover\": {\n      backgroundColor: p ? \"#fff\" : y.themeColor + 20,\n      color: y.themeColor,\n      \".MuiListItemIcon-root\": {\n        color: y.themeColor\n      }\n    },\n    \"&.Mui-selected\": {\n      color: \"white\",\n      backgroundColor: y.themeColor,\n      \"&:hover\": {\n        backgroundColor: y.themeColor,\n        color: \"white\"\n      },\n      \".MuiListItemIcon-root\": {\n        color: \"#fff\"\n      }\n    }\n  })), E = le(ni)(() => ({\n    display: \"flex\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    gap: \"10px\",\n    marginBottom: \"0px\",\n    padding: \"0px\",\n    cursor: \"pointer\",\n    color: \"inherit\"\n  }));\n  return /* @__PURE__ */ N.jsx(dt, { children: /* @__PURE__ */ N.jsx(Ls, { component: r, href: o, to: o, children: /* @__PURE__ */ N.jsxs(\n    S,\n    {\n      sx: { display: \"flex\", gap: \"15px\" },\n      target: g,\n      selected: !!x,\n      children: [\n        /* @__PURE__ */ N.jsx(\n          E,\n          {\n            sx: {\n              minWidth: \"0px\"\n            },\n            children: t || /* @__PURE__ */ N.jsx(Ds, {})\n          }\n        ),\n        y.isCollapse ? null : /* @__PURE__ */ N.jsxs(N.Fragment, { children: [\n          /* @__PURE__ */ N.jsx(oi, { sx: { my: 0 }, children: /* @__PURE__ */ N.jsx(\n            bt,\n            {\n              fontSize: l,\n              sx: { lineHeight: \"1\" },\n              variant: \"caption\",\n              children: e\n            }\n          ) }),\n          n && /* @__PURE__ */ N.jsx(\n            Is,\n            {\n              label: s,\n              color: i,\n              variant: m,\n              size: \"small\",\n              sx: { color: c }\n            }\n          )\n        ] })\n      ]\n    }\n  ) }) });\n}, Gm = ({\n  children: e,\n  img: t = \"https://adminmart.com/wp-content/uploads/2024/03/logo-admin-mart-news.png\",\n  href: r = \"/\",\n  component: n\n}) => {\n  const o = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Fr), i = le(\"span\")(() => ({\n    whiteSpace: \"nowrap\",\n    overflow: o.isCollapse ? \"hidden\" : \"visible\",\n    WebkitLineClamp: \"1\",\n    display: \"block\",\n    padding: \"15px 22px\",\n    textOverflow: \"ellipsis\"\n  }));\n  return /* @__PURE__ */ N.jsx(Ls, { href: r, component: n, to: r, children: /* @__PURE__ */ N.jsx(i, { children: t === \"\" ? /* @__PURE__ */ N.jsx(bt, { variant: \"body1\", children: e }) : /* @__PURE__ */ N.jsx(\n    dt,\n    {\n      component: \"img\",\n      sx: {\n        display: \"flex\",\n        alignItems: \"center\"\n      },\n      src: t\n    }\n  ) }) });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbXVpLXNpZGViYXIvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUMyQjtBQUM4RjtBQUN6RjtBQUNMO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxtQkFBbUIsT0FBTyxVQUFVO0FBQ3BDLG9CQUFvQixPQUFPLFVBQVU7QUFDckMsb0JBQW9CLE9BQU8sVUFBVTtBQUNyQyxxQkFBcUIsT0FBTyxVQUFVO0FBQ3RDLHFCQUFxQixPQUFPLFdBQVc7QUFDdkMsOEJBQThCLE9BQU8sVUFBVTtBQUMvQyx3QkFBd0IsT0FBTyxXQUFXO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3REFBd0QsdUNBQXVDO0FBQy9GO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU8sc0NBQXNDLDZCQUE2QixnQkFBZ0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwrQkFBK0IsOENBQThDLE1BQU0sYUFBYSx5Q0FBeUMsZ0NBQWdDLE9BQU87QUFDaEw7QUFDQTtBQUNBLE9BQU8sVUFBVTtBQUNqQjtBQUNBO0FBQ0EsV0FBVyxVQUFVLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBRTtBQUNkO0FBQ0EseUlBQXlJLFNBQVM7QUFDbEo7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFxQyxHQUFHLENBQWlCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTtBQUNoRSxzRkFBc0YsSUFBSSxRQUFRLEdBQUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtRkFBbUY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVCQUF1QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFILEdBQUc7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRix3Q0FBd0M7QUFDbEk7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLE9BQU87QUFDckYsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQkFBMEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFVBQVU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2REFBNkQ7QUFDdEY7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixtQkFBbUI7QUFDM0c7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGNBQWM7QUFDOUUsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsRUFBRTtBQUN4RDtBQUNBO0FBQ0Esc0RBQXNELEVBQUU7QUFDeEQ7QUFDQTtBQUNBLHNEQUFzRCxFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxjQUFjO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxXQUFXLGFBQWEsU0FBUyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBcUMsR0FBRyxDQUFpQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaURBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FB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QUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQXFDO0FBQ3BEO0FBQ0EsRUFBRSxFQUFFLENBQUU7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFxQztBQUNwRDtBQUNBLEVBQUUsRUFBRSxDQUFFO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBcUM7QUFDcEQ7QUFDQSxFQUFFLEVBQUUsQ0FBRTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFLEVBQUUseUJBQXlCO0FBQ2xELFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FB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O0FBQ3J0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFxQyxJQUFJLGdEQUFlO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtFQUErRSxZQUFZLHVCQUF1QixXQUFXLGFBQWEsV0FBVztBQUNySjtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxQ0FBcUMsSUFBSSxtQ0FBbUM7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQyxzQ0FBc0MsSUFBSSxtQ0FBbUM7QUFDNUg7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyx5QkFBeUIsNkNBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBVSxpREFBaUQsaURBQWdCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdURBQXVELE1BQU07QUFDN0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtGQUFrRixZQUFZO0FBQzlGO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUssdUVBQXVFO0FBQzVFO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCLDZDQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEJBQTBCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLDBHQUEwRyxjQUFjO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0QsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUErQjtBQUMzQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSx3QkFBd0IsNkNBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdURBQXVELFlBQVk7QUFDbkU7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQywwQkFBMEIsNkNBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCLDJDQUFVO0FBQzNCLFNBQVMsNENBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDJCQUEyQiw2Q0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyx3QkFBd0IsNkNBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxTQUFTLDBDQUFTO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsUUFBUSxZQUFZO0FBQ3BCLHNDQUFzQyxvQ0FBb0MsSUFBSSxzQ0FBc0M7QUFDcEgsVUFBVSxnQkFBZ0I7QUFDMUIsd0NBQXdDLG9DQUFvQyxTQUFTLHVDQUF1QyxJQUFJLG1DQUFtQztBQUNuSztBQUNBLEdBQUc7QUFDSCxRQUFRLFlBQVk7QUFDcEIsc0NBQXNDLG9DQUFvQyxTQUFTLHVDQUF1QyxJQUFJLG1DQUFtQztBQUNqSztBQUNBO0FBQ0Esd0NBQXdDLG9DQUFvQyxJQUFJLHNDQUFzQztBQUN0SDtBQUNBLEdBQUc7QUFDSCxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBLEdBQUc7QUFDSCxRQUFRLFlBQVk7QUFDcEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUNBQWlDLDhCQUE4QjtBQUMvRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLDBCQUEwQiw2Q0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksU0FBUyw2Q0FBWSxVQUFVLDBDQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNEJBQTRCLHlDQUFRO0FBQ3ZDO0FBQ0EsMENBQTBDLEtBQXFDO0FBQy9FLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQywwQkFBMEIsNkNBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJLFNBQVMsNkNBQVk7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBT0UiLCJzb3VyY2VzIjpbIi9ob21lL3JlbmF0by9Eb2N1bWVudHMvcG9ydGFsX2NvbnN1bC9mcm9udGVuZC9ub2RlX21vZHVsZXMvcmVhY3QtbXVpLXNpZGViYXIvZGlzdC9pbmRleC5lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgR3MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgS3MgPSAoZSwgdCwgcikgPT4gdCBpbiBlID8gR3MoZSwgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogciB9KSA6IGVbdF0gPSByO1xudmFyIGNyID0gKGUsIHQsIHIpID0+IEtzKGUsIHR5cGVvZiB0ICE9IFwic3ltYm9sXCIgPyB0ICsgXCJcIiA6IHQsIHIpO1xuaW1wb3J0ICogYXMgQyBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB5dCwgeyBmb3J3YXJkUmVmIGFzIFhzLCB1c2VDb250ZXh0IGFzIEpzLCBDaGlsZHJlbiBhcyBRcywgaXNWYWxpZEVsZW1lbnQgYXMgbm4sIGNsb25lRWxlbWVudCBhcyBvbiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgWnMgZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IFdyIGZyb20gXCJyZWFjdC1kb21cIjtcbmZ1bmN0aW9uIGVjKGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBcImRlZmF1bHRcIikgPyBlLmRlZmF1bHQgOiBlO1xufVxudmFyIFVyID0geyBleHBvcnRzOiB7fSB9LCBsciA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBhaTtcbmZ1bmN0aW9uIHRjKCkge1xuICBpZiAoYWkpIHJldHVybiBscjtcbiAgYWkgPSAxO1xuICB2YXIgZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSwgdCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTtcbiAgZnVuY3Rpb24gcihuLCBvLCBpKSB7XG4gICAgdmFyIHMgPSBudWxsO1xuICAgIGlmIChpICE9PSB2b2lkIDAgJiYgKHMgPSBcIlwiICsgaSksIG8ua2V5ICE9PSB2b2lkIDAgJiYgKHMgPSBcIlwiICsgby5rZXkpLCBcImtleVwiIGluIG8pIHtcbiAgICAgIGkgPSB7fTtcbiAgICAgIGZvciAodmFyIGMgaW4gbylcbiAgICAgICAgYyAhPT0gXCJrZXlcIiAmJiAoaVtjXSA9IG9bY10pO1xuICAgIH0gZWxzZSBpID0gbztcbiAgICByZXR1cm4gbyA9IGkucmVmLCB7XG4gICAgICAkJHR5cGVvZjogZSxcbiAgICAgIHR5cGU6IG4sXG4gICAgICBrZXk6IHMsXG4gICAgICByZWY6IG8gIT09IHZvaWQgMCA/IG8gOiBudWxsLFxuICAgICAgcHJvcHM6IGlcbiAgICB9O1xuICB9XG4gIHJldHVybiBsci5GcmFnbWVudCA9IHQsIGxyLmpzeCA9IHIsIGxyLmpzeHMgPSByLCBscjtcbn1cbnZhciB1ciA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgc2k7XG5mdW5jdGlvbiByYygpIHtcbiAgcmV0dXJuIHNpIHx8IChzaSA9IDEsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBlKHYpIHtcbiAgICAgIGlmICh2ID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiB2ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHYuJCR0eXBlb2YgPT09IHRlID8gbnVsbCA6IHYuZGlzcGxheU5hbWUgfHwgdi5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHYgPT0gXCJzdHJpbmdcIikgcmV0dXJuIHY7XG4gICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgY2FzZSB3OlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgaDpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBMOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgazpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgRDpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIGo6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHYgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygdi50YWcgPT0gXCJudW1iZXJcIiAmJiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApLCB2LiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBkOlxuICAgICAgICAgICAgcmV0dXJuICh2LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBCOlxuICAgICAgICAgICAgcmV0dXJuICh2Ll9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBBOlxuICAgICAgICAgICAgdmFyIE0gPSB2LnJlbmRlcjtcbiAgICAgICAgICAgIHJldHVybiB2ID0gdi5kaXNwbGF5TmFtZSwgdiB8fCAodiA9IE0uZGlzcGxheU5hbWUgfHwgTS5uYW1lIHx8IFwiXCIsIHYgPSB2ICE9PSBcIlwiID8gXCJGb3J3YXJkUmVmKFwiICsgdiArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpLCB2O1xuICAgICAgICAgIGNhc2UgVzpcbiAgICAgICAgICAgIHJldHVybiBNID0gdi5kaXNwbGF5TmFtZSB8fCBudWxsLCBNICE9PSBudWxsID8gTSA6IGUodi50eXBlKSB8fCBcIk1lbW9cIjtcbiAgICAgICAgICBjYXNlIHo6XG4gICAgICAgICAgICBNID0gdi5fcGF5bG9hZCwgdiA9IHYuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZSh2KE0pKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdCh2KSB7XG4gICAgICByZXR1cm4gXCJcIiArIHY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHIodikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdCh2KTtcbiAgICAgICAgdmFyIE0gPSAhMTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBNID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoTSkge1xuICAgICAgICBNID0gY29uc29sZTtcbiAgICAgICAgdmFyIFkgPSBNLmVycm9yLCBvZSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiB2W1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdi5jb25zdHJ1Y3Rvci5uYW1lIHx8IFwiT2JqZWN0XCI7XG4gICAgICAgIHJldHVybiBZLmNhbGwoXG4gICAgICAgICAgTSxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgb2VcbiAgICAgICAgKSwgdCh2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbigpIHtcbiAgICB9XG4gICAgZnVuY3Rpb24gbygpIHtcbiAgICAgIGlmIChIID09PSAwKSB7XG4gICAgICAgIFggPSBjb25zb2xlLmxvZywgXyA9IGNvbnNvbGUuaW5mbywgcSA9IGNvbnNvbGUud2FybiwgRyA9IGNvbnNvbGUuZXJyb3IsIHJlID0gY29uc29sZS5ncm91cCwgWiA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIGFlID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHYgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogbixcbiAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGluZm86IHYsXG4gICAgICAgICAgbG9nOiB2LFxuICAgICAgICAgIHdhcm46IHYsXG4gICAgICAgICAgZXJyb3I6IHYsXG4gICAgICAgICAgZ3JvdXA6IHYsXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHYsXG4gICAgICAgICAgZ3JvdXBFbmQ6IHZcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBIKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGkoKSB7XG4gICAgICBpZiAoSC0tLCBIID09PSAwKSB7XG4gICAgICAgIHZhciB2ID0geyBjb25maWd1cmFibGU6ICEwLCBlbnVtZXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBsb2c6IEkoe30sIHYsIHsgdmFsdWU6IFggfSksXG4gICAgICAgICAgaW5mbzogSSh7fSwgdiwgeyB2YWx1ZTogXyB9KSxcbiAgICAgICAgICB3YXJuOiBJKHt9LCB2LCB7IHZhbHVlOiBxIH0pLFxuICAgICAgICAgIGVycm9yOiBJKHt9LCB2LCB7IHZhbHVlOiBHIH0pLFxuICAgICAgICAgIGdyb3VwOiBJKHt9LCB2LCB7IHZhbHVlOiByZSB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogSSh7fSwgdiwgeyB2YWx1ZTogWiB9KSxcbiAgICAgICAgICBncm91cEVuZDogSSh7fSwgdiwgeyB2YWx1ZTogYWUgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gSCAmJiBjb25zb2xlLmVycm9yKFxuICAgICAgICBcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcyh2KSB7XG4gICAgICBpZiAoTyA9PT0gdm9pZCAwKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKFkpIHtcbiAgICAgICAgICB2YXIgTSA9IFkuc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgTyA9IE0gJiYgTVsxXSB8fCBcIlwiLCB5ZSA9IC0xIDwgWS5zdGFjay5pbmRleE9mKGBcbiAgICBhdGApID8gXCIgKDxhbm9ueW1vdXM+KVwiIDogLTEgPCBZLnN0YWNrLmluZGV4T2YoXCJAXCIpID8gXCJAdW5rbm93bjowOjBcIiA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBgXG5gICsgTyArIHYgKyB5ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYyh2LCBNKSB7XG4gICAgICBpZiAoIXYgfHwgRWUpIHJldHVybiBcIlwiO1xuICAgICAgdmFyIFkgPSBNZS5nZXQodik7XG4gICAgICBpZiAoWSAhPT0gdm9pZCAwKSByZXR1cm4gWTtcbiAgICAgIEVlID0gITAsIFkgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgb2UgPSBudWxsO1xuICAgICAgb2UgPSBGLkgsIEYuSCA9IG51bGwsIG8oKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBSZSA9IHtcbiAgICAgICAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKE0pIHtcbiAgICAgICAgICAgICAgICB2YXIgV2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChXZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFVlID0gdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdCh2LCBbXSwgV2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBXZS5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh1dCkge1xuICAgICAgICAgICAgICAgICAgICBVZSA9IHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdi5jYWxsKFdlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHV0KSB7XG4gICAgICAgICAgICAgICAgICBVZSA9IHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoV2UgPSB2KCkpICYmIHR5cGVvZiBXZS5jYXRjaCA9PSBcImZ1bmN0aW9uXCIgJiYgV2UuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHV0KSB7XG4gICAgICAgICAgICAgIGlmICh1dCAmJiBVZSAmJiB0eXBlb2YgdXQuc3RhY2sgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gW3V0LnN0YWNrLCBVZS5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUmUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIjtcbiAgICAgICAgdmFyIHVlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgdWUgJiYgdWUuY29uZmlndXJhYmxlICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICBSZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICk7XG4gICAgICAgIHZhciBLID0gUmUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksIGJlID0gS1swXSwgd2UgPSBLWzFdO1xuICAgICAgICBpZiAoYmUgJiYgd2UpIHtcbiAgICAgICAgICB2YXIgT2UgPSBiZS5zcGxpdChgXG5gKSwgY2UgPSB3ZS5zcGxpdChgXG5gKTtcbiAgICAgICAgICBmb3IgKEsgPSB1ZSA9IDA7IHVlIDwgT2UubGVuZ3RoICYmICFPZVt1ZV0uaW5jbHVkZXMoXG4gICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgKTsgKVxuICAgICAgICAgICAgdWUrKztcbiAgICAgICAgICBmb3IgKDsgSyA8IGNlLmxlbmd0aCAmJiAhY2VbS10uaW5jbHVkZXMoXG4gICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgKTsgKVxuICAgICAgICAgICAgSysrO1xuICAgICAgICAgIGlmICh1ZSA9PT0gT2UubGVuZ3RoIHx8IEsgPT09IGNlLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodWUgPSBPZS5sZW5ndGggLSAxLCBLID0gY2UubGVuZ3RoIC0gMTsgMSA8PSB1ZSAmJiAwIDw9IEsgJiYgT2VbdWVdICE9PSBjZVtLXTsgKVxuICAgICAgICAgICAgICBLLS07XG4gICAgICAgICAgZm9yICg7IDEgPD0gdWUgJiYgMCA8PSBLOyB1ZS0tLCBLLS0pXG4gICAgICAgICAgICBpZiAoT2VbdWVdICE9PSBjZVtLXSkge1xuICAgICAgICAgICAgICBpZiAodWUgIT09IDEgfHwgSyAhPT0gMSlcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKHVlLS0sIEstLSwgMCA+IEsgfHwgT2VbdWVdICE9PSBjZVtLXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgSWUgPSBgXG5gICsgT2VbdWVdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgXCIgYXQgbmV3IFwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IFwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2LmRpc3BsYXlOYW1lICYmIEllLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiYgKEllID0gSWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIHYuZGlzcGxheU5hbWUpKSwgdHlwZW9mIHYgPT0gXCJmdW5jdGlvblwiICYmIE1lLnNldCh2LCBJZSksIEllO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IHVlICYmIDAgPD0gSyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBFZSA9ICExLCBGLkggPSBvZSwgaSgpLCBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IFk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2UgPSAoT2UgPSB2ID8gdi5kaXNwbGF5TmFtZSB8fCB2Lm5hbWUgOiBcIlwiKSA/IHMoT2UpIDogXCJcIiwgdHlwZW9mIHYgPT0gXCJmdW5jdGlvblwiICYmIE1lLnNldCh2LCBPZSksIE9lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsKHYpIHtcbiAgICAgIGlmICh2ID09IG51bGwpIHJldHVybiBcIlwiO1xuICAgICAgaWYgKHR5cGVvZiB2ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgTSA9IHYucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gYyhcbiAgICAgICAgICB2LFxuICAgICAgICAgICEoIU0gfHwgIU0uaXNSZWFjdENvbXBvbmVudClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdiA9PSBcInN0cmluZ1wiKSByZXR1cm4gcyh2KTtcbiAgICAgIHN3aXRjaCAodikge1xuICAgICAgICBjYXNlIEQ6XG4gICAgICAgICAgcmV0dXJuIHMoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSBqOlxuICAgICAgICAgIHJldHVybiBzKFwiU3VzcGVuc2VMaXN0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2ID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAodi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgQTpcbiAgICAgICAgICAgIHJldHVybiB2ID0gYyh2LnJlbmRlciwgITEpLCB2O1xuICAgICAgICAgIGNhc2UgVzpcbiAgICAgICAgICAgIHJldHVybiBsKHYudHlwZSk7XG4gICAgICAgICAgY2FzZSB6OlxuICAgICAgICAgICAgTSA9IHYuX3BheWxvYWQsIHYgPSB2Ll9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGwodihNKSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHUoKSB7XG4gICAgICB2YXIgdiA9IEYuQTtcbiAgICAgIHJldHVybiB2ID09PSBudWxsID8gbnVsbCA6IHYuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcCh2KSB7XG4gICAgICBpZiAoUi5jYWxsKHYsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciBNID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2LCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChNICYmIE0uaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2LmtleSAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtKHYsIE0pIHtcbiAgICAgIGZ1bmN0aW9uIFkoKSB7XG4gICAgICAgIHZlIHx8ICh2ZSA9ICEwLCBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgTVxuICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIFkuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHYsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiBZLFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZygpIHtcbiAgICAgIHZhciB2ID0gZSh0aGlzLnR5cGUpO1xuICAgICAgcmV0dXJuIFBlW3ZdIHx8IChQZVt2XSA9ICEwLCBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgKSksIHYgPSB0aGlzLnByb3BzLnJlZiwgdiAhPT0gdm9pZCAwID8gdiA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHgodiwgTSwgWSwgb2UsIFJlLCB1ZSkge1xuICAgICAgcmV0dXJuIFkgPSB1ZS5yZWYsIHYgPSB7XG4gICAgICAgICQkdHlwZW9mOiBiLFxuICAgICAgICB0eXBlOiB2LFxuICAgICAgICBrZXk6IE0sXG4gICAgICAgIHByb3BzOiB1ZSxcbiAgICAgICAgX293bmVyOiBSZVxuICAgICAgfSwgKFkgIT09IHZvaWQgMCA/IFkgOiBudWxsKSAhPT0gbnVsbCA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2LCBcInJlZlwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICBnZXQ6IGdcbiAgICAgIH0pIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHYsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogITEsIHZhbHVlOiBudWxsIH0pLCB2Ll9zdG9yZSA9IHt9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkodi5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodiwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pLCBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHYucHJvcHMpLCBPYmplY3QuZnJlZXplKHYpKSwgdjtcbiAgICB9XG4gICAgZnVuY3Rpb24geSh2LCBNLCBZLCBvZSwgUmUsIHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHYgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdiA9PSBcImZ1bmN0aW9uXCIgfHwgdiA9PT0gdyB8fCB2ID09PSBMIHx8IHYgPT09IGsgfHwgdiA9PT0gRCB8fCB2ID09PSBqIHx8IHYgPT09IFUgfHwgdHlwZW9mIHYgPT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsICYmICh2LiQkdHlwZW9mID09PSB6IHx8IHYuJCR0eXBlb2YgPT09IFcgfHwgdi4kJHR5cGVvZiA9PT0gZCB8fCB2LiQkdHlwZW9mID09PSBCIHx8IHYuJCR0eXBlb2YgPT09IEEgfHwgdi4kJHR5cGVvZiA9PT0gSiB8fCB2LmdldE1vZHVsZUlkICE9PSB2b2lkIDApKSB7XG4gICAgICAgIHZhciBLID0gTS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKEsgIT09IHZvaWQgMClcbiAgICAgICAgICBpZiAob2UpXG4gICAgICAgICAgICBpZiAoUShLKSkge1xuICAgICAgICAgICAgICBmb3IgKG9lID0gMDsgb2UgPCBLLmxlbmd0aDsgb2UrKylcbiAgICAgICAgICAgICAgICBmKEtbb2VdLCB2KTtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKEspO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiBZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuIFVzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlIGYoSywgdik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgSyA9IFwiXCIsICh2ID09PSB2b2lkIDAgfHwgdHlwZW9mIHYgPT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHYpLmxlbmd0aCA9PT0gMCkgJiYgKEsgKz0gXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiKSwgdiA9PT0gbnVsbCA/IG9lID0gXCJudWxsXCIgOiBRKHYpID8gb2UgPSBcImFycmF5XCIgOiB2ICE9PSB2b2lkIDAgJiYgdi4kJHR5cGVvZiA9PT0gYiA/IChvZSA9IFwiPFwiICsgKGUodi50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCBLID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBvZSA9IHR5cGVvZiB2LCBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsXG4gICAgICAgICAgb2UsXG4gICAgICAgICAgS1xuICAgICAgICApO1xuICAgICAgaWYgKFIuY2FsbChNLCBcImtleVwiKSkge1xuICAgICAgICBLID0gZSh2KTtcbiAgICAgICAgdmFyIGJlID0gT2JqZWN0LmtleXMoTSkuZmlsdGVyKGZ1bmN0aW9uKE9lKSB7XG4gICAgICAgICAgcmV0dXJuIE9lICE9PSBcImtleVwiO1xuICAgICAgICB9KTtcbiAgICAgICAgb2UgPSAwIDwgYmUubGVuZ3RoID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGJlLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie2tleTogc29tZUtleX1cIiwgemVbSyArIG9lXSB8fCAoYmUgPSAwIDwgYmUubGVuZ3RoID8gXCJ7XCIgKyBiZS5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcInt9XCIsIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYEEgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxuICBsZXQgcHJvcHMgPSAlcztcbiAgPCVzIHsuLi5wcm9wc30gLz5cblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxuICBsZXQgcHJvcHMgPSAlcztcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPmAsXG4gICAgICAgICAgb2UsXG4gICAgICAgICAgSyxcbiAgICAgICAgICBiZSxcbiAgICAgICAgICBLXG4gICAgICAgICksIHplW0sgKyBvZV0gPSAhMCk7XG4gICAgICB9XG4gICAgICBpZiAoSyA9IG51bGwsIFkgIT09IHZvaWQgMCAmJiAocihZKSwgSyA9IFwiXCIgKyBZKSwgcChNKSAmJiAocihNLmtleSksIEsgPSBcIlwiICsgTS5rZXkpLCBcImtleVwiIGluIE0pIHtcbiAgICAgICAgWSA9IHt9O1xuICAgICAgICBmb3IgKHZhciB3ZSBpbiBNKVxuICAgICAgICAgIHdlICE9PSBcImtleVwiICYmIChZW3dlXSA9IE1bd2VdKTtcbiAgICAgIH0gZWxzZSBZID0gTTtcbiAgICAgIHJldHVybiBLICYmIG0oXG4gICAgICAgIFksXG4gICAgICAgIHR5cGVvZiB2ID09IFwiZnVuY3Rpb25cIiA/IHYuZGlzcGxheU5hbWUgfHwgdi5uYW1lIHx8IFwiVW5rbm93blwiIDogdlxuICAgICAgKSwgeCh2LCBLLCB1ZSwgUmUsIHUoKSwgWSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGYodiwgTSkge1xuICAgICAgaWYgKHR5cGVvZiB2ID09IFwib2JqZWN0XCIgJiYgdiAmJiB2LiQkdHlwZW9mICE9PSBRZSkge1xuICAgICAgICBpZiAoUSh2KSlcbiAgICAgICAgICBmb3IgKHZhciBZID0gMDsgWSA8IHYubGVuZ3RoOyBZKyspIHtcbiAgICAgICAgICAgIHZhciBvZSA9IHZbWV07XG4gICAgICAgICAgICBTKG9lKSAmJiBFKG9lLCBNKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFModikpXG4gICAgICAgICAgdi5fc3RvcmUgJiYgKHYuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgICAgICBlbHNlIGlmICh2ID09PSBudWxsIHx8IHR5cGVvZiB2ICE9IFwib2JqZWN0XCIgPyBZID0gbnVsbCA6IChZID0gViAmJiB2W1ZdIHx8IHZbXCJAQGl0ZXJhdG9yXCJdLCBZID0gdHlwZW9mIFkgPT0gXCJmdW5jdGlvblwiID8gWSA6IG51bGwpLCB0eXBlb2YgWSA9PSBcImZ1bmN0aW9uXCIgJiYgWSAhPT0gdi5lbnRyaWVzICYmIChZID0gWS5jYWxsKHYpLCBZICE9PSB2KSlcbiAgICAgICAgICBmb3IgKDsgISh2ID0gWS5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgIFModi52YWx1ZSkgJiYgRSh2LnZhbHVlLCBNKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUyh2KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHYgPT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsICYmIHYuJCR0eXBlb2YgPT09IGI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEUodiwgTSkge1xuICAgICAgaWYgKHYuX3N0b3JlICYmICF2Ll9zdG9yZS52YWxpZGF0ZWQgJiYgdi5rZXkgPT0gbnVsbCAmJiAodi5fc3RvcmUudmFsaWRhdGVkID0gMSwgTSA9IFAoTSksICFMZVtNXSkpIHtcbiAgICAgICAgTGVbTV0gPSAhMDtcbiAgICAgICAgdmFyIFkgPSBcIlwiO1xuICAgICAgICB2ICYmIHYuX293bmVyICE9IG51bGwgJiYgdi5fb3duZXIgIT09IHUoKSAmJiAoWSA9IG51bGwsIHR5cGVvZiB2Ll9vd25lci50YWcgPT0gXCJudW1iZXJcIiA/IFkgPSBlKHYuX293bmVyLnR5cGUpIDogdHlwZW9mIHYuX293bmVyLm5hbWUgPT0gXCJzdHJpbmdcIiAmJiAoWSA9IHYuX293bmVyLm5hbWUpLCBZID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBZICsgXCIuXCIpO1xuICAgICAgICB2YXIgb2UgPSBGLmdldEN1cnJlbnRTdGFjaztcbiAgICAgICAgRi5nZXRDdXJyZW50U3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgUmUgPSBsKHYudHlwZSk7XG4gICAgICAgICAgcmV0dXJuIG9lICYmIChSZSArPSBvZSgpIHx8IFwiXCIpLCBSZTtcbiAgICAgICAgfSwgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgICAgICAgTSxcbiAgICAgICAgICBZXG4gICAgICAgICksIEYuZ2V0Q3VycmVudFN0YWNrID0gb2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFAodikge1xuICAgICAgdmFyIE0gPSBcIlwiLCBZID0gdSgpO1xuICAgICAgcmV0dXJuIFkgJiYgKFkgPSBlKFkudHlwZSkpICYmIChNID0gYFxuXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBcXGBgICsgWSArIFwiYC5cIiksIE0gfHwgKHYgPSBlKHYpKSAmJiAoTSA9IGBcblxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8YCArIHYgKyBcIj4uXCIpLCBNO1xuICAgIH1cbiAgICB2YXIgVCA9IHl0LCBiID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLCBoID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgdyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgayA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgTCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgQiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSwgZCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCBBID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCBEID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCBqID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIFcgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgeiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLCBVID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSwgViA9IFN5bWJvbC5pdGVyYXRvciwgdGUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSwgRiA9IFQuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLCBSID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgSSA9IE9iamVjdC5hc3NpZ24sIEogPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSwgUSA9IEFycmF5LmlzQXJyYXksIEggPSAwLCBYLCBfLCBxLCBHLCByZSwgWiwgYWU7XG4gICAgbi5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICB2YXIgTywgeWUsIEVlID0gITEsIE1lID0gbmV3ICh0eXBlb2YgV2Vha01hcCA9PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogTWFwKSgpLCBRZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLCB2ZSwgUGUgPSB7fSwgemUgPSB7fSwgTGUgPSB7fTtcbiAgICB1ci5GcmFnbWVudCA9IHcsIHVyLmpzeCA9IGZ1bmN0aW9uKHYsIE0sIFksIG9lLCBSZSkge1xuICAgICAgcmV0dXJuIHkodiwgTSwgWSwgITEsIG9lLCBSZSk7XG4gICAgfSwgdXIuanN4cyA9IGZ1bmN0aW9uKHYsIE0sIFksIG9lLCBSZSkge1xuICAgICAgcmV0dXJuIHkodiwgTSwgWSwgITAsIG9lLCBSZSk7XG4gICAgfTtcbiAgfSgpKSwgdXI7XG59XG52YXIgY2k7XG5mdW5jdGlvbiBuYygpIHtcbiAgcmV0dXJuIGNpIHx8IChjaSA9IDEsIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IFVyLmV4cG9ydHMgPSB0YygpIDogVXIuZXhwb3J0cyA9IHJjKCkpLCBVci5leHBvcnRzO1xufVxudmFyIE4gPSBuYygpO1xuY29uc3QgRXIgPSB7XG4gIGJsYWNrOiBcIiMwMDBcIixcbiAgd2hpdGU6IFwiI2ZmZlwiXG59LCBXdCA9IHtcbiAgNTA6IFwiI2ZmZWJlZVwiLFxuICAxMDA6IFwiI2ZmY2RkMlwiLFxuICAyMDA6IFwiI2VmOWE5YVwiLFxuICAzMDA6IFwiI2U1NzM3M1wiLFxuICA0MDA6IFwiI2VmNTM1MFwiLFxuICA1MDA6IFwiI2Y0NDMzNlwiLFxuICA2MDA6IFwiI2U1MzkzNVwiLFxuICA3MDA6IFwiI2QzMmYyZlwiLFxuICA4MDA6IFwiI2M2MjgyOFwiLFxuICA5MDA6IFwiI2I3MWMxY1wiLFxuICBBMTAwOiBcIiNmZjhhODBcIixcbiAgQTIwMDogXCIjZmY1MjUyXCIsXG4gIEE0MDA6IFwiI2ZmMTc0NFwiLFxuICBBNzAwOiBcIiNkNTAwMDBcIlxufSwgVXQgPSB7XG4gIDUwOiBcIiNmM2U1ZjVcIixcbiAgMTAwOiBcIiNlMWJlZTdcIixcbiAgMjAwOiBcIiNjZTkzZDhcIixcbiAgMzAwOiBcIiNiYTY4YzhcIixcbiAgNDAwOiBcIiNhYjQ3YmNcIixcbiAgNTAwOiBcIiM5YzI3YjBcIixcbiAgNjAwOiBcIiM4ZTI0YWFcIixcbiAgNzAwOiBcIiM3YjFmYTJcIixcbiAgODAwOiBcIiM2YTFiOWFcIixcbiAgOTAwOiBcIiM0YTE0OGNcIixcbiAgQTEwMDogXCIjZWE4MGZjXCIsXG4gIEEyMDA6IFwiI2UwNDBmYlwiLFxuICBBNDAwOiBcIiNkNTAwZjlcIixcbiAgQTcwMDogXCIjYWEwMGZmXCJcbn0sIFl0ID0ge1xuICA1MDogXCIjZTNmMmZkXCIsXG4gIDEwMDogXCIjYmJkZWZiXCIsXG4gIDIwMDogXCIjOTBjYWY5XCIsXG4gIDMwMDogXCIjNjRiNWY2XCIsXG4gIDQwMDogXCIjNDJhNWY1XCIsXG4gIDUwMDogXCIjMjE5NmYzXCIsXG4gIDYwMDogXCIjMWU4OGU1XCIsXG4gIDcwMDogXCIjMTk3NmQyXCIsXG4gIDgwMDogXCIjMTU2NWMwXCIsXG4gIDkwMDogXCIjMGQ0N2ExXCIsXG4gIEExMDA6IFwiIzgyYjFmZlwiLFxuICBBMjAwOiBcIiM0NDhhZmZcIixcbiAgQTQwMDogXCIjMjk3OWZmXCIsXG4gIEE3MDA6IFwiIzI5NjJmZlwiXG59LCBIdCA9IHtcbiAgNTA6IFwiI2UxZjVmZVwiLFxuICAxMDA6IFwiI2IzZTVmY1wiLFxuICAyMDA6IFwiIzgxZDRmYVwiLFxuICAzMDA6IFwiIzRmYzNmN1wiLFxuICA0MDA6IFwiIzI5YjZmNlwiLFxuICA1MDA6IFwiIzAzYTlmNFwiLFxuICA2MDA6IFwiIzAzOWJlNVwiLFxuICA3MDA6IFwiIzAyODhkMVwiLFxuICA4MDA6IFwiIzAyNzdiZFwiLFxuICA5MDA6IFwiIzAxNTc5YlwiLFxuICBBMTAwOiBcIiM4MGQ4ZmZcIixcbiAgQTIwMDogXCIjNDBjNGZmXCIsXG4gIEE0MDA6IFwiIzAwYjBmZlwiLFxuICBBNzAwOiBcIiMwMDkxZWFcIlxufSwgcXQgPSB7XG4gIDUwOiBcIiNlOGY1ZTlcIixcbiAgMTAwOiBcIiNjOGU2YzlcIixcbiAgMjAwOiBcIiNhNWQ2YTdcIixcbiAgMzAwOiBcIiM4MWM3ODRcIixcbiAgNDAwOiBcIiM2NmJiNmFcIixcbiAgNTAwOiBcIiM0Y2FmNTBcIixcbiAgNjAwOiBcIiM0M2EwNDdcIixcbiAgNzAwOiBcIiMzODhlM2NcIixcbiAgODAwOiBcIiMyZTdkMzJcIixcbiAgOTAwOiBcIiMxYjVlMjBcIixcbiAgQTEwMDogXCIjYjlmNmNhXCIsXG4gIEEyMDA6IFwiIzY5ZjBhZVwiLFxuICBBNDAwOiBcIiMwMGU2NzZcIixcbiAgQTcwMDogXCIjMDBjODUzXCJcbn0sIGZyID0ge1xuICA1MDogXCIjZmZmM2UwXCIsXG4gIDEwMDogXCIjZmZlMGIyXCIsXG4gIDIwMDogXCIjZmZjYzgwXCIsXG4gIDMwMDogXCIjZmZiNzRkXCIsXG4gIDQwMDogXCIjZmZhNzI2XCIsXG4gIDUwMDogXCIjZmY5ODAwXCIsXG4gIDYwMDogXCIjZmI4YzAwXCIsXG4gIDcwMDogXCIjZjU3YzAwXCIsXG4gIDgwMDogXCIjZWY2YzAwXCIsXG4gIDkwMDogXCIjZTY1MTAwXCIsXG4gIEExMDA6IFwiI2ZmZDE4MFwiLFxuICBBMjAwOiBcIiNmZmFiNDBcIixcbiAgQTQwMDogXCIjZmY5MTAwXCIsXG4gIEE3MDA6IFwiI2ZmNmQwMFwiXG59LCBvYyA9IHtcbiAgNTA6IFwiI2ZhZmFmYVwiLFxuICAxMDA6IFwiI2Y1ZjVmNVwiLFxuICAyMDA6IFwiI2VlZWVlZVwiLFxuICAzMDA6IFwiI2UwZTBlMFwiLFxuICA0MDA6IFwiI2JkYmRiZFwiLFxuICA1MDA6IFwiIzllOWU5ZVwiLFxuICA2MDA6IFwiIzc1NzU3NVwiLFxuICA3MDA6IFwiIzYxNjE2MVwiLFxuICA4MDA6IFwiIzQyNDI0MlwiLFxuICA5MDA6IFwiIzIxMjEyMVwiLFxuICBBMTAwOiBcIiNmNWY1ZjVcIixcbiAgQTIwMDogXCIjZWVlZWVlXCIsXG4gIEE0MDA6IFwiI2JkYmRiZFwiLFxuICBBNzAwOiBcIiM2MTYxNjFcIlxufTtcbmZ1bmN0aW9uIGt0KGUsIC4uLnQpIHtcbiAgY29uc3QgciA9IG5ldyBVUkwoYGh0dHBzOi8vbXVpLmNvbS9wcm9kdWN0aW9uLWVycm9yLz9jb2RlPSR7ZX1gKTtcbiAgcmV0dXJuIHQuZm9yRWFjaCgobikgPT4gci5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiYXJnc1tdXCIsIG4pKSwgYE1pbmlmaWVkIE1VSSBlcnJvciAjJHtlfTsgdmlzaXQgJHtyfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZS5gO1xufVxuY29uc3Qgd3QgPSBcIiQkbWF0ZXJpYWxcIjtcbmZ1bmN0aW9uIGZuKCkge1xuICByZXR1cm4gZm4gPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciByID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgbiBpbiByKSAoe30pLmhhc093blByb3BlcnR5LmNhbGwociwgbikgJiYgKGVbbl0gPSByW25dKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBpYyhlKSB7XG4gIGlmIChlLnNoZWV0KVxuICAgIHJldHVybiBlLnNoZWV0O1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDsgdCsrKVxuICAgIGlmIChkb2N1bWVudC5zdHlsZVNoZWV0c1t0XS5vd25lck5vZGUgPT09IGUpXG4gICAgICByZXR1cm4gZG9jdW1lbnQuc3R5bGVTaGVldHNbdF07XG59XG5mdW5jdGlvbiBhYyhlKSB7XG4gIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICByZXR1cm4gdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVtb3Rpb25cIiwgZS5rZXkpLCBlLm5vbmNlICE9PSB2b2lkIDAgJiYgdC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBlLm5vbmNlKSwgdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKSksIHQuc2V0QXR0cmlidXRlKFwiZGF0YS1zXCIsIFwiXCIpLCB0O1xufVxudmFyIHNjID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBlKHIpIHtcbiAgICB2YXIgbiA9IHRoaXM7XG4gICAgdGhpcy5faW5zZXJ0VGFnID0gZnVuY3Rpb24obykge1xuICAgICAgdmFyIGk7XG4gICAgICBuLnRhZ3MubGVuZ3RoID09PSAwID8gbi5pbnNlcnRpb25Qb2ludCA/IGkgPSBuLmluc2VydGlvblBvaW50Lm5leHRTaWJsaW5nIDogbi5wcmVwZW5kID8gaSA9IG4uY29udGFpbmVyLmZpcnN0Q2hpbGQgOiBpID0gbi5iZWZvcmUgOiBpID0gbi50YWdzW24udGFncy5sZW5ndGggLSAxXS5uZXh0U2libGluZywgbi5jb250YWluZXIuaW5zZXJ0QmVmb3JlKG8sIGkpLCBuLnRhZ3MucHVzaChvKTtcbiAgICB9LCB0aGlzLmlzU3BlZWR5ID0gci5zcGVlZHkgPT09IHZvaWQgMCA/ICEwIDogci5zcGVlZHksIHRoaXMudGFncyA9IFtdLCB0aGlzLmN0ciA9IDAsIHRoaXMubm9uY2UgPSByLm5vbmNlLCB0aGlzLmtleSA9IHIua2V5LCB0aGlzLmNvbnRhaW5lciA9IHIuY29udGFpbmVyLCB0aGlzLnByZXBlbmQgPSByLnByZXBlbmQsIHRoaXMuaW5zZXJ0aW9uUG9pbnQgPSByLmluc2VydGlvblBvaW50LCB0aGlzLmJlZm9yZSA9IG51bGw7XG4gIH1cbiAgdmFyIHQgPSBlLnByb3RvdHlwZTtcbiAgcmV0dXJuIHQuaHlkcmF0ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICBuLmZvckVhY2godGhpcy5faW5zZXJ0VGFnKTtcbiAgfSwgdC5pbnNlcnQgPSBmdW5jdGlvbihuKSB7XG4gICAgdGhpcy5jdHIgJSAodGhpcy5pc1NwZWVkeSA/IDY1ZTMgOiAxKSA9PT0gMCAmJiB0aGlzLl9pbnNlcnRUYWcoYWModGhpcykpO1xuICAgIHZhciBvID0gdGhpcy50YWdzW3RoaXMudGFncy5sZW5ndGggLSAxXTtcbiAgICBpZiAodGhpcy5pc1NwZWVkeSkge1xuICAgICAgdmFyIGkgPSBpYyhvKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGkuaW5zZXJ0UnVsZShuLCBpLmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIG8uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobikpO1xuICAgIHRoaXMuY3RyKys7XG4gIH0sIHQuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRhZ3MuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgbztcbiAgICAgIHJldHVybiAobyA9IG4ucGFyZW50Tm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8ucmVtb3ZlQ2hpbGQobik7XG4gICAgfSksIHRoaXMudGFncyA9IFtdLCB0aGlzLmN0ciA9IDA7XG4gIH0sIGU7XG59KCksIFllID0gXCItbXMtXCIsIGRuID0gXCItbW96LVwiLCBmZSA9IFwiLXdlYmtpdC1cIiwgeGEgPSBcImNvbW1cIiwgU28gPSBcInJ1bGVcIiwgRW8gPSBcImRlY2xcIiwgY2MgPSBcIkBpbXBvcnRcIiwgU2EgPSBcIkBrZXlmcmFtZXNcIiwgbGMgPSBcIkBsYXllclwiLCB1YyA9IE1hdGguYWJzLCBSbiA9IFN0cmluZy5mcm9tQ2hhckNvZGUsIGZjID0gT2JqZWN0LmFzc2lnbjtcbmZ1bmN0aW9uIGRjKGUsIHQpIHtcbiAgcmV0dXJuIEJlKGUsIDApIF4gNDUgPyAoKCh0IDw8IDIgXiBCZShlLCAwKSkgPDwgMiBeIEJlKGUsIDEpKSA8PCAyIF4gQmUoZSwgMikpIDw8IDIgXiBCZShlLCAzKSA6IDA7XG59XG5mdW5jdGlvbiBFYShlKSB7XG4gIHJldHVybiBlLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIHBjKGUsIHQpIHtcbiAgcmV0dXJuIChlID0gdC5leGVjKGUpKSA/IGVbMF0gOiBlO1xufVxuZnVuY3Rpb24gZGUoZSwgdCwgcikge1xuICByZXR1cm4gZS5yZXBsYWNlKHQsIHIpO1xufVxuZnVuY3Rpb24gb28oZSwgdCkge1xuICByZXR1cm4gZS5pbmRleE9mKHQpO1xufVxuZnVuY3Rpb24gQmUoZSwgdCkge1xuICByZXR1cm4gZS5jaGFyQ29kZUF0KHQpIHwgMDtcbn1cbmZ1bmN0aW9uIENyKGUsIHQsIHIpIHtcbiAgcmV0dXJuIGUuc2xpY2UodCwgcik7XG59XG5mdW5jdGlvbiBtdChlKSB7XG4gIHJldHVybiBlLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIENvKGUpIHtcbiAgcmV0dXJuIGUubGVuZ3RoO1xufVxuZnVuY3Rpb24gWXIoZSwgdCkge1xuICByZXR1cm4gdC5wdXNoKGUpLCBlO1xufVxuZnVuY3Rpb24gbWMoZSwgdCkge1xuICByZXR1cm4gZS5tYXAodCkuam9pbihcIlwiKTtcbn1cbnZhciAkbiA9IDEsIFp0ID0gMSwgQ2EgPSAwLCBKZSA9IDAsIGplID0gMCwgaXIgPSBcIlwiO1xuZnVuY3Rpb24gUG4oZSwgdCwgciwgbiwgbywgaSwgcykge1xuICByZXR1cm4geyB2YWx1ZTogZSwgcm9vdDogdCwgcGFyZW50OiByLCB0eXBlOiBuLCBwcm9wczogbywgY2hpbGRyZW46IGksIGxpbmU6ICRuLCBjb2x1bW46IFp0LCBsZW5ndGg6IHMsIHJldHVybjogXCJcIiB9O1xufVxuZnVuY3Rpb24gZHIoZSwgdCkge1xuICByZXR1cm4gZmMoUG4oXCJcIiwgbnVsbCwgbnVsbCwgXCJcIiwgbnVsbCwgbnVsbCwgMCksIGUsIHsgbGVuZ3RoOiAtZS5sZW5ndGggfSwgdCk7XG59XG5mdW5jdGlvbiBoYygpIHtcbiAgcmV0dXJuIGplO1xufVxuZnVuY3Rpb24gZ2MoKSB7XG4gIHJldHVybiBqZSA9IEplID4gMCA/IEJlKGlyLCAtLUplKSA6IDAsIFp0LS0sIGplID09PSAxMCAmJiAoWnQgPSAxLCAkbi0tKSwgamU7XG59XG5mdW5jdGlvbiBldCgpIHtcbiAgcmV0dXJuIGplID0gSmUgPCBDYSA/IEJlKGlyLCBKZSsrKSA6IDAsIFp0KyssIGplID09PSAxMCAmJiAoWnQgPSAxLCAkbisrKSwgamU7XG59XG5mdW5jdGlvbiB2dCgpIHtcbiAgcmV0dXJuIEJlKGlyLCBKZSk7XG59XG5mdW5jdGlvbiBhbigpIHtcbiAgcmV0dXJuIEplO1xufVxuZnVuY3Rpb24gQXIoZSwgdCkge1xuICByZXR1cm4gQ3IoaXIsIGUsIHQpO1xufVxuZnVuY3Rpb24gVHIoZSkge1xuICBzd2l0Y2ggKGUpIHtcbiAgICAvLyBcXDAgXFx0IFxcbiBcXHIgXFxzIHdoaXRlc3BhY2UgdG9rZW5cbiAgICBjYXNlIDA6XG4gICAgY2FzZSA5OlxuICAgIGNhc2UgMTA6XG4gICAgY2FzZSAxMzpcbiAgICBjYXNlIDMyOlxuICAgICAgcmV0dXJuIDU7XG4gICAgLy8gISArICwgLyA+IEAgfiBpc29sYXRlIHRva2VuXG4gICAgY2FzZSAzMzpcbiAgICBjYXNlIDQzOlxuICAgIGNhc2UgNDQ6XG4gICAgY2FzZSA0NzpcbiAgICBjYXNlIDYyOlxuICAgIGNhc2UgNjQ6XG4gICAgY2FzZSAxMjY6XG4gICAgLy8gOyB7IH0gYnJlYWtwb2ludCB0b2tlblxuICAgIGNhc2UgNTk6XG4gICAgY2FzZSAxMjM6XG4gICAgY2FzZSAxMjU6XG4gICAgICByZXR1cm4gNDtcbiAgICAvLyA6IGFjY29tcGFuaWVkIHRva2VuXG4gICAgY2FzZSA1ODpcbiAgICAgIHJldHVybiAzO1xuICAgIC8vIFwiICcgKCBbIG9wZW5pbmcgZGVsaW1pdCB0b2tlblxuICAgIGNhc2UgMzQ6XG4gICAgY2FzZSAzOTpcbiAgICBjYXNlIDQwOlxuICAgIGNhc2UgOTE6XG4gICAgICByZXR1cm4gMjtcbiAgICAvLyApIF0gY2xvc2luZyBkZWxpbWl0IHRva2VuXG4gICAgY2FzZSA0MTpcbiAgICBjYXNlIDkzOlxuICAgICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBUYShlKSB7XG4gIHJldHVybiAkbiA9IFp0ID0gMSwgQ2EgPSBtdChpciA9IGUpLCBKZSA9IDAsIFtdO1xufVxuZnVuY3Rpb24gd2EoZSkge1xuICByZXR1cm4gaXIgPSBcIlwiLCBlO1xufVxuZnVuY3Rpb24gc24oZSkge1xuICByZXR1cm4gRWEoQXIoSmUgLSAxLCBpbyhlID09PSA5MSA/IGUgKyAyIDogZSA9PT0gNDAgPyBlICsgMSA6IGUpKSk7XG59XG5mdW5jdGlvbiB5YyhlKSB7XG4gIGZvciAoOyAoamUgPSB2dCgpKSAmJiBqZSA8IDMzOyApXG4gICAgZXQoKTtcbiAgcmV0dXJuIFRyKGUpID4gMiB8fCBUcihqZSkgPiAzID8gXCJcIiA6IFwiIFwiO1xufVxuZnVuY3Rpb24gYmMoZSwgdCkge1xuICBmb3IgKDsgLS10ICYmIGV0KCkgJiYgIShqZSA8IDQ4IHx8IGplID4gMTAyIHx8IGplID4gNTcgJiYgamUgPCA2NSB8fCBqZSA+IDcwICYmIGplIDwgOTcpOyApXG4gICAgO1xuICByZXR1cm4gQXIoZSwgYW4oKSArICh0IDwgNiAmJiB2dCgpID09IDMyICYmIGV0KCkgPT0gMzIpKTtcbn1cbmZ1bmN0aW9uIGlvKGUpIHtcbiAgZm9yICg7IGV0KCk7IClcbiAgICBzd2l0Y2ggKGplKSB7XG4gICAgICAvLyBdICkgXCIgJ1xuICAgICAgY2FzZSBlOlxuICAgICAgICByZXR1cm4gSmU7XG4gICAgICAvLyBcIiAnXG4gICAgICBjYXNlIDM0OlxuICAgICAgY2FzZSAzOTpcbiAgICAgICAgZSAhPT0gMzQgJiYgZSAhPT0gMzkgJiYgaW8oamUpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIChcbiAgICAgIGNhc2UgNDA6XG4gICAgICAgIGUgPT09IDQxICYmIGlvKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFxcXG4gICAgICBjYXNlIDkyOlxuICAgICAgICBldCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBKZTtcbn1cbmZ1bmN0aW9uIHZjKGUsIHQpIHtcbiAgZm9yICg7IGV0KCkgJiYgZSArIGplICE9PSA1NzsgKVxuICAgIGlmIChlICsgamUgPT09IDg0ICYmIHZ0KCkgPT09IDQ3KVxuICAgICAgYnJlYWs7XG4gIHJldHVybiBcIi8qXCIgKyBBcih0LCBKZSAtIDEpICsgXCIqXCIgKyBSbihlID09PSA0NyA/IGUgOiBldCgpKTtcbn1cbmZ1bmN0aW9uIHhjKGUpIHtcbiAgZm9yICg7ICFUcih2dCgpKTsgKVxuICAgIGV0KCk7XG4gIHJldHVybiBBcihlLCBKZSk7XG59XG5mdW5jdGlvbiBTYyhlKSB7XG4gIHJldHVybiB3YShjbihcIlwiLCBudWxsLCBudWxsLCBudWxsLCBbXCJcIl0sIGUgPSBUYShlKSwgMCwgWzBdLCBlKSk7XG59XG5mdW5jdGlvbiBjbihlLCB0LCByLCBuLCBvLCBpLCBzLCBjLCBsKSB7XG4gIGZvciAodmFyIHUgPSAwLCBwID0gMCwgbSA9IHMsIGcgPSAwLCB4ID0gMCwgeSA9IDAsIGYgPSAxLCBTID0gMSwgRSA9IDEsIFAgPSAwLCBUID0gXCJcIiwgYiA9IG8sIGggPSBpLCB3ID0gbiwgayA9IFQ7IFM7IClcbiAgICBzd2l0Y2ggKHkgPSBQLCBQID0gZXQoKSkge1xuICAgICAgLy8gKFxuICAgICAgY2FzZSA0MDpcbiAgICAgICAgaWYgKHkgIT0gMTA4ICYmIEJlKGssIG0gLSAxKSA9PSA1OCkge1xuICAgICAgICAgIG9vKGsgKz0gZGUoc24oUCksIFwiJlwiLCBcIiZcXGZcIiksIFwiJlxcZlwiKSAhPSAtMSAmJiAoRSA9IC0xKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gXCIgJyBbXG4gICAgICBjYXNlIDM0OlxuICAgICAgY2FzZSAzOTpcbiAgICAgIGNhc2UgOTE6XG4gICAgICAgIGsgKz0gc24oUCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gXFx0IFxcbiBcXHIgXFxzXG4gICAgICBjYXNlIDk6XG4gICAgICBjYXNlIDEwOlxuICAgICAgY2FzZSAxMzpcbiAgICAgIGNhc2UgMzI6XG4gICAgICAgIGsgKz0geWMoeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gXFxcbiAgICAgIGNhc2UgOTI6XG4gICAgICAgIGsgKz0gYmMoYW4oKSAtIDEsIDcpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIC8vIC9cbiAgICAgIGNhc2UgNDc6XG4gICAgICAgIHN3aXRjaCAodnQoKSkge1xuICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgIFlyKEVjKHZjKGV0KCksIGFuKCkpLCB0LCByKSwgbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgayArPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIC8vIHtcbiAgICAgIGNhc2UgMTIzICogZjpcbiAgICAgICAgY1t1KytdID0gbXQoaykgKiBFO1xuICAgICAgLy8gfSA7IFxcMFxuICAgICAgY2FzZSAxMjUgKiBmOlxuICAgICAgY2FzZSA1OTpcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgc3dpdGNoIChQKSB7XG4gICAgICAgICAgLy8gXFwwIH1cbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgICBTID0gMDtcbiAgICAgICAgICAvLyA7XG4gICAgICAgICAgY2FzZSA1OSArIHA6XG4gICAgICAgICAgICBFID09IC0xICYmIChrID0gZGUoaywgL1xcZi9nLCBcIlwiKSksIHggPiAwICYmIG10KGspIC0gbSAmJiBZcih4ID4gMzIgPyB1aShrICsgXCI7XCIsIG4sIHIsIG0gLSAxKSA6IHVpKGRlKGssIFwiIFwiLCBcIlwiKSArIFwiO1wiLCBuLCByLCBtIC0gMiksIGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gQCA7XG4gICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgIGsgKz0gXCI7XCI7XG4gICAgICAgICAgLy8geyBydWxlL2F0LXJ1bGVcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKFlyKHcgPSBsaShrLCB0LCByLCB1LCBwLCBvLCBjLCBULCBiID0gW10sIGggPSBbXSwgbSksIGkpLCBQID09PSAxMjMpXG4gICAgICAgICAgICAgIGlmIChwID09PSAwKVxuICAgICAgICAgICAgICAgIGNuKGssIHQsIHcsIHcsIGIsIGksIG0sIGMsIGgpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3dpdGNoIChnID09PSA5OSAmJiBCZShrLCAzKSA9PT0gMTEwID8gMTAwIDogZykge1xuICAgICAgICAgICAgICAgICAgLy8gZCBsIG0gc1xuICAgICAgICAgICAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwODpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICAgIGNuKGUsIHcsIHcsIG4gJiYgWXIobGkoZSwgdywgdywgMCwgMCwgbywgYywgVCwgbywgYiA9IFtdLCBtKSwgaCksIG8sIGgsIG0sIGMsIG4gPyBiIDogaCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY24oaywgdywgdywgdywgW1wiXCJdLCBoLCAwLCBjLCBoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdSA9IHAgPSB4ID0gMCwgZiA9IEUgPSAxLCBUID0gayA9IFwiXCIsIG0gPSBzO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIDpcbiAgICAgIGNhc2UgNTg6XG4gICAgICAgIG0gPSAxICsgbXQoayksIHggPSB5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGYgPCAxKSB7XG4gICAgICAgICAgaWYgKFAgPT0gMTIzKVxuICAgICAgICAgICAgLS1mO1xuICAgICAgICAgIGVsc2UgaWYgKFAgPT0gMTI1ICYmIGYrKyA9PSAwICYmIGdjKCkgPT0gMTI1KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChrICs9IFJuKFApLCBQICogZikge1xuICAgICAgICAgIC8vICZcbiAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgRSA9IHAgPiAwID8gMSA6IChrICs9IFwiXFxmXCIsIC0xKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vICxcbiAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgY1t1KytdID0gKG10KGspIC0gMSkgKiBFLCBFID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEBcbiAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgdnQoKSA9PT0gNDUgJiYgKGsgKz0gc24oZXQoKSkpLCBnID0gdnQoKSwgcCA9IG0gPSBtdChUID0gayArPSB4YyhhbigpKSksIFArKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIC1cbiAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgICAgeSA9PT0gNDUgJiYgbXQoaykgPT0gMiAmJiAoZiA9IDApO1xuICAgICAgICB9XG4gICAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIGxpKGUsIHQsIHIsIG4sIG8sIGksIHMsIGMsIGwsIHUsIHApIHtcbiAgZm9yICh2YXIgbSA9IG8gLSAxLCBnID0gbyA9PT0gMCA/IGkgOiBbXCJcIl0sIHggPSBDbyhnKSwgeSA9IDAsIGYgPSAwLCBTID0gMDsgeSA8IG47ICsreSlcbiAgICBmb3IgKHZhciBFID0gMCwgUCA9IENyKGUsIG0gKyAxLCBtID0gdWMoZiA9IHNbeV0pKSwgVCA9IGU7IEUgPCB4OyArK0UpXG4gICAgICAoVCA9IEVhKGYgPiAwID8gZ1tFXSArIFwiIFwiICsgUCA6IGRlKFAsIC8mXFxmL2csIGdbRV0pKSkgJiYgKGxbUysrXSA9IFQpO1xuICByZXR1cm4gUG4oZSwgdCwgciwgbyA9PT0gMCA/IFNvIDogYywgbCwgdSwgcCk7XG59XG5mdW5jdGlvbiBFYyhlLCB0LCByKSB7XG4gIHJldHVybiBQbihlLCB0LCByLCB4YSwgUm4oaGMoKSksIENyKGUsIDIsIC0yKSwgMCk7XG59XG5mdW5jdGlvbiB1aShlLCB0LCByLCBuKSB7XG4gIHJldHVybiBQbihlLCB0LCByLCBFbywgQ3IoZSwgMCwgbiksIENyKGUsIG4gKyAxLCAtMSksIG4pO1xufVxuZnVuY3Rpb24gWHQoZSwgdCkge1xuICBmb3IgKHZhciByID0gXCJcIiwgbiA9IENvKGUpLCBvID0gMDsgbyA8IG47IG8rKylcbiAgICByICs9IHQoZVtvXSwgbywgZSwgdCkgfHwgXCJcIjtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDYyhlLCB0LCByLCBuKSB7XG4gIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgY2FzZSBsYzpcbiAgICAgIGlmIChlLmNoaWxkcmVuLmxlbmd0aCkgYnJlYWs7XG4gICAgY2FzZSBjYzpcbiAgICBjYXNlIEVvOlxuICAgICAgcmV0dXJuIGUucmV0dXJuID0gZS5yZXR1cm4gfHwgZS52YWx1ZTtcbiAgICBjYXNlIHhhOlxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgY2FzZSBTYTpcbiAgICAgIHJldHVybiBlLnJldHVybiA9IGUudmFsdWUgKyBcIntcIiArIFh0KGUuY2hpbGRyZW4sIG4pICsgXCJ9XCI7XG4gICAgY2FzZSBTbzpcbiAgICAgIGUudmFsdWUgPSBlLnByb3BzLmpvaW4oXCIsXCIpO1xuICB9XG4gIHJldHVybiBtdChyID0gWHQoZS5jaGlsZHJlbiwgbikpID8gZS5yZXR1cm4gPSBlLnZhbHVlICsgXCJ7XCIgKyByICsgXCJ9XCIgOiBcIlwiO1xufVxuZnVuY3Rpb24gVGMoZSkge1xuICB2YXIgdCA9IENvKGUpO1xuICByZXR1cm4gZnVuY3Rpb24ociwgbiwgbywgaSkge1xuICAgIGZvciAodmFyIHMgPSBcIlwiLCBjID0gMDsgYyA8IHQ7IGMrKylcbiAgICAgIHMgKz0gZVtjXShyLCBuLCBvLCBpKSB8fCBcIlwiO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuZnVuY3Rpb24gd2MoZSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHQucm9vdCB8fCAodCA9IHQucmV0dXJuKSAmJiBlKHQpO1xuICB9O1xufVxuZnVuY3Rpb24gT2EoZSkge1xuICB2YXIgdCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgIHJldHVybiB0W3JdID09PSB2b2lkIDAgJiYgKHRbcl0gPSBlKHIpKSwgdFtyXTtcbiAgfTtcbn1cbnZhciBPYyA9IGZ1bmN0aW9uKHQsIHIsIG4pIHtcbiAgZm9yICh2YXIgbyA9IDAsIGkgPSAwOyBvID0gaSwgaSA9IHZ0KCksIG8gPT09IDM4ICYmIGkgPT09IDEyICYmIChyW25dID0gMSksICFUcihpKTsgKVxuICAgIGV0KCk7XG4gIHJldHVybiBBcih0LCBKZSk7XG59LCBSYyA9IGZ1bmN0aW9uKHQsIHIpIHtcbiAgdmFyIG4gPSAtMSwgbyA9IDQ0O1xuICBkb1xuICAgIHN3aXRjaCAoVHIobykpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgbyA9PT0gMzggJiYgdnQoKSA9PT0gMTIgJiYgKHJbbl0gPSAxKSwgdFtuXSArPSBPYyhKZSAtIDEsIHIsIG4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdFtuXSArPSBzbihvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGlmIChvID09PSA0NCkge1xuICAgICAgICAgIHRbKytuXSA9IHZ0KCkgPT09IDU4ID8gXCImXFxmXCIgOiBcIlwiLCByW25dID0gdFtuXS5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0W25dICs9IFJuKG8pO1xuICAgIH1cbiAgd2hpbGUgKG8gPSBldCgpKTtcbiAgcmV0dXJuIHQ7XG59LCAkYyA9IGZ1bmN0aW9uKHQsIHIpIHtcbiAgcmV0dXJuIHdhKFJjKFRhKHQpLCByKSk7XG59LCBmaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBQYyA9IGZ1bmN0aW9uKHQpIHtcbiAgaWYgKCEodC50eXBlICE9PSBcInJ1bGVcIiB8fCAhdC5wYXJlbnQgfHwgLy8gcG9zaXRpdmUgLmxlbmd0aCBpbmRpY2F0ZXMgdGhhdCB0aGlzIHJ1bGUgY29udGFpbnMgcHNldWRvXG4gIC8vIG5lZ2F0aXZlIC5sZW5ndGggaW5kaWNhdGVzIHRoYXQgdGhpcyBydWxlIGhhcyBiZWVuIGFscmVhZHkgcHJlZml4ZWRcbiAgdC5sZW5ndGggPCAxKSkge1xuICAgIGZvciAodmFyIHIgPSB0LnZhbHVlLCBuID0gdC5wYXJlbnQsIG8gPSB0LmNvbHVtbiA9PT0gbi5jb2x1bW4gJiYgdC5saW5lID09PSBuLmxpbmU7IG4udHlwZSAhPT0gXCJydWxlXCI7IClcbiAgICAgIGlmIChuID0gbi5wYXJlbnQsICFuKSByZXR1cm47XG4gICAgaWYgKCEodC5wcm9wcy5sZW5ndGggPT09IDEgJiYgci5jaGFyQ29kZUF0KDApICE9PSA1OCAmJiAhZmkuZ2V0KG4pKSAmJiAhbykge1xuICAgICAgZmkuc2V0KHQsICEwKTtcbiAgICAgIGZvciAodmFyIGkgPSBbXSwgcyA9ICRjKHIsIGkpLCBjID0gbi5wcm9wcywgbCA9IDAsIHUgPSAwOyBsIDwgcy5sZW5ndGg7IGwrKylcbiAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBjLmxlbmd0aDsgcCsrLCB1KyspXG4gICAgICAgICAgdC5wcm9wc1t1XSA9IGlbbF0gPyBzW2xdLnJlcGxhY2UoLyZcXGYvZywgY1twXSkgOiBjW3BdICsgXCIgXCIgKyBzW2xdO1xuICAgIH1cbiAgfVxufSwga2MgPSBmdW5jdGlvbih0KSB7XG4gIGlmICh0LnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgdmFyIHIgPSB0LnZhbHVlO1xuICAgIC8vIGNoYXJjb2RlIGZvciBsXG4gICAgci5jaGFyQ29kZUF0KDApID09PSAxMDggJiYgLy8gY2hhcmNvZGUgZm9yIGJcbiAgICByLmNoYXJDb2RlQXQoMikgPT09IDk4ICYmICh0LnJldHVybiA9IFwiXCIsIHQudmFsdWUgPSBcIlwiKTtcbiAgfVxufTtcbmZ1bmN0aW9uIFJhKGUsIHQpIHtcbiAgc3dpdGNoIChkYyhlLCB0KSkge1xuICAgIC8vIGNvbG9yLWFkanVzdFxuICAgIGNhc2UgNTEwMzpcbiAgICAgIHJldHVybiBmZSArIFwicHJpbnQtXCIgKyBlICsgZTtcbiAgICAvLyBhbmltYXRpb24sIGFuaW1hdGlvbi0oZGVsYXl8ZGlyZWN0aW9ufGR1cmF0aW9ufGZpbGwtbW9kZXxpdGVyYXRpb24tY291bnR8bmFtZXxwbGF5LXN0YXRlfHRpbWluZy1mdW5jdGlvbilcbiAgICBjYXNlIDU3Mzc6XG4gICAgY2FzZSA0MjAxOlxuICAgIGNhc2UgMzE3NzpcbiAgICBjYXNlIDM0MzM6XG4gICAgY2FzZSAxNjQxOlxuICAgIGNhc2UgNDQ1NzpcbiAgICBjYXNlIDI5MjE6XG4gICAgLy8gdGV4dC1kZWNvcmF0aW9uLCBmaWx0ZXIsIGNsaXAtcGF0aCwgYmFja2ZhY2UtdmlzaWJpbGl0eSwgY29sdW1uLCBib3gtZGVjb3JhdGlvbi1icmVha1xuICAgIGNhc2UgNTU3MjpcbiAgICBjYXNlIDYzNTY6XG4gICAgY2FzZSA1ODQ0OlxuICAgIGNhc2UgMzE5MTpcbiAgICBjYXNlIDY2NDU6XG4gICAgY2FzZSAzMDA1OlxuICAgIC8vIG1hc2ssIG1hc2staW1hZ2UsIG1hc2stKG1vZGV8Y2xpcHxzaXplKSwgbWFzay0ocmVwZWF0fG9yaWdpbiksIG1hc2stcG9zaXRpb24sIG1hc2stY29tcG9zaXRlLFxuICAgIGNhc2UgNjM5MTpcbiAgICBjYXNlIDU4Nzk6XG4gICAgY2FzZSA1NjIzOlxuICAgIGNhc2UgNjEzNTpcbiAgICBjYXNlIDQ1OTk6XG4gICAgY2FzZSA0ODU1OlxuICAgIC8vIGJhY2tncm91bmQtY2xpcCwgY29sdW1ucywgY29sdW1uLShjb3VudHxmaWxsfGdhcHxydWxlfHJ1bGUtY29sb3J8cnVsZS1zdHlsZXxydWxlLXdpZHRofHNwYW58d2lkdGgpXG4gICAgY2FzZSA0MjE1OlxuICAgIGNhc2UgNjM4OTpcbiAgICBjYXNlIDUxMDk6XG4gICAgY2FzZSA1MzY1OlxuICAgIGNhc2UgNTYyMTpcbiAgICBjYXNlIDM4Mjk6XG4gICAgICByZXR1cm4gZmUgKyBlICsgZTtcbiAgICAvLyBhcHBlYXJhbmNlLCB1c2VyLXNlbGVjdCwgdHJhbnNmb3JtLCBoeXBoZW5zLCB0ZXh0LXNpemUtYWRqdXN0XG4gICAgY2FzZSA1MzQ5OlxuICAgIGNhc2UgNDI0NjpcbiAgICBjYXNlIDQ4MTA6XG4gICAgY2FzZSA2OTY4OlxuICAgIGNhc2UgMjc1NjpcbiAgICAgIHJldHVybiBmZSArIGUgKyBkbiArIGUgKyBZZSArIGUgKyBlO1xuICAgIC8vIGZsZXgsIGZsZXgtZGlyZWN0aW9uXG4gICAgY2FzZSA2ODI4OlxuICAgIGNhc2UgNDI2ODpcbiAgICAgIHJldHVybiBmZSArIGUgKyBZZSArIGUgKyBlO1xuICAgIC8vIG9yZGVyXG4gICAgY2FzZSA2MTY1OlxuICAgICAgcmV0dXJuIGZlICsgZSArIFllICsgXCJmbGV4LVwiICsgZSArIGU7XG4gICAgLy8gYWxpZ24taXRlbXNcbiAgICBjYXNlIDUxODc6XG4gICAgICByZXR1cm4gZmUgKyBlICsgZGUoZSwgLyhcXHcrKS4rKDpbXl0rKS8sIGZlICsgXCJib3gtJDEkMlwiICsgWWUgKyBcImZsZXgtJDEkMlwiKSArIGU7XG4gICAgLy8gYWxpZ24tc2VsZlxuICAgIGNhc2UgNTQ0MzpcbiAgICAgIHJldHVybiBmZSArIGUgKyBZZSArIFwiZmxleC1pdGVtLVwiICsgZGUoZSwgL2ZsZXgtfC1zZWxmLywgXCJcIikgKyBlO1xuICAgIC8vIGFsaWduLWNvbnRlbnRcbiAgICBjYXNlIDQ2NzU6XG4gICAgICByZXR1cm4gZmUgKyBlICsgWWUgKyBcImZsZXgtbGluZS1wYWNrXCIgKyBkZShlLCAvYWxpZ24tY29udGVudHxmbGV4LXwtc2VsZi8sIFwiXCIpICsgZTtcbiAgICAvLyBmbGV4LXNocmlua1xuICAgIGNhc2UgNTU0ODpcbiAgICAgIHJldHVybiBmZSArIGUgKyBZZSArIGRlKGUsIFwic2hyaW5rXCIsIFwibmVnYXRpdmVcIikgKyBlO1xuICAgIC8vIGZsZXgtYmFzaXNcbiAgICBjYXNlIDUyOTI6XG4gICAgICByZXR1cm4gZmUgKyBlICsgWWUgKyBkZShlLCBcImJhc2lzXCIsIFwicHJlZmVycmVkLXNpemVcIikgKyBlO1xuICAgIC8vIGZsZXgtZ3Jvd1xuICAgIGNhc2UgNjA2MDpcbiAgICAgIHJldHVybiBmZSArIFwiYm94LVwiICsgZGUoZSwgXCItZ3Jvd1wiLCBcIlwiKSArIGZlICsgZSArIFllICsgZGUoZSwgXCJncm93XCIsIFwicG9zaXRpdmVcIikgKyBlO1xuICAgIC8vIHRyYW5zaXRpb25cbiAgICBjYXNlIDQ1NTQ6XG4gICAgICByZXR1cm4gZmUgKyBkZShlLCAvKFteLV0pKHRyYW5zZm9ybSkvZywgXCIkMVwiICsgZmUgKyBcIiQyXCIpICsgZTtcbiAgICAvLyBjdXJzb3JcbiAgICBjYXNlIDYxODc6XG4gICAgICByZXR1cm4gZGUoZGUoZGUoZSwgLyh6b29tLXxncmFiKS8sIGZlICsgXCIkMVwiKSwgLyhpbWFnZS1zZXQpLywgZmUgKyBcIiQxXCIpLCBlLCBcIlwiKSArIGU7XG4gICAgLy8gYmFja2dyb3VuZCwgYmFja2dyb3VuZC1pbWFnZVxuICAgIGNhc2UgNTQ5NTpcbiAgICBjYXNlIDM5NTk6XG4gICAgICByZXR1cm4gZGUoZSwgLyhpbWFnZS1zZXRcXChbXl0qKS8sIGZlICsgXCIkMSRgJDFcIik7XG4gICAgLy8ganVzdGlmeS1jb250ZW50XG4gICAgY2FzZSA0OTY4OlxuICAgICAgcmV0dXJuIGRlKGRlKGUsIC8oLis6KShmbGV4LSk/KC4qKS8sIGZlICsgXCJib3gtcGFjazokM1wiICsgWWUgKyBcImZsZXgtcGFjazokM1wiKSwgL3MuKy1iW147XSsvLCBcImp1c3RpZnlcIikgKyBmZSArIGUgKyBlO1xuICAgIC8vIChtYXJnaW58cGFkZGluZyktaW5saW5lLShzdGFydHxlbmQpXG4gICAgY2FzZSA0MDk1OlxuICAgIGNhc2UgMzU4MzpcbiAgICBjYXNlIDQwNjg6XG4gICAgY2FzZSAyNTMyOlxuICAgICAgcmV0dXJuIGRlKGUsIC8oLispLWlubGluZSguKykvLCBmZSArIFwiJDEkMlwiKSArIGU7XG4gICAgLy8gKG1pbnxtYXgpPyh3aWR0aHxoZWlnaHR8aW5saW5lLXNpemV8YmxvY2stc2l6ZSlcbiAgICBjYXNlIDgxMTY6XG4gICAgY2FzZSA3MDU5OlxuICAgIGNhc2UgNTc1MzpcbiAgICBjYXNlIDU1MzU6XG4gICAgY2FzZSA1NDQ1OlxuICAgIGNhc2UgNTcwMTpcbiAgICBjYXNlIDQ5MzM6XG4gICAgY2FzZSA0Njc3OlxuICAgIGNhc2UgNTUzMzpcbiAgICBjYXNlIDU3ODk6XG4gICAgY2FzZSA1MDIxOlxuICAgIGNhc2UgNDc2NTpcbiAgICAgIGlmIChtdChlKSAtIDEgLSB0ID4gNikgc3dpdGNoIChCZShlLCB0ICsgMSkpIHtcbiAgICAgICAgLy8gKG0pYXgtY29udGVudCwgKG0paW4tY29udGVudFxuICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICBpZiAoQmUoZSwgdCArIDQpICE9PSA0NSkgYnJlYWs7XG4gICAgICAgIC8vIChmKWlsbC1hdmFpbGFibGUsIChmKWl0LWNvbnRlbnRcbiAgICAgICAgY2FzZSAxMDI6XG4gICAgICAgICAgcmV0dXJuIGRlKGUsIC8oLis6KSguKyktKFteXSspLywgXCIkMVwiICsgZmUgKyBcIiQyLSQzJDFcIiArIGRuICsgKEJlKGUsIHQgKyAzKSA9PSAxMDggPyBcIiQzXCIgOiBcIiQyLSQzXCIpKSArIGU7XG4gICAgICAgIC8vIChzKXRyZXRjaFxuICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICByZXR1cm4gfm9vKGUsIFwic3RyZXRjaFwiKSA/IFJhKGRlKGUsIFwic3RyZXRjaFwiLCBcImZpbGwtYXZhaWxhYmxlXCIpLCB0KSArIGUgOiBlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgLy8gcG9zaXRpb246IHN0aWNreVxuICAgIGNhc2UgNDk0OTpcbiAgICAgIGlmIChCZShlLCB0ICsgMSkgIT09IDExNSkgYnJlYWs7XG4gICAgLy8gZGlzcGxheTogKGZsZXh8aW5saW5lLWZsZXgpXG4gICAgY2FzZSA2NDQ0OlxuICAgICAgc3dpdGNoIChCZShlLCBtdChlKSAtIDMgLSAofm9vKGUsIFwiIWltcG9ydGFudFwiKSAmJiAxMCkpKSB7XG4gICAgICAgIC8vIHN0aWMoayl5XG4gICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgIHJldHVybiBkZShlLCBcIjpcIiwgXCI6XCIgKyBmZSkgKyBlO1xuICAgICAgICAvLyAoaW5saW5lLSk/ZmwoZSl4XG4gICAgICAgIGNhc2UgMTAxOlxuICAgICAgICAgIHJldHVybiBkZShlLCAvKC4rOikoW147IV0rKSg7fCEuKyk/LywgXCIkMVwiICsgZmUgKyAoQmUoZSwgMTQpID09PSA0NSA/IFwiaW5saW5lLVwiIDogXCJcIikgKyBcImJveCQzJDFcIiArIGZlICsgXCIkMiQzJDFcIiArIFllICsgXCIkMmJveCQzXCIpICsgZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIC8vIHdyaXRpbmctbW9kZVxuICAgIGNhc2UgNTkzNjpcbiAgICAgIHN3aXRjaCAoQmUoZSwgdCArIDExKSkge1xuICAgICAgICAvLyB2ZXJ0aWNhbC1sKHIpXG4gICAgICAgIGNhc2UgMTE0OlxuICAgICAgICAgIHJldHVybiBmZSArIGUgKyBZZSArIGRlKGUsIC9bc3ZoXVxcdystW3RibHJdezJ9LywgXCJ0YlwiKSArIGU7XG4gICAgICAgIC8vIHZlcnRpY2FsLXIobClcbiAgICAgICAgY2FzZSAxMDg6XG4gICAgICAgICAgcmV0dXJuIGZlICsgZSArIFllICsgZGUoZSwgL1tzdmhdXFx3Ky1bdGJscl17Mn0vLCBcInRiLXJsXCIpICsgZTtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCgtKXRiXG4gICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgcmV0dXJuIGZlICsgZSArIFllICsgZGUoZSwgL1tzdmhdXFx3Ky1bdGJscl17Mn0vLCBcImxyXCIpICsgZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmZSArIGUgKyBZZSArIGUgKyBlO1xuICB9XG4gIHJldHVybiBlO1xufVxudmFyIEFjID0gZnVuY3Rpb24odCwgciwgbiwgbykge1xuICBpZiAodC5sZW5ndGggPiAtMSAmJiAhdC5yZXR1cm4pIHN3aXRjaCAodC50eXBlKSB7XG4gICAgY2FzZSBFbzpcbiAgICAgIHQucmV0dXJuID0gUmEodC52YWx1ZSwgdC5sZW5ndGgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTYTpcbiAgICAgIHJldHVybiBYdChbZHIodCwge1xuICAgICAgICB2YWx1ZTogZGUodC52YWx1ZSwgXCJAXCIsIFwiQFwiICsgZmUpXG4gICAgICB9KV0sIG8pO1xuICAgIGNhc2UgU286XG4gICAgICBpZiAodC5sZW5ndGgpIHJldHVybiBtYyh0LnByb3BzLCBmdW5jdGlvbihpKSB7XG4gICAgICAgIHN3aXRjaCAocGMoaSwgLyg6OnBsYWNcXHcrfDpyZWFkLVxcdyspLykpIHtcbiAgICAgICAgICAvLyA6cmVhZC0ob25seXx3cml0ZSlcbiAgICAgICAgICBjYXNlIFwiOnJlYWQtb25seVwiOlxuICAgICAgICAgIGNhc2UgXCI6cmVhZC13cml0ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFh0KFtkcih0LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBbZGUoaSwgLzoocmVhZC1cXHcrKS8sIFwiOlwiICsgZG4gKyBcIiQxXCIpXVxuICAgICAgICAgICAgfSldLCBvKTtcbiAgICAgICAgICAvLyA6cGxhY2Vob2xkZXJcbiAgICAgICAgICBjYXNlIFwiOjpwbGFjZWhvbGRlclwiOlxuICAgICAgICAgICAgcmV0dXJuIFh0KFtkcih0LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBbZGUoaSwgLzoocGxhY1xcdyspLywgXCI6XCIgKyBmZSArIFwiaW5wdXQtJDFcIildXG4gICAgICAgICAgICB9KSwgZHIodCwge1xuICAgICAgICAgICAgICBwcm9wczogW2RlKGksIC86KHBsYWNcXHcrKS8sIFwiOlwiICsgZG4gKyBcIiQxXCIpXVxuICAgICAgICAgICAgfSksIGRyKHQsIHtcbiAgICAgICAgICAgICAgcHJvcHM6IFtkZShpLCAvOihwbGFjXFx3KykvLCBZZSArIFwiaW5wdXQtJDFcIildXG4gICAgICAgICAgICB9KV0sIG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfSk7XG4gIH1cbn0sIE5jID0gW0FjXSwgTWMgPSBmdW5jdGlvbih0KSB7XG4gIHZhciByID0gdC5rZXk7XG4gIGlmIChyID09PSBcImNzc1wiKSB7XG4gICAgdmFyIG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVbZGF0YS1lbW90aW9uXTpub3QoW2RhdGEtc10pXCIpO1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobiwgZnVuY3Rpb24oZikge1xuICAgICAgdmFyIFMgPSBmLmdldEF0dHJpYnV0ZShcImRhdGEtZW1vdGlvblwiKTtcbiAgICAgIFMuaW5kZXhPZihcIiBcIikgIT09IC0xICYmIChkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGYpLCBmLnNldEF0dHJpYnV0ZShcImRhdGEtc1wiLCBcIlwiKSk7XG4gICAgfSk7XG4gIH1cbiAgdmFyIG8gPSB0LnN0eWxpc1BsdWdpbnMgfHwgTmMsIGkgPSB7fSwgcywgYyA9IFtdO1xuICBzID0gdC5jb250YWluZXIgfHwgZG9jdW1lbnQuaGVhZCwgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChcbiAgICAvLyB0aGlzIG1lYW5zIHdlIHdpbGwgaWdub3JlIGVsZW1lbnRzIHdoaWNoIGRvbid0IGhhdmUgYSBzcGFjZSBpbiB0aGVtIHdoaWNoXG4gICAgLy8gbWVhbnMgdGhhdCB0aGUgc3R5bGUgZWxlbWVudHMgd2UncmUgbG9va2luZyBhdCBhcmUgb25seSBFbW90aW9uIDExIHNlcnZlci1yZW5kZXJlZCBzdHlsZSBlbGVtZW50c1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlW2RhdGEtZW1vdGlvbl49XCInICsgciArICcgXCJdJyksXG4gICAgZnVuY3Rpb24oZikge1xuICAgICAgZm9yICh2YXIgUyA9IGYuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbW90aW9uXCIpLnNwbGl0KFwiIFwiKSwgRSA9IDE7IEUgPCBTLmxlbmd0aDsgRSsrKVxuICAgICAgICBpW1NbRV1dID0gITA7XG4gICAgICBjLnB1c2goZik7XG4gICAgfVxuICApO1xuICB2YXIgbCwgdSA9IFtQYywga2NdO1xuICB7XG4gICAgdmFyIHAsIG0gPSBbQ2MsIHdjKGZ1bmN0aW9uKGYpIHtcbiAgICAgIHAuaW5zZXJ0KGYpO1xuICAgIH0pXSwgZyA9IFRjKHUuY29uY2F0KG8sIG0pKSwgeCA9IGZ1bmN0aW9uKFMpIHtcbiAgICAgIHJldHVybiBYdChTYyhTKSwgZyk7XG4gICAgfTtcbiAgICBsID0gZnVuY3Rpb24oUywgRSwgUCwgVCkge1xuICAgICAgcCA9IFAsIHgoUyA/IFMgKyBcIntcIiArIEUuc3R5bGVzICsgXCJ9XCIgOiBFLnN0eWxlcyksIFQgJiYgKHkuaW5zZXJ0ZWRbRS5uYW1lXSA9ICEwKTtcbiAgICB9O1xuICB9XG4gIHZhciB5ID0ge1xuICAgIGtleTogcixcbiAgICBzaGVldDogbmV3IHNjKHtcbiAgICAgIGtleTogcixcbiAgICAgIGNvbnRhaW5lcjogcyxcbiAgICAgIG5vbmNlOiB0Lm5vbmNlLFxuICAgICAgc3BlZWR5OiB0LnNwZWVkeSxcbiAgICAgIHByZXBlbmQ6IHQucHJlcGVuZCxcbiAgICAgIGluc2VydGlvblBvaW50OiB0Lmluc2VydGlvblBvaW50XG4gICAgfSksXG4gICAgbm9uY2U6IHQubm9uY2UsXG4gICAgaW5zZXJ0ZWQ6IGksXG4gICAgcmVnaXN0ZXJlZDoge30sXG4gICAgaW5zZXJ0OiBsXG4gIH07XG4gIHJldHVybiB5LnNoZWV0Lmh5ZHJhdGUoYyksIHk7XG59LCBIciA9IHsgZXhwb3J0czoge30gfSwgcGUgPSB7fTtcbi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGRpO1xuZnVuY3Rpb24gSWMoKSB7XG4gIGlmIChkaSkgcmV0dXJuIHBlO1xuICBkaSA9IDE7XG4gIHZhciBlID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmZvciwgdCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSA6IDYwMTAzLCByID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIikgOiA2MDEwNiwgbiA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIikgOiA2MDEwNywgbyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIikgOiA2MDEwOCwgaSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIikgOiA2MDExNCwgcyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIikgOiA2MDEwOSwgYyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSA6IDYwMTEwLCBsID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5hc3luY19tb2RlXCIpIDogNjAxMTEsIHUgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKSA6IDYwMTExLCBwID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSA6IDYwMTEyLCBtID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSA6IDYwMTEzLCBnID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpIDogNjAxMjAsIHggPSBlID8gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIikgOiA2MDExNSwgeSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSA6IDYwMTE2LCBmID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKSA6IDYwMTIxLCBTID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mdW5kYW1lbnRhbFwiKSA6IDYwMTE3LCBFID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5yZXNwb25kZXJcIikgOiA2MDExOCwgUCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIikgOiA2MDExOTtcbiAgZnVuY3Rpb24gVChoKSB7XG4gICAgaWYgKHR5cGVvZiBoID09IFwib2JqZWN0XCIgJiYgaCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHcgPSBoLiQkdHlwZW9mO1xuICAgICAgc3dpdGNoICh3KSB7XG4gICAgICAgIGNhc2UgdDpcbiAgICAgICAgICBzd2l0Y2ggKGggPSBoLnR5cGUsIGgpIHtcbiAgICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgIGNhc2UgbjpcbiAgICAgICAgICAgIGNhc2UgaTpcbiAgICAgICAgICAgIGNhc2UgbzpcbiAgICAgICAgICAgIGNhc2UgbTpcbiAgICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzd2l0Y2ggKGggPSBoICYmIGguJCR0eXBlb2YsIGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICAgICAgY2FzZSBwOlxuICAgICAgICAgICAgICAgIGNhc2UgeTpcbiAgICAgICAgICAgICAgICBjYXNlIHg6XG4gICAgICAgICAgICAgICAgY2FzZSBzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgcmV0dXJuIHc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGIoaCkge1xuICAgIHJldHVybiBUKGgpID09PSB1O1xuICB9XG4gIHJldHVybiBwZS5Bc3luY01vZGUgPSBsLCBwZS5Db25jdXJyZW50TW9kZSA9IHUsIHBlLkNvbnRleHRDb25zdW1lciA9IGMsIHBlLkNvbnRleHRQcm92aWRlciA9IHMsIHBlLkVsZW1lbnQgPSB0LCBwZS5Gb3J3YXJkUmVmID0gcCwgcGUuRnJhZ21lbnQgPSBuLCBwZS5MYXp5ID0geSwgcGUuTWVtbyA9IHgsIHBlLlBvcnRhbCA9IHIsIHBlLlByb2ZpbGVyID0gaSwgcGUuU3RyaWN0TW9kZSA9IG8sIHBlLlN1c3BlbnNlID0gbSwgcGUuaXNBc3luY01vZGUgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGIoaCkgfHwgVChoKSA9PT0gbDtcbiAgfSwgcGUuaXNDb25jdXJyZW50TW9kZSA9IGIsIHBlLmlzQ29udGV4dENvbnN1bWVyID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSBjO1xuICB9LCBwZS5pc0NvbnRleHRQcm92aWRlciA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0gcztcbiAgfSwgcGUuaXNFbGVtZW50ID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiB0eXBlb2YgaCA9PSBcIm9iamVjdFwiICYmIGggIT09IG51bGwgJiYgaC4kJHR5cGVvZiA9PT0gdDtcbiAgfSwgcGUuaXNGb3J3YXJkUmVmID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSBwO1xuICB9LCBwZS5pc0ZyYWdtZW50ID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSBuO1xuICB9LCBwZS5pc0xhenkgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IHk7XG4gIH0sIHBlLmlzTWVtbyA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0geDtcbiAgfSwgcGUuaXNQb3J0YWwgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IHI7XG4gIH0sIHBlLmlzUHJvZmlsZXIgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IGk7XG4gIH0sIHBlLmlzU3RyaWN0TW9kZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0gbztcbiAgfSwgcGUuaXNTdXNwZW5zZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0gbTtcbiAgfSwgcGUuaXNWYWxpZEVsZW1lbnRUeXBlID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiB0eXBlb2YgaCA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBoID09IFwiZnVuY3Rpb25cIiB8fCBoID09PSBuIHx8IGggPT09IHUgfHwgaCA9PT0gaSB8fCBoID09PSBvIHx8IGggPT09IG0gfHwgaCA9PT0gZyB8fCB0eXBlb2YgaCA9PSBcIm9iamVjdFwiICYmIGggIT09IG51bGwgJiYgKGguJCR0eXBlb2YgPT09IHkgfHwgaC4kJHR5cGVvZiA9PT0geCB8fCBoLiQkdHlwZW9mID09PSBzIHx8IGguJCR0eXBlb2YgPT09IGMgfHwgaC4kJHR5cGVvZiA9PT0gcCB8fCBoLiQkdHlwZW9mID09PSBTIHx8IGguJCR0eXBlb2YgPT09IEUgfHwgaC4kJHR5cGVvZiA9PT0gUCB8fCBoLiQkdHlwZW9mID09PSBmKTtcbiAgfSwgcGUudHlwZU9mID0gVCwgcGU7XG59XG52YXIgbWUgPSB7fTtcbi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIHBpO1xuZnVuY3Rpb24gX2MoKSB7XG4gIHJldHVybiBwaSB8fCAocGkgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yLCB0ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpIDogNjAxMDMsIHIgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSA6IDYwMTA2LCBuID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSA6IDYwMTA3LCBvID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSA6IDYwMTA4LCBpID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSA6IDYwMTE0LCBzID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSA6IDYwMTA5LCBjID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpIDogNjAxMTAsIGwgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIikgOiA2MDExMSwgdSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuY29uY3VycmVudF9tb2RlXCIpIDogNjAxMTEsIHAgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpIDogNjAxMTIsIG0gPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpIDogNjAxMTMsIGcgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIikgOiA2MDEyMCwgeCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSA6IDYwMTE1LCB5ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpIDogNjAxMTYsIGYgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmJsb2NrXCIpIDogNjAxMjEsIFMgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmZ1bmRhbWVudGFsXCIpIDogNjAxMTcsIEUgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnJlc3BvbmRlclwiKSA6IDYwMTE4LCBQID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKSA6IDYwMTE5O1xuICAgIGZ1bmN0aW9uIFQoTykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBPID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIE8gPT0gXCJmdW5jdGlvblwiIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gICAgICBPID09PSBuIHx8IE8gPT09IHUgfHwgTyA9PT0gaSB8fCBPID09PSBvIHx8IE8gPT09IG0gfHwgTyA9PT0gZyB8fCB0eXBlb2YgTyA9PSBcIm9iamVjdFwiICYmIE8gIT09IG51bGwgJiYgKE8uJCR0eXBlb2YgPT09IHkgfHwgTy4kJHR5cGVvZiA9PT0geCB8fCBPLiQkdHlwZW9mID09PSBzIHx8IE8uJCR0eXBlb2YgPT09IGMgfHwgTy4kJHR5cGVvZiA9PT0gcCB8fCBPLiQkdHlwZW9mID09PSBTIHx8IE8uJCR0eXBlb2YgPT09IEUgfHwgTy4kJHR5cGVvZiA9PT0gUCB8fCBPLiQkdHlwZW9mID09PSBmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYihPKSB7XG4gICAgICBpZiAodHlwZW9mIE8gPT0gXCJvYmplY3RcIiAmJiBPICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB5ZSA9IE8uJCR0eXBlb2Y7XG4gICAgICAgIHN3aXRjaCAoeWUpIHtcbiAgICAgICAgICBjYXNlIHQ6XG4gICAgICAgICAgICB2YXIgRWUgPSBPLnR5cGU7XG4gICAgICAgICAgICBzd2l0Y2ggKEVlKSB7XG4gICAgICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgICBjYXNlIG46XG4gICAgICAgICAgICAgIGNhc2UgaTpcbiAgICAgICAgICAgICAgY2FzZSBvOlxuICAgICAgICAgICAgICBjYXNlIG06XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBNZSA9IEVlICYmIEVlLiQkdHlwZW9mO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoTWUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgYzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgcDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgeTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgeDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgczpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1lO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHllO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICByZXR1cm4geWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGggPSBsLCB3ID0gdSwgayA9IGMsIEwgPSBzLCBCID0gdCwgZCA9IHAsIEEgPSBuLCBEID0geSwgaiA9IHgsIFcgPSByLCB6ID0gaSwgVSA9IG8sIFYgPSBtLCB0ZSA9ICExO1xuICAgIGZ1bmN0aW9uIEYoTykge1xuICAgICAgcmV0dXJuIHRlIHx8ICh0ZSA9ICEwLCBjb25zb2xlLndhcm4oXCJUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSBSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLlwiKSksIFIoTykgfHwgYihPKSA9PT0gbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUihPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gdTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSShPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gSihPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gcztcbiAgICB9XG4gICAgZnVuY3Rpb24gUShPKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIE8gPT0gXCJvYmplY3RcIiAmJiBPICE9PSBudWxsICYmIE8uJCR0eXBlb2YgPT09IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEgoTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFgoTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIF8oTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHEoTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEcoTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSBpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBaKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSBvO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZShPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gbTtcbiAgICB9XG4gICAgbWUuQXN5bmNNb2RlID0gaCwgbWUuQ29uY3VycmVudE1vZGUgPSB3LCBtZS5Db250ZXh0Q29uc3VtZXIgPSBrLCBtZS5Db250ZXh0UHJvdmlkZXIgPSBMLCBtZS5FbGVtZW50ID0gQiwgbWUuRm9yd2FyZFJlZiA9IGQsIG1lLkZyYWdtZW50ID0gQSwgbWUuTGF6eSA9IEQsIG1lLk1lbW8gPSBqLCBtZS5Qb3J0YWwgPSBXLCBtZS5Qcm9maWxlciA9IHosIG1lLlN0cmljdE1vZGUgPSBVLCBtZS5TdXNwZW5zZSA9IFYsIG1lLmlzQXN5bmNNb2RlID0gRiwgbWUuaXNDb25jdXJyZW50TW9kZSA9IFIsIG1lLmlzQ29udGV4dENvbnN1bWVyID0gSSwgbWUuaXNDb250ZXh0UHJvdmlkZXIgPSBKLCBtZS5pc0VsZW1lbnQgPSBRLCBtZS5pc0ZvcndhcmRSZWYgPSBILCBtZS5pc0ZyYWdtZW50ID0gWCwgbWUuaXNMYXp5ID0gXywgbWUuaXNNZW1vID0gcSwgbWUuaXNQb3J0YWwgPSBHLCBtZS5pc1Byb2ZpbGVyID0gcmUsIG1lLmlzU3RyaWN0TW9kZSA9IFosIG1lLmlzU3VzcGVuc2UgPSBhZSwgbWUuaXNWYWxpZEVsZW1lbnRUeXBlID0gVCwgbWUudHlwZU9mID0gYjtcbiAgfSgpKSwgbWU7XG59XG52YXIgbWk7XG5mdW5jdGlvbiBqYygpIHtcbiAgcmV0dXJuIG1pIHx8IChtaSA9IDEsIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IEhyLmV4cG9ydHMgPSBJYygpIDogSHIuZXhwb3J0cyA9IF9jKCkpLCBIci5leHBvcnRzO1xufVxudmFyIFluLCBoaTtcbmZ1bmN0aW9uIERjKCkge1xuICBpZiAoaGkpIHJldHVybiBZbjtcbiAgaGkgPSAxO1xuICB2YXIgZSA9IGpjKCksIHQgPSB7XG4gICAgY2hpbGRDb250ZXh0VHlwZXM6ICEwLFxuICAgIGNvbnRleHRUeXBlOiAhMCxcbiAgICBjb250ZXh0VHlwZXM6ICEwLFxuICAgIGRlZmF1bHRQcm9wczogITAsXG4gICAgZGlzcGxheU5hbWU6ICEwLFxuICAgIGdldERlZmF1bHRQcm9wczogITAsXG4gICAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiAhMCxcbiAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6ICEwLFxuICAgIG1peGluczogITAsXG4gICAgcHJvcFR5cGVzOiAhMCxcbiAgICB0eXBlOiAhMFxuICB9LCByID0ge1xuICAgIG5hbWU6ICEwLFxuICAgIGxlbmd0aDogITAsXG4gICAgcHJvdG90eXBlOiAhMCxcbiAgICBjYWxsZXI6ICEwLFxuICAgIGNhbGxlZTogITAsXG4gICAgYXJndW1lbnRzOiAhMCxcbiAgICBhcml0eTogITBcbiAgfSwgbiA9IHtcbiAgICAkJHR5cGVvZjogITAsXG4gICAgcmVuZGVyOiAhMCxcbiAgICBkZWZhdWx0UHJvcHM6ICEwLFxuICAgIGRpc3BsYXlOYW1lOiAhMCxcbiAgICBwcm9wVHlwZXM6ICEwXG4gIH0sIG8gPSB7XG4gICAgJCR0eXBlb2Y6ICEwLFxuICAgIGNvbXBhcmU6ICEwLFxuICAgIGRlZmF1bHRQcm9wczogITAsXG4gICAgZGlzcGxheU5hbWU6ICEwLFxuICAgIHByb3BUeXBlczogITAsXG4gICAgdHlwZTogITBcbiAgfSwgaSA9IHt9O1xuICBpW2UuRm9yd2FyZFJlZl0gPSBuLCBpW2UuTWVtb10gPSBvO1xuICBmdW5jdGlvbiBzKHkpIHtcbiAgICByZXR1cm4gZS5pc01lbW8oeSkgPyBvIDogaVt5LiQkdHlwZW9mXSB8fCB0O1xuICB9XG4gIHZhciBjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBsID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsIHUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwgbSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgZyA9IE9iamVjdC5wcm90b3R5cGU7XG4gIGZ1bmN0aW9uIHgoeSwgZiwgUykge1xuICAgIGlmICh0eXBlb2YgZiAhPSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoZykge1xuICAgICAgICB2YXIgRSA9IG0oZik7XG4gICAgICAgIEUgJiYgRSAhPT0gZyAmJiB4KHksIEUsIFMpO1xuICAgICAgfVxuICAgICAgdmFyIFAgPSBsKGYpO1xuICAgICAgdSAmJiAoUCA9IFAuY29uY2F0KHUoZikpKTtcbiAgICAgIGZvciAodmFyIFQgPSBzKHkpLCBiID0gcyhmKSwgaCA9IDA7IGggPCBQLmxlbmd0aDsgKytoKSB7XG4gICAgICAgIHZhciB3ID0gUFtoXTtcbiAgICAgICAgaWYgKCFyW3ddICYmICEoUyAmJiBTW3ddKSAmJiAhKGIgJiYgYlt3XSkgJiYgIShUICYmIFRbd10pKSB7XG4gICAgICAgICAgdmFyIGsgPSBwKGYsIHcpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjKHksIHcsIGspO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geTtcbiAgfVxuICByZXR1cm4gWW4gPSB4LCBZbjtcbn1cbkRjKCk7XG52YXIgTGMgPSAhMDtcbmZ1bmN0aW9uICRhKGUsIHQsIHIpIHtcbiAgdmFyIG4gPSBcIlwiO1xuICByZXR1cm4gci5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgZVtvXSAhPT0gdm9pZCAwID8gdC5wdXNoKGVbb10gKyBcIjtcIikgOiBvICYmIChuICs9IG8gKyBcIiBcIik7XG4gIH0pLCBuO1xufVxudmFyIFRvID0gZnVuY3Rpb24odCwgciwgbikge1xuICB2YXIgbyA9IHQua2V5ICsgXCItXCIgKyByLm5hbWU7XG4gIC8vIHdlIG9ubHkgbmVlZCB0byBhZGQgdGhlIHN0eWxlcyB0byB0aGUgcmVnaXN0ZXJlZCBjYWNoZSBpZiB0aGVcbiAgLy8gY2xhc3MgbmFtZSBjb3VsZCBiZSB1c2VkIGZ1cnRoZXIgZG93blxuICAvLyB0aGUgdHJlZSBidXQgaWYgaXQncyBhIHN0cmluZyB0YWcsIHdlIGtub3cgaXQgd29uJ3RcbiAgLy8gc28gd2UgZG9uJ3QgaGF2ZSB0byBhZGQgaXQgdG8gcmVnaXN0ZXJlZCBjYWNoZS5cbiAgLy8gdGhpcyBpbXByb3ZlcyBtZW1vcnkgdXNhZ2Ugc2luY2Ugd2UgY2FuIGF2b2lkIHN0b3JpbmcgdGhlIHdob2xlIHN0eWxlIHN0cmluZ1xuICAobiA9PT0gITEgfHwgLy8gd2UgbmVlZCB0byBhbHdheXMgc3RvcmUgaXQgaWYgd2UncmUgaW4gY29tcGF0IG1vZGUgYW5kXG4gIC8vIGluIG5vZGUgc2luY2UgZW1vdGlvbi1zZXJ2ZXIgcmVsaWVzIG9uIHdoZXRoZXIgYSBzdHlsZSBpcyBpblxuICAvLyB0aGUgcmVnaXN0ZXJlZCBjYWNoZSB0byBrbm93IHdoZXRoZXIgYSBzdHlsZSBpcyBnbG9iYWwgb3Igbm90XG4gIC8vIGFsc28sIG5vdGUgdGhhdCB0aGlzIGNoZWNrIHdpbGwgYmUgZGVhZCBjb2RlIGVsaW1pbmF0ZWQgaW4gdGhlIGJyb3dzZXJcbiAgTGMgPT09ICExKSAmJiB0LnJlZ2lzdGVyZWRbb10gPT09IHZvaWQgMCAmJiAodC5yZWdpc3RlcmVkW29dID0gci5zdHlsZXMpO1xufSwgd28gPSBmdW5jdGlvbih0LCByLCBuKSB7XG4gIFRvKHQsIHIsIG4pO1xuICB2YXIgbyA9IHQua2V5ICsgXCItXCIgKyByLm5hbWU7XG4gIGlmICh0Lmluc2VydGVkW3IubmFtZV0gPT09IHZvaWQgMCkge1xuICAgIHZhciBpID0gcjtcbiAgICBkb1xuICAgICAgdC5pbnNlcnQociA9PT0gaSA/IFwiLlwiICsgbyA6IFwiXCIsIGksIHQuc2hlZXQsICEwKSwgaSA9IGkubmV4dDtcbiAgICB3aGlsZSAoaSAhPT0gdm9pZCAwKTtcbiAgfVxufTtcbmZ1bmN0aW9uIEJjKGUpIHtcbiAgZm9yICh2YXIgdCA9IDAsIHIsIG4gPSAwLCBvID0gZS5sZW5ndGg7IG8gPj0gNDsgKytuLCBvIC09IDQpXG4gICAgciA9IGUuY2hhckNvZGVBdChuKSAmIDI1NSB8IChlLmNoYXJDb2RlQXQoKytuKSAmIDI1NSkgPDwgOCB8IChlLmNoYXJDb2RlQXQoKytuKSAmIDI1NSkgPDwgMTYgfCAoZS5jaGFyQ29kZUF0KCsrbikgJiAyNTUpIDw8IDI0LCByID0gLyogTWF0aC5pbXVsKGssIG0pOiAqL1xuICAgIChyICYgNjU1MzUpICogMTU0MDQ4MzQ3NyArICgociA+Pj4gMTYpICogNTk3OTcgPDwgMTYpLCByIF49IC8qIGsgPj4+IHI6ICovXG4gICAgciA+Pj4gMjQsIHQgPSAvKiBNYXRoLmltdWwoaywgbSk6ICovXG4gICAgKHIgJiA2NTUzNSkgKiAxNTQwNDgzNDc3ICsgKChyID4+PiAxNikgKiA1OTc5NyA8PCAxNikgXiAvKiBNYXRoLmltdWwoaCwgbSk6ICovXG4gICAgKHQgJiA2NTUzNSkgKiAxNTQwNDgzNDc3ICsgKCh0ID4+PiAxNikgKiA1OTc5NyA8PCAxNik7XG4gIHN3aXRjaCAobykge1xuICAgIGNhc2UgMzpcbiAgICAgIHQgXj0gKGUuY2hhckNvZGVBdChuICsgMikgJiAyNTUpIDw8IDE2O1xuICAgIGNhc2UgMjpcbiAgICAgIHQgXj0gKGUuY2hhckNvZGVBdChuICsgMSkgJiAyNTUpIDw8IDg7XG4gICAgY2FzZSAxOlxuICAgICAgdCBePSBlLmNoYXJDb2RlQXQobikgJiAyNTUsIHQgPSAvKiBNYXRoLmltdWwoaCwgbSk6ICovXG4gICAgICAodCAmIDY1NTM1KSAqIDE1NDA0ODM0NzcgKyAoKHQgPj4+IDE2KSAqIDU5Nzk3IDw8IDE2KTtcbiAgfVxuICByZXR1cm4gdCBePSB0ID4+PiAxMywgdCA9IC8qIE1hdGguaW11bChoLCBtKTogKi9cbiAgKHQgJiA2NTUzNSkgKiAxNTQwNDgzNDc3ICsgKCh0ID4+PiAxNikgKiA1OTc5NyA8PCAxNiksICgodCBeIHQgPj4+IDE1KSA+Pj4gMCkudG9TdHJpbmcoMzYpO1xufVxudmFyIFZjID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogMSxcbiAgYXNwZWN0UmF0aW86IDEsXG4gIGJvcmRlckltYWdlT3V0c2V0OiAxLFxuICBib3JkZXJJbWFnZVNsaWNlOiAxLFxuICBib3JkZXJJbWFnZVdpZHRoOiAxLFxuICBib3hGbGV4OiAxLFxuICBib3hGbGV4R3JvdXA6IDEsXG4gIGJveE9yZGluYWxHcm91cDogMSxcbiAgY29sdW1uQ291bnQ6IDEsXG4gIGNvbHVtbnM6IDEsXG4gIGZsZXg6IDEsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4UG9zaXRpdmU6IDEsXG4gIGZsZXhTaHJpbms6IDEsXG4gIGZsZXhOZWdhdGl2ZTogMSxcbiAgZmxleE9yZGVyOiAxLFxuICBncmlkUm93OiAxLFxuICBncmlkUm93RW5kOiAxLFxuICBncmlkUm93U3BhbjogMSxcbiAgZ3JpZFJvd1N0YXJ0OiAxLFxuICBncmlkQ29sdW1uOiAxLFxuICBncmlkQ29sdW1uRW5kOiAxLFxuICBncmlkQ29sdW1uU3BhbjogMSxcbiAgZ3JpZENvbHVtblN0YXJ0OiAxLFxuICBtc0dyaWRSb3c6IDEsXG4gIG1zR3JpZFJvd1NwYW46IDEsXG4gIG1zR3JpZENvbHVtbjogMSxcbiAgbXNHcmlkQ29sdW1uU3BhbjogMSxcbiAgZm9udFdlaWdodDogMSxcbiAgbGluZUhlaWdodDogMSxcbiAgb3BhY2l0eTogMSxcbiAgb3JkZXI6IDEsXG4gIG9ycGhhbnM6IDEsXG4gIHNjYWxlOiAxLFxuICB0YWJTaXplOiAxLFxuICB3aWRvd3M6IDEsXG4gIHpJbmRleDogMSxcbiAgem9vbTogMSxcbiAgV2Via2l0TGluZUNsYW1wOiAxLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiAxLFxuICBmbG9vZE9wYWNpdHk6IDEsXG4gIHN0b3BPcGFjaXR5OiAxLFxuICBzdHJva2VEYXNoYXJyYXk6IDEsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IDEsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDEsXG4gIHN0cm9rZU9wYWNpdHk6IDEsXG4gIHN0cm9rZVdpZHRoOiAxXG59LCBGYyA9IC9bQS1aXXxebXMvZywgemMgPSAvX0VNT18oW15fXSs/KV8oW15dKj8pX0VNT18vZywgUGEgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0LmNoYXJDb2RlQXQoMSkgPT09IDQ1O1xufSwgZ2kgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0ICE9IG51bGwgJiYgdHlwZW9mIHQgIT0gXCJib29sZWFuXCI7XG59LCBIbiA9IC8qIEBfX1BVUkVfXyAqLyBPYShmdW5jdGlvbihlKSB7XG4gIHJldHVybiBQYShlKSA/IGUgOiBlLnJlcGxhY2UoRmMsIFwiLSQmXCIpLnRvTG93ZXJDYXNlKCk7XG59KSwgeWkgPSBmdW5jdGlvbih0LCByKSB7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJhbmltYXRpb25cIjpcbiAgICBjYXNlIFwiYW5pbWF0aW9uTmFtZVwiOlxuICAgICAgaWYgKHR5cGVvZiByID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiByLnJlcGxhY2UoemMsIGZ1bmN0aW9uKG4sIG8sIGkpIHtcbiAgICAgICAgICByZXR1cm4gaHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBvLFxuICAgICAgICAgICAgc3R5bGVzOiBpLFxuICAgICAgICAgICAgbmV4dDogaHRcbiAgICAgICAgICB9LCBvO1xuICAgICAgICB9KTtcbiAgfVxuICByZXR1cm4gVmNbdF0gIT09IDEgJiYgIVBhKHQpICYmIHR5cGVvZiByID09IFwibnVtYmVyXCIgJiYgciAhPT0gMCA/IHIgKyBcInB4XCIgOiByO1xufTtcbmZ1bmN0aW9uIHdyKGUsIHQsIHIpIHtcbiAgaWYgKHIgPT0gbnVsbClcbiAgICByZXR1cm4gXCJcIjtcbiAgdmFyIG4gPSByO1xuICBpZiAobi5fX2Vtb3Rpb25fc3R5bGVzICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIG47XG4gIHN3aXRjaCAodHlwZW9mIHIpIHtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICB2YXIgbyA9IHI7XG4gICAgICBpZiAoby5hbmltID09PSAxKVxuICAgICAgICByZXR1cm4gaHQgPSB7XG4gICAgICAgICAgbmFtZTogby5uYW1lLFxuICAgICAgICAgIHN0eWxlczogby5zdHlsZXMsXG4gICAgICAgICAgbmV4dDogaHRcbiAgICAgICAgfSwgby5uYW1lO1xuICAgICAgdmFyIGkgPSByO1xuICAgICAgaWYgKGkuc3R5bGVzICE9PSB2b2lkIDApIHtcbiAgICAgICAgdmFyIHMgPSBpLm5leHQ7XG4gICAgICAgIGlmIChzICE9PSB2b2lkIDApXG4gICAgICAgICAgZm9yICg7IHMgIT09IHZvaWQgMDsgKVxuICAgICAgICAgICAgaHQgPSB7XG4gICAgICAgICAgICAgIG5hbWU6IHMubmFtZSxcbiAgICAgICAgICAgICAgc3R5bGVzOiBzLnN0eWxlcyxcbiAgICAgICAgICAgICAgbmV4dDogaHRcbiAgICAgICAgICAgIH0sIHMgPSBzLm5leHQ7XG4gICAgICAgIHZhciBjID0gaS5zdHlsZXMgKyBcIjtcIjtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgICByZXR1cm4gV2MoZSwgdCwgcik7XG4gICAgfVxuICAgIGNhc2UgXCJmdW5jdGlvblwiOiB7XG4gICAgICBpZiAoZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBsID0gaHQsIHUgPSByKGUpO1xuICAgICAgICByZXR1cm4gaHQgPSBsLCB3cihlLCB0LCB1KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgcCA9IHI7XG4gIGlmICh0ID09IG51bGwpXG4gICAgcmV0dXJuIHA7XG4gIHZhciBtID0gdFtwXTtcbiAgcmV0dXJuIG0gIT09IHZvaWQgMCA/IG0gOiBwO1xufVxuZnVuY3Rpb24gV2MoZSwgdCwgcikge1xuICB2YXIgbiA9IFwiXCI7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKVxuICAgIGZvciAodmFyIG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKylcbiAgICAgIG4gKz0gd3IoZSwgdCwgcltvXSkgKyBcIjtcIjtcbiAgZWxzZVxuICAgIGZvciAodmFyIGkgaW4gcikge1xuICAgICAgdmFyIHMgPSByW2ldO1xuICAgICAgaWYgKHR5cGVvZiBzICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIGMgPSBzO1xuICAgICAgICB0ICE9IG51bGwgJiYgdFtjXSAhPT0gdm9pZCAwID8gbiArPSBpICsgXCJ7XCIgKyB0W2NdICsgXCJ9XCIgOiBnaShjKSAmJiAobiArPSBIbihpKSArIFwiOlwiICsgeWkoaSwgYykgKyBcIjtcIik7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocykgJiYgdHlwZW9mIHNbMF0gPT0gXCJzdHJpbmdcIiAmJiAodCA9PSBudWxsIHx8IHRbc1swXV0gPT09IHZvaWQgMCkpXG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgcy5sZW5ndGg7IGwrKylcbiAgICAgICAgICBnaShzW2xdKSAmJiAobiArPSBIbihpKSArIFwiOlwiICsgeWkoaSwgc1tsXSkgKyBcIjtcIik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHUgPSB3cihlLCB0LCBzKTtcbiAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgY2FzZSBcImFuaW1hdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJhbmltYXRpb25OYW1lXCI6IHtcbiAgICAgICAgICAgIG4gKz0gSG4oaSkgKyBcIjpcIiArIHUgKyBcIjtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbiArPSBpICsgXCJ7XCIgKyB1ICsgXCJ9XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIHJldHVybiBuO1xufVxudmFyIGJpID0gL2xhYmVsOlxccyooW15cXHM7e10rKVxccyooO3wkKS9nLCBodDtcbmZ1bmN0aW9uIE5yKGUsIHQsIHIpIHtcbiAgaWYgKGUubGVuZ3RoID09PSAxICYmIHR5cGVvZiBlWzBdID09IFwib2JqZWN0XCIgJiYgZVswXSAhPT0gbnVsbCAmJiBlWzBdLnN0eWxlcyAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBlWzBdO1xuICB2YXIgbiA9ICEwLCBvID0gXCJcIjtcbiAgaHQgPSB2b2lkIDA7XG4gIHZhciBpID0gZVswXTtcbiAgaWYgKGkgPT0gbnVsbCB8fCBpLnJhdyA9PT0gdm9pZCAwKVxuICAgIG4gPSAhMSwgbyArPSB3cihyLCB0LCBpKTtcbiAgZWxzZSB7XG4gICAgdmFyIHMgPSBpO1xuICAgIG8gKz0gc1swXTtcbiAgfVxuICBmb3IgKHZhciBjID0gMTsgYyA8IGUubGVuZ3RoOyBjKyspXG4gICAgaWYgKG8gKz0gd3IociwgdCwgZVtjXSksIG4pIHtcbiAgICAgIHZhciBsID0gaTtcbiAgICAgIG8gKz0gbFtjXTtcbiAgICB9XG4gIGJpLmxhc3RJbmRleCA9IDA7XG4gIGZvciAodmFyIHUgPSBcIlwiLCBwOyAocCA9IGJpLmV4ZWMobykpICE9PSBudWxsOyApXG4gICAgdSArPSBcIi1cIiArIHBbMV07XG4gIHZhciBtID0gQmMobykgKyB1O1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG0sXG4gICAgc3R5bGVzOiBvLFxuICAgIG5leHQ6IGh0XG4gIH07XG59XG52YXIgVWMgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0KCk7XG59LCBrYSA9IEMudXNlSW5zZXJ0aW9uRWZmZWN0ID8gQy51c2VJbnNlcnRpb25FZmZlY3QgOiAhMSwgQWEgPSBrYSB8fCBVYywgdmkgPSBrYSB8fCBDLnVzZUxheW91dEVmZmVjdCwgTmEgPSAvKiBAX19QVVJFX18gKi8gQy5jcmVhdGVDb250ZXh0KFxuICAvLyB3ZSdyZSBkb2luZyB0aGlzIHRvIGF2b2lkIHByZWNvbnN0cnVjdCdzIGRlYWQgY29kZSBlbGltaW5hdGlvbiBpbiB0aGlzIG9uZSBjYXNlXG4gIC8vIGJlY2F1c2UgdGhpcyBtb2R1bGUgaXMgcHJpbWFyaWx5IGludGVuZGVkIGZvciB0aGUgYnJvd3NlciBhbmQgbm9kZVxuICAvLyBidXQgaXQncyBhbHNvIHJlcXVpcmVkIGluIHJlYWN0IG5hdGl2ZSBhbmQgc2ltaWxhciBlbnZpcm9ubWVudHMgc29tZXRpbWVzXG4gIC8vIGFuZCB3ZSBjb3VsZCBoYXZlIGEgc3BlY2lhbCBidWlsZCBqdXN0IGZvciB0aGF0XG4gIC8vIGJ1dCB0aGlzIGlzIG11Y2ggZWFzaWVyIGFuZCB0aGUgbmF0aXZlIHBhY2thZ2VzXG4gIC8vIG1pZ2h0IHVzZSBhIGRpZmZlcmVudCB0aGVtZSBjb250ZXh0IGluIHRoZSBmdXR1cmUgYW55d2F5XG4gIHR5cGVvZiBIVE1MRWxlbWVudCA8IFwidVwiID8gLyogQF9fUFVSRV9fICovIE1jKHtcbiAgICBrZXk6IFwiY3NzXCJcbiAgfSkgOiBudWxsXG4pO1xuTmEuUHJvdmlkZXI7XG52YXIgT28gPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gWHMoZnVuY3Rpb24ociwgbikge1xuICAgIHZhciBvID0gSnMoTmEpO1xuICAgIHJldHVybiB0KHIsIG8sIG4pO1xuICB9KTtcbn0sIE1yID0gLyogQF9fUFVSRV9fICovIEMuY3JlYXRlQ29udGV4dCh7fSksIFJvID0ge30uaGFzT3duUHJvcGVydHksIGFvID0gXCJfX0VNT1RJT05fVFlQRV9QTEVBU0VfRE9fTk9UX1VTRV9fXCIsIFljID0gZnVuY3Rpb24odCwgcikge1xuICB2YXIgbiA9IHt9O1xuICBmb3IgKHZhciBvIGluIHIpXG4gICAgUm8uY2FsbChyLCBvKSAmJiAobltvXSA9IHJbb10pO1xuICByZXR1cm4gblthb10gPSB0LCBuO1xufSwgSGMgPSBmdW5jdGlvbih0KSB7XG4gIHZhciByID0gdC5jYWNoZSwgbiA9IHQuc2VyaWFsaXplZCwgbyA9IHQuaXNTdHJpbmdUYWc7XG4gIHJldHVybiBUbyhyLCBuLCBvKSwgQWEoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHdvKHIsIG4sIG8pO1xuICB9KSwgbnVsbDtcbn0sIHFjID0gLyogQF9fUFVSRV9fICovIE9vKGZ1bmN0aW9uKGUsIHQsIHIpIHtcbiAgdmFyIG4gPSBlLmNzcztcbiAgdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiAmJiB0LnJlZ2lzdGVyZWRbbl0gIT09IHZvaWQgMCAmJiAobiA9IHQucmVnaXN0ZXJlZFtuXSk7XG4gIHZhciBvID0gZVthb10sIGkgPSBbbl0sIHMgPSBcIlwiO1xuICB0eXBlb2YgZS5jbGFzc05hbWUgPT0gXCJzdHJpbmdcIiA/IHMgPSAkYSh0LnJlZ2lzdGVyZWQsIGksIGUuY2xhc3NOYW1lKSA6IGUuY2xhc3NOYW1lICE9IG51bGwgJiYgKHMgPSBlLmNsYXNzTmFtZSArIFwiIFwiKTtcbiAgdmFyIGMgPSBOcihpLCB2b2lkIDAsIEMudXNlQ29udGV4dChNcikpO1xuICBzICs9IHQua2V5ICsgXCItXCIgKyBjLm5hbWU7XG4gIHZhciBsID0ge307XG4gIGZvciAodmFyIHUgaW4gZSlcbiAgICBSby5jYWxsKGUsIHUpICYmIHUgIT09IFwiY3NzXCIgJiYgdSAhPT0gYW8gJiYgKGxbdV0gPSBlW3VdKTtcbiAgcmV0dXJuIGwuY2xhc3NOYW1lID0gcywgciAmJiAobC5yZWYgPSByKSwgLyogQF9fUFVSRV9fICovIEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gQy5jcmVhdGVFbGVtZW50KEhjLCB7XG4gICAgY2FjaGU6IHQsXG4gICAgc2VyaWFsaXplZDogYyxcbiAgICBpc1N0cmluZ1RhZzogdHlwZW9mIG8gPT0gXCJzdHJpbmdcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIEMuY3JlYXRlRWxlbWVudChvLCBsKSk7XG59KSwgR2MgPSBxYywgS2MgPSBmdW5jdGlvbih0LCByKSB7XG4gIHZhciBuID0gYXJndW1lbnRzO1xuICBpZiAociA9PSBudWxsIHx8ICFSby5jYWxsKHIsIFwiY3NzXCIpKVxuICAgIHJldHVybiBDLmNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCBuKTtcbiAgdmFyIG8gPSBuLmxlbmd0aCwgaSA9IG5ldyBBcnJheShvKTtcbiAgaVswXSA9IEdjLCBpWzFdID0gWWModCwgcik7XG4gIGZvciAodmFyIHMgPSAyOyBzIDwgbzsgcysrKVxuICAgIGlbc10gPSBuW3NdO1xuICByZXR1cm4gQy5jcmVhdGVFbGVtZW50LmFwcGx5KG51bGwsIGkpO1xufTtcbihmdW5jdGlvbihlKSB7XG4gIHZhciB0O1xuICB0IHx8ICh0ID0gZS5KU1ggfHwgKGUuSlNYID0ge30pKTtcbn0pKEtjKTtcbnZhciBYYyA9IC8qIEBfX1BVUkVfXyAqLyBPbyhmdW5jdGlvbihlLCB0KSB7XG4gIHZhciByID0gZS5zdHlsZXMsIG4gPSBOcihbcl0sIHZvaWQgMCwgQy51c2VDb250ZXh0KE1yKSksIG8gPSBDLnVzZVJlZigpO1xuICByZXR1cm4gdmkoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSB0LmtleSArIFwiLWdsb2JhbFwiLCBzID0gbmV3IHQuc2hlZXQuY29uc3RydWN0b3Ioe1xuICAgICAga2V5OiBpLFxuICAgICAgbm9uY2U6IHQuc2hlZXQubm9uY2UsXG4gICAgICBjb250YWluZXI6IHQuc2hlZXQuY29udGFpbmVyLFxuICAgICAgc3BlZWR5OiB0LnNoZWV0LmlzU3BlZWR5XG4gICAgfSksIGMgPSAhMSwgbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtZW1vdGlvbj1cIicgKyBpICsgXCIgXCIgKyBuLm5hbWUgKyAnXCJdJyk7XG4gICAgcmV0dXJuIHQuc2hlZXQudGFncy5sZW5ndGggJiYgKHMuYmVmb3JlID0gdC5zaGVldC50YWdzWzBdKSwgbCAhPT0gbnVsbCAmJiAoYyA9ICEwLCBsLnNldEF0dHJpYnV0ZShcImRhdGEtZW1vdGlvblwiLCBpKSwgcy5oeWRyYXRlKFtsXSkpLCBvLmN1cnJlbnQgPSBbcywgY10sIGZ1bmN0aW9uKCkge1xuICAgICAgcy5mbHVzaCgpO1xuICAgIH07XG4gIH0sIFt0XSksIHZpKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpID0gby5jdXJyZW50LCBzID0gaVswXSwgYyA9IGlbMV07XG4gICAgaWYgKGMpIHtcbiAgICAgIGlbMV0gPSAhMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG4ubmV4dCAhPT0gdm9pZCAwICYmIHdvKHQsIG4ubmV4dCwgITApLCBzLnRhZ3MubGVuZ3RoKSB7XG4gICAgICB2YXIgbCA9IHMudGFnc1tzLnRhZ3MubGVuZ3RoIC0gMV0ubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgcy5iZWZvcmUgPSBsLCBzLmZsdXNoKCk7XG4gICAgfVxuICAgIHQuaW5zZXJ0KFwiXCIsIG4sIHMsICExKTtcbiAgfSwgW3QsIG4ubmFtZV0pLCBudWxsO1xufSk7XG5mdW5jdGlvbiAkbygpIHtcbiAgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoZSksIHIgPSAwOyByIDwgZTsgcisrKVxuICAgIHRbcl0gPSBhcmd1bWVudHNbcl07XG4gIHJldHVybiBOcih0KTtcbn1cbmZ1bmN0aW9uIElyKCkge1xuICB2YXIgZSA9ICRvLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKSwgdCA9IFwiYW5pbWF0aW9uLVwiICsgZS5uYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IHQsXG4gICAgc3R5bGVzOiBcIkBrZXlmcmFtZXMgXCIgKyB0ICsgXCJ7XCIgKyBlLnN0eWxlcyArIFwifVwiLFxuICAgIGFuaW06IDEsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiX0VNT19cIiArIHRoaXMubmFtZSArIFwiX1wiICsgdGhpcy5zdHlsZXMgKyBcIl9FTU9fXCI7XG4gICAgfVxuICB9O1xufVxudmFyIEpjID0gL14oKGNoaWxkcmVufGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MfGtleXxyZWZ8YXV0b0ZvY3VzfGRlZmF1bHRWYWx1ZXxkZWZhdWx0Q2hlY2tlZHxpbm5lckhUTUx8c3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nfHN1cHByZXNzSHlkcmF0aW9uV2FybmluZ3x2YWx1ZUxpbmt8YWJicnxhY2NlcHR8YWNjZXB0Q2hhcnNldHxhY2Nlc3NLZXl8YWN0aW9ufGFsbG93fGFsbG93VXNlck1lZGlhfGFsbG93UGF5bWVudFJlcXVlc3R8YWxsb3dGdWxsU2NyZWVufGFsbG93VHJhbnNwYXJlbmN5fGFsdHxhc3luY3xhdXRvQ29tcGxldGV8YXV0b1BsYXl8Y2FwdHVyZXxjZWxsUGFkZGluZ3xjZWxsU3BhY2luZ3xjaGFsbGVuZ2V8Y2hhclNldHxjaGVja2VkfGNpdGV8Y2xhc3NJRHxjbGFzc05hbWV8Y29sc3xjb2xTcGFufGNvbnRlbnR8Y29udGVudEVkaXRhYmxlfGNvbnRleHRNZW51fGNvbnRyb2xzfGNvbnRyb2xzTGlzdHxjb29yZHN8Y3Jvc3NPcmlnaW58ZGF0YXxkYXRlVGltZXxkZWNvZGluZ3xkZWZhdWx0fGRlZmVyfGRpcnxkaXNhYmxlZHxkaXNhYmxlUGljdHVyZUluUGljdHVyZXxkaXNhYmxlUmVtb3RlUGxheWJhY2t8ZG93bmxvYWR8ZHJhZ2dhYmxlfGVuY1R5cGV8ZW50ZXJLZXlIaW50fGZldGNocHJpb3JpdHl8ZmV0Y2hQcmlvcml0eXxmb3JtfGZvcm1BY3Rpb258Zm9ybUVuY1R5cGV8Zm9ybU1ldGhvZHxmb3JtTm9WYWxpZGF0ZXxmb3JtVGFyZ2V0fGZyYW1lQm9yZGVyfGhlYWRlcnN8aGVpZ2h0fGhpZGRlbnxoaWdofGhyZWZ8aHJlZkxhbmd8aHRtbEZvcnxodHRwRXF1aXZ8aWR8aW5wdXRNb2RlfGludGVncml0eXxpc3xrZXlQYXJhbXN8a2V5VHlwZXxraW5kfGxhYmVsfGxhbmd8bGlzdHxsb2FkaW5nfGxvb3B8bG93fG1hcmdpbkhlaWdodHxtYXJnaW5XaWR0aHxtYXh8bWF4TGVuZ3RofG1lZGlhfG1lZGlhR3JvdXB8bWV0aG9kfG1pbnxtaW5MZW5ndGh8bXVsdGlwbGV8bXV0ZWR8bmFtZXxub25jZXxub1ZhbGlkYXRlfG9wZW58b3B0aW11bXxwYXR0ZXJufHBsYWNlaG9sZGVyfHBsYXlzSW5saW5lfHBvc3RlcnxwcmVsb2FkfHByb2ZpbGV8cmFkaW9Hcm91cHxyZWFkT25seXxyZWZlcnJlclBvbGljeXxyZWx8cmVxdWlyZWR8cmV2ZXJzZWR8cm9sZXxyb3dzfHJvd1NwYW58c2FuZGJveHxzY29wZXxzY29wZWR8c2Nyb2xsaW5nfHNlYW1sZXNzfHNlbGVjdGVkfHNoYXBlfHNpemV8c2l6ZXN8c2xvdHxzcGFufHNwZWxsQ2hlY2t8c3JjfHNyY0RvY3xzcmNMYW5nfHNyY1NldHxzdGFydHxzdGVwfHN0eWxlfHN1bW1hcnl8dGFiSW5kZXh8dGFyZ2V0fHRpdGxlfHRyYW5zbGF0ZXx0eXBlfHVzZU1hcHx2YWx1ZXx3aWR0aHx3bW9kZXx3cmFwfGFib3V0fGRhdGF0eXBlfGlubGlzdHxwcmVmaXh8cHJvcGVydHl8cmVzb3VyY2V8dHlwZW9mfHZvY2FifGF1dG9DYXBpdGFsaXplfGF1dG9Db3JyZWN0fGF1dG9TYXZlfGNvbG9yfGluY3JlbWVudGFsfGZhbGxiYWNrfGluZXJ0fGl0ZW1Qcm9wfGl0ZW1TY29wZXxpdGVtVHlwZXxpdGVtSUR8aXRlbVJlZnxvbnxvcHRpb258cmVzdWx0c3xzZWN1cml0eXx1bnNlbGVjdGFibGV8YWNjZW50SGVpZ2h0fGFjY3VtdWxhdGV8YWRkaXRpdmV8YWxpZ25tZW50QmFzZWxpbmV8YWxsb3dSZW9yZGVyfGFscGhhYmV0aWN8YW1wbGl0dWRlfGFyYWJpY0Zvcm18YXNjZW50fGF0dHJpYnV0ZU5hbWV8YXR0cmlidXRlVHlwZXxhdXRvUmV2ZXJzZXxhemltdXRofGJhc2VGcmVxdWVuY3l8YmFzZWxpbmVTaGlmdHxiYXNlUHJvZmlsZXxiYm94fGJlZ2lufGJpYXN8Ynl8Y2FsY01vZGV8Y2FwSGVpZ2h0fGNsaXB8Y2xpcFBhdGhVbml0c3xjbGlwUGF0aHxjbGlwUnVsZXxjb2xvckludGVycG9sYXRpb258Y29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc3xjb2xvclByb2ZpbGV8Y29sb3JSZW5kZXJpbmd8Y29udGVudFNjcmlwdFR5cGV8Y29udGVudFN0eWxlVHlwZXxjdXJzb3J8Y3h8Y3l8ZHxkZWNlbGVyYXRlfGRlc2NlbnR8ZGlmZnVzZUNvbnN0YW50fGRpcmVjdGlvbnxkaXNwbGF5fGRpdmlzb3J8ZG9taW5hbnRCYXNlbGluZXxkdXJ8ZHh8ZHl8ZWRnZU1vZGV8ZWxldmF0aW9ufGVuYWJsZUJhY2tncm91bmR8ZW5kfGV4cG9uZW50fGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWR8ZmlsbHxmaWxsT3BhY2l0eXxmaWxsUnVsZXxmaWx0ZXJ8ZmlsdGVyUmVzfGZpbHRlclVuaXRzfGZsb29kQ29sb3J8Zmxvb2RPcGFjaXR5fGZvY3VzYWJsZXxmb250RmFtaWx5fGZvbnRTaXplfGZvbnRTaXplQWRqdXN0fGZvbnRTdHJldGNofGZvbnRTdHlsZXxmb250VmFyaWFudHxmb250V2VpZ2h0fGZvcm1hdHxmcm9tfGZyfGZ4fGZ5fGcxfGcyfGdseXBoTmFtZXxnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbHxnbHlwaE9yaWVudGF0aW9uVmVydGljYWx8Z2x5cGhSZWZ8Z3JhZGllbnRUcmFuc2Zvcm18Z3JhZGllbnRVbml0c3xoYW5naW5nfGhvcml6QWR2WHxob3Jpek9yaWdpblh8aWRlb2dyYXBoaWN8aW1hZ2VSZW5kZXJpbmd8aW58aW4yfGludGVyY2VwdHxrfGsxfGsyfGszfGs0fGtlcm5lbE1hdHJpeHxrZXJuZWxVbml0TGVuZ3RofGtlcm5pbmd8a2V5UG9pbnRzfGtleVNwbGluZXN8a2V5VGltZXN8bGVuZ3RoQWRqdXN0fGxldHRlclNwYWNpbmd8bGlnaHRpbmdDb2xvcnxsaW1pdGluZ0NvbmVBbmdsZXxsb2NhbHxtYXJrZXJFbmR8bWFya2VyTWlkfG1hcmtlclN0YXJ0fG1hcmtlckhlaWdodHxtYXJrZXJVbml0c3xtYXJrZXJXaWR0aHxtYXNrfG1hc2tDb250ZW50VW5pdHN8bWFza1VuaXRzfG1hdGhlbWF0aWNhbHxtb2RlfG51bU9jdGF2ZXN8b2Zmc2V0fG9wYWNpdHl8b3BlcmF0b3J8b3JkZXJ8b3JpZW50fG9yaWVudGF0aW9ufG9yaWdpbnxvdmVyZmxvd3xvdmVybGluZVBvc2l0aW9ufG92ZXJsaW5lVGhpY2tuZXNzfHBhbm9zZTF8cGFpbnRPcmRlcnxwYXRoTGVuZ3RofHBhdHRlcm5Db250ZW50VW5pdHN8cGF0dGVyblRyYW5zZm9ybXxwYXR0ZXJuVW5pdHN8cG9pbnRlckV2ZW50c3xwb2ludHN8cG9pbnRzQXRYfHBvaW50c0F0WXxwb2ludHNBdFp8cHJlc2VydmVBbHBoYXxwcmVzZXJ2ZUFzcGVjdFJhdGlvfHByaW1pdGl2ZVVuaXRzfHJ8cmFkaXVzfHJlZlh8cmVmWXxyZW5kZXJpbmdJbnRlbnR8cmVwZWF0Q291bnR8cmVwZWF0RHVyfHJlcXVpcmVkRXh0ZW5zaW9uc3xyZXF1aXJlZEZlYXR1cmVzfHJlc3RhcnR8cmVzdWx0fHJvdGF0ZXxyeHxyeXxzY2FsZXxzZWVkfHNoYXBlUmVuZGVyaW5nfHNsb3BlfHNwYWNpbmd8c3BlY3VsYXJDb25zdGFudHxzcGVjdWxhckV4cG9uZW50fHNwZWVkfHNwcmVhZE1ldGhvZHxzdGFydE9mZnNldHxzdGREZXZpYXRpb258c3RlbWh8c3RlbXZ8c3RpdGNoVGlsZXN8c3RvcENvbG9yfHN0b3BPcGFjaXR5fHN0cmlrZXRocm91Z2hQb3NpdGlvbnxzdHJpa2V0aHJvdWdoVGhpY2tuZXNzfHN0cmluZ3xzdHJva2V8c3Ryb2tlRGFzaGFycmF5fHN0cm9rZURhc2hvZmZzZXR8c3Ryb2tlTGluZWNhcHxzdHJva2VMaW5lam9pbnxzdHJva2VNaXRlcmxpbWl0fHN0cm9rZU9wYWNpdHl8c3Ryb2tlV2lkdGh8c3VyZmFjZVNjYWxlfHN5c3RlbUxhbmd1YWdlfHRhYmxlVmFsdWVzfHRhcmdldFh8dGFyZ2V0WXx0ZXh0QW5jaG9yfHRleHREZWNvcmF0aW9ufHRleHRSZW5kZXJpbmd8dGV4dExlbmd0aHx0b3x0cmFuc2Zvcm18dTF8dTJ8dW5kZXJsaW5lUG9zaXRpb258dW5kZXJsaW5lVGhpY2tuZXNzfHVuaWNvZGV8dW5pY29kZUJpZGl8dW5pY29kZVJhbmdlfHVuaXRzUGVyRW18dkFscGhhYmV0aWN8dkhhbmdpbmd8dklkZW9ncmFwaGljfHZNYXRoZW1hdGljYWx8dmFsdWVzfHZlY3RvckVmZmVjdHx2ZXJzaW9ufHZlcnRBZHZZfHZlcnRPcmlnaW5YfHZlcnRPcmlnaW5ZfHZpZXdCb3h8dmlld1RhcmdldHx2aXNpYmlsaXR5fHdpZHRoc3x3b3JkU3BhY2luZ3x3cml0aW5nTW9kZXx4fHhIZWlnaHR8eDF8eDJ8eENoYW5uZWxTZWxlY3Rvcnx4bGlua0FjdHVhdGV8eGxpbmtBcmNyb2xlfHhsaW5rSHJlZnx4bGlua1JvbGV8eGxpbmtTaG93fHhsaW5rVGl0bGV8eGxpbmtUeXBlfHhtbEJhc2V8eG1sbnN8eG1sbnNYbGlua3x4bWxMYW5nfHhtbFNwYWNlfHl8eTF8eTJ8eUNoYW5uZWxTZWxlY3Rvcnx6fHpvb21BbmRQYW58Zm9yfGNsYXNzfGF1dG9mb2N1cyl8KChbRGRdW0FhXVtUdF1bQWFdfFtBYV1bUnJdW0lpXVtBYV18eCktLiopKSQvLCBRYyA9IC8qIEBfX1BVUkVfXyAqLyBPYShcbiAgZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBKYy50ZXN0KGUpIHx8IGUuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGUuY2hhckNvZGVBdCgxKSA9PT0gMTEwICYmIGUuY2hhckNvZGVBdCgyKSA8IDkxO1xuICB9XG4gIC8qIForMSAqL1xuKSwgWmMgPSBRYywgZWwgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0ICE9PSBcInRoZW1lXCI7XG59LCB4aSA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgLy8gOTYgaXMgb25lIGxlc3MgdGhhbiB0aGUgY2hhciBjb2RlXG4gIC8vIGZvciBcImFcIiBzbyB0aGlzIGlzIGNoZWNraW5nIHRoYXRcbiAgLy8gaXQncyBhIGxvd2VyY2FzZSBjaGFyYWN0ZXJcbiAgdC5jaGFyQ29kZUF0KDApID4gOTYgPyBaYyA6IGVsO1xufSwgU2kgPSBmdW5jdGlvbih0LCByLCBuKSB7XG4gIHZhciBvO1xuICBpZiAocikge1xuICAgIHZhciBpID0gci5zaG91bGRGb3J3YXJkUHJvcDtcbiAgICBvID0gdC5fX2Vtb3Rpb25fZm9yd2FyZFByb3AgJiYgaSA/IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiB0Ll9fZW1vdGlvbl9mb3J3YXJkUHJvcChzKSAmJiBpKHMpO1xuICAgIH0gOiBpO1xuICB9XG4gIHJldHVybiB0eXBlb2YgbyAhPSBcImZ1bmN0aW9uXCIgJiYgbiAmJiAobyA9IHQuX19lbW90aW9uX2ZvcndhcmRQcm9wKSwgbztcbn0sIHRsID0gZnVuY3Rpb24odCkge1xuICB2YXIgciA9IHQuY2FjaGUsIG4gPSB0LnNlcmlhbGl6ZWQsIG8gPSB0LmlzU3RyaW5nVGFnO1xuICByZXR1cm4gVG8ociwgbiwgbyksIEFhKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB3byhyLCBuLCBvKTtcbiAgfSksIG51bGw7XG59LCBybCA9IGZ1bmN0aW9uIGUodCwgcikge1xuICB2YXIgbiA9IHQuX19lbW90aW9uX3JlYWwgPT09IHQsIG8gPSBuICYmIHQuX19lbW90aW9uX2Jhc2UgfHwgdCwgaSwgcztcbiAgciAhPT0gdm9pZCAwICYmIChpID0gci5sYWJlbCwgcyA9IHIudGFyZ2V0KTtcbiAgdmFyIGMgPSBTaSh0LCByLCBuKSwgbCA9IGMgfHwgeGkobyksIHUgPSAhbChcImFzXCIpO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHMsIG0gPSBuICYmIHQuX19lbW90aW9uX3N0eWxlcyAhPT0gdm9pZCAwID8gdC5fX2Vtb3Rpb25fc3R5bGVzLnNsaWNlKDApIDogW107XG4gICAgaWYgKGkgIT09IHZvaWQgMCAmJiBtLnB1c2goXCJsYWJlbDpcIiArIGkgKyBcIjtcIiksIHBbMF0gPT0gbnVsbCB8fCBwWzBdLnJhdyA9PT0gdm9pZCAwKVxuICAgICAgbS5wdXNoLmFwcGx5KG0sIHApO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGcgPSBwWzBdO1xuICAgICAgbS5wdXNoKGdbMF0pO1xuICAgICAgZm9yICh2YXIgeCA9IHAubGVuZ3RoLCB5ID0gMTsgeSA8IHg7IHkrKylcbiAgICAgICAgbS5wdXNoKHBbeV0sIGdbeV0pO1xuICAgIH1cbiAgICB2YXIgZiA9IE9vKGZ1bmN0aW9uKFMsIEUsIFApIHtcbiAgICAgIHZhciBUID0gdSAmJiBTLmFzIHx8IG8sIGIgPSBcIlwiLCBoID0gW10sIHcgPSBTO1xuICAgICAgaWYgKFMudGhlbWUgPT0gbnVsbCkge1xuICAgICAgICB3ID0ge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gUylcbiAgICAgICAgICB3W2tdID0gU1trXTtcbiAgICAgICAgdy50aGVtZSA9IEMudXNlQ29udGV4dChNcik7XG4gICAgICB9XG4gICAgICB0eXBlb2YgUy5jbGFzc05hbWUgPT0gXCJzdHJpbmdcIiA/IGIgPSAkYShFLnJlZ2lzdGVyZWQsIGgsIFMuY2xhc3NOYW1lKSA6IFMuY2xhc3NOYW1lICE9IG51bGwgJiYgKGIgPSBTLmNsYXNzTmFtZSArIFwiIFwiKTtcbiAgICAgIHZhciBMID0gTnIobS5jb25jYXQoaCksIEUucmVnaXN0ZXJlZCwgdyk7XG4gICAgICBiICs9IEUua2V5ICsgXCItXCIgKyBMLm5hbWUsIHMgIT09IHZvaWQgMCAmJiAoYiArPSBcIiBcIiArIHMpO1xuICAgICAgdmFyIEIgPSB1ICYmIGMgPT09IHZvaWQgMCA/IHhpKFQpIDogbCwgZCA9IHt9O1xuICAgICAgZm9yICh2YXIgQSBpbiBTKVxuICAgICAgICB1ICYmIEEgPT09IFwiYXNcIiB8fCBCKEEpICYmIChkW0FdID0gU1tBXSk7XG4gICAgICByZXR1cm4gZC5jbGFzc05hbWUgPSBiLCBQICYmIChkLnJlZiA9IFApLCAvKiBAX19QVVJFX18gKi8gQy5jcmVhdGVFbGVtZW50KEMuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBDLmNyZWF0ZUVsZW1lbnQodGwsIHtcbiAgICAgICAgY2FjaGU6IEUsXG4gICAgICAgIHNlcmlhbGl6ZWQ6IEwsXG4gICAgICAgIGlzU3RyaW5nVGFnOiB0eXBlb2YgVCA9PSBcInN0cmluZ1wiXG4gICAgICB9KSwgLyogQF9fUFVSRV9fICovIEMuY3JlYXRlRWxlbWVudChULCBkKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGYuZGlzcGxheU5hbWUgPSBpICE9PSB2b2lkIDAgPyBpIDogXCJTdHlsZWQoXCIgKyAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IG8gOiBvLmRpc3BsYXlOYW1lIHx8IG8ubmFtZSB8fCBcIkNvbXBvbmVudFwiKSArIFwiKVwiLCBmLmRlZmF1bHRQcm9wcyA9IHQuZGVmYXVsdFByb3BzLCBmLl9fZW1vdGlvbl9yZWFsID0gZiwgZi5fX2Vtb3Rpb25fYmFzZSA9IG8sIGYuX19lbW90aW9uX3N0eWxlcyA9IG0sIGYuX19lbW90aW9uX2ZvcndhcmRQcm9wID0gYywgT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwidG9TdHJpbmdcIiwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCIuXCIgKyBzO1xuICAgICAgfVxuICAgIH0pLCBmLndpdGhDb21wb25lbnQgPSBmdW5jdGlvbihTLCBFKSB7XG4gICAgICB2YXIgUCA9IGUoUywgZm4oe30sIHIsIEUsIHtcbiAgICAgICAgc2hvdWxkRm9yd2FyZFByb3A6IFNpKGYsIEUsICEwKVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIFAuYXBwbHkodm9pZCAwLCBtKTtcbiAgICB9LCBmO1xuICB9O1xufSwgbmwgPSBbXG4gIFwiYVwiLFxuICBcImFiYnJcIixcbiAgXCJhZGRyZXNzXCIsXG4gIFwiYXJlYVwiLFxuICBcImFydGljbGVcIixcbiAgXCJhc2lkZVwiLFxuICBcImF1ZGlvXCIsXG4gIFwiYlwiLFxuICBcImJhc2VcIixcbiAgXCJiZGlcIixcbiAgXCJiZG9cIixcbiAgXCJiaWdcIixcbiAgXCJibG9ja3F1b3RlXCIsXG4gIFwiYm9keVwiLFxuICBcImJyXCIsXG4gIFwiYnV0dG9uXCIsXG4gIFwiY2FudmFzXCIsXG4gIFwiY2FwdGlvblwiLFxuICBcImNpdGVcIixcbiAgXCJjb2RlXCIsXG4gIFwiY29sXCIsXG4gIFwiY29sZ3JvdXBcIixcbiAgXCJkYXRhXCIsXG4gIFwiZGF0YWxpc3RcIixcbiAgXCJkZFwiLFxuICBcImRlbFwiLFxuICBcImRldGFpbHNcIixcbiAgXCJkZm5cIixcbiAgXCJkaWFsb2dcIixcbiAgXCJkaXZcIixcbiAgXCJkbFwiLFxuICBcImR0XCIsXG4gIFwiZW1cIixcbiAgXCJlbWJlZFwiLFxuICBcImZpZWxkc2V0XCIsXG4gIFwiZmlnY2FwdGlvblwiLFxuICBcImZpZ3VyZVwiLFxuICBcImZvb3RlclwiLFxuICBcImZvcm1cIixcbiAgXCJoMVwiLFxuICBcImgyXCIsXG4gIFwiaDNcIixcbiAgXCJoNFwiLFxuICBcImg1XCIsXG4gIFwiaDZcIixcbiAgXCJoZWFkXCIsXG4gIFwiaGVhZGVyXCIsXG4gIFwiaGdyb3VwXCIsXG4gIFwiaHJcIixcbiAgXCJodG1sXCIsXG4gIFwiaVwiLFxuICBcImlmcmFtZVwiLFxuICBcImltZ1wiLFxuICBcImlucHV0XCIsXG4gIFwiaW5zXCIsXG4gIFwia2JkXCIsXG4gIFwia2V5Z2VuXCIsXG4gIFwibGFiZWxcIixcbiAgXCJsZWdlbmRcIixcbiAgXCJsaVwiLFxuICBcImxpbmtcIixcbiAgXCJtYWluXCIsXG4gIFwibWFwXCIsXG4gIFwibWFya1wiLFxuICBcIm1hcnF1ZWVcIixcbiAgXCJtZW51XCIsXG4gIFwibWVudWl0ZW1cIixcbiAgXCJtZXRhXCIsXG4gIFwibWV0ZXJcIixcbiAgXCJuYXZcIixcbiAgXCJub3NjcmlwdFwiLFxuICBcIm9iamVjdFwiLFxuICBcIm9sXCIsXG4gIFwib3B0Z3JvdXBcIixcbiAgXCJvcHRpb25cIixcbiAgXCJvdXRwdXRcIixcbiAgXCJwXCIsXG4gIFwicGFyYW1cIixcbiAgXCJwaWN0dXJlXCIsXG4gIFwicHJlXCIsXG4gIFwicHJvZ3Jlc3NcIixcbiAgXCJxXCIsXG4gIFwicnBcIixcbiAgXCJydFwiLFxuICBcInJ1YnlcIixcbiAgXCJzXCIsXG4gIFwic2FtcFwiLFxuICBcInNjcmlwdFwiLFxuICBcInNlY3Rpb25cIixcbiAgXCJzZWxlY3RcIixcbiAgXCJzbWFsbFwiLFxuICBcInNvdXJjZVwiLFxuICBcInNwYW5cIixcbiAgXCJzdHJvbmdcIixcbiAgXCJzdHlsZVwiLFxuICBcInN1YlwiLFxuICBcInN1bW1hcnlcIixcbiAgXCJzdXBcIixcbiAgXCJ0YWJsZVwiLFxuICBcInRib2R5XCIsXG4gIFwidGRcIixcbiAgXCJ0ZXh0YXJlYVwiLFxuICBcInRmb290XCIsXG4gIFwidGhcIixcbiAgXCJ0aGVhZFwiLFxuICBcInRpbWVcIixcbiAgXCJ0aXRsZVwiLFxuICBcInRyXCIsXG4gIFwidHJhY2tcIixcbiAgXCJ1XCIsXG4gIFwidWxcIixcbiAgXCJ2YXJcIixcbiAgXCJ2aWRlb1wiLFxuICBcIndiclwiLFxuICAvLyBTVkdcbiAgXCJjaXJjbGVcIixcbiAgXCJjbGlwUGF0aFwiLFxuICBcImRlZnNcIixcbiAgXCJlbGxpcHNlXCIsXG4gIFwiZm9yZWlnbk9iamVjdFwiLFxuICBcImdcIixcbiAgXCJpbWFnZVwiLFxuICBcImxpbmVcIixcbiAgXCJsaW5lYXJHcmFkaWVudFwiLFxuICBcIm1hc2tcIixcbiAgXCJwYXRoXCIsXG4gIFwicGF0dGVyblwiLFxuICBcInBvbHlnb25cIixcbiAgXCJwb2x5bGluZVwiLFxuICBcInJhZGlhbEdyYWRpZW50XCIsXG4gIFwicmVjdFwiLFxuICBcInN0b3BcIixcbiAgXCJzdmdcIixcbiAgXCJ0ZXh0XCIsXG4gIFwidHNwYW5cIlxuXSwgc28gPSBybC5iaW5kKG51bGwpO1xubmwuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gIHNvW2VdID0gc28oZSk7XG59KTtcbnZhciBxciA9IHsgZXhwb3J0czoge30gfSwgR3IgPSB7IGV4cG9ydHM6IHt9IH0sIGhlID0ge307XG4vKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBFaTtcbmZ1bmN0aW9uIG9sKCkge1xuICBpZiAoRWkpIHJldHVybiBoZTtcbiAgRWkgPSAxO1xuICB2YXIgZSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5mb3IsIHQgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIikgOiA2MDEwMywgciA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpIDogNjAxMDYsIG4gPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpIDogNjAxMDcsIG8gPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpIDogNjAxMDgsIGkgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpIDogNjAxMTQsIHMgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpIDogNjAxMDksIGMgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIikgOiA2MDExMCwgbCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuYXN5bmNfbW9kZVwiKSA6IDYwMTExLCB1ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIikgOiA2MDExMSwgcCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIikgOiA2MDExMiwgbSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIikgOiA2MDExMywgZyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSA6IDYwMTIwLCB4ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpIDogNjAxMTUsIHkgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIikgOiA2MDExNiwgZiA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuYmxvY2tcIikgOiA2MDEyMSwgUyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZnVuZGFtZW50YWxcIikgOiA2MDExNywgRSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucmVzcG9uZGVyXCIpIDogNjAxMTgsIFAgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpIDogNjAxMTk7XG4gIGZ1bmN0aW9uIFQoaCkge1xuICAgIGlmICh0eXBlb2YgaCA9PSBcIm9iamVjdFwiICYmIGggIT09IG51bGwpIHtcbiAgICAgIHZhciB3ID0gaC4kJHR5cGVvZjtcbiAgICAgIHN3aXRjaCAodykge1xuICAgICAgICBjYXNlIHQ6XG4gICAgICAgICAgc3dpdGNoIChoID0gaC50eXBlLCBoKSB7XG4gICAgICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgICBjYXNlIG46XG4gICAgICAgICAgICBjYXNlIGk6XG4gICAgICAgICAgICBjYXNlIG86XG4gICAgICAgICAgICBjYXNlIG06XG4gICAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc3dpdGNoIChoID0gaCAmJiBoLiQkdHlwZW9mLCBoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBjOlxuICAgICAgICAgICAgICAgIGNhc2UgcDpcbiAgICAgICAgICAgICAgICBjYXNlIHk6XG4gICAgICAgICAgICAgICAgY2FzZSB4OlxuICAgICAgICAgICAgICAgIGNhc2UgczpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSByOlxuICAgICAgICAgIHJldHVybiB3O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0gdTtcbiAgfVxuICByZXR1cm4gaGUuQXN5bmNNb2RlID0gbCwgaGUuQ29uY3VycmVudE1vZGUgPSB1LCBoZS5Db250ZXh0Q29uc3VtZXIgPSBjLCBoZS5Db250ZXh0UHJvdmlkZXIgPSBzLCBoZS5FbGVtZW50ID0gdCwgaGUuRm9yd2FyZFJlZiA9IHAsIGhlLkZyYWdtZW50ID0gbiwgaGUuTGF6eSA9IHksIGhlLk1lbW8gPSB4LCBoZS5Qb3J0YWwgPSByLCBoZS5Qcm9maWxlciA9IGksIGhlLlN0cmljdE1vZGUgPSBvLCBoZS5TdXNwZW5zZSA9IG0sIGhlLmlzQXN5bmNNb2RlID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBiKGgpIHx8IFQoaCkgPT09IGw7XG4gIH0sIGhlLmlzQ29uY3VycmVudE1vZGUgPSBiLCBoZS5pc0NvbnRleHRDb25zdW1lciA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0gYztcbiAgfSwgaGUuaXNDb250ZXh0UHJvdmlkZXIgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IHM7XG4gIH0sIGhlLmlzRWxlbWVudCA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGggPT0gXCJvYmplY3RcIiAmJiBoICE9PSBudWxsICYmIGguJCR0eXBlb2YgPT09IHQ7XG4gIH0sIGhlLmlzRm9yd2FyZFJlZiA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0gcDtcbiAgfSwgaGUuaXNGcmFnbWVudCA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0gbjtcbiAgfSwgaGUuaXNMYXp5ID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSB5O1xuICB9LCBoZS5pc01lbW8gPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IHg7XG4gIH0sIGhlLmlzUG9ydGFsID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSByO1xuICB9LCBoZS5pc1Byb2ZpbGVyID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSBpO1xuICB9LCBoZS5pc1N0cmljdE1vZGUgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IG87XG4gIH0sIGhlLmlzU3VzcGVuc2UgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IG07XG4gIH0sIGhlLmlzVmFsaWRFbGVtZW50VHlwZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGggPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgaCA9PSBcImZ1bmN0aW9uXCIgfHwgaCA9PT0gbiB8fCBoID09PSB1IHx8IGggPT09IGkgfHwgaCA9PT0gbyB8fCBoID09PSBtIHx8IGggPT09IGcgfHwgdHlwZW9mIGggPT0gXCJvYmplY3RcIiAmJiBoICE9PSBudWxsICYmIChoLiQkdHlwZW9mID09PSB5IHx8IGguJCR0eXBlb2YgPT09IHggfHwgaC4kJHR5cGVvZiA9PT0gcyB8fCBoLiQkdHlwZW9mID09PSBjIHx8IGguJCR0eXBlb2YgPT09IHAgfHwgaC4kJHR5cGVvZiA9PT0gUyB8fCBoLiQkdHlwZW9mID09PSBFIHx8IGguJCR0eXBlb2YgPT09IFAgfHwgaC4kJHR5cGVvZiA9PT0gZik7XG4gIH0sIGhlLnR5cGVPZiA9IFQsIGhlO1xufVxudmFyIGdlID0ge307XG4vKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBDaTtcbmZ1bmN0aW9uIGlsKCkge1xuICByZXR1cm4gQ2kgfHwgKENpID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmZvciwgdCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSA6IDYwMTAzLCByID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIikgOiA2MDEwNiwgbiA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIikgOiA2MDEwNywgbyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIikgOiA2MDEwOCwgaSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIikgOiA2MDExNCwgcyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIikgOiA2MDEwOSwgYyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSA6IDYwMTEwLCBsID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5hc3luY19tb2RlXCIpIDogNjAxMTEsIHUgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKSA6IDYwMTExLCBwID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSA6IDYwMTEyLCBtID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSA6IDYwMTEzLCBnID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpIDogNjAxMjAsIHggPSBlID8gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIikgOiA2MDExNSwgeSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSA6IDYwMTE2LCBmID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKSA6IDYwMTIxLCBTID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mdW5kYW1lbnRhbFwiKSA6IDYwMTE3LCBFID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5yZXNwb25kZXJcIikgOiA2MDExOCwgUCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIikgOiA2MDExOTtcbiAgICBmdW5jdGlvbiBUKE8pIHtcbiAgICAgIHJldHVybiB0eXBlb2YgTyA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBPID09IFwiZnVuY3Rpb25cIiB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICAgICAgTyA9PT0gbiB8fCBPID09PSB1IHx8IE8gPT09IGkgfHwgTyA9PT0gbyB8fCBPID09PSBtIHx8IE8gPT09IGcgfHwgdHlwZW9mIE8gPT0gXCJvYmplY3RcIiAmJiBPICE9PSBudWxsICYmIChPLiQkdHlwZW9mID09PSB5IHx8IE8uJCR0eXBlb2YgPT09IHggfHwgTy4kJHR5cGVvZiA9PT0gcyB8fCBPLiQkdHlwZW9mID09PSBjIHx8IE8uJCR0eXBlb2YgPT09IHAgfHwgTy4kJHR5cGVvZiA9PT0gUyB8fCBPLiQkdHlwZW9mID09PSBFIHx8IE8uJCR0eXBlb2YgPT09IFAgfHwgTy4kJHR5cGVvZiA9PT0gZik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGIoTykge1xuICAgICAgaWYgKHR5cGVvZiBPID09IFwib2JqZWN0XCIgJiYgTyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgeWUgPSBPLiQkdHlwZW9mO1xuICAgICAgICBzd2l0Y2ggKHllKSB7XG4gICAgICAgICAgY2FzZSB0OlxuICAgICAgICAgICAgdmFyIEVlID0gTy50eXBlO1xuICAgICAgICAgICAgc3dpdGNoIChFZSkge1xuICAgICAgICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgICAgY2FzZSBuOlxuICAgICAgICAgICAgICBjYXNlIGk6XG4gICAgICAgICAgICAgIGNhc2UgbzpcbiAgICAgICAgICAgICAgY2FzZSBtOlxuICAgICAgICAgICAgICAgIHJldHVybiBFZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgTWUgPSBFZSAmJiBFZS4kJHR5cGVvZjtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKE1lKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICAgICAgICBjYXNlIHA6XG4gICAgICAgICAgICAgICAgICBjYXNlIHk6XG4gICAgICAgICAgICAgICAgICBjYXNlIHg6XG4gICAgICAgICAgICAgICAgICBjYXNlIHM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNZTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgcmV0dXJuIHllO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBoID0gbCwgdyA9IHUsIGsgPSBjLCBMID0gcywgQiA9IHQsIGQgPSBwLCBBID0gbiwgRCA9IHksIGogPSB4LCBXID0gciwgeiA9IGksIFUgPSBvLCBWID0gbSwgdGUgPSAhMTtcbiAgICBmdW5jdGlvbiBGKE8pIHtcbiAgICAgIHJldHVybiB0ZSB8fCAodGUgPSAhMCwgY29uc29sZS53YXJuKFwiVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS5cIikpLCBSKE8pIHx8IGIoTykgPT09IGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFIoTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IHU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEkoTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEooTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFEoTykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBPID09IFwib2JqZWN0XCIgJiYgTyAhPT0gbnVsbCAmJiBPLiQkdHlwZW9mID09PSB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBIKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBYKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBxKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSB4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBHKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSByO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZShPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gWihPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gbztcbiAgICB9XG4gICAgZnVuY3Rpb24gYWUoTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IG07XG4gICAgfVxuICAgIGdlLkFzeW5jTW9kZSA9IGgsIGdlLkNvbmN1cnJlbnRNb2RlID0gdywgZ2UuQ29udGV4dENvbnN1bWVyID0gaywgZ2UuQ29udGV4dFByb3ZpZGVyID0gTCwgZ2UuRWxlbWVudCA9IEIsIGdlLkZvcndhcmRSZWYgPSBkLCBnZS5GcmFnbWVudCA9IEEsIGdlLkxhenkgPSBELCBnZS5NZW1vID0gaiwgZ2UuUG9ydGFsID0gVywgZ2UuUHJvZmlsZXIgPSB6LCBnZS5TdHJpY3RNb2RlID0gVSwgZ2UuU3VzcGVuc2UgPSBWLCBnZS5pc0FzeW5jTW9kZSA9IEYsIGdlLmlzQ29uY3VycmVudE1vZGUgPSBSLCBnZS5pc0NvbnRleHRDb25zdW1lciA9IEksIGdlLmlzQ29udGV4dFByb3ZpZGVyID0gSiwgZ2UuaXNFbGVtZW50ID0gUSwgZ2UuaXNGb3J3YXJkUmVmID0gSCwgZ2UuaXNGcmFnbWVudCA9IFgsIGdlLmlzTGF6eSA9IF8sIGdlLmlzTWVtbyA9IHEsIGdlLmlzUG9ydGFsID0gRywgZ2UuaXNQcm9maWxlciA9IHJlLCBnZS5pc1N0cmljdE1vZGUgPSBaLCBnZS5pc1N1c3BlbnNlID0gYWUsIGdlLmlzVmFsaWRFbGVtZW50VHlwZSA9IFQsIGdlLnR5cGVPZiA9IGI7XG4gIH0oKSksIGdlO1xufVxudmFyIFRpO1xuZnVuY3Rpb24gTWEoKSB7XG4gIHJldHVybiBUaSB8fCAoVGkgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBHci5leHBvcnRzID0gb2woKSA6IEdyLmV4cG9ydHMgPSBpbCgpKSwgR3IuZXhwb3J0cztcbn1cbi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xudmFyIHFuLCB3aTtcbmZ1bmN0aW9uIGFsKCkge1xuICBpZiAod2kpIHJldHVybiBxbjtcbiAgd2kgPSAxO1xuICB2YXIgZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIHQgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCByID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgZnVuY3Rpb24gbihpKSB7XG4gICAgaWYgKGkgPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZFwiKTtcbiAgICByZXR1cm4gT2JqZWN0KGkpO1xuICB9XG4gIGZ1bmN0aW9uIG8oKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghT2JqZWN0LmFzc2lnbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgdmFyIGkgPSBuZXcgU3RyaW5nKFwiYWJjXCIpO1xuICAgICAgaWYgKGlbNV0gPSBcImRlXCIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGkpWzBdID09PSBcIjVcIilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgZm9yICh2YXIgcyA9IHt9LCBjID0gMDsgYyA8IDEwOyBjKyspXG4gICAgICAgIHNbXCJfXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpXSA9IGM7XG4gICAgICB2YXIgbCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHMpLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBzW3BdO1xuICAgICAgfSk7XG4gICAgICBpZiAobC5qb2luKFwiXCIpICE9PSBcIjAxMjM0NTY3ODlcIilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgdmFyIHUgPSB7fTtcbiAgICAgIHJldHVybiBcImFiY2RlZmdoaWprbG1ub3BxcnN0XCIuc3BsaXQoXCJcIikuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgIHVbcF0gPSBwO1xuICAgICAgfSksIE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHUpKS5qb2luKFwiXCIpID09PSBcImFiY2RlZmdoaWprbG1ub3BxcnN0XCI7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICB9XG4gIHJldHVybiBxbiA9IG8oKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbihpLCBzKSB7XG4gICAgZm9yICh2YXIgYywgbCA9IG4oaSksIHUsIHAgPSAxOyBwIDwgYXJndW1lbnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICBjID0gT2JqZWN0KGFyZ3VtZW50c1twXSk7XG4gICAgICBmb3IgKHZhciBtIGluIGMpXG4gICAgICAgIHQuY2FsbChjLCBtKSAmJiAobFttXSA9IGNbbV0pO1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdSA9IGUoYyk7XG4gICAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgdS5sZW5ndGg7IGcrKylcbiAgICAgICAgICByLmNhbGwoYywgdVtnXSkgJiYgKGxbdVtnXV0gPSBjW3VbZ11dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGw7XG4gIH0sIHFuO1xufVxudmFyIEduLCBPaTtcbmZ1bmN0aW9uIFBvKCkge1xuICBpZiAoT2kpIHJldHVybiBHbjtcbiAgT2kgPSAxO1xuICB2YXIgZSA9IFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIjtcbiAgcmV0dXJuIEduID0gZSwgR247XG59XG52YXIgS24sIFJpO1xuZnVuY3Rpb24gSWEoKSB7XG4gIHJldHVybiBSaSB8fCAoUmkgPSAxLCBLbiA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KSksIEtuO1xufVxudmFyIFhuLCAkaTtcbmZ1bmN0aW9uIHNsKCkge1xuICBpZiAoJGkpIHJldHVybiBYbjtcbiAgJGkgPSAxO1xuICB2YXIgZSA9IGZ1bmN0aW9uKCkge1xuICB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIHQgPSAvKiBAX19QVVJFX18gKi8gUG8oKSwgciA9IHt9LCBuID0gLyogQF9fUFVSRV9fICovIElhKCk7XG4gICAgZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBzID0gXCJXYXJuaW5nOiBcIiArIGk7XG4gICAgICB0eXBlb2YgY29uc29sZSA8IFwidVwiICYmIGNvbnNvbGUuZXJyb3Iocyk7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocyk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG8oaSwgcywgYywgbCwgdSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gaSlcbiAgICAgICAgaWYgKG4oaSwgcCkpIHtcbiAgICAgICAgICB2YXIgbTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpW3BdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICB2YXIgZyA9IEVycm9yKFxuICAgICAgICAgICAgICAgIChsIHx8IFwiUmVhY3QgY2xhc3NcIikgKyBcIjogXCIgKyBjICsgXCIgdHlwZSBgXCIgKyBwICsgXCJgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGBcIiArIHR5cGVvZiBpW3BdICsgXCJgLlRoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRocm93IGcubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbSA9IGlbcF0ocywgcCwgbCwgYywgbnVsbCwgdCk7XG4gICAgICAgICAgfSBjYXRjaCAoeSkge1xuICAgICAgICAgICAgbSA9IHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtICYmICEobSBpbnN0YW5jZW9mIEVycm9yKSAmJiBlKFxuICAgICAgICAgICAgKGwgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgXCIgKyBjICsgXCIgYFwiICsgcCArIFwiYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhIFwiICsgdHlwZW9mIG0gKyBcIi4gWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCBzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuXCJcbiAgICAgICAgICApLCBtIGluc3RhbmNlb2YgRXJyb3IgJiYgIShtLm1lc3NhZ2UgaW4gcikpIHtcbiAgICAgICAgICAgIHJbbS5tZXNzYWdlXSA9ICEwO1xuICAgICAgICAgICAgdmFyIHggPSB1ID8gdSgpIDogXCJcIjtcbiAgICAgICAgICAgIGUoXG4gICAgICAgICAgICAgIFwiRmFpbGVkIFwiICsgYyArIFwiIHR5cGU6IFwiICsgbS5tZXNzYWdlICsgKHggPz8gXCJcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChyID0ge30pO1xuICB9LCBYbiA9IG8sIFhuO1xufVxudmFyIEpuLCBQaTtcbmZ1bmN0aW9uIGNsKCkge1xuICBpZiAoUGkpIHJldHVybiBKbjtcbiAgUGkgPSAxO1xuICB2YXIgZSA9IE1hKCksIHQgPSBhbCgpLCByID0gLyogQF9fUFVSRV9fICovIFBvKCksIG4gPSAvKiBAX19QVVJFX18gKi8gSWEoKSwgbyA9IC8qIEBfX1BVUkVfXyAqLyBzbCgpLCBpID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoaSA9IGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgbCA9IFwiV2FybmluZzogXCIgKyBjO1xuICAgIHR5cGVvZiBjb25zb2xlIDwgXCJ1XCIgJiYgY29uc29sZS5lcnJvcihsKTtcbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGwpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIHMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEpuID0gZnVuY3Rpb24oYywgbCkge1xuICAgIHZhciB1ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBwID0gXCJAQGl0ZXJhdG9yXCI7XG4gICAgZnVuY3Rpb24gbShSKSB7XG4gICAgICB2YXIgSSA9IFIgJiYgKHUgJiYgUlt1XSB8fCBSW3BdKTtcbiAgICAgIGlmICh0eXBlb2YgSSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBJO1xuICAgIH1cbiAgICB2YXIgZyA9IFwiPDxhbm9ueW1vdXM+PlwiLCB4ID0ge1xuICAgICAgYXJyYXk6IEUoXCJhcnJheVwiKSxcbiAgICAgIGJpZ2ludDogRShcImJpZ2ludFwiKSxcbiAgICAgIGJvb2w6IEUoXCJib29sZWFuXCIpLFxuICAgICAgZnVuYzogRShcImZ1bmN0aW9uXCIpLFxuICAgICAgbnVtYmVyOiBFKFwibnVtYmVyXCIpLFxuICAgICAgb2JqZWN0OiBFKFwib2JqZWN0XCIpLFxuICAgICAgc3RyaW5nOiBFKFwic3RyaW5nXCIpLFxuICAgICAgc3ltYm9sOiBFKFwic3ltYm9sXCIpLFxuICAgICAgYW55OiBQKCksXG4gICAgICBhcnJheU9mOiBULFxuICAgICAgZWxlbWVudDogYigpLFxuICAgICAgZWxlbWVudFR5cGU6IGgoKSxcbiAgICAgIGluc3RhbmNlT2Y6IHcsXG4gICAgICBub2RlOiBkKCksXG4gICAgICBvYmplY3RPZjogTCxcbiAgICAgIG9uZU9mOiBrLFxuICAgICAgb25lT2ZUeXBlOiBCLFxuICAgICAgc2hhcGU6IEQsXG4gICAgICBleGFjdDogalxuICAgIH07XG4gICAgZnVuY3Rpb24geShSLCBJKSB7XG4gICAgICByZXR1cm4gUiA9PT0gSSA/IFIgIT09IDAgfHwgMSAvIFIgPT09IDEgLyBJIDogUiAhPT0gUiAmJiBJICE9PSBJO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmKFIsIEkpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IFIsIHRoaXMuZGF0YSA9IEkgJiYgdHlwZW9mIEkgPT0gXCJvYmplY3RcIiA/IEkgOiB7fSwgdGhpcy5zdGFjayA9IFwiXCI7XG4gICAgfVxuICAgIGYucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuICAgIGZ1bmN0aW9uIFMoUikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgdmFyIEkgPSB7fSwgSiA9IDA7XG4gICAgICBmdW5jdGlvbiBRKFgsIF8sIHEsIEcsIHJlLCBaLCBhZSkge1xuICAgICAgICBpZiAoRyA9IEcgfHwgZywgWiA9IFogfHwgcSwgYWUgIT09IHIpIHtcbiAgICAgICAgICBpZiAobCkge1xuICAgICAgICAgICAgdmFyIE8gPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiBSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyBPLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgTztcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2YgY29uc29sZSA8IFwidVwiKSB7XG4gICAgICAgICAgICB2YXIgeWUgPSBHICsgXCI6XCIgKyBxO1xuICAgICAgICAgICAgIUlbeWVdICYmIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgSiA8IDMgJiYgKGkoXG4gICAgICAgICAgICAgIFwiWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBgXCIgKyBaICsgXCJgIHByb3Agb24gYFwiICsgRyArIFwiYC4gVGhpcyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiBZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzIGxpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyBmb3IgZGV0YWlscy5cIlxuICAgICAgICAgICAgKSwgSVt5ZV0gPSAhMCwgSisrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9bcV0gPT0gbnVsbCA/IFggPyBfW3FdID09PSBudWxsID8gbmV3IGYoXCJUaGUgXCIgKyByZSArIFwiIGBcIiArIFogKyBcImAgaXMgbWFya2VkIGFzIHJlcXVpcmVkIFwiICsgKFwiaW4gYFwiICsgRyArIFwiYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuXCIpKSA6IG5ldyBmKFwiVGhlIFwiICsgcmUgKyBcIiBgXCIgKyBaICsgXCJgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiBcIiArIChcImBcIiArIEcgKyBcImAsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuXCIpKSA6IG51bGwgOiBSKF8sIHEsIEcsIHJlLCBaKTtcbiAgICAgIH1cbiAgICAgIHZhciBIID0gUS5iaW5kKG51bGwsICExKTtcbiAgICAgIHJldHVybiBILmlzUmVxdWlyZWQgPSBRLmJpbmQobnVsbCwgITApLCBIO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFKFIpIHtcbiAgICAgIGZ1bmN0aW9uIEkoSiwgUSwgSCwgWCwgXywgcSkge1xuICAgICAgICB2YXIgRyA9IEpbUV0sIHJlID0gVShHKTtcbiAgICAgICAgaWYgKHJlICE9PSBSKSB7XG4gICAgICAgICAgdmFyIFogPSBWKEcpO1xuICAgICAgICAgIHJldHVybiBuZXcgZihcbiAgICAgICAgICAgIFwiSW52YWxpZCBcIiArIFggKyBcIiBgXCIgKyBfICsgXCJgIG9mIHR5cGUgXCIgKyAoXCJgXCIgKyBaICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIEggKyBcImAsIGV4cGVjdGVkIFwiKSArIChcImBcIiArIFIgKyBcImAuXCIpLFxuICAgICAgICAgICAgeyBleHBlY3RlZFR5cGU6IFIgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gUyhJKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUCgpIHtcbiAgICAgIHJldHVybiBTKHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUKFIpIHtcbiAgICAgIGZ1bmN0aW9uIEkoSiwgUSwgSCwgWCwgXykge1xuICAgICAgICBpZiAodHlwZW9mIFIgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBuZXcgZihcIlByb3BlcnR5IGBcIiArIF8gKyBcImAgb2YgY29tcG9uZW50IGBcIiArIEggKyBcImAgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuXCIpO1xuICAgICAgICB2YXIgcSA9IEpbUV07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShxKSkge1xuICAgICAgICAgIHZhciBHID0gVShxKTtcbiAgICAgICAgICByZXR1cm4gbmV3IGYoXCJJbnZhbGlkIFwiICsgWCArIFwiIGBcIiArIF8gKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIEcgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgSCArIFwiYCwgZXhwZWN0ZWQgYW4gYXJyYXkuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciByZSA9IDA7IHJlIDwgcS5sZW5ndGg7IHJlKyspIHtcbiAgICAgICAgICB2YXIgWiA9IFIocSwgcmUsIEgsIFgsIF8gKyBcIltcIiArIHJlICsgXCJdXCIsIHIpO1xuICAgICAgICAgIGlmIChaIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gWjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTKEkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiKCkge1xuICAgICAgZnVuY3Rpb24gUihJLCBKLCBRLCBILCBYKSB7XG4gICAgICAgIHZhciBfID0gSVtKXTtcbiAgICAgICAgaWYgKCFjKF8pKSB7XG4gICAgICAgICAgdmFyIHEgPSBVKF8pO1xuICAgICAgICAgIHJldHVybiBuZXcgZihcIkludmFsaWQgXCIgKyBIICsgXCIgYFwiICsgWCArIFwiYCBvZiB0eXBlIFwiICsgKFwiYFwiICsgcSArIFwiYCBzdXBwbGllZCB0byBgXCIgKyBRICsgXCJgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTKFIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoKCkge1xuICAgICAgZnVuY3Rpb24gUihJLCBKLCBRLCBILCBYKSB7XG4gICAgICAgIHZhciBfID0gSVtKXTtcbiAgICAgICAgaWYgKCFlLmlzVmFsaWRFbGVtZW50VHlwZShfKSkge1xuICAgICAgICAgIHZhciBxID0gVShfKTtcbiAgICAgICAgICByZXR1cm4gbmV3IGYoXCJJbnZhbGlkIFwiICsgSCArIFwiIGBcIiArIFggKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIHEgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgUSArIFwiYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTKFIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3KFIpIHtcbiAgICAgIGZ1bmN0aW9uIEkoSiwgUSwgSCwgWCwgXykge1xuICAgICAgICBpZiAoIShKW1FdIGluc3RhbmNlb2YgUikpIHtcbiAgICAgICAgICB2YXIgcSA9IFIubmFtZSB8fCBnLCBHID0gRihKW1FdKTtcbiAgICAgICAgICByZXR1cm4gbmV3IGYoXCJJbnZhbGlkIFwiICsgWCArIFwiIGBcIiArIF8gKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIEcgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgSCArIFwiYCwgZXhwZWN0ZWQgXCIpICsgKFwiaW5zdGFuY2Ugb2YgYFwiICsgcSArIFwiYC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFMoSSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGsoUikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KFIpKVxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChhcmd1bWVudHMubGVuZ3RoID4gMSA/IGkoXG4gICAgICAgICAgXCJJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCBcIiArIGFyZ3VtZW50cy5sZW5ndGggKyBcIiBhcmd1bWVudHMuIEEgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLlwiXG4gICAgICAgICkgOiBpKFwiSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuXCIpKSwgcztcbiAgICAgIGZ1bmN0aW9uIEkoSiwgUSwgSCwgWCwgXykge1xuICAgICAgICBmb3IgKHZhciBxID0gSltRXSwgRyA9IDA7IEcgPCBSLmxlbmd0aDsgRysrKVxuICAgICAgICAgIGlmICh5KHEsIFJbR10pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciByZSA9IEpTT04uc3RyaW5naWZ5KFIsIGZ1bmN0aW9uKGFlLCBPKSB7XG4gICAgICAgICAgdmFyIHllID0gVihPKTtcbiAgICAgICAgICByZXR1cm4geWUgPT09IFwic3ltYm9sXCIgPyBTdHJpbmcoTykgOiBPO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBmKFwiSW52YWxpZCBcIiArIFggKyBcIiBgXCIgKyBfICsgXCJgIG9mIHZhbHVlIGBcIiArIFN0cmluZyhxKSArIFwiYCBcIiArIChcInN1cHBsaWVkIHRvIGBcIiArIEggKyBcImAsIGV4cGVjdGVkIG9uZSBvZiBcIiArIHJlICsgXCIuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTKEkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMKFIpIHtcbiAgICAgIGZ1bmN0aW9uIEkoSiwgUSwgSCwgWCwgXykge1xuICAgICAgICBpZiAodHlwZW9mIFIgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBuZXcgZihcIlByb3BlcnR5IGBcIiArIF8gKyBcImAgb2YgY29tcG9uZW50IGBcIiArIEggKyBcImAgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLlwiKTtcbiAgICAgICAgdmFyIHEgPSBKW1FdLCBHID0gVShxKTtcbiAgICAgICAgaWYgKEcgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuIG5ldyBmKFwiSW52YWxpZCBcIiArIFggKyBcIiBgXCIgKyBfICsgXCJgIG9mIHR5cGUgXCIgKyAoXCJgXCIgKyBHICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIEggKyBcImAsIGV4cGVjdGVkIGFuIG9iamVjdC5cIikpO1xuICAgICAgICBmb3IgKHZhciByZSBpbiBxKVxuICAgICAgICAgIGlmIChuKHEsIHJlKSkge1xuICAgICAgICAgICAgdmFyIFogPSBSKHEsIHJlLCBILCBYLCBfICsgXCIuXCIgKyByZSwgcik7XG4gICAgICAgICAgICBpZiAoWiBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICAgICAgICByZXR1cm4gWjtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFMoSSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEIoUikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KFIpKVxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGkoXCJJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuXCIpLCBzO1xuICAgICAgZm9yICh2YXIgSSA9IDA7IEkgPCBSLmxlbmd0aDsgSSsrKSB7XG4gICAgICAgIHZhciBKID0gUltJXTtcbiAgICAgICAgaWYgKHR5cGVvZiBKICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4gaShcbiAgICAgICAgICAgIFwiSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0IHJlY2VpdmVkIFwiICsgdGUoSikgKyBcIiBhdCBpbmRleCBcIiArIEkgKyBcIi5cIlxuICAgICAgICAgICksIHM7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBRKEgsIFgsIF8sIHEsIEcpIHtcbiAgICAgICAgZm9yICh2YXIgcmUgPSBbXSwgWiA9IDA7IFogPCBSLmxlbmd0aDsgWisrKSB7XG4gICAgICAgICAgdmFyIGFlID0gUltaXSwgTyA9IGFlKEgsIFgsIF8sIHEsIEcsIHIpO1xuICAgICAgICAgIGlmIChPID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICBPLmRhdGEgJiYgbihPLmRhdGEsIFwiZXhwZWN0ZWRUeXBlXCIpICYmIHJlLnB1c2goTy5kYXRhLmV4cGVjdGVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHllID0gcmUubGVuZ3RoID4gMCA/IFwiLCBleHBlY3RlZCBvbmUgb2YgdHlwZSBbXCIgKyByZS5qb2luKFwiLCBcIikgKyBcIl1cIiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBuZXcgZihcIkludmFsaWQgXCIgKyBxICsgXCIgYFwiICsgRyArIFwiYCBzdXBwbGllZCB0byBcIiArIChcImBcIiArIF8gKyBcImBcIiArIHllICsgXCIuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTKFEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgZnVuY3Rpb24gUihJLCBKLCBRLCBILCBYKSB7XG4gICAgICAgIHJldHVybiBXKElbSl0pID8gbnVsbCA6IG5ldyBmKFwiSW52YWxpZCBcIiArIEggKyBcIiBgXCIgKyBYICsgXCJgIHN1cHBsaWVkIHRvIFwiICsgKFwiYFwiICsgUSArIFwiYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTKFIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBKFIsIEksIEosIFEsIEgpIHtcbiAgICAgIHJldHVybiBuZXcgZihcbiAgICAgICAgKFIgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIEkgKyBcIiB0eXBlIGBcIiArIEogKyBcIi5cIiArIFEgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgSCArIFwiYC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRChSKSB7XG4gICAgICBmdW5jdGlvbiBJKEosIFEsIEgsIFgsIF8pIHtcbiAgICAgICAgdmFyIHEgPSBKW1FdLCBHID0gVShxKTtcbiAgICAgICAgaWYgKEcgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuIG5ldyBmKFwiSW52YWxpZCBcIiArIFggKyBcIiBgXCIgKyBfICsgXCJgIG9mIHR5cGUgYFwiICsgRyArIFwiYCBcIiArIChcInN1cHBsaWVkIHRvIGBcIiArIEggKyBcImAsIGV4cGVjdGVkIGBvYmplY3RgLlwiKSk7XG4gICAgICAgIGZvciAodmFyIHJlIGluIFIpIHtcbiAgICAgICAgICB2YXIgWiA9IFJbcmVdO1xuICAgICAgICAgIGlmICh0eXBlb2YgWiAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICByZXR1cm4gQShILCBYLCBfLCByZSwgVihaKSk7XG4gICAgICAgICAgdmFyIGFlID0gWihxLCByZSwgSCwgWCwgXyArIFwiLlwiICsgcmUsIHIpO1xuICAgICAgICAgIGlmIChhZSlcbiAgICAgICAgICAgIHJldHVybiBhZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTKEkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqKFIpIHtcbiAgICAgIGZ1bmN0aW9uIEkoSiwgUSwgSCwgWCwgXykge1xuICAgICAgICB2YXIgcSA9IEpbUV0sIEcgPSBVKHEpO1xuICAgICAgICBpZiAoRyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm4gbmV3IGYoXCJJbnZhbGlkIFwiICsgWCArIFwiIGBcIiArIF8gKyBcImAgb2YgdHlwZSBgXCIgKyBHICsgXCJgIFwiICsgKFwic3VwcGxpZWQgdG8gYFwiICsgSCArIFwiYCwgZXhwZWN0ZWQgYG9iamVjdGAuXCIpKTtcbiAgICAgICAgdmFyIHJlID0gdCh7fSwgSltRXSwgUik7XG4gICAgICAgIGZvciAodmFyIFogaW4gcmUpIHtcbiAgICAgICAgICB2YXIgYWUgPSBSW1pdO1xuICAgICAgICAgIGlmIChuKFIsIFopICYmIHR5cGVvZiBhZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICByZXR1cm4gQShILCBYLCBfLCBaLCBWKGFlKSk7XG4gICAgICAgICAgaWYgKCFhZSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgZihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIFwiICsgWCArIFwiIGBcIiArIF8gKyBcImAga2V5IGBcIiArIFogKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgSCArIFwiYC5cXG5CYWQgb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KEpbUV0sIG51bGwsIFwiICBcIikgKyBgXG5WYWxpZCBrZXlzOiBgICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoUiksIG51bGwsIFwiICBcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIE8gPSBhZShxLCBaLCBILCBYLCBfICsgXCIuXCIgKyBaLCByKTtcbiAgICAgICAgICBpZiAoTylcbiAgICAgICAgICAgIHJldHVybiBPO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFMoSSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFcoUikge1xuICAgICAgc3dpdGNoICh0eXBlb2YgUikge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICByZXR1cm4gIVI7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShSKSlcbiAgICAgICAgICAgIHJldHVybiBSLmV2ZXJ5KFcpO1xuICAgICAgICAgIGlmIChSID09PSBudWxsIHx8IGMoUikpXG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgdmFyIEkgPSBtKFIpO1xuICAgICAgICAgIGlmIChJKSB7XG4gICAgICAgICAgICB2YXIgSiA9IEkuY2FsbChSKSwgUTtcbiAgICAgICAgICAgIGlmIChJICE9PSBSLmVudHJpZXMpIHtcbiAgICAgICAgICAgICAgZm9yICg7ICEoUSA9IEoubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgICAgICAgaWYgKCFXKFEudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGZvciAoOyAhKFEgPSBKLm5leHQoKSkuZG9uZTsgKSB7XG4gICAgICAgICAgICAgICAgdmFyIEggPSBRLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChIICYmICFXKEhbMV0pKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24geihSLCBJKSB7XG4gICAgICByZXR1cm4gUiA9PT0gXCJzeW1ib2xcIiA/ICEwIDogSSA/IElbXCJAQHRvU3RyaW5nVGFnXCJdID09PSBcIlN5bWJvbFwiIHx8IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIEkgaW5zdGFuY2VvZiBTeW1ib2wgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVShSKSB7XG4gICAgICB2YXIgSSA9IHR5cGVvZiBSO1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoUikgPyBcImFycmF5XCIgOiBSIGluc3RhbmNlb2YgUmVnRXhwID8gXCJvYmplY3RcIiA6IHooSSwgUikgPyBcInN5bWJvbFwiIDogSTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVihSKSB7XG4gICAgICBpZiAodHlwZW9mIFIgPiBcInVcIiB8fCBSID09PSBudWxsKVxuICAgICAgICByZXR1cm4gXCJcIiArIFI7XG4gICAgICB2YXIgSSA9IFUoUik7XG4gICAgICBpZiAoSSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoUiBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgcmV0dXJuIFwiZGF0ZVwiO1xuICAgICAgICBpZiAoUiBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgICByZXR1cm4gXCJyZWdleHBcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBJO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZShSKSB7XG4gICAgICB2YXIgSSA9IFYoUik7XG4gICAgICBzd2l0Y2ggKEkpIHtcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICByZXR1cm4gXCJhbiBcIiArIEk7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgIGNhc2UgXCJyZWdleHBcIjpcbiAgICAgICAgICByZXR1cm4gXCJhIFwiICsgSTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gSTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gRihSKSB7XG4gICAgICByZXR1cm4gIVIuY29uc3RydWN0b3IgfHwgIVIuY29uc3RydWN0b3IubmFtZSA/IGcgOiBSLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiB4LmNoZWNrUHJvcFR5cGVzID0gbywgeC5yZXNldFdhcm5pbmdDYWNoZSA9IG8ucmVzZXRXYXJuaW5nQ2FjaGUsIHguUHJvcFR5cGVzID0geCwgeDtcbiAgfSwgSm47XG59XG52YXIgUW4sIGtpO1xuZnVuY3Rpb24gbGwoKSB7XG4gIGlmIChraSkgcmV0dXJuIFFuO1xuICBraSA9IDE7XG4gIHZhciBlID0gLyogQF9fUFVSRV9fICovIFBvKCk7XG4gIGZ1bmN0aW9uIHQoKSB7XG4gIH1cbiAgZnVuY3Rpb24gcigpIHtcbiAgfVxuICByZXR1cm4gci5yZXNldFdhcm5pbmdDYWNoZSA9IHQsIFFuID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gbihzLCBjLCBsLCB1LCBwLCBtKSB7XG4gICAgICBpZiAobSAhPT0gZSkge1xuICAgICAgICB2YXIgZyA9IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuIFVzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uIFJlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXNcIlxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBnLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgZztcbiAgICAgIH1cbiAgICB9XG4gICAgbi5pc1JlcXVpcmVkID0gbjtcbiAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIHZhciBpID0ge1xuICAgICAgYXJyYXk6IG4sXG4gICAgICBiaWdpbnQ6IG4sXG4gICAgICBib29sOiBuLFxuICAgICAgZnVuYzogbixcbiAgICAgIG51bWJlcjogbixcbiAgICAgIG9iamVjdDogbixcbiAgICAgIHN0cmluZzogbixcbiAgICAgIHN5bWJvbDogbixcbiAgICAgIGFueTogbixcbiAgICAgIGFycmF5T2Y6IG8sXG4gICAgICBlbGVtZW50OiBuLFxuICAgICAgZWxlbWVudFR5cGU6IG4sXG4gICAgICBpbnN0YW5jZU9mOiBvLFxuICAgICAgbm9kZTogbixcbiAgICAgIG9iamVjdE9mOiBvLFxuICAgICAgb25lT2Y6IG8sXG4gICAgICBvbmVPZlR5cGU6IG8sXG4gICAgICBzaGFwZTogbyxcbiAgICAgIGV4YWN0OiBvLFxuICAgICAgY2hlY2tQcm9wVHlwZXM6IHIsXG4gICAgICByZXNldFdhcm5pbmdDYWNoZTogdFxuICAgIH07XG4gICAgcmV0dXJuIGkuUHJvcFR5cGVzID0gaSwgaTtcbiAgfSwgUW47XG59XG52YXIgQWk7XG5mdW5jdGlvbiB1bCgpIHtcbiAgaWYgKEFpKSByZXR1cm4gcXIuZXhwb3J0cztcbiAgaWYgKEFpID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIGUgPSBNYSgpLCB0ID0gITA7XG4gICAgcXIuZXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBjbCgpKGUuaXNFbGVtZW50LCB0KTtcbiAgfSBlbHNlXG4gICAgcXIuZXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBsbCgpKCk7XG4gIHJldHVybiBxci5leHBvcnRzO1xufVxudmFyIGZsID0gLyogQF9fUFVSRV9fICovIHVsKCk7XG5jb25zdCBhID0gLyogQF9fUFVSRV9fICovIGVjKGZsKTtcbmZ1bmN0aW9uIGRsKGUpIHtcbiAgcmV0dXJuIGUgPT0gbnVsbCB8fCBPYmplY3Qua2V5cyhlKS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiBfYShlKSB7XG4gIGNvbnN0IHtcbiAgICBzdHlsZXM6IHQsXG4gICAgZGVmYXVsdFRoZW1lOiByID0ge31cbiAgfSA9IGUsIG4gPSB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyAobykgPT4gdChkbChvKSA/IHIgOiBvKSA6IHQ7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goWGMsIHtcbiAgICBzdHlsZXM6IG5cbiAgfSk7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKF9hLnByb3BUeXBlcyA9IHtcbiAgZGVmYXVsdFRoZW1lOiBhLm9iamVjdCxcbiAgc3R5bGVzOiBhLm9uZU9mVHlwZShbYS5hcnJheSwgYS5zdHJpbmcsIGEub2JqZWN0LCBhLmZ1bmNdKVxufSk7XG4vKipcbiAqIEBtdWkvc3R5bGVkLWVuZ2luZSB2Ni40LjBcbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5mdW5jdGlvbiBqYShlLCB0KSB7XG4gIGNvbnN0IHIgPSBzbyhlLCB0KTtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/ICguLi5uKSA9PiB7XG4gICAgY29uc3QgbyA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBgXCIke2V9XCJgIDogXCJjb21wb25lbnRcIjtcbiAgICByZXR1cm4gbi5sZW5ndGggPT09IDAgPyBjb25zb2xlLmVycm9yKFtgTVVJOiBTZWVtcyBsaWtlIHlvdSBjYWxsZWQgXFxgc3R5bGVkKCR7b30pKClcXGAgd2l0aG91dCBhIFxcYHN0eWxlXFxgIGFyZ3VtZW50LmAsICdZb3UgbXVzdCBwcm92aWRlIGEgYHN0eWxlc2AgYXJndW1lbnQ6IGBzdHlsZWQoXCJkaXZcIikoc3R5bGVZb3VGb3Jnb3RUb1Bhc3MpYC4nXS5qb2luKGBcbmApKSA6IG4uc29tZSgoaSkgPT4gaSA9PT0gdm9pZCAwKSAmJiBjb25zb2xlLmVycm9yKGBNVUk6IHRoZSBzdHlsZWQoJHtvfSkoLi4uYXJncykgQVBJIHJlcXVpcmVzIGFsbCBpdHMgYXJncyB0byBiZSBkZWZpbmVkLmApLCByKC4uLm4pO1xuICB9IDogcjtcbn1cbmZ1bmN0aW9uIHBsKGUsIHQpIHtcbiAgQXJyYXkuaXNBcnJheShlLl9fZW1vdGlvbl9zdHlsZXMpICYmIChlLl9fZW1vdGlvbl9zdHlsZXMgPSB0KGUuX19lbW90aW9uX3N0eWxlcykpO1xufVxuY29uc3QgTmkgPSBbXTtcbmZ1bmN0aW9uIE1pKGUpIHtcbiAgcmV0dXJuIE5pWzBdID0gZSwgTnIoTmkpO1xufVxudmFyIEtyID0geyBleHBvcnRzOiB7fSB9LCB4ZSA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtaXMucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBJaTtcbmZ1bmN0aW9uIG1sKCkge1xuICBpZiAoSWkpIHJldHVybiB4ZTtcbiAgSWkgPSAxO1xuICB2YXIgZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSwgdCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksIHIgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIG4gPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksIG8gPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksIGkgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksIHMgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSwgYyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSwgbCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSwgdSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLCBwID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksIG0gPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgZyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksIHggPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKTtcbiAgZnVuY3Rpb24geShmKSB7XG4gICAgaWYgKHR5cGVvZiBmID09IFwib2JqZWN0XCIgJiYgZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIFMgPSBmLiQkdHlwZW9mO1xuICAgICAgc3dpdGNoIChTKSB7XG4gICAgICAgIGNhc2UgZTpcbiAgICAgICAgICBzd2l0Y2ggKGYgPSBmLnR5cGUsIGYpIHtcbiAgICAgICAgICAgIGNhc2UgcjpcbiAgICAgICAgICAgIGNhc2UgbzpcbiAgICAgICAgICAgIGNhc2UgbjpcbiAgICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzd2l0Y2ggKGYgPSBmICYmIGYuJCR0eXBlb2YsIGYpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHM6XG4gICAgICAgICAgICAgICAgY2FzZSBjOlxuICAgICAgICAgICAgICAgIGNhc2UgbTpcbiAgICAgICAgICAgICAgICBjYXNlIHA6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgICAgICBjYXNlIGk6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgdDpcbiAgICAgICAgICByZXR1cm4gUztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHhlLkNvbnRleHRDb25zdW1lciA9IGksIHhlLkNvbnRleHRQcm92aWRlciA9IHMsIHhlLkVsZW1lbnQgPSBlLCB4ZS5Gb3J3YXJkUmVmID0gYywgeGUuRnJhZ21lbnQgPSByLCB4ZS5MYXp5ID0gbSwgeGUuTWVtbyA9IHAsIHhlLlBvcnRhbCA9IHQsIHhlLlByb2ZpbGVyID0gbywgeGUuU3RyaWN0TW9kZSA9IG4sIHhlLlN1c3BlbnNlID0gbCwgeGUuU3VzcGVuc2VMaXN0ID0gdSwgeGUuaXNDb250ZXh0Q29uc3VtZXIgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHkoZikgPT09IGk7XG4gIH0sIHhlLmlzQ29udGV4dFByb3ZpZGVyID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB5KGYpID09PSBzO1xuICB9LCB4ZS5pc0VsZW1lbnQgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBmID09IFwib2JqZWN0XCIgJiYgZiAhPT0gbnVsbCAmJiBmLiQkdHlwZW9mID09PSBlO1xuICB9LCB4ZS5pc0ZvcndhcmRSZWYgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHkoZikgPT09IGM7XG4gIH0sIHhlLmlzRnJhZ21lbnQgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHkoZikgPT09IHI7XG4gIH0sIHhlLmlzTGF6eSA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4geShmKSA9PT0gbTtcbiAgfSwgeGUuaXNNZW1vID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB5KGYpID09PSBwO1xuICB9LCB4ZS5pc1BvcnRhbCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4geShmKSA9PT0gdDtcbiAgfSwgeGUuaXNQcm9maWxlciA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4geShmKSA9PT0gbztcbiAgfSwgeGUuaXNTdHJpY3RNb2RlID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB5KGYpID09PSBuO1xuICB9LCB4ZS5pc1N1c3BlbnNlID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB5KGYpID09PSBsO1xuICB9LCB4ZS5pc1N1c3BlbnNlTGlzdCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4geShmKSA9PT0gdTtcbiAgfSwgeGUuaXNWYWxpZEVsZW1lbnRUeXBlID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB0eXBlb2YgZiA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBmID09IFwiZnVuY3Rpb25cIiB8fCBmID09PSByIHx8IGYgPT09IG8gfHwgZiA9PT0gbiB8fCBmID09PSBsIHx8IGYgPT09IHUgfHwgZiA9PT0gZyB8fCB0eXBlb2YgZiA9PSBcIm9iamVjdFwiICYmIGYgIT09IG51bGwgJiYgKGYuJCR0eXBlb2YgPT09IG0gfHwgZi4kJHR5cGVvZiA9PT0gcCB8fCBmLiQkdHlwZW9mID09PSBzIHx8IGYuJCR0eXBlb2YgPT09IGkgfHwgZi4kJHR5cGVvZiA9PT0gYyB8fCBmLiQkdHlwZW9mID09PSB4IHx8IGYuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCk7XG4gIH0sIHhlLnR5cGVPZiA9IHksIHhlO1xufVxudmFyIFNlID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBfaTtcbmZ1bmN0aW9uIGhsKCkge1xuICByZXR1cm4gX2kgfHwgKF9pID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGUoZikge1xuICAgICAgaWYgKHR5cGVvZiBmID09IFwib2JqZWN0XCIgJiYgZiAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgUyA9IGYuJCR0eXBlb2Y7XG4gICAgICAgIHN3aXRjaCAoUykge1xuICAgICAgICAgIGNhc2UgdDpcbiAgICAgICAgICAgIHN3aXRjaCAoZiA9IGYudHlwZSwgZikge1xuICAgICAgICAgICAgICBjYXNlIG46XG4gICAgICAgICAgICAgIGNhc2UgaTpcbiAgICAgICAgICAgICAgY2FzZSBvOlxuICAgICAgICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgICAgIGNhc2UgcDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGYgPSBmICYmIGYuJCR0eXBlb2YsIGYpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgYzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgbTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICAgICAgICBjYXNlIHM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgcjpcbiAgICAgICAgICAgIHJldHVybiBTO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0ID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLCByID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgbyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgaSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgcyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSwgYyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCBsID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCB1ID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCBwID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIG0gPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgZyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLCB4ID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSwgeSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpO1xuICAgIFNlLkNvbnRleHRDb25zdW1lciA9IHMsIFNlLkNvbnRleHRQcm92aWRlciA9IGMsIFNlLkVsZW1lbnQgPSB0LCBTZS5Gb3J3YXJkUmVmID0gbCwgU2UuRnJhZ21lbnQgPSBuLCBTZS5MYXp5ID0gZywgU2UuTWVtbyA9IG0sIFNlLlBvcnRhbCA9IHIsIFNlLlByb2ZpbGVyID0gaSwgU2UuU3RyaWN0TW9kZSA9IG8sIFNlLlN1c3BlbnNlID0gdSwgU2UuU3VzcGVuc2VMaXN0ID0gcCwgU2UuaXNDb250ZXh0Q29uc3VtZXIgPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZShmKSA9PT0gcztcbiAgICB9LCBTZS5pc0NvbnRleHRQcm92aWRlciA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBlKGYpID09PSBjO1xuICAgIH0sIFNlLmlzRWxlbWVudCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZiA9PSBcIm9iamVjdFwiICYmIGYgIT09IG51bGwgJiYgZi4kJHR5cGVvZiA9PT0gdDtcbiAgICB9LCBTZS5pc0ZvcndhcmRSZWYgPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZShmKSA9PT0gbDtcbiAgICB9LCBTZS5pc0ZyYWdtZW50ID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGUoZikgPT09IG47XG4gICAgfSwgU2UuaXNMYXp5ID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGUoZikgPT09IGc7XG4gICAgfSwgU2UuaXNNZW1vID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGUoZikgPT09IG07XG4gICAgfSwgU2UuaXNQb3J0YWwgPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZShmKSA9PT0gcjtcbiAgICB9LCBTZS5pc1Byb2ZpbGVyID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGUoZikgPT09IGk7XG4gICAgfSwgU2UuaXNTdHJpY3RNb2RlID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGUoZikgPT09IG87XG4gICAgfSwgU2UuaXNTdXNwZW5zZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBlKGYpID09PSB1O1xuICAgIH0sIFNlLmlzU3VzcGVuc2VMaXN0ID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGUoZikgPT09IHA7XG4gICAgfSwgU2UuaXNWYWxpZEVsZW1lbnRUeXBlID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBmID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGYgPT0gXCJmdW5jdGlvblwiIHx8IGYgPT09IG4gfHwgZiA9PT0gaSB8fCBmID09PSBvIHx8IGYgPT09IHUgfHwgZiA9PT0gcCB8fCBmID09PSB4IHx8IHR5cGVvZiBmID09IFwib2JqZWN0XCIgJiYgZiAhPT0gbnVsbCAmJiAoZi4kJHR5cGVvZiA9PT0gZyB8fCBmLiQkdHlwZW9mID09PSBtIHx8IGYuJCR0eXBlb2YgPT09IGMgfHwgZi4kJHR5cGVvZiA9PT0gcyB8fCBmLiQkdHlwZW9mID09PSBsIHx8IGYuJCR0eXBlb2YgPT09IHkgfHwgZi5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKTtcbiAgICB9LCBTZS50eXBlT2YgPSBlO1xuICB9KCkpLCBTZTtcbn1cbnZhciBqaTtcbmZ1bmN0aW9uIGdsKCkge1xuICByZXR1cm4gamkgfHwgKGppID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gS3IuZXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBtbCgpIDogS3IuZXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBobCgpKSwgS3IuZXhwb3J0cztcbn1cbnZhciBwbiA9IC8qIEBfX1BVUkVfXyAqLyBnbCgpO1xuZnVuY3Rpb24gZ3QoZSkge1xuICBpZiAodHlwZW9mIGUgIT0gXCJvYmplY3RcIiB8fCBlID09PSBudWxsKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgdCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihlKTtcbiAgcmV0dXJuICh0ID09PSBudWxsIHx8IHQgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpID09PSBudWxsKSAmJiAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBlKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiBlKTtcbn1cbmZ1bmN0aW9uIERhKGUpIHtcbiAgaWYgKC8qIEBfX1BVUkVfXyAqLyBDLmlzVmFsaWRFbGVtZW50KGUpIHx8IHBuLmlzVmFsaWRFbGVtZW50VHlwZShlKSB8fCAhZ3QoZSkpXG4gICAgcmV0dXJuIGU7XG4gIGNvbnN0IHQgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKHIpID0+IHtcbiAgICB0W3JdID0gRGEoZVtyXSk7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gdHQoZSwgdCwgciA9IHtcbiAgY2xvbmU6ICEwXG59KSB7XG4gIGNvbnN0IG4gPSByLmNsb25lID8ge1xuICAgIC4uLmVcbiAgfSA6IGU7XG4gIHJldHVybiBndChlKSAmJiBndCh0KSAmJiBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChvKSA9PiB7XG4gICAgLyogQF9fUFVSRV9fICovIEMuaXNWYWxpZEVsZW1lbnQodFtvXSkgfHwgcG4uaXNWYWxpZEVsZW1lbnRUeXBlKHRbb10pID8gbltvXSA9IHRbb10gOiBndCh0W29dKSAmJiAvLyBBdm9pZCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIG8pICYmIGd0KGVbb10pID8gbltvXSA9IHR0KGVbb10sIHRbb10sIHIpIDogci5jbG9uZSA/IG5bb10gPSBndCh0W29dKSA/IERhKHRbb10pIDogdFtvXSA6IG5bb10gPSB0W29dO1xuICB9KSwgbjtcbn1cbmNvbnN0IHlsID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IE9iamVjdC5rZXlzKGUpLm1hcCgocikgPT4gKHtcbiAgICBrZXk6IHIsXG4gICAgdmFsOiBlW3JdXG4gIH0pKSB8fCBbXTtcbiAgcmV0dXJuIHQuc29ydCgociwgbikgPT4gci52YWwgLSBuLnZhbCksIHQucmVkdWNlKChyLCBuKSA9PiAoe1xuICAgIC4uLnIsXG4gICAgW24ua2V5XTogbi52YWxcbiAgfSksIHt9KTtcbn07XG5mdW5jdGlvbiBibChlKSB7XG4gIGNvbnN0IHtcbiAgICAvLyBUaGUgYnJlYWtwb2ludCAqKnN0YXJ0KiogYXQgdGhpcyB2YWx1ZS5cbiAgICAvLyBGb3IgaW5zdGFuY2Ugd2l0aCB0aGUgZmlyc3QgYnJlYWtwb2ludCB4czogW3hzLCBzbSkuXG4gICAgdmFsdWVzOiB0ID0ge1xuICAgICAgeHM6IDAsXG4gICAgICAvLyBwaG9uZVxuICAgICAgc206IDYwMCxcbiAgICAgIC8vIHRhYmxldFxuICAgICAgbWQ6IDkwMCxcbiAgICAgIC8vIHNtYWxsIGxhcHRvcFxuICAgICAgbGc6IDEyMDAsXG4gICAgICAvLyBkZXNrdG9wXG4gICAgICB4bDogMTUzNlxuICAgICAgLy8gbGFyZ2Ugc2NyZWVuXG4gICAgfSxcbiAgICB1bml0OiByID0gXCJweFwiLFxuICAgIHN0ZXA6IG4gPSA1LFxuICAgIC4uLm9cbiAgfSA9IGUsIGkgPSB5bCh0KSwgcyA9IE9iamVjdC5rZXlzKGkpO1xuICBmdW5jdGlvbiBjKGcpIHtcbiAgICByZXR1cm4gYEBtZWRpYSAobWluLXdpZHRoOiR7dHlwZW9mIHRbZ10gPT0gXCJudW1iZXJcIiA/IHRbZ10gOiBnfSR7cn0pYDtcbiAgfVxuICBmdW5jdGlvbiBsKGcpIHtcbiAgICByZXR1cm4gYEBtZWRpYSAobWF4LXdpZHRoOiR7KHR5cGVvZiB0W2ddID09IFwibnVtYmVyXCIgPyB0W2ddIDogZykgLSBuIC8gMTAwfSR7cn0pYDtcbiAgfVxuICBmdW5jdGlvbiB1KGcsIHgpIHtcbiAgICBjb25zdCB5ID0gcy5pbmRleE9mKHgpO1xuICAgIHJldHVybiBgQG1lZGlhIChtaW4td2lkdGg6JHt0eXBlb2YgdFtnXSA9PSBcIm51bWJlclwiID8gdFtnXSA6IGd9JHtyfSkgYW5kIChtYXgtd2lkdGg6JHsoeSAhPT0gLTEgJiYgdHlwZW9mIHRbc1t5XV0gPT0gXCJudW1iZXJcIiA/IHRbc1t5XV0gOiB4KSAtIG4gLyAxMDB9JHtyfSlgO1xuICB9XG4gIGZ1bmN0aW9uIHAoZykge1xuICAgIHJldHVybiBzLmluZGV4T2YoZykgKyAxIDwgcy5sZW5ndGggPyB1KGcsIHNbcy5pbmRleE9mKGcpICsgMV0pIDogYyhnKTtcbiAgfVxuICBmdW5jdGlvbiBtKGcpIHtcbiAgICBjb25zdCB4ID0gcy5pbmRleE9mKGcpO1xuICAgIHJldHVybiB4ID09PSAwID8gYyhzWzFdKSA6IHggPT09IHMubGVuZ3RoIC0gMSA/IGwoc1t4XSkgOiB1KGcsIHNbcy5pbmRleE9mKGcpICsgMV0pLnJlcGxhY2UoXCJAbWVkaWFcIiwgXCJAbWVkaWEgbm90IGFsbCBhbmRcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBrZXlzOiBzLFxuICAgIHZhbHVlczogaSxcbiAgICB1cDogYyxcbiAgICBkb3duOiBsLFxuICAgIGJldHdlZW46IHUsXG4gICAgb25seTogcCxcbiAgICBub3Q6IG0sXG4gICAgdW5pdDogcixcbiAgICAuLi5vXG4gIH07XG59XG5mdW5jdGlvbiB2bChlLCB0KSB7XG4gIGlmICghZS5jb250YWluZXJRdWVyaWVzKVxuICAgIHJldHVybiB0O1xuICBjb25zdCByID0gT2JqZWN0LmtleXModCkuZmlsdGVyKChuKSA9PiBuLnN0YXJ0c1dpdGgoXCJAY29udGFpbmVyXCIpKS5zb3J0KChuLCBvKSA9PiB7XG4gICAgdmFyIHMsIGM7XG4gICAgY29uc3QgaSA9IC9taW4td2lkdGg6XFxzKihbMC05Ll0rKS87XG4gICAgcmV0dXJuICsoKChzID0gbi5tYXRjaChpKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHNbMV0pIHx8IDApIC0gKygoKGMgPSBvLm1hdGNoKGkpKSA9PSBudWxsID8gdm9pZCAwIDogY1sxXSkgfHwgMCk7XG4gIH0pO1xuICByZXR1cm4gci5sZW5ndGggPyByLnJlZHVjZSgobiwgbykgPT4ge1xuICAgIGNvbnN0IGkgPSB0W29dO1xuICAgIHJldHVybiBkZWxldGUgbltvXSwgbltvXSA9IGksIG47XG4gIH0sIHtcbiAgICAuLi50XG4gIH0pIDogdDtcbn1cbmZ1bmN0aW9uIHhsKGUsIHQpIHtcbiAgcmV0dXJuIHQgPT09IFwiQFwiIHx8IHQuc3RhcnRzV2l0aChcIkBcIikgJiYgKGUuc29tZSgocikgPT4gdC5zdGFydHNXaXRoKGBAJHtyfWApKSB8fCAhIXQubWF0Y2goL15AXFxkLykpO1xufVxuZnVuY3Rpb24gU2woZSwgdCkge1xuICBjb25zdCByID0gdC5tYXRjaCgvXkAoW14vXSspP1xcLz8oLispPyQvKTtcbiAgaWYgKCFyKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBgTVVJOiBUaGUgcHJvdmlkZWQgc2hvcnRoYW5kICR7YCgke3R9KWB9IGlzIGludmFsaWQuIFRoZSBmb3JtYXQgc2hvdWxkIGJlIFxcYEA8YnJlYWtwb2ludCB8IG51bWJlcj5cXGAgb3IgXFxgQDxicmVha3BvaW50IHwgbnVtYmVyPi88Y29udGFpbmVyPlxcYC5cbkZvciBleGFtcGxlLCBcXGBAc21cXGAgb3IgXFxgQDYwMFxcYCBvciBcXGBANDByZW0vc2lkZWJhclxcYC5gIDoga3QoMTgsIGAoJHt0fSlgKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgWywgbiwgb10gPSByLCBpID0gTnVtYmVyLmlzTmFOKCtuKSA/IG4gfHwgMCA6ICtuO1xuICByZXR1cm4gZS5jb250YWluZXJRdWVyaWVzKG8pLnVwKGkpO1xufVxuZnVuY3Rpb24gRWwoZSkge1xuICBjb25zdCB0ID0gKGksIHMpID0+IGkucmVwbGFjZShcIkBtZWRpYVwiLCBzID8gYEBjb250YWluZXIgJHtzfWAgOiBcIkBjb250YWluZXJcIik7XG4gIGZ1bmN0aW9uIHIoaSwgcykge1xuICAgIGkudXAgPSAoLi4uYykgPT4gdChlLmJyZWFrcG9pbnRzLnVwKC4uLmMpLCBzKSwgaS5kb3duID0gKC4uLmMpID0+IHQoZS5icmVha3BvaW50cy5kb3duKC4uLmMpLCBzKSwgaS5iZXR3ZWVuID0gKC4uLmMpID0+IHQoZS5icmVha3BvaW50cy5iZXR3ZWVuKC4uLmMpLCBzKSwgaS5vbmx5ID0gKC4uLmMpID0+IHQoZS5icmVha3BvaW50cy5vbmx5KC4uLmMpLCBzKSwgaS5ub3QgPSAoLi4uYykgPT4ge1xuICAgICAgY29uc3QgbCA9IHQoZS5icmVha3BvaW50cy5ub3QoLi4uYyksIHMpO1xuICAgICAgcmV0dXJuIGwuaW5jbHVkZXMoXCJub3QgYWxsIGFuZFwiKSA/IGwucmVwbGFjZShcIm5vdCBhbGwgYW5kIFwiLCBcIlwiKS5yZXBsYWNlKFwibWluLXdpZHRoOlwiLCBcIndpZHRoPFwiKS5yZXBsYWNlKFwibWF4LXdpZHRoOlwiLCBcIndpZHRoPlwiKS5yZXBsYWNlKFwiYW5kXCIsIFwib3JcIikgOiBsO1xuICAgIH07XG4gIH1cbiAgY29uc3QgbiA9IHt9LCBvID0gKGkpID0+IChyKG4sIGkpLCBuKTtcbiAgcmV0dXJuIHIobyksIHtcbiAgICAuLi5lLFxuICAgIGNvbnRhaW5lclF1ZXJpZXM6IG9cbiAgfTtcbn1cbmNvbnN0IENsID0ge1xuICBib3JkZXJSYWRpdXM6IDRcbn0sIE10ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gYS5vbmVPZlR5cGUoW2EubnVtYmVyLCBhLnN0cmluZywgYS5vYmplY3QsIGEuYXJyYXldKSA6IHt9O1xuZnVuY3Rpb24gdnIoZSwgdCkge1xuICByZXR1cm4gdCA/IHR0KGUsIHQsIHtcbiAgICBjbG9uZTogITFcbiAgICAvLyBObyBuZWVkIHRvIGNsb25lIGRlZXAsIGl0J3Mgd2F5IGZhc3Rlci5cbiAgfSkgOiBlO1xufVxuY29uc3Qga24gPSB7XG4gIHhzOiAwLFxuICAvLyBwaG9uZVxuICBzbTogNjAwLFxuICAvLyB0YWJsZXRcbiAgbWQ6IDkwMCxcbiAgLy8gc21hbGwgbGFwdG9wXG4gIGxnOiAxMjAwLFxuICAvLyBkZXNrdG9wXG4gIHhsOiAxNTM2XG4gIC8vIGxhcmdlIHNjcmVlblxufSwgRGkgPSB7XG4gIC8vIFNvcnRlZCBBU0MgYnkgc2l6ZS4gVGhhdCdzIGltcG9ydGFudC5cbiAgLy8gSXQgY2FuJ3QgYmUgY29uZmlndXJlZCBhcyBpdCdzIHVzZWQgc3RhdGljYWxseSBmb3IgcHJvcFR5cGVzLlxuICBrZXlzOiBbXCJ4c1wiLCBcInNtXCIsIFwibWRcIiwgXCJsZ1wiLCBcInhsXCJdLFxuICB1cDogKGUpID0+IGBAbWVkaWEgKG1pbi13aWR0aDoke2tuW2VdfXB4KWBcbn0sIFRsID0ge1xuICBjb250YWluZXJRdWVyaWVzOiAoZSkgPT4gKHtcbiAgICB1cDogKHQpID0+IHtcbiAgICAgIGxldCByID0gdHlwZW9mIHQgPT0gXCJudW1iZXJcIiA/IHQgOiBrblt0XSB8fCB0O1xuICAgICAgcmV0dXJuIHR5cGVvZiByID09IFwibnVtYmVyXCIgJiYgKHIgPSBgJHtyfXB4YCksIGUgPyBgQGNvbnRhaW5lciAke2V9IChtaW4td2lkdGg6JHtyfSlgIDogYEBjb250YWluZXIgKG1pbi13aWR0aDoke3J9KWA7XG4gICAgfVxuICB9KVxufTtcbmZ1bmN0aW9uIE90KGUsIHQsIHIpIHtcbiAgY29uc3QgbiA9IGUudGhlbWUgfHwge307XG4gIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgY29uc3QgaSA9IG4uYnJlYWtwb2ludHMgfHwgRGk7XG4gICAgcmV0dXJuIHQucmVkdWNlKChzLCBjLCBsKSA9PiAoc1tpLnVwKGkua2V5c1tsXSldID0gcih0W2xdKSwgcyksIHt9KTtcbiAgfVxuICBpZiAodHlwZW9mIHQgPT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IGkgPSBuLmJyZWFrcG9pbnRzIHx8IERpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0KS5yZWR1Y2UoKHMsIGMpID0+IHtcbiAgICAgIGlmICh4bChpLmtleXMsIGMpKSB7XG4gICAgICAgIGNvbnN0IGwgPSBTbChuLmNvbnRhaW5lclF1ZXJpZXMgPyBuIDogVGwsIGMpO1xuICAgICAgICBsICYmIChzW2xdID0gcih0W2NdLCBjKSk7XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5rZXlzKGkudmFsdWVzIHx8IGtuKS5pbmNsdWRlcyhjKSkge1xuICAgICAgICBjb25zdCBsID0gaS51cChjKTtcbiAgICAgICAgc1tsXSA9IHIodFtjXSwgYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsID0gYztcbiAgICAgICAgc1tsXSA9IHRbbF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9LCB7fSk7XG4gIH1cbiAgcmV0dXJuIHIodCk7XG59XG5mdW5jdGlvbiB3bChlID0ge30pIHtcbiAgdmFyIHI7XG4gIHJldHVybiAoKHIgPSBlLmtleXMpID09IG51bGwgPyB2b2lkIDAgOiByLnJlZHVjZSgobiwgbykgPT4ge1xuICAgIGNvbnN0IGkgPSBlLnVwKG8pO1xuICAgIHJldHVybiBuW2ldID0ge30sIG47XG4gIH0sIHt9KSkgfHwge307XG59XG5mdW5jdGlvbiBPbChlLCB0KSB7XG4gIHJldHVybiBlLnJlZHVjZSgociwgbikgPT4ge1xuICAgIGNvbnN0IG8gPSByW25dO1xuICAgIHJldHVybiAoIW8gfHwgT2JqZWN0LmtleXMobykubGVuZ3RoID09PSAwKSAmJiBkZWxldGUgcltuXSwgcjtcbiAgfSwgdCk7XG59XG5mdW5jdGlvbiBlZShlKSB7XG4gIGlmICh0eXBlb2YgZSAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk1VSTogYGNhcGl0YWxpemUoc3RyaW5nKWAgZXhwZWN0cyBhIHN0cmluZyBhcmd1bWVudC5cIiA6IGt0KDcpKTtcbiAgcmV0dXJuIGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBlLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gQW4oZSwgdCwgciA9ICEwKSB7XG4gIGlmICghdCB8fCB0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoZSAmJiBlLnZhcnMgJiYgcikge1xuICAgIGNvbnN0IG4gPSBgdmFycy4ke3R9YC5zcGxpdChcIi5cIikucmVkdWNlKChvLCBpKSA9PiBvICYmIG9baV0gPyBvW2ldIDogbnVsbCwgZSk7XG4gICAgaWYgKG4gIT0gbnVsbClcbiAgICAgIHJldHVybiBuO1xuICB9XG4gIHJldHVybiB0LnNwbGl0KFwiLlwiKS5yZWR1Y2UoKG4sIG8pID0+IG4gJiYgbltvXSAhPSBudWxsID8gbltvXSA6IG51bGwsIGUpO1xufVxuZnVuY3Rpb24gbW4oZSwgdCwgciwgbiA9IHIpIHtcbiAgbGV0IG87XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBvID0gZShyKSA6IEFycmF5LmlzQXJyYXkoZSkgPyBvID0gZVtyXSB8fCBuIDogbyA9IEFuKGUsIHIpIHx8IG4sIHQgJiYgKG8gPSB0KG8sIG4sIGUpKSwgbztcbn1cbmZ1bmN0aW9uIF9lKGUpIHtcbiAgY29uc3Qge1xuICAgIHByb3A6IHQsXG4gICAgY3NzUHJvcGVydHk6IHIgPSBlLnByb3AsXG4gICAgdGhlbWVLZXk6IG4sXG4gICAgdHJhbnNmb3JtOiBvXG4gIH0gPSBlLCBpID0gKHMpID0+IHtcbiAgICBpZiAoc1t0XSA9PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYyA9IHNbdF0sIGwgPSBzLnRoZW1lLCB1ID0gQW4obCwgbikgfHwge307XG4gICAgcmV0dXJuIE90KHMsIGMsIChtKSA9PiB7XG4gICAgICBsZXQgZyA9IG1uKHUsIG8sIG0pO1xuICAgICAgcmV0dXJuIG0gPT09IGcgJiYgdHlwZW9mIG0gPT0gXCJzdHJpbmdcIiAmJiAoZyA9IG1uKHUsIG8sIGAke3R9JHttID09PSBcImRlZmF1bHRcIiA/IFwiXCIgOiBlZShtKX1gLCBtKSksIHIgPT09ICExID8gZyA6IHtcbiAgICAgICAgW3JdOiBnXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gaS5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gICAgW3RdOiBNdFxuICB9IDoge30sIGkuZmlsdGVyUHJvcHMgPSBbdF0sIGk7XG59XG5mdW5jdGlvbiBSbChlKSB7XG4gIGNvbnN0IHQgPSB7fTtcbiAgcmV0dXJuIChyKSA9PiAodFtyXSA9PT0gdm9pZCAwICYmICh0W3JdID0gZShyKSksIHRbcl0pO1xufVxuY29uc3QgJGwgPSB7XG4gIG06IFwibWFyZ2luXCIsXG4gIHA6IFwicGFkZGluZ1wiXG59LCBQbCA9IHtcbiAgdDogXCJUb3BcIixcbiAgcjogXCJSaWdodFwiLFxuICBiOiBcIkJvdHRvbVwiLFxuICBsOiBcIkxlZnRcIixcbiAgeDogW1wiTGVmdFwiLCBcIlJpZ2h0XCJdLFxuICB5OiBbXCJUb3BcIiwgXCJCb3R0b21cIl1cbn0sIExpID0ge1xuICBtYXJnaW5YOiBcIm14XCIsXG4gIG1hcmdpblk6IFwibXlcIixcbiAgcGFkZGluZ1g6IFwicHhcIixcbiAgcGFkZGluZ1k6IFwicHlcIlxufSwga2wgPSBSbCgoZSkgPT4ge1xuICBpZiAoZS5sZW5ndGggPiAyKVxuICAgIGlmIChMaVtlXSlcbiAgICAgIGUgPSBMaVtlXTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gW2VdO1xuICBjb25zdCBbdCwgcl0gPSBlLnNwbGl0KFwiXCIpLCBuID0gJGxbdF0sIG8gPSBQbFtyXSB8fCBcIlwiO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvKSA/IG8ubWFwKChpKSA9PiBuICsgaSkgOiBbbiArIG9dO1xufSksIE5uID0gW1wibVwiLCBcIm10XCIsIFwibXJcIiwgXCJtYlwiLCBcIm1sXCIsIFwibXhcIiwgXCJteVwiLCBcIm1hcmdpblwiLCBcIm1hcmdpblRvcFwiLCBcIm1hcmdpblJpZ2h0XCIsIFwibWFyZ2luQm90dG9tXCIsIFwibWFyZ2luTGVmdFwiLCBcIm1hcmdpblhcIiwgXCJtYXJnaW5ZXCIsIFwibWFyZ2luSW5saW5lXCIsIFwibWFyZ2luSW5saW5lU3RhcnRcIiwgXCJtYXJnaW5JbmxpbmVFbmRcIiwgXCJtYXJnaW5CbG9ja1wiLCBcIm1hcmdpbkJsb2NrU3RhcnRcIiwgXCJtYXJnaW5CbG9ja0VuZFwiXSwgTW4gPSBbXCJwXCIsIFwicHRcIiwgXCJwclwiLCBcInBiXCIsIFwicGxcIiwgXCJweFwiLCBcInB5XCIsIFwicGFkZGluZ1wiLCBcInBhZGRpbmdUb3BcIiwgXCJwYWRkaW5nUmlnaHRcIiwgXCJwYWRkaW5nQm90dG9tXCIsIFwicGFkZGluZ0xlZnRcIiwgXCJwYWRkaW5nWFwiLCBcInBhZGRpbmdZXCIsIFwicGFkZGluZ0lubGluZVwiLCBcInBhZGRpbmdJbmxpbmVTdGFydFwiLCBcInBhZGRpbmdJbmxpbmVFbmRcIiwgXCJwYWRkaW5nQmxvY2tcIiwgXCJwYWRkaW5nQmxvY2tTdGFydFwiLCBcInBhZGRpbmdCbG9ja0VuZFwiXSwgQWwgPSBbLi4uTm4sIC4uLk1uXTtcbmZ1bmN0aW9uIF9yKGUsIHQsIHIsIG4pIHtcbiAgY29uc3QgbyA9IEFuKGUsIHQsICEwKSA/PyByO1xuICByZXR1cm4gdHlwZW9mIG8gPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgbyA9PSBcInN0cmluZ1wiID8gKGkpID0+IHR5cGVvZiBpID09IFwic3RyaW5nXCIgPyBpIDogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2YgaSAhPSBcIm51bWJlclwiICYmIGNvbnNvbGUuZXJyb3IoYE1VSTogRXhwZWN0ZWQgJHtufSBhcmd1bWVudCB0byBiZSBhIG51bWJlciBvciBhIHN0cmluZywgZ290ICR7aX0uYCksIHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyBgY2FsYygke2l9ICogJHtvfSlgIDogbyAqIGkpIDogQXJyYXkuaXNBcnJheShvKSA/IChpKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gaTtcbiAgICBjb25zdCBzID0gTWF0aC5hYnMoaSk7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChOdW1iZXIuaXNJbnRlZ2VyKHMpID8gcyA+IG8ubGVuZ3RoIC0gMSAmJiBjb25zb2xlLmVycm9yKFtgTVVJOiBUaGUgdmFsdWUgcHJvdmlkZWQgKCR7c30pIG92ZXJmbG93cy5gLCBgVGhlIHN1cHBvcnRlZCB2YWx1ZXMgYXJlOiAke0pTT04uc3RyaW5naWZ5KG8pfS5gLCBgJHtzfSA+ICR7by5sZW5ndGggLSAxfSwgeW91IG5lZWQgdG8gYWRkIHRoZSBtaXNzaW5nIHZhbHVlcy5gXS5qb2luKGBcbmApKSA6IGNvbnNvbGUuZXJyb3IoW2BNVUk6IFRoZSBcXGB0aGVtZS4ke3R9XFxgIGFycmF5IHR5cGUgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggbm9uIGludGVnZXIgdmFsdWVzLllvdSBzaG91bGQgZWl0aGVyIHVzZSBhbiBpbnRlZ2VyIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgYXMgaW5kZXgsIG9yIGRlZmluZSB0aGUgXFxgdGhlbWUuJHt0fVxcYCBhcyBhIG51bWJlci5gXS5qb2luKGBcbmApKSk7XG4gICAgY29uc3QgYyA9IG9bc107XG4gICAgcmV0dXJuIGkgPj0gMCA/IGMgOiB0eXBlb2YgYyA9PSBcIm51bWJlclwiID8gLWMgOiBgLSR7Y31gO1xuICB9IDogdHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiID8gbyA6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihbYE1VSTogVGhlIFxcYHRoZW1lLiR7dH1cXGAgdmFsdWUgKCR7b30pIGlzIGludmFsaWQuYCwgXCJJdCBzaG91bGQgYmUgYSBudW1iZXIsIGFuIGFycmF5IG9yIGEgZnVuY3Rpb24uXCJdLmpvaW4oYFxuYCkpLCAoKSA9PiB7XG4gIH0pO1xufVxuZnVuY3Rpb24ga28oZSkge1xuICByZXR1cm4gX3IoZSwgXCJzcGFjaW5nXCIsIDgsIFwic3BhY2luZ1wiKTtcbn1cbmZ1bmN0aW9uIGpyKGUsIHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgfHwgdCA9PSBudWxsID8gdCA6IGUodCk7XG59XG5mdW5jdGlvbiBObChlLCB0KSB7XG4gIHJldHVybiAocikgPT4gZS5yZWR1Y2UoKG4sIG8pID0+IChuW29dID0ganIodCwgciksIG4pLCB7fSk7XG59XG5mdW5jdGlvbiBNbChlLCB0LCByLCBuKSB7XG4gIGlmICghdC5pbmNsdWRlcyhyKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgbyA9IGtsKHIpLCBpID0gTmwobywgbiksIHMgPSBlW3JdO1xuICByZXR1cm4gT3QoZSwgcywgaSk7XG59XG5mdW5jdGlvbiBMYShlLCB0KSB7XG4gIGNvbnN0IHIgPSBrbyhlLnRoZW1lKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLm1hcCgobikgPT4gTWwoZSwgdCwgbiwgcikpLnJlZHVjZSh2ciwge30pO1xufVxuZnVuY3Rpb24ga2UoZSkge1xuICByZXR1cm4gTGEoZSwgTm4pO1xufVxua2UucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gTm4ucmVkdWNlKChlLCB0KSA9PiAoZVt0XSA9IE10LCBlKSwge30pIDoge307XG5rZS5maWx0ZXJQcm9wcyA9IE5uO1xuZnVuY3Rpb24gQWUoZSkge1xuICByZXR1cm4gTGEoZSwgTW4pO1xufVxuQWUucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gTW4ucmVkdWNlKChlLCB0KSA9PiAoZVt0XSA9IE10LCBlKSwge30pIDoge307XG5BZS5maWx0ZXJQcm9wcyA9IE1uO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEFsLnJlZHVjZSgoZSwgdCkgPT4gKGVbdF0gPSBNdCwgZSksIHt9KTtcbmZ1bmN0aW9uIEJhKGUgPSA4LCB0ID0ga28oe1xuICBzcGFjaW5nOiBlXG59KSkge1xuICBpZiAoZS5tdWkpXG4gICAgcmV0dXJuIGU7XG4gIGNvbnN0IHIgPSAoLi4ubikgPT4gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAobi5sZW5ndGggPD0gNCB8fCBjb25zb2xlLmVycm9yKGBNVUk6IFRvbyBtYW55IGFyZ3VtZW50cyBwcm92aWRlZCwgZXhwZWN0ZWQgYmV0d2VlbiAwIGFuZCA0LCBnb3QgJHtuLmxlbmd0aH1gKSksIChuLmxlbmd0aCA9PT0gMCA/IFsxXSA6IG4pLm1hcCgoaSkgPT4ge1xuICAgIGNvbnN0IHMgPSB0KGkpO1xuICAgIHJldHVybiB0eXBlb2YgcyA9PSBcIm51bWJlclwiID8gYCR7c31weGAgOiBzO1xuICB9KS5qb2luKFwiIFwiKSk7XG4gIHJldHVybiByLm11aSA9ICEwLCByO1xufVxuZnVuY3Rpb24gSW4oLi4uZSkge1xuICBjb25zdCB0ID0gZS5yZWR1Y2UoKG4sIG8pID0+IChvLmZpbHRlclByb3BzLmZvckVhY2goKGkpID0+IHtcbiAgICBuW2ldID0gbztcbiAgfSksIG4pLCB7fSksIHIgPSAobikgPT4gT2JqZWN0LmtleXMobikucmVkdWNlKChvLCBpKSA9PiB0W2ldID8gdnIobywgdFtpXShuKSkgOiBvLCB7fSk7XG4gIHJldHVybiByLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGUucmVkdWNlKChuLCBvKSA9PiBPYmplY3QuYXNzaWduKG4sIG8ucHJvcFR5cGVzKSwge30pIDoge30sIHIuZmlsdGVyUHJvcHMgPSBlLnJlZHVjZSgobiwgbykgPT4gbi5jb25jYXQoby5maWx0ZXJQcm9wcyksIFtdKSwgcjtcbn1cbmZ1bmN0aW9uIG90KGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlICE9IFwibnVtYmVyXCIgPyBlIDogYCR7ZX1weCBzb2xpZGA7XG59XG5mdW5jdGlvbiBsdChlLCB0KSB7XG4gIHJldHVybiBfZSh7XG4gICAgcHJvcDogZSxcbiAgICB0aGVtZUtleTogXCJib3JkZXJzXCIsXG4gICAgdHJhbnNmb3JtOiB0XG4gIH0pO1xufVxuY29uc3QgSWwgPSBsdChcImJvcmRlclwiLCBvdCksIF9sID0gbHQoXCJib3JkZXJUb3BcIiwgb3QpLCBqbCA9IGx0KFwiYm9yZGVyUmlnaHRcIiwgb3QpLCBEbCA9IGx0KFwiYm9yZGVyQm90dG9tXCIsIG90KSwgTGwgPSBsdChcImJvcmRlckxlZnRcIiwgb3QpLCBCbCA9IGx0KFwiYm9yZGVyQ29sb3JcIiksIFZsID0gbHQoXCJib3JkZXJUb3BDb2xvclwiKSwgRmwgPSBsdChcImJvcmRlclJpZ2h0Q29sb3JcIiksIHpsID0gbHQoXCJib3JkZXJCb3R0b21Db2xvclwiKSwgV2wgPSBsdChcImJvcmRlckxlZnRDb2xvclwiKSwgVWwgPSBsdChcIm91dGxpbmVcIiwgb3QpLCBZbCA9IGx0KFwib3V0bGluZUNvbG9yXCIpLCBfbiA9IChlKSA9PiB7XG4gIGlmIChlLmJvcmRlclJhZGl1cyAhPT0gdm9pZCAwICYmIGUuYm9yZGVyUmFkaXVzICE9PSBudWxsKSB7XG4gICAgY29uc3QgdCA9IF9yKGUudGhlbWUsIFwic2hhcGUuYm9yZGVyUmFkaXVzXCIsIDQsIFwiYm9yZGVyUmFkaXVzXCIpLCByID0gKG4pID0+ICh7XG4gICAgICBib3JkZXJSYWRpdXM6IGpyKHQsIG4pXG4gICAgfSk7XG4gICAgcmV0dXJuIE90KGUsIGUuYm9yZGVyUmFkaXVzLCByKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5fbi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIGJvcmRlclJhZGl1czogTXRcbn0gOiB7fTtcbl9uLmZpbHRlclByb3BzID0gW1wiYm9yZGVyUmFkaXVzXCJdO1xuSW4oSWwsIF9sLCBqbCwgRGwsIExsLCBCbCwgVmwsIEZsLCB6bCwgV2wsIF9uLCBVbCwgWWwpO1xuY29uc3Qgam4gPSAoZSkgPT4ge1xuICBpZiAoZS5nYXAgIT09IHZvaWQgMCAmJiBlLmdhcCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHQgPSBfcihlLnRoZW1lLCBcInNwYWNpbmdcIiwgOCwgXCJnYXBcIiksIHIgPSAobikgPT4gKHtcbiAgICAgIGdhcDoganIodCwgbilcbiAgICB9KTtcbiAgICByZXR1cm4gT3QoZSwgZS5nYXAsIHIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmpuLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgZ2FwOiBNdFxufSA6IHt9O1xuam4uZmlsdGVyUHJvcHMgPSBbXCJnYXBcIl07XG5jb25zdCBEbiA9IChlKSA9PiB7XG4gIGlmIChlLmNvbHVtbkdhcCAhPT0gdm9pZCAwICYmIGUuY29sdW1uR2FwICE9PSBudWxsKSB7XG4gICAgY29uc3QgdCA9IF9yKGUudGhlbWUsIFwic3BhY2luZ1wiLCA4LCBcImNvbHVtbkdhcFwiKSwgciA9IChuKSA9PiAoe1xuICAgICAgY29sdW1uR2FwOiBqcih0LCBuKVxuICAgIH0pO1xuICAgIHJldHVybiBPdChlLCBlLmNvbHVtbkdhcCwgcik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuRG4ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICBjb2x1bW5HYXA6IE10XG59IDoge307XG5Ebi5maWx0ZXJQcm9wcyA9IFtcImNvbHVtbkdhcFwiXTtcbmNvbnN0IExuID0gKGUpID0+IHtcbiAgaWYgKGUucm93R2FwICE9PSB2b2lkIDAgJiYgZS5yb3dHYXAgIT09IG51bGwpIHtcbiAgICBjb25zdCB0ID0gX3IoZS50aGVtZSwgXCJzcGFjaW5nXCIsIDgsIFwicm93R2FwXCIpLCByID0gKG4pID0+ICh7XG4gICAgICByb3dHYXA6IGpyKHQsIG4pXG4gICAgfSk7XG4gICAgcmV0dXJuIE90KGUsIGUucm93R2FwLCByKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5Mbi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIHJvd0dhcDogTXRcbn0gOiB7fTtcbkxuLmZpbHRlclByb3BzID0gW1wicm93R2FwXCJdO1xuY29uc3QgSGwgPSBfZSh7XG4gIHByb3A6IFwiZ3JpZENvbHVtblwiXG59KSwgcWwgPSBfZSh7XG4gIHByb3A6IFwiZ3JpZFJvd1wiXG59KSwgR2wgPSBfZSh7XG4gIHByb3A6IFwiZ3JpZEF1dG9GbG93XCJcbn0pLCBLbCA9IF9lKHtcbiAgcHJvcDogXCJncmlkQXV0b0NvbHVtbnNcIlxufSksIFhsID0gX2Uoe1xuICBwcm9wOiBcImdyaWRBdXRvUm93c1wiXG59KSwgSmwgPSBfZSh7XG4gIHByb3A6IFwiZ3JpZFRlbXBsYXRlQ29sdW1uc1wiXG59KSwgUWwgPSBfZSh7XG4gIHByb3A6IFwiZ3JpZFRlbXBsYXRlUm93c1wiXG59KSwgWmwgPSBfZSh7XG4gIHByb3A6IFwiZ3JpZFRlbXBsYXRlQXJlYXNcIlxufSksIGV1ID0gX2Uoe1xuICBwcm9wOiBcImdyaWRBcmVhXCJcbn0pO1xuSW4oam4sIERuLCBMbiwgSGwsIHFsLCBHbCwgS2wsIFhsLCBKbCwgUWwsIFpsLCBldSk7XG5mdW5jdGlvbiBKdChlLCB0KSB7XG4gIHJldHVybiB0ID09PSBcImdyZXlcIiA/IHQgOiBlO1xufVxuY29uc3QgdHUgPSBfZSh7XG4gIHByb3A6IFwiY29sb3JcIixcbiAgdGhlbWVLZXk6IFwicGFsZXR0ZVwiLFxuICB0cmFuc2Zvcm06IEp0XG59KSwgcnUgPSBfZSh7XG4gIHByb3A6IFwiYmdjb2xvclwiLFxuICBjc3NQcm9wZXJ0eTogXCJiYWNrZ3JvdW5kQ29sb3JcIixcbiAgdGhlbWVLZXk6IFwicGFsZXR0ZVwiLFxuICB0cmFuc2Zvcm06IEp0XG59KSwgbnUgPSBfZSh7XG4gIHByb3A6IFwiYmFja2dyb3VuZENvbG9yXCIsXG4gIHRoZW1lS2V5OiBcInBhbGV0dGVcIixcbiAgdHJhbnNmb3JtOiBKdFxufSk7XG5Jbih0dSwgcnUsIG51KTtcbmZ1bmN0aW9uIFplKGUpIHtcbiAgcmV0dXJuIGUgPD0gMSAmJiBlICE9PSAwID8gYCR7ZSAqIDEwMH0lYCA6IGU7XG59XG5jb25zdCBvdSA9IF9lKHtcbiAgcHJvcDogXCJ3aWR0aFwiLFxuICB0cmFuc2Zvcm06IFplXG59KSwgQW8gPSAoZSkgPT4ge1xuICBpZiAoZS5tYXhXaWR0aCAhPT0gdm9pZCAwICYmIGUubWF4V2lkdGggIT09IG51bGwpIHtcbiAgICBjb25zdCB0ID0gKHIpID0+IHtcbiAgICAgIHZhciBvLCBpLCBzLCBjLCBsO1xuICAgICAgY29uc3QgbiA9ICgocyA9IChpID0gKG8gPSBlLnRoZW1lKSA9PSBudWxsID8gdm9pZCAwIDogby5icmVha3BvaW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IGkudmFsdWVzKSA9PSBudWxsID8gdm9pZCAwIDogc1tyXSkgfHwga25bcl07XG4gICAgICByZXR1cm4gbiA/ICgobCA9IChjID0gZS50aGVtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGMuYnJlYWtwb2ludHMpID09IG51bGwgPyB2b2lkIDAgOiBsLnVuaXQpICE9PSBcInB4XCIgPyB7XG4gICAgICAgIG1heFdpZHRoOiBgJHtufSR7ZS50aGVtZS5icmVha3BvaW50cy51bml0fWBcbiAgICAgIH0gOiB7XG4gICAgICAgIG1heFdpZHRoOiBuXG4gICAgICB9IDoge1xuICAgICAgICBtYXhXaWR0aDogWmUocilcbiAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gT3QoZSwgZS5tYXhXaWR0aCwgdCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuQW8uZmlsdGVyUHJvcHMgPSBbXCJtYXhXaWR0aFwiXTtcbmNvbnN0IGl1ID0gX2Uoe1xuICBwcm9wOiBcIm1pbldpZHRoXCIsXG4gIHRyYW5zZm9ybTogWmVcbn0pLCBhdSA9IF9lKHtcbiAgcHJvcDogXCJoZWlnaHRcIixcbiAgdHJhbnNmb3JtOiBaZVxufSksIHN1ID0gX2Uoe1xuICBwcm9wOiBcIm1heEhlaWdodFwiLFxuICB0cmFuc2Zvcm06IFplXG59KSwgY3UgPSBfZSh7XG4gIHByb3A6IFwibWluSGVpZ2h0XCIsXG4gIHRyYW5zZm9ybTogWmVcbn0pO1xuX2Uoe1xuICBwcm9wOiBcInNpemVcIixcbiAgY3NzUHJvcGVydHk6IFwid2lkdGhcIixcbiAgdHJhbnNmb3JtOiBaZVxufSk7XG5fZSh7XG4gIHByb3A6IFwic2l6ZVwiLFxuICBjc3NQcm9wZXJ0eTogXCJoZWlnaHRcIixcbiAgdHJhbnNmb3JtOiBaZVxufSk7XG5jb25zdCBsdSA9IF9lKHtcbiAgcHJvcDogXCJib3hTaXppbmdcIlxufSk7XG5JbihvdSwgQW8sIGl1LCBhdSwgc3UsIGN1LCBsdSk7XG5jb25zdCBEciA9IHtcbiAgLy8gYm9yZGVyc1xuICBib3JkZXI6IHtcbiAgICB0aGVtZUtleTogXCJib3JkZXJzXCIsXG4gICAgdHJhbnNmb3JtOiBvdFxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICB0aGVtZUtleTogXCJib3JkZXJzXCIsXG4gICAgdHJhbnNmb3JtOiBvdFxuICB9LFxuICBib3JkZXJSaWdodDoge1xuICAgIHRoZW1lS2V5OiBcImJvcmRlcnNcIixcbiAgICB0cmFuc2Zvcm06IG90XG4gIH0sXG4gIGJvcmRlckJvdHRvbToge1xuICAgIHRoZW1lS2V5OiBcImJvcmRlcnNcIixcbiAgICB0cmFuc2Zvcm06IG90XG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICB0aGVtZUtleTogXCJib3JkZXJzXCIsXG4gICAgdHJhbnNmb3JtOiBvdFxuICB9LFxuICBib3JkZXJDb2xvcjoge1xuICAgIHRoZW1lS2V5OiBcInBhbGV0dGVcIlxuICB9LFxuICBib3JkZXJUb3BDb2xvcjoge1xuICAgIHRoZW1lS2V5OiBcInBhbGV0dGVcIlxuICB9LFxuICBib3JkZXJSaWdodENvbG9yOiB7XG4gICAgdGhlbWVLZXk6IFwicGFsZXR0ZVwiXG4gIH0sXG4gIGJvcmRlckJvdHRvbUNvbG9yOiB7XG4gICAgdGhlbWVLZXk6IFwicGFsZXR0ZVwiXG4gIH0sXG4gIGJvcmRlckxlZnRDb2xvcjoge1xuICAgIHRoZW1lS2V5OiBcInBhbGV0dGVcIlxuICB9LFxuICBvdXRsaW5lOiB7XG4gICAgdGhlbWVLZXk6IFwiYm9yZGVyc1wiLFxuICAgIHRyYW5zZm9ybTogb3RcbiAgfSxcbiAgb3V0bGluZUNvbG9yOiB7XG4gICAgdGhlbWVLZXk6IFwicGFsZXR0ZVwiXG4gIH0sXG4gIGJvcmRlclJhZGl1czoge1xuICAgIHRoZW1lS2V5OiBcInNoYXBlLmJvcmRlclJhZGl1c1wiLFxuICAgIHN0eWxlOiBfblxuICB9LFxuICAvLyBwYWxldHRlXG4gIGNvbG9yOiB7XG4gICAgdGhlbWVLZXk6IFwicGFsZXR0ZVwiLFxuICAgIHRyYW5zZm9ybTogSnRcbiAgfSxcbiAgYmdjb2xvcjoge1xuICAgIHRoZW1lS2V5OiBcInBhbGV0dGVcIixcbiAgICBjc3NQcm9wZXJ0eTogXCJiYWNrZ3JvdW5kQ29sb3JcIixcbiAgICB0cmFuc2Zvcm06IEp0XG4gIH0sXG4gIGJhY2tncm91bmRDb2xvcjoge1xuICAgIHRoZW1lS2V5OiBcInBhbGV0dGVcIixcbiAgICB0cmFuc2Zvcm06IEp0XG4gIH0sXG4gIC8vIHNwYWNpbmdcbiAgcDoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwdDoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwcjoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwYjoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwbDoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBweDoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBweToge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwYWRkaW5nOiB7XG4gICAgc3R5bGU6IEFlXG4gIH0sXG4gIHBhZGRpbmdUb3A6IHtcbiAgICBzdHlsZTogQWVcbiAgfSxcbiAgcGFkZGluZ1JpZ2h0OiB7XG4gICAgc3R5bGU6IEFlXG4gIH0sXG4gIHBhZGRpbmdCb3R0b206IHtcbiAgICBzdHlsZTogQWVcbiAgfSxcbiAgcGFkZGluZ0xlZnQ6IHtcbiAgICBzdHlsZTogQWVcbiAgfSxcbiAgcGFkZGluZ1g6IHtcbiAgICBzdHlsZTogQWVcbiAgfSxcbiAgcGFkZGluZ1k6IHtcbiAgICBzdHlsZTogQWVcbiAgfSxcbiAgcGFkZGluZ0lubGluZToge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwYWRkaW5nSW5saW5lU3RhcnQ6IHtcbiAgICBzdHlsZTogQWVcbiAgfSxcbiAgcGFkZGluZ0lubGluZUVuZDoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwYWRkaW5nQmxvY2s6IHtcbiAgICBzdHlsZTogQWVcbiAgfSxcbiAgcGFkZGluZ0Jsb2NrU3RhcnQ6IHtcbiAgICBzdHlsZTogQWVcbiAgfSxcbiAgcGFkZGluZ0Jsb2NrRW5kOiB7XG4gICAgc3R5bGU6IEFlXG4gIH0sXG4gIG06IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbXQ6IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbXI6IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbWI6IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbWw6IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbXg6IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbXk6IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbWFyZ2luOiB7XG4gICAgc3R5bGU6IGtlXG4gIH0sXG4gIG1hcmdpblRvcDoge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBtYXJnaW5SaWdodDoge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBtYXJnaW5Cb3R0b206IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbWFyZ2luTGVmdDoge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBtYXJnaW5YOiB7XG4gICAgc3R5bGU6IGtlXG4gIH0sXG4gIG1hcmdpblk6IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbWFyZ2luSW5saW5lOiB7XG4gICAgc3R5bGU6IGtlXG4gIH0sXG4gIG1hcmdpbklubGluZVN0YXJ0OiB7XG4gICAgc3R5bGU6IGtlXG4gIH0sXG4gIG1hcmdpbklubGluZUVuZDoge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBtYXJnaW5CbG9jazoge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBtYXJnaW5CbG9ja1N0YXJ0OiB7XG4gICAgc3R5bGU6IGtlXG4gIH0sXG4gIG1hcmdpbkJsb2NrRW5kOiB7XG4gICAgc3R5bGU6IGtlXG4gIH0sXG4gIC8vIGRpc3BsYXlcbiAgZGlzcGxheVByaW50OiB7XG4gICAgY3NzUHJvcGVydHk6ICExLFxuICAgIHRyYW5zZm9ybTogKGUpID0+ICh7XG4gICAgICBcIkBtZWRpYSBwcmludFwiOiB7XG4gICAgICAgIGRpc3BsYXk6IGVcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBkaXNwbGF5OiB7fSxcbiAgb3ZlcmZsb3c6IHt9LFxuICB0ZXh0T3ZlcmZsb3c6IHt9LFxuICB2aXNpYmlsaXR5OiB7fSxcbiAgd2hpdGVTcGFjZToge30sXG4gIC8vIGZsZXhib3hcbiAgZmxleEJhc2lzOiB7fSxcbiAgZmxleERpcmVjdGlvbjoge30sXG4gIGZsZXhXcmFwOiB7fSxcbiAganVzdGlmeUNvbnRlbnQ6IHt9LFxuICBhbGlnbkl0ZW1zOiB7fSxcbiAgYWxpZ25Db250ZW50OiB7fSxcbiAgb3JkZXI6IHt9LFxuICBmbGV4OiB7fSxcbiAgZmxleEdyb3c6IHt9LFxuICBmbGV4U2hyaW5rOiB7fSxcbiAgYWxpZ25TZWxmOiB7fSxcbiAganVzdGlmeUl0ZW1zOiB7fSxcbiAganVzdGlmeVNlbGY6IHt9LFxuICAvLyBncmlkXG4gIGdhcDoge1xuICAgIHN0eWxlOiBqblxuICB9LFxuICByb3dHYXA6IHtcbiAgICBzdHlsZTogTG5cbiAgfSxcbiAgY29sdW1uR2FwOiB7XG4gICAgc3R5bGU6IERuXG4gIH0sXG4gIGdyaWRDb2x1bW46IHt9LFxuICBncmlkUm93OiB7fSxcbiAgZ3JpZEF1dG9GbG93OiB7fSxcbiAgZ3JpZEF1dG9Db2x1bW5zOiB7fSxcbiAgZ3JpZEF1dG9Sb3dzOiB7fSxcbiAgZ3JpZFRlbXBsYXRlQ29sdW1uczoge30sXG4gIGdyaWRUZW1wbGF0ZVJvd3M6IHt9LFxuICBncmlkVGVtcGxhdGVBcmVhczoge30sXG4gIGdyaWRBcmVhOiB7fSxcbiAgLy8gcG9zaXRpb25zXG4gIHBvc2l0aW9uOiB7fSxcbiAgekluZGV4OiB7XG4gICAgdGhlbWVLZXk6IFwiekluZGV4XCJcbiAgfSxcbiAgdG9wOiB7fSxcbiAgcmlnaHQ6IHt9LFxuICBib3R0b206IHt9LFxuICBsZWZ0OiB7fSxcbiAgLy8gc2hhZG93c1xuICBib3hTaGFkb3c6IHtcbiAgICB0aGVtZUtleTogXCJzaGFkb3dzXCJcbiAgfSxcbiAgLy8gc2l6aW5nXG4gIHdpZHRoOiB7XG4gICAgdHJhbnNmb3JtOiBaZVxuICB9LFxuICBtYXhXaWR0aDoge1xuICAgIHN0eWxlOiBBb1xuICB9LFxuICBtaW5XaWR0aDoge1xuICAgIHRyYW5zZm9ybTogWmVcbiAgfSxcbiAgaGVpZ2h0OiB7XG4gICAgdHJhbnNmb3JtOiBaZVxuICB9LFxuICBtYXhIZWlnaHQ6IHtcbiAgICB0cmFuc2Zvcm06IFplXG4gIH0sXG4gIG1pbkhlaWdodDoge1xuICAgIHRyYW5zZm9ybTogWmVcbiAgfSxcbiAgYm94U2l6aW5nOiB7fSxcbiAgLy8gdHlwb2dyYXBoeVxuICBmb250OiB7XG4gICAgdGhlbWVLZXk6IFwiZm9udFwiXG4gIH0sXG4gIGZvbnRGYW1pbHk6IHtcbiAgICB0aGVtZUtleTogXCJ0eXBvZ3JhcGh5XCJcbiAgfSxcbiAgZm9udFNpemU6IHtcbiAgICB0aGVtZUtleTogXCJ0eXBvZ3JhcGh5XCJcbiAgfSxcbiAgZm9udFN0eWxlOiB7XG4gICAgdGhlbWVLZXk6IFwidHlwb2dyYXBoeVwiXG4gIH0sXG4gIGZvbnRXZWlnaHQ6IHtcbiAgICB0aGVtZUtleTogXCJ0eXBvZ3JhcGh5XCJcbiAgfSxcbiAgbGV0dGVyU3BhY2luZzoge30sXG4gIHRleHRUcmFuc2Zvcm06IHt9LFxuICBsaW5lSGVpZ2h0OiB7fSxcbiAgdGV4dEFsaWduOiB7fSxcbiAgdHlwb2dyYXBoeToge1xuICAgIGNzc1Byb3BlcnR5OiAhMSxcbiAgICB0aGVtZUtleTogXCJ0eXBvZ3JhcGh5XCJcbiAgfVxufTtcbmZ1bmN0aW9uIHV1KC4uLmUpIHtcbiAgY29uc3QgdCA9IGUucmVkdWNlKChuLCBvKSA9PiBuLmNvbmNhdChPYmplY3Qua2V5cyhvKSksIFtdKSwgciA9IG5ldyBTZXQodCk7XG4gIHJldHVybiBlLmV2ZXJ5KChuKSA9PiByLnNpemUgPT09IE9iamVjdC5rZXlzKG4pLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBmdShlLCB0KSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKHQpIDogZTtcbn1cbmZ1bmN0aW9uIGR1KCkge1xuICBmdW5jdGlvbiBlKHIsIG4sIG8sIGkpIHtcbiAgICBjb25zdCBzID0ge1xuICAgICAgW3JdOiBuLFxuICAgICAgdGhlbWU6IG9cbiAgICB9LCBjID0gaVtyXTtcbiAgICBpZiAoIWMpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBbcl06IG5cbiAgICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgY3NzUHJvcGVydHk6IGwgPSByLFxuICAgICAgdGhlbWVLZXk6IHUsXG4gICAgICB0cmFuc2Zvcm06IHAsXG4gICAgICBzdHlsZTogbVxuICAgIH0gPSBjO1xuICAgIGlmIChuID09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAodSA9PT0gXCJ0eXBvZ3JhcGh5XCIgJiYgbiA9PT0gXCJpbmhlcml0XCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBbcl06IG5cbiAgICAgIH07XG4gICAgY29uc3QgZyA9IEFuKG8sIHUpIHx8IHt9O1xuICAgIHJldHVybiBtID8gbShzKSA6IE90KHMsIG4sICh5KSA9PiB7XG4gICAgICBsZXQgZiA9IG1uKGcsIHAsIHkpO1xuICAgICAgcmV0dXJuIHkgPT09IGYgJiYgdHlwZW9mIHkgPT0gXCJzdHJpbmdcIiAmJiAoZiA9IG1uKGcsIHAsIGAke3J9JHt5ID09PSBcImRlZmF1bHRcIiA/IFwiXCIgOiBlZSh5KX1gLCB5KSksIGwgPT09ICExID8gZiA6IHtcbiAgICAgICAgW2xdOiBmXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHQocikge1xuICAgIGNvbnN0IHtcbiAgICAgIHN4OiBuLFxuICAgICAgdGhlbWU6IG8gPSB7fVxuICAgIH0gPSByIHx8IHt9O1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGkgPSBvLnVuc3RhYmxlX3N4Q29uZmlnID8/IERyO1xuICAgIGZ1bmN0aW9uIHMoYykge1xuICAgICAgbGV0IGwgPSBjO1xuICAgICAgaWYgKHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgbCA9IGMobyk7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgYyAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gYztcbiAgICAgIGlmICghbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCB1ID0gd2woby5icmVha3BvaW50cyksIHAgPSBPYmplY3Qua2V5cyh1KTtcbiAgICAgIGxldCBtID0gdTtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhsKS5mb3JFYWNoKChnKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBmdShsW2ddLCBvKTtcbiAgICAgICAgaWYgKHggIT0gbnVsbClcbiAgICAgICAgICBpZiAodHlwZW9mIHggPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIGlmIChpW2ddKVxuICAgICAgICAgICAgICBtID0gdnIobSwgZShnLCB4LCBvLCBpKSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgeSA9IE90KHtcbiAgICAgICAgICAgICAgICB0aGVtZTogb1xuICAgICAgICAgICAgICB9LCB4LCAoZikgPT4gKHtcbiAgICAgICAgICAgICAgICBbZ106IGZcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB1dSh5LCB4KSA/IG1bZ10gPSB0KHtcbiAgICAgICAgICAgICAgICBzeDogeCxcbiAgICAgICAgICAgICAgICB0aGVtZTogb1xuICAgICAgICAgICAgICB9KSA6IG0gPSB2cihtLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBtID0gdnIobSwgZShnLCB4LCBvLCBpKSk7XG4gICAgICB9KSwgdmwobywgT2wocCwgbSkpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShuKSA/IG4ubWFwKHMpIDogcyhuKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmNvbnN0IEF0ID0gZHUoKTtcbkF0LmZpbHRlclByb3BzID0gW1wic3hcIl07XG5mdW5jdGlvbiBwdShlLCB0KSB7XG4gIHZhciBuO1xuICBjb25zdCByID0gdGhpcztcbiAgaWYgKHIudmFycykge1xuICAgIGlmICghKChuID0gci5jb2xvclNjaGVtZXMpICE9IG51bGwgJiYgbltlXSkgfHwgdHlwZW9mIHIuZ2V0Q29sb3JTY2hlbWVTZWxlY3RvciAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4ge307XG4gICAgbGV0IG8gPSByLmdldENvbG9yU2NoZW1lU2VsZWN0b3IoZSk7XG4gICAgcmV0dXJuIG8gPT09IFwiJlwiID8gdCA6ICgoby5pbmNsdWRlcyhcImRhdGEtXCIpIHx8IG8uaW5jbHVkZXMoXCIuXCIpKSAmJiAobyA9IGAqOndoZXJlKCR7by5yZXBsYWNlKC9cXHMqJiQvLCBcIlwiKX0pICZgKSwge1xuICAgICAgW29dOiB0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHIucGFsZXR0ZS5tb2RlID09PSBlID8gdCA6IHt9O1xufVxuZnVuY3Rpb24gTm8oZSA9IHt9LCAuLi50KSB7XG4gIGNvbnN0IHtcbiAgICBicmVha3BvaW50czogciA9IHt9LFxuICAgIHBhbGV0dGU6IG4gPSB7fSxcbiAgICBzcGFjaW5nOiBvLFxuICAgIHNoYXBlOiBpID0ge30sXG4gICAgLi4uc1xuICB9ID0gZSwgYyA9IGJsKHIpLCBsID0gQmEobyk7XG4gIGxldCB1ID0gdHQoe1xuICAgIGJyZWFrcG9pbnRzOiBjLFxuICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICBjb21wb25lbnRzOiB7fSxcbiAgICAvLyBJbmplY3QgY29tcG9uZW50IGRlZmluaXRpb25zLlxuICAgIHBhbGV0dGU6IHtcbiAgICAgIG1vZGU6IFwibGlnaHRcIixcbiAgICAgIC4uLm5cbiAgICB9LFxuICAgIHNwYWNpbmc6IGwsXG4gICAgc2hhcGU6IHtcbiAgICAgIC4uLkNsLFxuICAgICAgLi4uaVxuICAgIH1cbiAgfSwgcyk7XG4gIHJldHVybiB1ID0gRWwodSksIHUuYXBwbHlTdHlsZXMgPSBwdSwgdSA9IHQucmVkdWNlKChwLCBtKSA9PiB0dChwLCBtKSwgdSksIHUudW5zdGFibGVfc3hDb25maWcgPSB7XG4gICAgLi4uRHIsXG4gICAgLi4ucyA9PSBudWxsID8gdm9pZCAwIDogcy51bnN0YWJsZV9zeENvbmZpZ1xuICB9LCB1LnVuc3RhYmxlX3N4ID0gZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBBdCh7XG4gICAgICBzeDogbSxcbiAgICAgIHRoZW1lOiB0aGlzXG4gICAgfSk7XG4gIH0sIHU7XG59XG5mdW5jdGlvbiBtdShlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhlKS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiBWYShlID0gbnVsbCkge1xuICBjb25zdCB0ID0gQy51c2VDb250ZXh0KE1yKTtcbiAgcmV0dXJuICF0IHx8IG11KHQpID8gZSA6IHQ7XG59XG5jb25zdCBodSA9IE5vKCk7XG5mdW5jdGlvbiBGYShlID0gaHUpIHtcbiAgcmV0dXJuIFZhKGUpO1xufVxuY29uc3QgZ3UgPSAoZSkgPT4ge1xuICB2YXIgbjtcbiAgY29uc3QgdCA9IHtcbiAgICBzeXN0ZW1Qcm9wczoge30sXG4gICAgb3RoZXJQcm9wczoge31cbiAgfSwgciA9ICgobiA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUudGhlbWUpID09IG51bGwgPyB2b2lkIDAgOiBuLnVuc3RhYmxlX3N4Q29uZmlnKSA/PyBEcjtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKG8pID0+IHtcbiAgICByW29dID8gdC5zeXN0ZW1Qcm9wc1tvXSA9IGVbb10gOiB0Lm90aGVyUHJvcHNbb10gPSBlW29dO1xuICB9KSwgdDtcbn07XG5mdW5jdGlvbiB6YShlKSB7XG4gIGNvbnN0IHtcbiAgICBzeDogdCxcbiAgICAuLi5yXG4gIH0gPSBlLCB7XG4gICAgc3lzdGVtUHJvcHM6IG4sXG4gICAgb3RoZXJQcm9wczogb1xuICB9ID0gZ3Uocik7XG4gIGxldCBpO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/IGkgPSBbbiwgLi4udF0gOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyBpID0gKC4uLnMpID0+IHtcbiAgICBjb25zdCBjID0gdCguLi5zKTtcbiAgICByZXR1cm4gZ3QoYykgPyB7XG4gICAgICAuLi5uLFxuICAgICAgLi4uY1xuICAgIH0gOiBuO1xuICB9IDogaSA9IHtcbiAgICAuLi5uLFxuICAgIC4uLnRcbiAgfSwge1xuICAgIC4uLm8sXG4gICAgc3g6IGlcbiAgfTtcbn1cbmNvbnN0IEJpID0gKGUpID0+IGUsIHl1ID0gKCkgPT4ge1xuICBsZXQgZSA9IEJpO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyZSh0KSB7XG4gICAgICBlID0gdDtcbiAgICB9LFxuICAgIGdlbmVyYXRlKHQpIHtcbiAgICAgIHJldHVybiBlKHQpO1xuICAgIH0sXG4gICAgcmVzZXQoKSB7XG4gICAgICBlID0gQmk7XG4gICAgfVxuICB9O1xufSwgV2EgPSB5dSgpO1xuZnVuY3Rpb24gVWEoZSkge1xuICB2YXIgdCwgciwgbiA9IFwiXCI7XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwibnVtYmVyXCIpIG4gKz0gZTtcbiAgZWxzZSBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIikgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICB2YXIgbyA9IGUubGVuZ3RoO1xuICAgIGZvciAodCA9IDA7IHQgPCBvOyB0KyspIGVbdF0gJiYgKHIgPSBVYShlW3RdKSkgJiYgKG4gJiYgKG4gKz0gXCIgXCIpLCBuICs9IHIpO1xuICB9IGVsc2UgZm9yIChyIGluIGUpIGVbcl0gJiYgKG4gJiYgKG4gKz0gXCIgXCIpLCBuICs9IHIpO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHNlKCkge1xuICBmb3IgKHZhciBlLCB0LCByID0gMCwgbiA9IFwiXCIsIG8gPSBhcmd1bWVudHMubGVuZ3RoOyByIDwgbzsgcisrKSAoZSA9IGFyZ3VtZW50c1tyXSkgJiYgKHQgPSBVYShlKSkgJiYgKG4gJiYgKG4gKz0gXCIgXCIpLCBuICs9IHQpO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGJ1KGUgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdGhlbWVJZDogdCxcbiAgICBkZWZhdWx0VGhlbWU6IHIsXG4gICAgZGVmYXVsdENsYXNzTmFtZTogbiA9IFwiTXVpQm94LXJvb3RcIixcbiAgICBnZW5lcmF0ZUNsYXNzTmFtZTogb1xuICB9ID0gZSwgaSA9IGphKFwiZGl2XCIsIHtcbiAgICBzaG91bGRGb3J3YXJkUHJvcDogKGMpID0+IGMgIT09IFwidGhlbWVcIiAmJiBjICE9PSBcInN4XCIgJiYgYyAhPT0gXCJhc1wiXG4gIH0pKEF0KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24obCwgdSkge1xuICAgIGNvbnN0IHAgPSBGYShyKSwge1xuICAgICAgY2xhc3NOYW1lOiBtLFxuICAgICAgY29tcG9uZW50OiBnID0gXCJkaXZcIixcbiAgICAgIC4uLnhcbiAgICB9ID0gemEobCk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChpLCB7XG4gICAgICBhczogZyxcbiAgICAgIHJlZjogdSxcbiAgICAgIGNsYXNzTmFtZTogc2UobSwgbyA/IG8obikgOiBuKSxcbiAgICAgIHRoZW1lOiB0ICYmIHBbdF0gfHwgcCxcbiAgICAgIC4uLnhcbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCB2dSA9IHtcbiAgYWN0aXZlOiBcImFjdGl2ZVwiLFxuICBjaGVja2VkOiBcImNoZWNrZWRcIixcbiAgY29tcGxldGVkOiBcImNvbXBsZXRlZFwiLFxuICBkaXNhYmxlZDogXCJkaXNhYmxlZFwiLFxuICBlcnJvcjogXCJlcnJvclwiLFxuICBleHBhbmRlZDogXCJleHBhbmRlZFwiLFxuICBmb2N1c2VkOiBcImZvY3VzZWRcIixcbiAgZm9jdXNWaXNpYmxlOiBcImZvY3VzVmlzaWJsZVwiLFxuICBvcGVuOiBcIm9wZW5cIixcbiAgcmVhZE9ubHk6IFwicmVhZE9ubHlcIixcbiAgcmVxdWlyZWQ6IFwicmVxdWlyZWRcIixcbiAgc2VsZWN0ZWQ6IFwic2VsZWN0ZWRcIlxufTtcbmZ1bmN0aW9uIFZlKGUsIHQsIHIgPSBcIk11aVwiKSB7XG4gIGNvbnN0IG4gPSB2dVt0XTtcbiAgcmV0dXJuIG4gPyBgJHtyfS0ke259YCA6IGAke1dhLmdlbmVyYXRlKGUpfS0ke3R9YDtcbn1cbmZ1bmN0aW9uIEZlKGUsIHQsIHIgPSBcIk11aVwiKSB7XG4gIGNvbnN0IG4gPSB7fTtcbiAgcmV0dXJuIHQuZm9yRWFjaCgobykgPT4ge1xuICAgIG5bb10gPSBWZShlLCBvLCByKTtcbiAgfSksIG47XG59XG5mdW5jdGlvbiBZYShlLCB0ID0gXCJcIikge1xuICByZXR1cm4gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgfHwgdDtcbn1cbmZ1bmN0aW9uIFZpKGUsIHQsIHIpIHtcbiAgY29uc3QgbiA9IFlhKHQpO1xuICByZXR1cm4gZS5kaXNwbGF5TmFtZSB8fCAobiAhPT0gXCJcIiA/IGAke3J9KCR7bn0pYCA6IHIpO1xufVxuZnVuY3Rpb24geHUoZSkge1xuICBpZiAoZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gZTtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuIFlhKGUsIFwiQ29tcG9uZW50XCIpO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiKVxuICAgICAgc3dpdGNoIChlLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgcG4uRm9yd2FyZFJlZjpcbiAgICAgICAgICByZXR1cm4gVmkoZSwgZS5yZW5kZXIsIFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgY2FzZSBwbi5NZW1vOlxuICAgICAgICAgIHJldHVybiBWaShlLCBlLnR5cGUsIFwibWVtb1wiKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEhhKGUpIHtcbiAgY29uc3Qge1xuICAgIHZhcmlhbnRzOiB0LFxuICAgIC4uLnJcbiAgfSA9IGUsIG4gPSB7XG4gICAgdmFyaWFudHM6IHQsXG4gICAgc3R5bGU6IE1pKHIpLFxuICAgIGlzUHJvY2Vzc2VkOiAhMFxuICB9O1xuICByZXR1cm4gbi5zdHlsZSA9PT0gciB8fCB0ICYmIHQuZm9yRWFjaCgobykgPT4ge1xuICAgIHR5cGVvZiBvLnN0eWxlICE9IFwiZnVuY3Rpb25cIiAmJiAoby5zdHlsZSA9IE1pKG8uc3R5bGUpKTtcbiAgfSksIG47XG59XG5jb25zdCBTdSA9IE5vKCk7XG5mdW5jdGlvbiBabihlKSB7XG4gIHJldHVybiBlICE9PSBcIm93bmVyU3RhdGVcIiAmJiBlICE9PSBcInRoZW1lXCIgJiYgZSAhPT0gXCJzeFwiICYmIGUgIT09IFwiYXNcIjtcbn1cbmZ1bmN0aW9uIEV1KGUpIHtcbiAgcmV0dXJuIGUgPyAodCwgcikgPT4gcltlXSA6IG51bGw7XG59XG5mdW5jdGlvbiBDdShlLCB0LCByKSB7XG4gIGUudGhlbWUgPSBSdShlLnRoZW1lKSA/IHIgOiBlLnRoZW1lW3RdIHx8IGUudGhlbWU7XG59XG5mdW5jdGlvbiBsbihlLCB0KSB7XG4gIGNvbnN0IHIgPSB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0KGUpIDogdDtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpXG4gICAgcmV0dXJuIHIuZmxhdE1hcCgobikgPT4gbG4oZSwgbikpO1xuICBpZiAoQXJyYXkuaXNBcnJheShyID09IG51bGwgPyB2b2lkIDAgOiByLnZhcmlhbnRzKSkge1xuICAgIGxldCBuO1xuICAgIGlmIChyLmlzUHJvY2Vzc2VkKVxuICAgICAgbiA9IHIuc3R5bGU7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHZhcmlhbnRzOiBvLFxuICAgICAgICAuLi5pXG4gICAgICB9ID0gcjtcbiAgICAgIG4gPSBpO1xuICAgIH1cbiAgICByZXR1cm4gcWEoZSwgci52YXJpYW50cywgW25dKTtcbiAgfVxuICByZXR1cm4gciAhPSBudWxsICYmIHIuaXNQcm9jZXNzZWQgPyByLnN0eWxlIDogcjtcbn1cbmZ1bmN0aW9uIHFhKGUsIHQsIHIgPSBbXSkge1xuICB2YXIgbztcbiAgbGV0IG47XG4gIGU6IGZvciAobGV0IGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHMgPSB0W2ldO1xuICAgIGlmICh0eXBlb2Ygcy5wcm9wcyA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmIChuID8/IChuID0ge1xuICAgICAgICAuLi5lLFxuICAgICAgICAuLi5lLm93bmVyU3RhdGUsXG4gICAgICAgIG93bmVyU3RhdGU6IGUub3duZXJTdGF0ZVxuICAgICAgfSksICFzLnByb3BzKG4pKVxuICAgICAgICBjb250aW51ZTtcbiAgICB9IGVsc2VcbiAgICAgIGZvciAoY29uc3QgYyBpbiBzLnByb3BzKVxuICAgICAgICBpZiAoZVtjXSAhPT0gcy5wcm9wc1tjXSAmJiAoKG8gPSBlLm93bmVyU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBvW2NdKSAhPT0gcy5wcm9wc1tjXSlcbiAgICAgICAgICBjb250aW51ZSBlO1xuICAgIHR5cGVvZiBzLnN0eWxlID09IFwiZnVuY3Rpb25cIiA/IChuID8/IChuID0ge1xuICAgICAgLi4uZSxcbiAgICAgIC4uLmUub3duZXJTdGF0ZSxcbiAgICAgIG93bmVyU3RhdGU6IGUub3duZXJTdGF0ZVxuICAgIH0pLCByLnB1c2gocy5zdHlsZShuKSkpIDogci5wdXNoKHMuc3R5bGUpO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gVHUoZSA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB0aGVtZUlkOiB0LFxuICAgIGRlZmF1bHRUaGVtZTogciA9IFN1LFxuICAgIHJvb3RTaG91bGRGb3J3YXJkUHJvcDogbiA9IFpuLFxuICAgIHNsb3RTaG91bGRGb3J3YXJkUHJvcDogbyA9IFpuXG4gIH0gPSBlO1xuICBmdW5jdGlvbiBpKGMpIHtcbiAgICBDdShjLCB0LCByKTtcbiAgfVxuICByZXR1cm4gKGMsIGwgPSB7fSkgPT4ge1xuICAgIHBsKGMsIChoKSA9PiBoLmZpbHRlcigodykgPT4gdyAhPT0gQXQpKTtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lOiB1LFxuICAgICAgc2xvdDogcCxcbiAgICAgIHNraXBWYXJpYW50c1Jlc29sdmVyOiBtLFxuICAgICAgc2tpcFN4OiBnLFxuICAgICAgLy8gVE9ETyB2NjogcmVtb3ZlIGBsb3dlcmNhc2VGaXJzdExldHRlcigpYCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG4gICAgICAvLyBGb3IgbW9yZSBkZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vbXVpL21hdGVyaWFsLXVpL3B1bGwvMzc5MDhcbiAgICAgIG92ZXJyaWRlc1Jlc29sdmVyOiB4ID0gRXUoR2EocCkpLFxuICAgICAgLi4ueVxuICAgIH0gPSBsLCBmID0gbSAhPT0gdm9pZCAwID8gbSA6IChcbiAgICAgIC8vIFRPRE8gdjY6IHJlbW92ZSBgUm9vdGAgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxuICAgICAgLy8gRm9yIG1vcmUgZGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL211aS9tYXRlcmlhbC11aS9wdWxsLzM3OTA4XG4gICAgICBwICYmIHAgIT09IFwiUm9vdFwiICYmIHAgIT09IFwicm9vdFwiIHx8ICExXG4gICAgKSwgUyA9IGcgfHwgITE7XG4gICAgbGV0IEUgPSBabjtcbiAgICBwID09PSBcIlJvb3RcIiB8fCBwID09PSBcInJvb3RcIiA/IEUgPSBuIDogcCA/IEUgPSBvIDogJHUoYykgJiYgKEUgPSB2b2lkIDApO1xuICAgIGNvbnN0IFAgPSBqYShjLCB7XG4gICAgICBzaG91bGRGb3J3YXJkUHJvcDogRSxcbiAgICAgIGxhYmVsOiBPdSh1LCBwKSxcbiAgICAgIC4uLnlcbiAgICB9KSwgVCA9IChoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGggPT0gXCJmdW5jdGlvblwiICYmIGguX19lbW90aW9uX3JlYWwgIT09IGgpXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgcmV0dXJuIGxuKGssIGgpO1xuICAgICAgICB9O1xuICAgICAgaWYgKGd0KGgpKSB7XG4gICAgICAgIGNvbnN0IHcgPSBIYShoKTtcbiAgICAgICAgcmV0dXJuIHcudmFyaWFudHMgPyBmdW5jdGlvbihMKSB7XG4gICAgICAgICAgcmV0dXJuIGxuKEwsIHcpO1xuICAgICAgICB9IDogdy5zdHlsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoO1xuICAgIH0sIGIgPSAoLi4uaCkgPT4ge1xuICAgICAgY29uc3QgdyA9IFtdLCBrID0gaC5tYXAoVCksIEwgPSBbXTtcbiAgICAgIGlmICh3LnB1c2goaSksIHUgJiYgeCAmJiBMLnB1c2goZnVuY3Rpb24oRCkge1xuICAgICAgICB2YXIgVSwgVjtcbiAgICAgICAgY29uc3QgVyA9IChWID0gKFUgPSBELnRoZW1lLmNvbXBvbmVudHMpID09IG51bGwgPyB2b2lkIDAgOiBVW3VdKSA9PSBudWxsID8gdm9pZCAwIDogVi5zdHlsZU92ZXJyaWRlcztcbiAgICAgICAgaWYgKCFXKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCB6ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdGUgaW4gVylcbiAgICAgICAgICB6W3RlXSA9IGxuKEQsIFdbdGVdKTtcbiAgICAgICAgcmV0dXJuIHgoRCwgeik7XG4gICAgICB9KSwgdSAmJiAhZiAmJiBMLnB1c2goZnVuY3Rpb24oRCkge1xuICAgICAgICB2YXIgeiwgVTtcbiAgICAgICAgY29uc3QgaiA9IEQudGhlbWUsIFcgPSAoVSA9ICh6ID0gaiA9PSBudWxsID8gdm9pZCAwIDogai5jb21wb25lbnRzKSA9PSBudWxsID8gdm9pZCAwIDogelt1XSkgPT0gbnVsbCA/IHZvaWQgMCA6IFUudmFyaWFudHM7XG4gICAgICAgIHJldHVybiBXID8gcWEoRCwgVykgOiBudWxsO1xuICAgICAgfSksIFMgfHwgTC5wdXNoKEF0KSwgQXJyYXkuaXNBcnJheShrWzBdKSkge1xuICAgICAgICBjb25zdCBBID0gay5zaGlmdCgpLCBEID0gbmV3IEFycmF5KHcubGVuZ3RoKS5maWxsKFwiXCIpLCBqID0gbmV3IEFycmF5KEwubGVuZ3RoKS5maWxsKFwiXCIpO1xuICAgICAgICBsZXQgVztcbiAgICAgICAgVyA9IFsuLi5ELCAuLi5BLCAuLi5qXSwgVy5yYXcgPSBbLi4uRCwgLi4uQS5yYXcsIC4uLmpdLCB3LnVuc2hpZnQoVyk7XG4gICAgICB9XG4gICAgICBjb25zdCBCID0gWy4uLncsIC4uLmssIC4uLkxdLCBkID0gUCguLi5CKTtcbiAgICAgIHJldHVybiBjLm11aU5hbWUgJiYgKGQubXVpTmFtZSA9IGMubXVpTmFtZSksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoZC5kaXNwbGF5TmFtZSA9IHd1KHUsIHAsIGMpKSwgZDtcbiAgICB9O1xuICAgIHJldHVybiBQLndpdGhDb25maWcgJiYgKGIud2l0aENvbmZpZyA9IFAud2l0aENvbmZpZyksIGI7XG4gIH07XG59XG5mdW5jdGlvbiB3dShlLCB0LCByKSB7XG4gIHJldHVybiBlID8gYCR7ZX0ke2VlKHQgfHwgXCJcIil9YCA6IGBTdHlsZWQoJHt4dShyKX0pYDtcbn1cbmZ1bmN0aW9uIE91KGUsIHQpIHtcbiAgbGV0IHI7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZSAmJiAociA9IGAke2V9LSR7R2EodCB8fCBcIlJvb3RcIil9YCksIHI7XG59XG5mdW5jdGlvbiBSdShlKSB7XG4gIGZvciAoY29uc3QgdCBpbiBlKVxuICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gJHUoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAvLyA5NiBpcyBvbmUgbGVzcyB0aGFuIHRoZSBjaGFyIGNvZGVcbiAgLy8gZm9yIFwiYVwiIHNvIHRoaXMgaXMgY2hlY2tpbmcgdGhhdFxuICAvLyBpdCdzIGEgbG93ZXJjYXNlIGNoYXJhY3RlclxuICBlLmNoYXJDb2RlQXQoMCkgPiA5Njtcbn1cbmZ1bmN0aW9uIEdhKGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIGUuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBjbyhlLCB0KSB7XG4gIGNvbnN0IHIgPSB7XG4gICAgLi4udFxuICB9O1xuICBmb3IgKGNvbnN0IG4gaW4gZSlcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIG4pKSB7XG4gICAgICBjb25zdCBvID0gbjtcbiAgICAgIGlmIChvID09PSBcImNvbXBvbmVudHNcIiB8fCBvID09PSBcInNsb3RzXCIpXG4gICAgICAgIHJbb10gPSB7XG4gICAgICAgICAgLi4uZVtvXSxcbiAgICAgICAgICAuLi5yW29dXG4gICAgICAgIH07XG4gICAgICBlbHNlIGlmIChvID09PSBcImNvbXBvbmVudHNQcm9wc1wiIHx8IG8gPT09IFwic2xvdFByb3BzXCIpIHtcbiAgICAgICAgY29uc3QgaSA9IGVbb10sIHMgPSB0W29dO1xuICAgICAgICBpZiAoIXMpXG4gICAgICAgICAgcltvXSA9IGkgfHwge307XG4gICAgICAgIGVsc2UgaWYgKCFpKVxuICAgICAgICAgIHJbb10gPSBzO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByW29dID0ge1xuICAgICAgICAgICAgLi4uc1xuICAgICAgICAgIH07XG4gICAgICAgICAgZm9yIChjb25zdCBjIGluIGkpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksIGMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGwgPSBjO1xuICAgICAgICAgICAgICByW29dW2xdID0gY28oaVtsXSwgc1tsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSByW29dID09PSB2b2lkIDAgJiYgKHJbb10gPSBlW29dKTtcbiAgICB9XG4gIHJldHVybiByO1xufVxuY29uc3QgRnQgPSB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyBDLnVzZUxheW91dEVmZmVjdCA6IEMudXNlRWZmZWN0O1xuZnVuY3Rpb24gUHUoZSwgdCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLCByID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHQsIE1hdGgubWluKGUsIHIpKTtcbn1cbmZ1bmN0aW9uIE1vKGUsIHQgPSAwLCByID0gMSkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChlIDwgdCB8fCBlID4gcikgJiYgY29uc29sZS5lcnJvcihgTVVJOiBUaGUgdmFsdWUgcHJvdmlkZWQgJHtlfSBpcyBvdXQgb2YgcmFuZ2UgWyR7dH0sICR7cn1dLmApLCBQdShlLCB0LCByKTtcbn1cbmZ1bmN0aW9uIGt1KGUpIHtcbiAgZSA9IGUuc2xpY2UoMSk7XG4gIGNvbnN0IHQgPSBuZXcgUmVnRXhwKGAuezEsJHtlLmxlbmd0aCA+PSA2ID8gMiA6IDF9fWAsIFwiZ1wiKTtcbiAgbGV0IHIgPSBlLm1hdGNoKHQpO1xuICByZXR1cm4gciAmJiByWzBdLmxlbmd0aCA9PT0gMSAmJiAociA9IHIubWFwKChuKSA9PiBuICsgbikpLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZS5sZW5ndGggIT09IGUudHJpbSgpLmxlbmd0aCAmJiBjb25zb2xlLmVycm9yKGBNVUk6IFRoZSBjb2xvcjogXCIke2V9XCIgaXMgaW52YWxpZC4gTWFrZSBzdXJlIHRoZSBjb2xvciBpbnB1dCBkb2Vzbid0IGNvbnRhaW4gbGVhZGluZy90cmFpbGluZyBzcGFjZS5gKSwgciA/IGByZ2Ike3IubGVuZ3RoID09PSA0ID8gXCJhXCIgOiBcIlwifSgke3IubWFwKChuLCBvKSA9PiBvIDwgMyA/IHBhcnNlSW50KG4sIDE2KSA6IE1hdGgucm91bmQocGFyc2VJbnQobiwgMTYpIC8gMjU1ICogMWUzKSAvIDFlMykuam9pbihcIiwgXCIpfSlgIDogXCJcIjtcbn1cbmZ1bmN0aW9uIE50KGUpIHtcbiAgaWYgKGUudHlwZSlcbiAgICByZXR1cm4gZTtcbiAgaWYgKGUuY2hhckF0KDApID09PSBcIiNcIilcbiAgICByZXR1cm4gTnQoa3UoZSkpO1xuICBjb25zdCB0ID0gZS5pbmRleE9mKFwiKFwiKSwgciA9IGUuc3Vic3RyaW5nKDAsIHQpO1xuICBpZiAoIVtcInJnYlwiLCBcInJnYmFcIiwgXCJoc2xcIiwgXCJoc2xhXCIsIFwiY29sb3JcIl0uaW5jbHVkZXMocikpXG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGBNVUk6IFVuc3VwcG9ydGVkIFxcYCR7ZX1cXGAgY29sb3IuXG5UaGUgZm9sbG93aW5nIGZvcm1hdHMgYXJlIHN1cHBvcnRlZDogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKS5gIDoga3QoOSwgZSkpO1xuICBsZXQgbiA9IGUuc3Vic3RyaW5nKHQgKyAxLCBlLmxlbmd0aCAtIDEpLCBvO1xuICBpZiAociA9PT0gXCJjb2xvclwiKSB7XG4gICAgaWYgKG4gPSBuLnNwbGl0KFwiIFwiKSwgbyA9IG4uc2hpZnQoKSwgbi5sZW5ndGggPT09IDQgJiYgblszXS5jaGFyQXQoMCkgPT09IFwiL1wiICYmIChuWzNdID0gblszXS5zbGljZSgxKSksICFbXCJzcmdiXCIsIFwiZGlzcGxheS1wM1wiLCBcImE5OC1yZ2JcIiwgXCJwcm9waG90by1yZ2JcIiwgXCJyZWMtMjAyMFwiXS5pbmNsdWRlcyhvKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBgTVVJOiB1bnN1cHBvcnRlZCBcXGAke299XFxgIGNvbG9yIHNwYWNlLlxuVGhlIGZvbGxvd2luZyBjb2xvciBzcGFjZXMgYXJlIHN1cHBvcnRlZDogc3JnYiwgZGlzcGxheS1wMywgYTk4LXJnYiwgcHJvcGhvdG8tcmdiLCByZWMtMjAyMC5gIDoga3QoMTAsIG8pKTtcbiAgfSBlbHNlXG4gICAgbiA9IG4uc3BsaXQoXCIsXCIpO1xuICByZXR1cm4gbiA9IG4ubWFwKChpKSA9PiBwYXJzZUZsb2F0KGkpKSwge1xuICAgIHR5cGU6IHIsXG4gICAgdmFsdWVzOiBuLFxuICAgIGNvbG9yU3BhY2U6IG9cbiAgfTtcbn1cbmNvbnN0IEF1ID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IE50KGUpO1xuICByZXR1cm4gdC52YWx1ZXMuc2xpY2UoMCwgMykubWFwKChyLCBuKSA9PiB0LnR5cGUuaW5jbHVkZXMoXCJoc2xcIikgJiYgbiAhPT0gMCA/IGAke3J9JWAgOiByKS5qb2luKFwiIFwiKTtcbn0sIGdyID0gKGUsIHQpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gQXUoZSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB0ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLndhcm4odCksIGU7XG4gIH1cbn07XG5mdW5jdGlvbiBCbihlKSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlOiB0LFxuICAgIGNvbG9yU3BhY2U6IHJcbiAgfSA9IGU7XG4gIGxldCB7XG4gICAgdmFsdWVzOiBuXG4gIH0gPSBlO1xuICByZXR1cm4gdC5pbmNsdWRlcyhcInJnYlwiKSA/IG4gPSBuLm1hcCgobywgaSkgPT4gaSA8IDMgPyBwYXJzZUludChvLCAxMCkgOiBvKSA6IHQuaW5jbHVkZXMoXCJoc2xcIikgJiYgKG5bMV0gPSBgJHtuWzFdfSVgLCBuWzJdID0gYCR7blsyXX0lYCksIHQuaW5jbHVkZXMoXCJjb2xvclwiKSA/IG4gPSBgJHtyfSAke24uam9pbihcIiBcIil9YCA6IG4gPSBgJHtuLmpvaW4oXCIsIFwiKX1gLCBgJHt0fSgke259KWA7XG59XG5mdW5jdGlvbiBLYShlKSB7XG4gIGUgPSBOdChlKTtcbiAgY29uc3Qge1xuICAgIHZhbHVlczogdFxuICB9ID0gZSwgciA9IHRbMF0sIG4gPSB0WzFdIC8gMTAwLCBvID0gdFsyXSAvIDEwMCwgaSA9IG4gKiBNYXRoLm1pbihvLCAxIC0gbyksIHMgPSAodSwgcCA9ICh1ICsgciAvIDMwKSAlIDEyKSA9PiBvIC0gaSAqIE1hdGgubWF4KE1hdGgubWluKHAgLSAzLCA5IC0gcCwgMSksIC0xKTtcbiAgbGV0IGMgPSBcInJnYlwiO1xuICBjb25zdCBsID0gW01hdGgucm91bmQocygwKSAqIDI1NSksIE1hdGgucm91bmQocyg4KSAqIDI1NSksIE1hdGgucm91bmQocyg0KSAqIDI1NSldO1xuICByZXR1cm4gZS50eXBlID09PSBcImhzbGFcIiAmJiAoYyArPSBcImFcIiwgbC5wdXNoKHRbM10pKSwgQm4oe1xuICAgIHR5cGU6IGMsXG4gICAgdmFsdWVzOiBsXG4gIH0pO1xufVxuZnVuY3Rpb24gbG8oZSkge1xuICBlID0gTnQoZSk7XG4gIGxldCB0ID0gZS50eXBlID09PSBcImhzbFwiIHx8IGUudHlwZSA9PT0gXCJoc2xhXCIgPyBOdChLYShlKSkudmFsdWVzIDogZS52YWx1ZXM7XG4gIHJldHVybiB0ID0gdC5tYXAoKHIpID0+IChlLnR5cGUgIT09IFwiY29sb3JcIiAmJiAociAvPSAyNTUpLCByIDw9IDAuMDM5MjggPyByIC8gMTIuOTIgOiAoKHIgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40KSksIE51bWJlcigoMC4yMTI2ICogdFswXSArIDAuNzE1MiAqIHRbMV0gKyAwLjA3MjIgKiB0WzJdKS50b0ZpeGVkKDMpKTtcbn1cbmZ1bmN0aW9uIEZpKGUsIHQpIHtcbiAgY29uc3QgciA9IGxvKGUpLCBuID0gbG8odCk7XG4gIHJldHVybiAoTWF0aC5tYXgociwgbikgKyAwLjA1KSAvIChNYXRoLm1pbihyLCBuKSArIDAuMDUpO1xufVxuZnVuY3Rpb24gRGUoZSwgdCkge1xuICByZXR1cm4gZSA9IE50KGUpLCB0ID0gTW8odCksIChlLnR5cGUgPT09IFwicmdiXCIgfHwgZS50eXBlID09PSBcImhzbFwiKSAmJiAoZS50eXBlICs9IFwiYVwiKSwgZS50eXBlID09PSBcImNvbG9yXCIgPyBlLnZhbHVlc1szXSA9IGAvJHt0fWAgOiBlLnZhbHVlc1szXSA9IHQsIEJuKGUpO1xufVxuZnVuY3Rpb24gWHIoZSwgdCwgcikge1xuICB0cnkge1xuICAgIHJldHVybiBEZShlLCB0KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cbmZ1bmN0aW9uIElvKGUsIHQpIHtcbiAgaWYgKGUgPSBOdChlKSwgdCA9IE1vKHQpLCBlLnR5cGUuaW5jbHVkZXMoXCJoc2xcIikpXG4gICAgZS52YWx1ZXNbMl0gKj0gMSAtIHQ7XG4gIGVsc2UgaWYgKGUudHlwZS5pbmNsdWRlcyhcInJnYlwiKSB8fCBlLnR5cGUuaW5jbHVkZXMoXCJjb2xvclwiKSlcbiAgICBmb3IgKGxldCByID0gMDsgciA8IDM7IHIgKz0gMSlcbiAgICAgIGUudmFsdWVzW3JdICo9IDEgLSB0O1xuICByZXR1cm4gQm4oZSk7XG59XG5mdW5jdGlvbiBDZShlLCB0LCByKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIElvKGUsIHQpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuZnVuY3Rpb24gX28oZSwgdCkge1xuICBpZiAoZSA9IE50KGUpLCB0ID0gTW8odCksIGUudHlwZS5pbmNsdWRlcyhcImhzbFwiKSlcbiAgICBlLnZhbHVlc1syXSArPSAoMTAwIC0gZS52YWx1ZXNbMl0pICogdDtcbiAgZWxzZSBpZiAoZS50eXBlLmluY2x1ZGVzKFwicmdiXCIpKVxuICAgIGZvciAobGV0IHIgPSAwOyByIDwgMzsgciArPSAxKVxuICAgICAgZS52YWx1ZXNbcl0gKz0gKDI1NSAtIGUudmFsdWVzW3JdKSAqIHQ7XG4gIGVsc2UgaWYgKGUudHlwZS5pbmNsdWRlcyhcImNvbG9yXCIpKVxuICAgIGZvciAobGV0IHIgPSAwOyByIDwgMzsgciArPSAxKVxuICAgICAgZS52YWx1ZXNbcl0gKz0gKDEgLSBlLnZhbHVlc1tyXSkgKiB0O1xuICByZXR1cm4gQm4oZSk7XG59XG5mdW5jdGlvbiBUZShlLCB0LCByKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIF9vKGUsIHQpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuZnVuY3Rpb24gTnUoZSwgdCA9IDAuMTUpIHtcbiAgcmV0dXJuIGxvKGUpID4gMC41ID8gSW8oZSwgdCkgOiBfbyhlLCB0KTtcbn1cbmZ1bmN0aW9uIEpyKGUsIHQsIHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gTnUoZSwgdCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5mdW5jdGlvbiBhcihlLCB0KSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyAoKSA9PiBudWxsIDogZnVuY3Rpb24oLi4ubikge1xuICAgIHJldHVybiBlKC4uLm4pIHx8IHQoLi4ubik7XG4gIH07XG59XG5mdW5jdGlvbiBNdShlKSB7XG4gIGNvbnN0IHtcbiAgICBwcm90b3R5cGU6IHQgPSB7fVxuICB9ID0gZTtcbiAgcmV0dXJuICEhdC5pc1JlYWN0Q29tcG9uZW50O1xufVxuZnVuY3Rpb24gWGEoZSwgdCwgciwgbiwgbykge1xuICBjb25zdCBpID0gZVt0XSwgcyA9IG8gfHwgdDtcbiAgaWYgKGkgPT0gbnVsbCB8fCAvLyBXaGVuIHNlcnZlci1zaWRlIHJlbmRlcmluZyBSZWFjdCBkb2Vzbid0IHdhcm4gZWl0aGVyLlxuICAvLyBUaGlzIGlzIG5vdCBhbiBhY2N1cmF0ZSBjaGVjayBmb3IgU1NSLlxuICAvLyBUaGlzIGlzIG9ubHkgaW4gcGxhY2UgZm9yIEVtb3Rpb24gY29tcGF0LlxuICAvLyBUT0RPOiBSZXZpc2l0IG9uY2UgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDA0NyBpcyByZXNvbHZlZC5cbiAgdHlwZW9mIHdpbmRvdyA+IFwidVwiKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgYztcbiAgY29uc3QgbCA9IGkudHlwZTtcbiAgcmV0dXJuIHR5cGVvZiBsID09IFwiZnVuY3Rpb25cIiAmJiAhTXUobCkgJiYgKGMgPSBcIkRpZCB5b3UgYWNjaWRlbnRhbGx5IHVzZSBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCBmb3IgYW4gZWxlbWVudCBpbnN0ZWFkP1wiKSwgYyAhPT0gdm9pZCAwID8gbmV3IEVycm9yKGBJbnZhbGlkICR7bn0gXFxgJHtzfVxcYCBzdXBwbGllZCB0byBcXGAke3J9XFxgLiBFeHBlY3RlZCBhbiBlbGVtZW50IHRoYXQgY2FuIGhvbGQgYSByZWYuICR7Y30gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHBzOi8vbXVpLmNvbS9yL2NhdmVhdC13aXRoLXJlZnMtZ3VpZGVgKSA6IG51bGw7XG59XG5jb25zdCBqbyA9IGFyKGEuZWxlbWVudCwgWGEpO1xuam8uaXNSZXF1aXJlZCA9IGFyKGEuZWxlbWVudC5pc1JlcXVpcmVkLCBYYSk7XG5mdW5jdGlvbiBJdShlKSB7XG4gIGNvbnN0IHtcbiAgICBwcm90b3R5cGU6IHQgPSB7fVxuICB9ID0gZTtcbiAgcmV0dXJuICEhdC5pc1JlYWN0Q29tcG9uZW50O1xufVxuZnVuY3Rpb24gX3UoZSwgdCwgciwgbiwgbykge1xuICBjb25zdCBpID0gZVt0XSwgcyA9IG8gfHwgdDtcbiAgaWYgKGkgPT0gbnVsbCB8fCAvLyBXaGVuIHNlcnZlci1zaWRlIHJlbmRlcmluZyBSZWFjdCBkb2Vzbid0IHdhcm4gZWl0aGVyLlxuICAvLyBUaGlzIGlzIG5vdCBhbiBhY2N1cmF0ZSBjaGVjayBmb3IgU1NSLlxuICAvLyBUaGlzIGlzIG9ubHkgaW4gcGxhY2UgZm9yIGVtb3Rpb24gY29tcGF0LlxuICAvLyBUT0RPOiBSZXZpc2l0IG9uY2UgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDA0NyBpcyByZXNvbHZlZC5cbiAgdHlwZW9mIHdpbmRvdyA+IFwidVwiKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgYztcbiAgcmV0dXJuIHR5cGVvZiBpID09IFwiZnVuY3Rpb25cIiAmJiAhSXUoaSkgJiYgKGMgPSBcIkRpZCB5b3UgYWNjaWRlbnRhbGx5IHByb3ZpZGUgYSBwbGFpbiBmdW5jdGlvbiBjb21wb25lbnQgaW5zdGVhZD9cIiksIGMgIT09IHZvaWQgMCA/IG5ldyBFcnJvcihgSW52YWxpZCAke259IFxcYCR7c31cXGAgc3VwcGxpZWQgdG8gXFxgJHtyfVxcYC4gRXhwZWN0ZWQgYW4gZWxlbWVudCB0eXBlIHRoYXQgY2FuIGhvbGQgYSByZWYuICR7Y30gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHBzOi8vbXVpLmNvbS9yL2NhdmVhdC13aXRoLXJlZnMtZ3VpZGVgKSA6IG51bGw7XG59XG5jb25zdCBKYSA9IGFyKGEuZWxlbWVudFR5cGUsIF91KSwganUgPSBcImV4YWN0LXByb3A6IOKAi1wiO1xuZnVuY3Rpb24gRG8oZSkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZSA6IHtcbiAgICAuLi5lLFxuICAgIFtqdV06ICh0KSA9PiB7XG4gICAgICBjb25zdCByID0gT2JqZWN0LmtleXModCkuZmlsdGVyKChuKSA9PiAhZS5oYXNPd25Qcm9wZXJ0eShuKSk7XG4gICAgICByZXR1cm4gci5sZW5ndGggPiAwID8gbmV3IEVycm9yKGBUaGUgZm9sbG93aW5nIHByb3BzIGFyZSBub3Qgc3VwcG9ydGVkOiAke3IubWFwKChuKSA9PiBgXFxgJHtufVxcYGApLmpvaW4oXCIsIFwiKX0uIFBsZWFzZSByZW1vdmUgdGhlbS5gKSA6IG51bGw7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gT3IoZSwgdCwgciwgbiwgbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBpID0gZVt0XSwgcyA9IG8gfHwgdDtcbiAgcmV0dXJuIGkgPT0gbnVsbCA/IG51bGwgOiBpICYmIGkubm9kZVR5cGUgIT09IDEgPyBuZXcgRXJyb3IoYEludmFsaWQgJHtufSBcXGAke3N9XFxgIHN1cHBsaWVkIHRvIFxcYCR7cn1cXGAuIEV4cGVjdGVkIGFuIEhUTUxFbGVtZW50LmApIDogbnVsbDtcbn1cbmNvbnN0IExvID0gYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3RdKTtcbmZ1bmN0aW9uIHppKGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xufVxuZnVuY3Rpb24gdW8oZSwgdCkge1xuICB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKHQpIDogZSAmJiAoZS5jdXJyZW50ID0gdCk7XG59XG5sZXQgV2kgPSAwO1xuZnVuY3Rpb24gRHUoZSkge1xuICBjb25zdCBbdCwgcl0gPSBDLnVzZVN0YXRlKGUpLCBuID0gZSB8fCB0O1xuICByZXR1cm4gQy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHQgPT0gbnVsbCAmJiAoV2kgKz0gMSwgcihgbXVpLSR7V2l9YCkpO1xuICB9LCBbdF0pLCBuO1xufVxuY29uc3QgTHUgPSB7XG4gIC4uLkNcbn0sIFVpID0gTHUudXNlSWQ7XG5mdW5jdGlvbiBRYShlKSB7XG4gIGlmIChVaSAhPT0gdm9pZCAwKSB7XG4gICAgY29uc3QgdCA9IFVpKCk7XG4gICAgcmV0dXJuIGUgPz8gdDtcbiAgfVxuICByZXR1cm4gRHUoZSk7XG59XG5mdW5jdGlvbiBCdShlLCB0LCByLCBuLCBvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGkgPSBvIHx8IHQ7XG4gIHJldHVybiB0eXBlb2YgZVt0XSA8IFwidVwiID8gbmV3IEVycm9yKGBUaGUgcHJvcCBcXGAke2l9XFxgIGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSByZW1vdmUgaXQuYCkgOiBudWxsO1xufVxuZnVuY3Rpb24gVnUoe1xuICBjb250cm9sbGVkOiBlLFxuICBkZWZhdWx0OiB0LFxuICBuYW1lOiByLFxuICBzdGF0ZTogbiA9IFwidmFsdWVcIlxufSkge1xuICBjb25zdCB7XG4gICAgY3VycmVudDogb1xuICB9ID0gQy51c2VSZWYoZSAhPT0gdm9pZCAwKSwgW2ksIHNdID0gQy51c2VTdGF0ZSh0KSwgYyA9IG8gPyBlIDogaTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIG8gIT09IChlICE9PSB2b2lkIDApICYmIGNvbnNvbGUuZXJyb3IoW2BNVUk6IEEgY29tcG9uZW50IGlzIGNoYW5naW5nIHRoZSAke28gPyBcIlwiIDogXCJ1blwifWNvbnRyb2xsZWQgJHtufSBzdGF0ZSBvZiAke3J9IHRvIGJlICR7byA/IFwidW5cIiA6IFwiXCJ9Y29udHJvbGxlZC5gLCBcIkVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLlwiLCBgRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAke3J9IGVsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LmAsIFwiVGhlIG5hdHVyZSBvZiB0aGUgc3RhdGUgaXMgZGV0ZXJtaW5lZCBkdXJpbmcgdGhlIGZpcnN0IHJlbmRlci4gSXQncyBjb25zaWRlcmVkIGNvbnRyb2xsZWQgaWYgdGhlIHZhbHVlIGlzIG5vdCBgdW5kZWZpbmVkYC5cIiwgXCJNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzXCJdLmpvaW4oYFxuYCkpO1xuICAgIH0sIFtuLCByLCBlXSk7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudDogdVxuICAgIH0gPSBDLnVzZVJlZih0KTtcbiAgICBDLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAhbyAmJiAhT2JqZWN0LmlzKHUsIHQpICYmIGNvbnNvbGUuZXJyb3IoW2BNVUk6IEEgY29tcG9uZW50IGlzIGNoYW5naW5nIHRoZSBkZWZhdWx0ICR7bn0gc3RhdGUgb2YgYW4gdW5jb250cm9sbGVkICR7cn0gYWZ0ZXIgYmVpbmcgaW5pdGlhbGl6ZWQuIFRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBvcHQgdG8gdXNlIGEgY29udHJvbGxlZCAke3J9LmBdLmpvaW4oYFxuYCkpO1xuICAgIH0sIFtKU09OLnN0cmluZ2lmeSh0KV0pO1xuICB9XG4gIGNvbnN0IGwgPSBDLnVzZUNhbGxiYWNrKCh1KSA9PiB7XG4gICAgbyB8fCBzKHUpO1xuICB9LCBbXSk7XG4gIHJldHVybiBbYywgbF07XG59XG5mdW5jdGlvbiBRdChlKSB7XG4gIGNvbnN0IHQgPSBDLnVzZVJlZihlKTtcbiAgcmV0dXJuIEZ0KCgpID0+IHtcbiAgICB0LmN1cnJlbnQgPSBlO1xuICB9KSwgQy51c2VSZWYoKC4uLnIpID0+IChcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGhpZGUgYHRoaXNgXG4gICAgKDAsIHQuY3VycmVudCkoLi4ucilcbiAgKSkuY3VycmVudDtcbn1cbmZ1bmN0aW9uIGF0KC4uLmUpIHtcbiAgcmV0dXJuIEMudXNlTWVtbygoKSA9PiBlLmV2ZXJ5KCh0KSA9PiB0ID09IG51bGwpID8gbnVsbCA6ICh0KSA9PiB7XG4gICAgZS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICB1byhyLCB0KTtcbiAgICB9KTtcbiAgfSwgZSk7XG59XG5jb25zdCBZaSA9IHt9O1xuZnVuY3Rpb24gWmEoZSwgdCkge1xuICBjb25zdCByID0gQy51c2VSZWYoWWkpO1xuICByZXR1cm4gci5jdXJyZW50ID09PSBZaSAmJiAoci5jdXJyZW50ID0gZSh0KSksIHI7XG59XG5jb25zdCBGdSA9IFtdO1xuZnVuY3Rpb24genUoZSkge1xuICBDLnVzZUVmZmVjdChlLCBGdSk7XG59XG5jbGFzcyBWbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNyKHRoaXMsIFwiY3VycmVudElkXCIsIG51bGwpO1xuICAgIGNyKHRoaXMsIFwiY2xlYXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50SWQgIT09IG51bGwgJiYgKGNsZWFyVGltZW91dCh0aGlzLmN1cnJlbnRJZCksIHRoaXMuY3VycmVudElkID0gbnVsbCk7XG4gICAgfSk7XG4gICAgY3IodGhpcywgXCJkaXNwb3NlRWZmZWN0XCIsICgpID0+IHRoaXMuY2xlYXIpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBWbigpO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBgZm5gIGFmdGVyIGBkZWxheWAsIGNsZWFyaW5nIGFueSBwcmV2aW91c2x5IHNjaGVkdWxlZCBjYWxsLlxuICAgKi9cbiAgc3RhcnQodCwgcikge1xuICAgIHRoaXMuY2xlYXIoKSwgdGhpcy5jdXJyZW50SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudElkID0gbnVsbCwgcigpO1xuICAgIH0sIHQpO1xuICB9XG59XG5mdW5jdGlvbiBEdCgpIHtcbiAgY29uc3QgZSA9IFphKFZuLmNyZWF0ZSkuY3VycmVudDtcbiAgcmV0dXJuIHp1KGUuZGlzcG9zZUVmZmVjdCksIGU7XG59XG5mdW5jdGlvbiBobihlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGUubWF0Y2hlcyhcIjpmb2N1cy12aXNpYmxlXCIpO1xuICB9IGNhdGNoIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIS9qc2RvbS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgY29uc29sZS53YXJuKFtcIk1VSTogVGhlIGA6Zm9jdXMtdmlzaWJsZWAgcHNldWRvIGNsYXNzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLlwiLCBcIlNvbWUgY29tcG9uZW50cyByZWx5IG9uIHRoaXMgZmVhdHVyZSB0byB3b3JrIHByb3Blcmx5LlwiXS5qb2luKGBcbmApKTtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBHZShlLCB0LCByID0gdm9pZCAwKSB7XG4gIGNvbnN0IG4gPSB7fTtcbiAgZm9yIChjb25zdCBvIGluIGUpIHtcbiAgICBjb25zdCBpID0gZVtvXTtcbiAgICBsZXQgcyA9IFwiXCIsIGMgPSAhMDtcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IGkubGVuZ3RoOyBsICs9IDEpIHtcbiAgICAgIGNvbnN0IHUgPSBpW2xdO1xuICAgICAgdSAmJiAocyArPSAoYyA9PT0gITAgPyBcIlwiIDogXCIgXCIpICsgdCh1KSwgYyA9ICExLCByICYmIHJbdV0gJiYgKHMgKz0gXCIgXCIgKyByW3VdKSk7XG4gICAgfVxuICAgIG5bb10gPSBzO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gV3UoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGVzKGUsIHQsIHIpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCB8fCBXdShlKSA/IHQgOiB7XG4gICAgLi4udCxcbiAgICBvd25lclN0YXRlOiB7XG4gICAgICAuLi50Lm93bmVyU3RhdGUsXG4gICAgICAuLi5yXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gVXUoZSwgdCA9IFtdKSB7XG4gIGlmIChlID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHt9O1xuICBjb25zdCByID0ge307XG4gIHJldHVybiBPYmplY3Qua2V5cyhlKS5maWx0ZXIoKG4pID0+IG4ubWF0Y2goL15vbltBLVpdLykgJiYgdHlwZW9mIGVbbl0gPT0gXCJmdW5jdGlvblwiICYmICF0LmluY2x1ZGVzKG4pKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgcltuXSA9IGVbbl07XG4gIH0pLCByO1xufVxuZnVuY3Rpb24gSGkoZSkge1xuICBpZiAoZSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMoZSkuZmlsdGVyKChyKSA9PiAhKHIubWF0Y2goL15vbltBLVpdLykgJiYgdHlwZW9mIGVbcl0gPT0gXCJmdW5jdGlvblwiKSkuZm9yRWFjaCgocikgPT4ge1xuICAgIHRbcl0gPSBlW3JdO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIHRzKGUpIHtcbiAgY29uc3Qge1xuICAgIGdldFNsb3RQcm9wczogdCxcbiAgICBhZGRpdGlvbmFsUHJvcHM6IHIsXG4gICAgZXh0ZXJuYWxTbG90UHJvcHM6IG4sXG4gICAgZXh0ZXJuYWxGb3J3YXJkZWRQcm9wczogbyxcbiAgICBjbGFzc05hbWU6IGlcbiAgfSA9IGU7XG4gIGlmICghdCkge1xuICAgIGNvbnN0IHggPSBzZShyID09IG51bGwgPyB2b2lkIDAgOiByLmNsYXNzTmFtZSwgaSwgbyA9PSBudWxsID8gdm9pZCAwIDogby5jbGFzc05hbWUsIG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uY2xhc3NOYW1lKSwgeSA9IHtcbiAgICAgIC4uLnIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuc3R5bGUsXG4gICAgICAuLi5vID09IG51bGwgPyB2b2lkIDAgOiBvLnN0eWxlLFxuICAgICAgLi4ubiA9PSBudWxsID8gdm9pZCAwIDogbi5zdHlsZVxuICAgIH0sIGYgPSB7XG4gICAgICAuLi5yLFxuICAgICAgLi4ubyxcbiAgICAgIC4uLm5cbiAgICB9O1xuICAgIHJldHVybiB4Lmxlbmd0aCA+IDAgJiYgKGYuY2xhc3NOYW1lID0geCksIE9iamVjdC5rZXlzKHkpLmxlbmd0aCA+IDAgJiYgKGYuc3R5bGUgPSB5KSwge1xuICAgICAgcHJvcHM6IGYsXG4gICAgICBpbnRlcm5hbFJlZjogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBjb25zdCBzID0gVXUoe1xuICAgIC4uLm8sXG4gICAgLi4ublxuICB9KSwgYyA9IEhpKG4pLCBsID0gSGkobyksIHUgPSB0KHMpLCBwID0gc2UodSA9PSBudWxsID8gdm9pZCAwIDogdS5jbGFzc05hbWUsIHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuY2xhc3NOYW1lLCBpLCBvID09IG51bGwgPyB2b2lkIDAgOiBvLmNsYXNzTmFtZSwgbiA9PSBudWxsID8gdm9pZCAwIDogbi5jbGFzc05hbWUpLCBtID0ge1xuICAgIC4uLnUgPT0gbnVsbCA/IHZvaWQgMCA6IHUuc3R5bGUsXG4gICAgLi4uciA9PSBudWxsID8gdm9pZCAwIDogci5zdHlsZSxcbiAgICAuLi5vID09IG51bGwgPyB2b2lkIDAgOiBvLnN0eWxlLFxuICAgIC4uLm4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uc3R5bGVcbiAgfSwgZyA9IHtcbiAgICAuLi51LFxuICAgIC4uLnIsXG4gICAgLi4ubCxcbiAgICAuLi5jXG4gIH07XG4gIHJldHVybiBwLmxlbmd0aCA+IDAgJiYgKGcuY2xhc3NOYW1lID0gcCksIE9iamVjdC5rZXlzKG0pLmxlbmd0aCA+IDAgJiYgKGcuc3R5bGUgPSBtKSwge1xuICAgIHByb3BzOiBnLFxuICAgIGludGVybmFsUmVmOiB1LnJlZlxuICB9O1xufVxuZnVuY3Rpb24gcnMoZSwgdCwgcikge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSh0LCByKSA6IGU7XG59XG5mdW5jdGlvbiBZdShlKSB7XG4gIHZhciBtO1xuICBjb25zdCB7XG4gICAgZWxlbWVudFR5cGU6IHQsXG4gICAgZXh0ZXJuYWxTbG90UHJvcHM6IHIsXG4gICAgb3duZXJTdGF0ZTogbixcbiAgICBza2lwUmVzb2x2aW5nU2xvdFByb3BzOiBvID0gITEsXG4gICAgLi4uaVxuICB9ID0gZSwgcyA9IG8gPyB7fSA6IHJzKHIsIG4pLCB7XG4gICAgcHJvcHM6IGMsXG4gICAgaW50ZXJuYWxSZWY6IGxcbiAgfSA9IHRzKHtcbiAgICAuLi5pLFxuICAgIGV4dGVybmFsU2xvdFByb3BzOiBzXG4gIH0pLCB1ID0gYXQobCwgcyA9PSBudWxsID8gdm9pZCAwIDogcy5yZWYsIChtID0gZS5hZGRpdGlvbmFsUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBtLnJlZik7XG4gIHJldHVybiBlcyh0LCB7XG4gICAgLi4uYyxcbiAgICByZWY6IHVcbiAgfSwgbik7XG59XG5mdW5jdGlvbiBCbyhlKSB7XG4gIHZhciB0O1xuICByZXR1cm4gcGFyc2VJbnQoQy52ZXJzaW9uLCAxMCkgPj0gMTkgPyAoKHQgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogdC5yZWYpIHx8IG51bGwgOiAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5yZWYpIHx8IG51bGw7XG59XG5jb25zdCBWbyA9IC8qIEBfX1BVUkVfXyAqLyBDLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKFZvLmRpc3BsYXlOYW1lID0gXCJUaGVtZUNvbnRleHRcIik7XG5mdW5jdGlvbiBGbygpIHtcbiAgY29uc3QgZSA9IEMudXNlQ29udGV4dChWbyk7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgQy51c2VEZWJ1Z1ZhbHVlKGUpLCBlO1xufVxuY29uc3QgSHUgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yLCBxdSA9IEh1ID8gU3ltYm9sLmZvcihcIm11aS5uZXN0ZWRcIikgOiBcIl9fVEhFTUVfTkVTVEVEX19cIjtcbmZ1bmN0aW9uIEd1KGUsIHQpIHtcbiAgaWYgKHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHIgPSB0KGUpO1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHIgfHwgY29uc29sZS5lcnJvcihbXCJNVUk6IFlvdSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHlvdXIgdGhlbWUgZnVuY3Rpb24sIGkuZS5cIiwgXCI8VGhlbWVQcm92aWRlciB0aGVtZT17KCkgPT4gKHt9KX0gLz5cIl0uam9pbihgXG5gKSkpLCByO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZSxcbiAgICAuLi50XG4gIH07XG59XG5mdW5jdGlvbiBnbihlKSB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbjogdCxcbiAgICB0aGVtZTogclxuICB9ID0gZSwgbiA9IEZvKCk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBuID09PSBudWxsICYmIHR5cGVvZiByID09IFwiZnVuY3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFtcIk1VSTogWW91IGFyZSBwcm92aWRpbmcgYSB0aGVtZSBmdW5jdGlvbiBwcm9wIHRvIHRoZSBUaGVtZVByb3ZpZGVyIGNvbXBvbmVudDpcIiwgXCI8VGhlbWVQcm92aWRlciB0aGVtZT17b3V0ZXJUaGVtZSA9PiBvdXRlclRoZW1lfSAvPlwiLCBcIlwiLCBcIkhvd2V2ZXIsIG5vIG91dGVyIHRoZW1lIGlzIHByZXNlbnQuXCIsIFwiTWFrZSBzdXJlIGEgdGhlbWUgaXMgYWxyZWFkeSBpbmplY3RlZCBoaWdoZXIgaW4gdGhlIFJlYWN0IHRyZWUgb3IgcHJvdmlkZSBhIHRoZW1lIG9iamVjdC5cIl0uam9pbihgXG5gKSk7XG4gIGNvbnN0IG8gPSBDLnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGkgPSBuID09PSBudWxsID8ge1xuICAgICAgLi4uclxuICAgIH0gOiBHdShuLCByKTtcbiAgICByZXR1cm4gaSAhPSBudWxsICYmIChpW3F1XSA9IG4gIT09IG51bGwpLCBpO1xuICB9LCBbciwgbl0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KFZvLlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG8sXG4gICAgY2hpbGRyZW46IHRcbiAgfSk7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGduLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFlvdXIgY29tcG9uZW50IHRyZWUuXG4gICAqL1xuICBjaGlsZHJlbjogYS5ub2RlLFxuICAvKipcbiAgICogQSB0aGVtZSBvYmplY3QuIFlvdSBjYW4gcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIGV4dGVuZCB0aGUgb3V0ZXIgdGhlbWUuXG4gICAqL1xuICB0aGVtZTogYS5vbmVPZlR5cGUoW2Eub2JqZWN0LCBhLmZ1bmNdKS5pc1JlcXVpcmVkXG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGduLnByb3BUeXBlcyA9IERvKGduLnByb3BUeXBlcykpO1xuY29uc3QgbnMgPSAvKiBAX19QVVJFX18gKi8gQy5jcmVhdGVDb250ZXh0KCk7XG5mdW5jdGlvbiBvcyh7XG4gIHZhbHVlOiBlLFxuICAuLi50XG59KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3gobnMuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZSA/PyAhMCxcbiAgICAuLi50XG4gIH0pO1xufVxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChvcy5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBhLm5vZGUsXG4gIHZhbHVlOiBhLmJvb2xcbn0pO1xuY29uc3QgaXMgPSAoKSA9PiBDLnVzZUNvbnRleHQobnMpID8/ICExLCBhcyA9IC8qIEBfX1BVUkVfXyAqLyBDLmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmZ1bmN0aW9uIHNzKHtcbiAgdmFsdWU6IGUsXG4gIGNoaWxkcmVuOiB0XG59KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goYXMuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZSxcbiAgICBjaGlsZHJlbjogdFxuICB9KTtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoc3MucHJvcFR5cGVzID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgVHlwZVNjcmlwdCB0eXBlcyBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNoaWxkcmVuOiBhLm5vZGUsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICB2YWx1ZTogYS5vYmplY3Rcbn0pO1xuZnVuY3Rpb24gS3UoZSkge1xuICBjb25zdCB7XG4gICAgdGhlbWU6IHQsXG4gICAgbmFtZTogcixcbiAgICBwcm9wczogblxuICB9ID0gZTtcbiAgaWYgKCF0IHx8ICF0LmNvbXBvbmVudHMgfHwgIXQuY29tcG9uZW50c1tyXSlcbiAgICByZXR1cm4gbjtcbiAgY29uc3QgbyA9IHQuY29tcG9uZW50c1tyXTtcbiAgcmV0dXJuIG8uZGVmYXVsdFByb3BzID8gY28oby5kZWZhdWx0UHJvcHMsIG4pIDogIW8uc3R5bGVPdmVycmlkZXMgJiYgIW8udmFyaWFudHMgPyBjbyhvLCBuKSA6IG47XG59XG5mdW5jdGlvbiBYdSh7XG4gIHByb3BzOiBlLFxuICBuYW1lOiB0XG59KSB7XG4gIGNvbnN0IHIgPSBDLnVzZUNvbnRleHQoYXMpO1xuICByZXR1cm4gS3Uoe1xuICAgIHByb3BzOiBlLFxuICAgIG5hbWU6IHQsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbXBvbmVudHM6IHJcbiAgICB9XG4gIH0pO1xufVxuY29uc3QgcWkgPSB7fTtcbmZ1bmN0aW9uIEdpKGUsIHQsIHIsIG4gPSAhMSkge1xuICByZXR1cm4gQy51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBvID0gZSAmJiB0W2VdIHx8IHQ7XG4gICAgaWYgKHR5cGVvZiByID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgaSA9IHIobyksIHMgPSBlID8ge1xuICAgICAgICAuLi50LFxuICAgICAgICBbZV06IGlcbiAgICAgIH0gOiBpO1xuICAgICAgcmV0dXJuIG4gPyAoKSA9PiBzIDogcztcbiAgICB9XG4gICAgcmV0dXJuIGUgPyB7XG4gICAgICAuLi50LFxuICAgICAgW2VdOiByXG4gICAgfSA6IHtcbiAgICAgIC4uLnQsXG4gICAgICAuLi5yXG4gICAgfTtcbiAgfSwgW2UsIHQsIHIsIG5dKTtcbn1cbmZ1bmN0aW9uIFJyKGUpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuOiB0LFxuICAgIHRoZW1lOiByLFxuICAgIHRoZW1lSWQ6IG5cbiAgfSA9IGUsIG8gPSBWYShxaSksIGkgPSBGbygpIHx8IHFpO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKG8gPT09IG51bGwgJiYgdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiIHx8IG4gJiYgbyAmJiAhb1tuXSAmJiB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIpICYmIGNvbnNvbGUuZXJyb3IoW1wiTVVJOiBZb3UgYXJlIHByb3ZpZGluZyBhIHRoZW1lIGZ1bmN0aW9uIHByb3AgdG8gdGhlIFRoZW1lUHJvdmlkZXIgY29tcG9uZW50OlwiLCBcIjxUaGVtZVByb3ZpZGVyIHRoZW1lPXtvdXRlclRoZW1lID0+IG91dGVyVGhlbWV9IC8+XCIsIFwiXCIsIFwiSG93ZXZlciwgbm8gb3V0ZXIgdGhlbWUgaXMgcHJlc2VudC5cIiwgXCJNYWtlIHN1cmUgYSB0aGVtZSBpcyBhbHJlYWR5IGluamVjdGVkIGhpZ2hlciBpbiB0aGUgUmVhY3QgdHJlZSBvciBwcm92aWRlIGEgdGhlbWUgb2JqZWN0LlwiXS5qb2luKGBcbmApKTtcbiAgY29uc3QgcyA9IEdpKG4sIG8sIHIpLCBjID0gR2kobiwgaSwgciwgITApLCBsID0gKG4gPyBzW25dIDogcykuZGlyZWN0aW9uID09PSBcInJ0bFwiO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KGduLCB7XG4gICAgdGhlbWU6IGMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChNci5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHMsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KG9zLCB7XG4gICAgICAgIHZhbHVlOiBsLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KHNzLCB7XG4gICAgICAgICAgdmFsdWU6IG4gPyBzW25dLmNvbXBvbmVudHMgOiBzLmNvbXBvbmVudHMsXG4gICAgICAgICAgY2hpbGRyZW46IHRcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKFJyLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgICAgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBZb3VyIGNvbXBvbmVudCB0cmVlLlxuICAgKi9cbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgLyoqXG4gICAqIEEgdGhlbWUgb2JqZWN0LiBZb3UgY2FuIHByb3ZpZGUgYSBmdW5jdGlvbiB0byBleHRlbmQgdGhlIG91dGVyIHRoZW1lLlxuICAgKi9cbiAgdGhlbWU6IGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0XSkuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIFRoZSBkZXNpZ24gc3lzdGVtJ3MgdW5pcXVlIGlkIGZvciBnZXR0aW5nIHRoZSBjb3JyZXNwb25kZWQgdGhlbWUgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgZGVzaWduIHN5c3RlbXMuXG4gICAqL1xuICB0aGVtZUlkOiBhLnN0cmluZ1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChSci5wcm9wVHlwZXMgPSBEbyhSci5wcm9wVHlwZXMpKTtcbmNvbnN0IEtpID0ge1xuICB0aGVtZTogdm9pZCAwXG59O1xuZnVuY3Rpb24gSnUoZSkge1xuICBsZXQgdCwgcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKG8pIHtcbiAgICBsZXQgaSA9IHQ7XG4gICAgcmV0dXJuIChpID09PSB2b2lkIDAgfHwgby50aGVtZSAhPT0gcikgJiYgKEtpLnRoZW1lID0gby50aGVtZSwgaSA9IEhhKGUoS2kpKSwgdCA9IGksIHIgPSBvLnRoZW1lKSwgaTtcbiAgfTtcbn1cbmNvbnN0IHpvID0gXCJtb2RlXCIsIFdvID0gXCJjb2xvci1zY2hlbWVcIiwgUXUgPSBcImRhdGEtY29sb3Itc2NoZW1lXCI7XG5mdW5jdGlvbiBadShlKSB7XG4gIGNvbnN0IHtcbiAgICBkZWZhdWx0TW9kZTogdCA9IFwic3lzdGVtXCIsXG4gICAgZGVmYXVsdExpZ2h0Q29sb3JTY2hlbWU6IHIgPSBcImxpZ2h0XCIsXG4gICAgZGVmYXVsdERhcmtDb2xvclNjaGVtZTogbiA9IFwiZGFya1wiLFxuICAgIG1vZGVTdG9yYWdlS2V5OiBvID0gem8sXG4gICAgY29sb3JTY2hlbWVTdG9yYWdlS2V5OiBpID0gV28sXG4gICAgYXR0cmlidXRlOiBzID0gUXUsXG4gICAgY29sb3JTY2hlbWVOb2RlOiBjID0gXCJkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcIixcbiAgICBub25jZTogbFxuICB9ID0gZTtcbiAgbGV0IHUgPSBcIlwiLCBwID0gcztcbiAgaWYgKHMgPT09IFwiY2xhc3NcIiAmJiAocCA9IFwiLiVzXCIpLCBzID09PSBcImRhdGFcIiAmJiAocCA9IFwiW2RhdGEtJXNdXCIpLCBwLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgY29uc3QgZyA9IHAuc3Vic3RyaW5nKDEpO1xuICAgIHUgKz0gYCR7Y30uY2xhc3NMaXN0LnJlbW92ZSgnJHtnfScucmVwbGFjZSgnJXMnLCBsaWdodCksICcke2d9Jy5yZXBsYWNlKCclcycsIGRhcmspKTtcbiAgICAgICR7Y30uY2xhc3NMaXN0LmFkZCgnJHtnfScucmVwbGFjZSgnJXMnLCBjb2xvclNjaGVtZSkpO2A7XG4gIH1cbiAgY29uc3QgbSA9IHAubWF0Y2goL1xcWyhbXlxcXV0rKVxcXS8pO1xuICBpZiAobSkge1xuICAgIGNvbnN0IFtnLCB4XSA9IG1bMV0uc3BsaXQoXCI9XCIpO1xuICAgIHggfHwgKHUgKz0gYCR7Y30ucmVtb3ZlQXR0cmlidXRlKCcke2d9Jy5yZXBsYWNlKCclcycsIGxpZ2h0KSk7XG4gICAgICAke2N9LnJlbW92ZUF0dHJpYnV0ZSgnJHtnfScucmVwbGFjZSgnJXMnLCBkYXJrKSk7YCksIHUgKz0gYFxuICAgICAgJHtjfS5zZXRBdHRyaWJ1dGUoJyR7Z30nLnJlcGxhY2UoJyVzJywgY29sb3JTY2hlbWUpLCAke3ggPyBgJHt4fS5yZXBsYWNlKCclcycsIGNvbG9yU2NoZW1lKWAgOiAnXCJcIid9KTtgO1xuICB9IGVsc2VcbiAgICB1ICs9IGAke2N9LnNldEF0dHJpYnV0ZSgnJHtwfScsIGNvbG9yU2NoZW1lKTtgO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KFwic2NyaXB0XCIsIHtcbiAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6ICEwLFxuICAgIG5vbmNlOiB0eXBlb2Ygd2luZG93ID4gXCJ1XCIgPyBsIDogXCJcIixcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiBgKGZ1bmN0aW9uKCkge1xudHJ5IHtcbiAgbGV0IGNvbG9yU2NoZW1lID0gJyc7XG4gIGNvbnN0IG1vZGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnJHtvfScpIHx8ICcke3R9JztcbiAgY29uc3QgZGFyayA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCcke2l9LWRhcmsnKSB8fCAnJHtufSc7XG4gIGNvbnN0IGxpZ2h0ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJyR7aX0tbGlnaHQnKSB8fCAnJHtyfSc7XG4gIGlmIChtb2RlID09PSAnc3lzdGVtJykge1xuICAgIC8vIGhhbmRsZSBzeXN0ZW0gbW9kZVxuICAgIGNvbnN0IG1xbCA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJyk7XG4gICAgaWYgKG1xbC5tYXRjaGVzKSB7XG4gICAgICBjb2xvclNjaGVtZSA9IGRhcmtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3JTY2hlbWUgPSBsaWdodFxuICAgIH1cbiAgfVxuICBpZiAobW9kZSA9PT0gJ2xpZ2h0Jykge1xuICAgIGNvbG9yU2NoZW1lID0gbGlnaHQ7XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkYXJrJykge1xuICAgIGNvbG9yU2NoZW1lID0gZGFyaztcbiAgfVxuICBpZiAoY29sb3JTY2hlbWUpIHtcbiAgICAke3V9XG4gIH1cbn0gY2F0Y2goZSl7fX0pKCk7YFxuICAgIH1cbiAgfSwgXCJtdWktY29sb3Itc2NoZW1lLWluaXRcIik7XG59XG5mdW5jdGlvbiBYaShlKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgdHlwZW9mIHdpbmRvdy5tYXRjaE1lZGlhID09IFwiZnVuY3Rpb25cIiAmJiBlID09PSBcInN5c3RlbVwiKVxuICAgIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikubWF0Y2hlcyA/IFwiZGFya1wiIDogXCJsaWdodFwiO1xufVxuZnVuY3Rpb24gY3MoZSwgdCkge1xuICBpZiAoZS5tb2RlID09PSBcImxpZ2h0XCIgfHwgZS5tb2RlID09PSBcInN5c3RlbVwiICYmIGUuc3lzdGVtTW9kZSA9PT0gXCJsaWdodFwiKVxuICAgIHJldHVybiB0KFwibGlnaHRcIik7XG4gIGlmIChlLm1vZGUgPT09IFwiZGFya1wiIHx8IGUubW9kZSA9PT0gXCJzeXN0ZW1cIiAmJiBlLnN5c3RlbU1vZGUgPT09IFwiZGFya1wiKVxuICAgIHJldHVybiB0KFwiZGFya1wiKTtcbn1cbmZ1bmN0aW9uIGVmKGUpIHtcbiAgcmV0dXJuIGNzKGUsICh0KSA9PiB7XG4gICAgaWYgKHQgPT09IFwibGlnaHRcIilcbiAgICAgIHJldHVybiBlLmxpZ2h0Q29sb3JTY2hlbWU7XG4gICAgaWYgKHQgPT09IFwiZGFya1wiKVxuICAgICAgcmV0dXJuIGUuZGFya0NvbG9yU2NoZW1lO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGVvKGUsIHQpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPiBcInVcIilcbiAgICByZXR1cm47XG4gIGxldCByO1xuICB0cnkge1xuICAgIHIgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShlKSB8fCB2b2lkIDAsIHIgfHwgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZSwgdCk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiByIHx8IHQ7XG59XG5mdW5jdGlvbiB0ZihlKSB7XG4gIGNvbnN0IHtcbiAgICBkZWZhdWx0TW9kZTogdCA9IFwibGlnaHRcIixcbiAgICBkZWZhdWx0TGlnaHRDb2xvclNjaGVtZTogcixcbiAgICBkZWZhdWx0RGFya0NvbG9yU2NoZW1lOiBuLFxuICAgIHN1cHBvcnRlZENvbG9yU2NoZW1lczogbyA9IFtdLFxuICAgIG1vZGVTdG9yYWdlS2V5OiBpID0gem8sXG4gICAgY29sb3JTY2hlbWVTdG9yYWdlS2V5OiBzID0gV28sXG4gICAgc3RvcmFnZVdpbmRvdzogYyA9IHR5cGVvZiB3aW5kb3cgPiBcInVcIiA/IHZvaWQgMCA6IHdpbmRvdyxcbiAgICBub1NzcjogbCA9ICExXG4gIH0gPSBlLCB1ID0gby5qb2luKFwiLFwiKSwgcCA9IG8ubGVuZ3RoID4gMSwgW20sIGddID0gQy51c2VTdGF0ZSgoKSA9PiB7XG4gICAgY29uc3QgYiA9IGVvKGksIHQpLCBoID0gZW8oYCR7c30tbGlnaHRgLCByKSwgdyA9IGVvKGAke3N9LWRhcmtgLCBuKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kZTogYixcbiAgICAgIHN5c3RlbU1vZGU6IFhpKGIpLFxuICAgICAgbGlnaHRDb2xvclNjaGVtZTogaCxcbiAgICAgIGRhcmtDb2xvclNjaGVtZTogd1xuICAgIH07XG4gIH0pLCBbeCwgeV0gPSBDLnVzZVN0YXRlKGwgfHwgIXApO1xuICBDLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgeSghMCk7XG4gIH0sIFtdKTtcbiAgY29uc3QgZiA9IGVmKG0pLCBTID0gQy51c2VDYWxsYmFjaygoYikgPT4ge1xuICAgIGcoKGgpID0+IHtcbiAgICAgIGlmIChiID09PSBoLm1vZGUpXG4gICAgICAgIHJldHVybiBoO1xuICAgICAgY29uc3QgdyA9IGIgPz8gdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGksIHcpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5oLFxuICAgICAgICBtb2RlOiB3LFxuICAgICAgICBzeXN0ZW1Nb2RlOiBYaSh3KVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSwgW2ksIHRdKSwgRSA9IEMudXNlQ2FsbGJhY2soKGIpID0+IHtcbiAgICBiID8gdHlwZW9mIGIgPT0gXCJzdHJpbmdcIiA/IGIgJiYgIXUuaW5jbHVkZXMoYikgPyBjb25zb2xlLmVycm9yKGBcXGAke2J9XFxgIGRvZXMgbm90IGV4aXN0IGluIFxcYHRoZW1lLmNvbG9yU2NoZW1lc1xcYC5gKSA6IGcoKGgpID0+IHtcbiAgICAgIGNvbnN0IHcgPSB7XG4gICAgICAgIC4uLmhcbiAgICAgIH07XG4gICAgICByZXR1cm4gY3MoaCwgKGspID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgJHtzfS0ke2t9YCwgYik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICAgIGsgPT09IFwibGlnaHRcIiAmJiAody5saWdodENvbG9yU2NoZW1lID0gYiksIGsgPT09IFwiZGFya1wiICYmICh3LmRhcmtDb2xvclNjaGVtZSA9IGIpO1xuICAgICAgfSksIHc7XG4gICAgfSkgOiBnKChoKSA9PiB7XG4gICAgICBjb25zdCB3ID0ge1xuICAgICAgICAuLi5oXG4gICAgICB9LCBrID0gYi5saWdodCA9PT0gbnVsbCA/IHIgOiBiLmxpZ2h0LCBMID0gYi5kYXJrID09PSBudWxsID8gbiA6IGIuZGFyaztcbiAgICAgIGlmIChrKVxuICAgICAgICBpZiAoIXUuaW5jbHVkZXMoaykpXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgXFxgJHtrfVxcYCBkb2VzIG5vdCBleGlzdCBpbiBcXGB0aGVtZS5jb2xvclNjaGVtZXNcXGAuYCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHcubGlnaHRDb2xvclNjaGVtZSA9IGs7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGAke3N9LWxpZ2h0YCwgayk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBpZiAoTClcbiAgICAgICAgaWYgKCF1LmluY2x1ZGVzKEwpKVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFxcYCR7TH1cXGAgZG9lcyBub3QgZXhpc3QgaW4gXFxgdGhlbWUuY29sb3JTY2hlbWVzXFxgLmApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB3LmRhcmtDb2xvclNjaGVtZSA9IEw7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGAke3N9LWRhcmtgLCBMKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiB3O1xuICAgIH0pIDogZygoaCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYCR7c30tbGlnaHRgLCByKSwgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYCR7c30tZGFya2AsIG4pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5oLFxuICAgICAgICBsaWdodENvbG9yU2NoZW1lOiByLFxuICAgICAgICBkYXJrQ29sb3JTY2hlbWU6IG5cbiAgICAgIH07XG4gICAgfSk7XG4gIH0sIFt1LCBzLCByLCBuXSksIFAgPSBDLnVzZUNhbGxiYWNrKChiKSA9PiB7XG4gICAgbS5tb2RlID09PSBcInN5c3RlbVwiICYmIGcoKGgpID0+IHtcbiAgICAgIGNvbnN0IHcgPSBiICE9IG51bGwgJiYgYi5tYXRjaGVzID8gXCJkYXJrXCIgOiBcImxpZ2h0XCI7XG4gICAgICByZXR1cm4gaC5zeXN0ZW1Nb2RlID09PSB3ID8gaCA6IHtcbiAgICAgICAgLi4uaCxcbiAgICAgICAgc3lzdGVtTW9kZTogd1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSwgW20ubW9kZV0pLCBUID0gQy51c2VSZWYoUCk7XG4gIHJldHVybiBULmN1cnJlbnQgPSBQLCBDLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubWF0Y2hNZWRpYSAhPSBcImZ1bmN0aW9uXCIgfHwgIXApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYiA9ICguLi53KSA9PiBULmN1cnJlbnQoLi4udyksIGggPSB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIik7XG4gICAgcmV0dXJuIGguYWRkTGlzdGVuZXIoYiksIGIoaCksICgpID0+IHtcbiAgICAgIGgucmVtb3ZlTGlzdGVuZXIoYik7XG4gICAgfTtcbiAgfSwgW3BdKSwgQy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjICYmIHApIHtcbiAgICAgIGNvbnN0IGIgPSAoaCkgPT4ge1xuICAgICAgICBjb25zdCB3ID0gaC5uZXdWYWx1ZTtcbiAgICAgICAgdHlwZW9mIGgua2V5ID09IFwic3RyaW5nXCIgJiYgaC5rZXkuc3RhcnRzV2l0aChzKSAmJiAoIXcgfHwgdS5tYXRjaCh3KSkgJiYgKGgua2V5LmVuZHNXaXRoKFwibGlnaHRcIikgJiYgRSh7XG4gICAgICAgICAgbGlnaHQ6IHdcbiAgICAgICAgfSksIGgua2V5LmVuZHNXaXRoKFwiZGFya1wiKSAmJiBFKHtcbiAgICAgICAgICBkYXJrOiB3XG4gICAgICAgIH0pKSwgaC5rZXkgPT09IGkgJiYgKCF3IHx8IFtcImxpZ2h0XCIsIFwiZGFya1wiLCBcInN5c3RlbVwiXS5pbmNsdWRlcyh3KSkgJiYgUyh3IHx8IHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBjLmFkZEV2ZW50TGlzdGVuZXIoXCJzdG9yYWdlXCIsIGIpLCAoKSA9PiB7XG4gICAgICAgIGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0b3JhZ2VcIiwgYik7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW0UsIFMsIGksIHMsIHUsIHQsIGMsIHBdKSwge1xuICAgIC4uLm0sXG4gICAgbW9kZTogeCA/IG0ubW9kZSA6IHZvaWQgMCxcbiAgICBzeXN0ZW1Nb2RlOiB4ID8gbS5zeXN0ZW1Nb2RlIDogdm9pZCAwLFxuICAgIGNvbG9yU2NoZW1lOiB4ID8gZiA6IHZvaWQgMCxcbiAgICBzZXRNb2RlOiBTLFxuICAgIHNldENvbG9yU2NoZW1lOiBFXG4gIH07XG59XG5jb25zdCByZiA9IFwiKnstd2Via2l0LXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7LW1vei10cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50Oy1vLXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7LW1zLXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7dHJhbnNpdGlvbjpub25lIWltcG9ydGFudH1cIjtcbmZ1bmN0aW9uIG5mKGUpIHtcbiAgY29uc3Qge1xuICAgIHRoZW1lSWQ6IHQsXG4gICAgLyoqXG4gICAgICogVGhpcyBgdGhlbWVgIG9iamVjdCBuZWVkcyB0byBmb2xsb3cgYSBjZXJ0YWluIHN0cnVjdHVyZSB0b1xuICAgICAqIGJlIHVzZWQgY29ycmVjdGx5IGJ5IHRoZSBmaW5lbCBgQ3NzVmFyc1Byb3ZpZGVyYC4gSXQgc2hvdWxkIGhhdmUgYVxuICAgICAqIGBjb2xvclNjaGVtZXNgIGtleSB3aXRoIHRoZSBsaWdodCBhbmQgZGFyayAoYW5kIGFueSBvdGhlcikgcGFsZXR0ZS5cbiAgICAgKiBJdCBzaG91bGQgYWxzbyBpZGVhbGx5IGhhdmUgYSB2YXJzIG9iamVjdCBjcmVhdGVkIHVzaW5nIGBwcmVwYXJlQ3NzVmFyc2AuXG4gICAgICovXG4gICAgdGhlbWU6IHIgPSB7fSxcbiAgICBtb2RlU3RvcmFnZUtleTogbiA9IHpvLFxuICAgIGNvbG9yU2NoZW1lU3RvcmFnZUtleTogbyA9IFdvLFxuICAgIGRpc2FibGVUcmFuc2l0aW9uT25DaGFuZ2U6IGkgPSAhMSxcbiAgICBkZWZhdWx0Q29sb3JTY2hlbWU6IHMsXG4gICAgcmVzb2x2ZVRoZW1lOiBjXG4gIH0gPSBlLCBsID0ge1xuICAgIGFsbENvbG9yU2NoZW1lczogW10sXG4gICAgY29sb3JTY2hlbWU6IHZvaWQgMCxcbiAgICBkYXJrQ29sb3JTY2hlbWU6IHZvaWQgMCxcbiAgICBsaWdodENvbG9yU2NoZW1lOiB2b2lkIDAsXG4gICAgbW9kZTogdm9pZCAwLFxuICAgIHNldENvbG9yU2NoZW1lOiAoKSA9PiB7XG4gICAgfSxcbiAgICBzZXRNb2RlOiAoKSA9PiB7XG4gICAgfSxcbiAgICBzeXN0ZW1Nb2RlOiB2b2lkIDBcbiAgfSwgdSA9IC8qIEBfX1BVUkVfXyAqLyBDLmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICh1LmRpc3BsYXlOYW1lID0gXCJDb2xvclNjaGVtZUNvbnRleHRcIik7XG4gIGNvbnN0IHAgPSAoKSA9PiBDLnVzZUNvbnRleHQodSkgfHwgbCwgbSA9IHt9LCBnID0ge307XG4gIGZ1bmN0aW9uIHgoRSkge1xuICAgIHZhciBZLCBvZSwgUmUsIHVlO1xuICAgIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuOiBQLFxuICAgICAgdGhlbWU6IFQsXG4gICAgICBtb2RlU3RvcmFnZUtleTogYiA9IG4sXG4gICAgICBjb2xvclNjaGVtZVN0b3JhZ2VLZXk6IGggPSBvLFxuICAgICAgZGlzYWJsZVRyYW5zaXRpb25PbkNoYW5nZTogdyA9IGksXG4gICAgICBzdG9yYWdlV2luZG93OiBrID0gdHlwZW9mIHdpbmRvdyA+IFwidVwiID8gdm9pZCAwIDogd2luZG93LFxuICAgICAgZG9jdW1lbnROb2RlOiBMID0gdHlwZW9mIGRvY3VtZW50ID4gXCJ1XCIgPyB2b2lkIDAgOiBkb2N1bWVudCxcbiAgICAgIGNvbG9yU2NoZW1lTm9kZTogQiA9IHR5cGVvZiBkb2N1bWVudCA+IFwidVwiID8gdm9pZCAwIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgZGlzYWJsZU5lc3RlZENvbnRleHQ6IGQgPSAhMSxcbiAgICAgIGRpc2FibGVTdHlsZVNoZWV0R2VuZXJhdGlvbjogQSA9ICExLFxuICAgICAgZGVmYXVsdE1vZGU6IEQgPSBcInN5c3RlbVwiLFxuICAgICAgbm9Tc3I6IGpcbiAgICB9ID0gRSwgVyA9IEMudXNlUmVmKCExKSwgeiA9IEZvKCksIFUgPSBDLnVzZUNvbnRleHQodSksIFYgPSAhIVUgJiYgIWQsIHRlID0gQy51c2VNZW1vKCgpID0+IFQgfHwgKHR5cGVvZiByID09IFwiZnVuY3Rpb25cIiA/IHIoKSA6IHIpLCBbVF0pLCBGID0gdGVbdF0sIFIgPSBGIHx8IHRlLCB7XG4gICAgICBjb2xvclNjaGVtZXM6IEkgPSBtLFxuICAgICAgY29tcG9uZW50czogSiA9IGcsXG4gICAgICBjc3NWYXJQcmVmaXg6IFFcbiAgICB9ID0gUiwgSCA9IE9iamVjdC5rZXlzKEkpLmZpbHRlcigoSykgPT4gISFJW0tdKS5qb2luKFwiLFwiKSwgWCA9IEMudXNlTWVtbygoKSA9PiBILnNwbGl0KFwiLFwiKSwgW0hdKSwgXyA9IHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBzIDogcy5saWdodCwgcSA9IHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBzIDogcy5kYXJrLCBHID0gSVtfXSAmJiBJW3FdID8gRCA6ICgob2UgPSAoWSA9IElbUi5kZWZhdWx0Q29sb3JTY2hlbWVdKSA9PSBudWxsID8gdm9pZCAwIDogWS5wYWxldHRlKSA9PSBudWxsID8gdm9pZCAwIDogb2UubW9kZSkgfHwgKChSZSA9IFIucGFsZXR0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IFJlLm1vZGUpLCB7XG4gICAgICBtb2RlOiByZSxcbiAgICAgIHNldE1vZGU6IFosXG4gICAgICBzeXN0ZW1Nb2RlOiBhZSxcbiAgICAgIGxpZ2h0Q29sb3JTY2hlbWU6IE8sXG4gICAgICBkYXJrQ29sb3JTY2hlbWU6IHllLFxuICAgICAgY29sb3JTY2hlbWU6IEVlLFxuICAgICAgc2V0Q29sb3JTY2hlbWU6IE1lXG4gICAgfSA9IHRmKHtcbiAgICAgIHN1cHBvcnRlZENvbG9yU2NoZW1lczogWCxcbiAgICAgIGRlZmF1bHRMaWdodENvbG9yU2NoZW1lOiBfLFxuICAgICAgZGVmYXVsdERhcmtDb2xvclNjaGVtZTogcSxcbiAgICAgIG1vZGVTdG9yYWdlS2V5OiBiLFxuICAgICAgY29sb3JTY2hlbWVTdG9yYWdlS2V5OiBoLFxuICAgICAgZGVmYXVsdE1vZGU6IEcsXG4gICAgICBzdG9yYWdlV2luZG93OiBrLFxuICAgICAgbm9Tc3I6IGpcbiAgICB9KTtcbiAgICBsZXQgUWUgPSByZSwgdmUgPSBFZTtcbiAgICBWICYmIChRZSA9IFUubW9kZSwgdmUgPSBVLmNvbG9yU2NoZW1lKTtcbiAgICBjb25zdCBQZSA9IEMudXNlTWVtbygoKSA9PiB7XG4gICAgICB2YXIgT2U7XG4gICAgICBjb25zdCBLID0gdmUgfHwgUi5kZWZhdWx0Q29sb3JTY2hlbWUsIGJlID0gKChPZSA9IFIuZ2VuZXJhdGVUaGVtZVZhcnMpID09IG51bGwgPyB2b2lkIDAgOiBPZS5jYWxsKFIpKSB8fCBSLnZhcnMsIHdlID0ge1xuICAgICAgICAuLi5SLFxuICAgICAgICBjb21wb25lbnRzOiBKLFxuICAgICAgICBjb2xvclNjaGVtZXM6IEksXG4gICAgICAgIGNzc1ZhclByZWZpeDogUSxcbiAgICAgICAgdmFyczogYmVcbiAgICAgIH07XG4gICAgICBpZiAodHlwZW9mIHdlLmdlbmVyYXRlU3BhY2luZyA9PSBcImZ1bmN0aW9uXCIgJiYgKHdlLnNwYWNpbmcgPSB3ZS5nZW5lcmF0ZVNwYWNpbmcoKSksIEspIHtcbiAgICAgICAgY29uc3QgY2UgPSBJW0tdO1xuICAgICAgICBjZSAmJiB0eXBlb2YgY2UgPT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhjZSkuZm9yRWFjaCgoSWUpID0+IHtcbiAgICAgICAgICBjZVtJZV0gJiYgdHlwZW9mIGNlW0llXSA9PSBcIm9iamVjdFwiID8gd2VbSWVdID0ge1xuICAgICAgICAgICAgLi4ud2VbSWVdLFxuICAgICAgICAgICAgLi4uY2VbSWVdXG4gICAgICAgICAgfSA6IHdlW0llXSA9IGNlW0llXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYyA/IGMod2UpIDogd2U7XG4gICAgfSwgW1IsIHZlLCBKLCBJLCBRXSksIHplID0gUi5jb2xvclNjaGVtZVNlbGVjdG9yO1xuICAgIEZ0KCgpID0+IHtcbiAgICAgIGlmICh2ZSAmJiBCICYmIHplICYmIHplICE9PSBcIm1lZGlhXCIpIHtcbiAgICAgICAgY29uc3QgSyA9IHplO1xuICAgICAgICBsZXQgYmUgPSB6ZTtcbiAgICAgICAgaWYgKEsgPT09IFwiY2xhc3NcIiAmJiAoYmUgPSBcIi4lc1wiKSwgSyA9PT0gXCJkYXRhXCIgJiYgKGJlID0gXCJbZGF0YS0lc11cIiksIEsgIT0gbnVsbCAmJiBLLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSAmJiAhSy5pbmNsdWRlcyhcIiVzXCIpICYmIChiZSA9IGBbJHtLfT1cIiVzXCJdYCksIGJlLnN0YXJ0c1dpdGgoXCIuXCIpKVxuICAgICAgICAgIEIuY2xhc3NMaXN0LnJlbW92ZSguLi5YLm1hcCgod2UpID0+IGJlLnN1YnN0cmluZygxKS5yZXBsYWNlKFwiJXNcIiwgd2UpKSksIEIuY2xhc3NMaXN0LmFkZChiZS5zdWJzdHJpbmcoMSkucmVwbGFjZShcIiVzXCIsIHZlKSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHdlID0gYmUucmVwbGFjZShcIiVzXCIsIHZlKS5tYXRjaCgvXFxbKFteXFxdXSspXFxdLyk7XG4gICAgICAgICAgaWYgKHdlKSB7XG4gICAgICAgICAgICBjb25zdCBbT2UsIGNlXSA9IHdlWzFdLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgIGNlIHx8IFguZm9yRWFjaCgoSWUpID0+IHtcbiAgICAgICAgICAgICAgQi5yZW1vdmVBdHRyaWJ1dGUoT2UucmVwbGFjZSh2ZSwgSWUpKTtcbiAgICAgICAgICAgIH0pLCBCLnNldEF0dHJpYnV0ZShPZSwgY2UgPyBjZS5yZXBsYWNlKC9cInwnL2csIFwiXCIpIDogXCJcIik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBCLnNldEF0dHJpYnV0ZShiZSwgdmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3ZlLCB6ZSwgQiwgWF0pLCBDLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgSztcbiAgICAgIGlmICh3ICYmIFcuY3VycmVudCAmJiBMKSB7XG4gICAgICAgIGNvbnN0IGJlID0gTC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIGJlLmFwcGVuZENoaWxkKEwuY3JlYXRlVGV4dE5vZGUocmYpKSwgTC5oZWFkLmFwcGVuZENoaWxkKGJlKSwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoTC5ib2R5KSwgSyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIEwuaGVhZC5yZW1vdmVDaGlsZChiZSk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KEspO1xuICAgICAgfTtcbiAgICB9LCBbdmUsIHcsIExdKSwgQy51c2VFZmZlY3QoKCkgPT4gKFcuY3VycmVudCA9ICEwLCAoKSA9PiB7XG4gICAgICBXLmN1cnJlbnQgPSAhMTtcbiAgICB9KSwgW10pO1xuICAgIGNvbnN0IExlID0gQy51c2VNZW1vKCgpID0+ICh7XG4gICAgICBhbGxDb2xvclNjaGVtZXM6IFgsXG4gICAgICBjb2xvclNjaGVtZTogdmUsXG4gICAgICBkYXJrQ29sb3JTY2hlbWU6IHllLFxuICAgICAgbGlnaHRDb2xvclNjaGVtZTogTyxcbiAgICAgIG1vZGU6IFFlLFxuICAgICAgc2V0Q29sb3JTY2hlbWU6IE1lLFxuICAgICAgc2V0TW9kZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gWiA6IChLKSA9PiB7XG4gICAgICAgIFBlLmNvbG9yU2NoZW1lU2VsZWN0b3IgPT09IFwibWVkaWFcIiAmJiBjb25zb2xlLmVycm9yKFtcIk1VSTogVGhlIGBzZXRNb2RlYCBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IGlmIGBjb2xvclNjaGVtZVNlbGVjdG9yYCBpcyBgbWVkaWFgIChgbWVkaWFgIGlzIHRoZSBkZWZhdWx0IHZhbHVlKS5cIiwgXCJUbyB0b2dnbGUgdGhlIG1vZGUgbWFudWFsbHksIHBsZWFzZSBjb25maWd1cmUgYGNvbG9yU2NoZW1lU2VsZWN0b3JgIHRvIHVzZSBhIGNsYXNzIG9yIGRhdGEgYXR0cmlidXRlLlwiLCBcIlRvIGxlYXJuIG1vcmUsIHZpc2l0IGh0dHBzOi8vbXVpLmNvbS9tYXRlcmlhbC11aS9jdXN0b21pemF0aW9uL2Nzcy10aGVtZS12YXJpYWJsZXMvY29uZmlndXJhdGlvbi8jdG9nZ2xpbmctZGFyay1tb2RlLW1hbnVhbGx5XCJdLmpvaW4oYFxuYCkpLCBaKEspO1xuICAgICAgfSxcbiAgICAgIHN5c3RlbU1vZGU6IGFlXG4gICAgfSksIFtYLCB2ZSwgeWUsIE8sIFFlLCBNZSwgWiwgYWUsIFBlLmNvbG9yU2NoZW1lU2VsZWN0b3JdKTtcbiAgICBsZXQgdiA9ICEwO1xuICAgIChBIHx8IFIuY3NzVmFyaWFibGVzID09PSAhMSB8fCBWICYmICh6ID09IG51bGwgPyB2b2lkIDAgOiB6LmNzc1ZhclByZWZpeCkgPT09IFEpICYmICh2ID0gITEpO1xuICAgIGNvbnN0IE0gPSAvKiBAX19QVVJFX18gKi8gTi5qc3hzKEMuRnJhZ21lbnQsIHtcbiAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIE4uanN4KFJyLCB7XG4gICAgICAgIHRoZW1lSWQ6IEYgPyB0IDogdm9pZCAwLFxuICAgICAgICB0aGVtZTogUGUsXG4gICAgICAgIGNoaWxkcmVuOiBQXG4gICAgICB9KSwgdiAmJiAvKiBAX19QVVJFX18gKi8gTi5qc3goX2EsIHtcbiAgICAgICAgc3R5bGVzOiAoKHVlID0gUGUuZ2VuZXJhdGVTdHlsZVNoZWV0cykgPT0gbnVsbCA/IHZvaWQgMCA6IHVlLmNhbGwoUGUpKSB8fCBbXVxuICAgICAgfSldXG4gICAgfSk7XG4gICAgcmV0dXJuIFYgPyBNIDogLyogQF9fUFVSRV9fICovIE4uanN4KHUuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBMZSxcbiAgICAgIGNoaWxkcmVuOiBNXG4gICAgfSk7XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICh4LnByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IHRyZWUuXG4gICAgICovXG4gICAgY2hpbGRyZW46IGEubm9kZSxcbiAgICAvKipcbiAgICAgKiBUaGUgbm9kZSB1c2VkIHRvIGF0dGFjaCB0aGUgY29sb3Itc2NoZW1lIGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIGNvbG9yU2NoZW1lTm9kZTogYS5hbnksXG4gICAgLyoqXG4gICAgICogbG9jYWxTdG9yYWdlIGtleSB1c2VkIHRvIHN0b3JlIGBjb2xvclNjaGVtZWBcbiAgICAgKi9cbiAgICBjb2xvclNjaGVtZVN0b3JhZ2VLZXk6IGEuc3RyaW5nLFxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IG1vZGUgd2hlbiB0aGUgc3RvcmFnZSBpcyBlbXB0eSxcbiAgICAgKiByZXF1aXJlIHRoZSB0aGVtZSB0byBoYXZlIGBjb2xvclNjaGVtZXNgIHdpdGggbGlnaHQgYW5kIGRhcmsuXG4gICAgICovXG4gICAgZGVmYXVsdE1vZGU6IGEuc3RyaW5nLFxuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIHByb3ZpZGVyIGNyZWF0ZXMgaXRzIG93biBjb250ZXh0IGFuZCBnZW5lcmF0ZSBzdHlsZXNoZWV0IGFzIGlmIGl0IGlzIGEgcm9vdCBgQ3NzVmFyc1Byb3ZpZGVyYC5cbiAgICAgKi9cbiAgICBkaXNhYmxlTmVzdGVkQ29udGV4dDogYS5ib29sLFxuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIHN0eWxlIHNoZWV0IHdvbid0IGJlIGdlbmVyYXRlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb250cm9sbGluZyBuZXN0ZWQgQ3NzVmFyc1Byb3ZpZGVyIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIGRpc2FibGVTdHlsZVNoZWV0R2VuZXJhdGlvbjogYS5ib29sLFxuICAgIC8qKlxuICAgICAqIERpc2FibGUgQ1NTIHRyYW5zaXRpb25zIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gbW9kZXMgb3IgY29sb3Igc2NoZW1lcy5cbiAgICAgKi9cbiAgICBkaXNhYmxlVHJhbnNpdGlvbk9uQ2hhbmdlOiBhLmJvb2wsXG4gICAgLyoqXG4gICAgICogVGhlIGRvY3VtZW50IHRvIGF0dGFjaCB0aGUgYXR0cmlidXRlIHRvLlxuICAgICAqL1xuICAgIGRvY3VtZW50Tm9kZTogYS5hbnksXG4gICAgLyoqXG4gICAgICogVGhlIGtleSBpbiB0aGUgbG9jYWwgc3RvcmFnZSB1c2VkIHRvIHN0b3JlIGN1cnJlbnQgY29sb3Igc2NoZW1lLlxuICAgICAqL1xuICAgIG1vZGVTdG9yYWdlS2V5OiBhLnN0cmluZyxcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBtb2RlIHdpbGwgYmUgdGhlIHNhbWUgdmFsdWUgYXMgdGhlIHN0b3JhZ2Ugd2l0aG91dCBhbiBleHRyYSByZXJlbmRlcmluZyBhZnRlciB0aGUgaHlkcmF0aW9uLlxuICAgICAqIFlvdSBzaG91bGQgdXNlIHRoaXMgb3B0aW9uIGluIGNvbmp1Y3Rpb24gd2l0aCBgSW5pdENvbG9yU2NoZW1lU2NyaXB0YCBjb21wb25lbnQuXG4gICAgICovXG4gICAgbm9Tc3I6IGEuYm9vbCxcbiAgICAvKipcbiAgICAgKiBUaGUgd2luZG93IHRoYXQgYXR0YWNoZXMgdGhlICdzdG9yYWdlJyBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAZGVmYXVsdCB3aW5kb3dcbiAgICAgKi9cbiAgICBzdG9yYWdlV2luZG93OiBhLmFueSxcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsY3VsYXRlZCB0aGVtZSBvYmplY3QgdGhhdCB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIGNvbnRleHQuXG4gICAgICovXG4gICAgdGhlbWU6IGEub2JqZWN0XG4gIH0pO1xuICBjb25zdCB5ID0gdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/IHMgOiBzLmxpZ2h0LCBmID0gdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/IHMgOiBzLmRhcms7XG4gIHJldHVybiB7XG4gICAgQ3NzVmFyc1Byb3ZpZGVyOiB4LFxuICAgIHVzZUNvbG9yU2NoZW1lOiBwLFxuICAgIGdldEluaXRDb2xvclNjaGVtZVNjcmlwdDogKEUpID0+IFp1KHtcbiAgICAgIGNvbG9yU2NoZW1lU3RvcmFnZUtleTogbyxcbiAgICAgIGRlZmF1bHRMaWdodENvbG9yU2NoZW1lOiB5LFxuICAgICAgZGVmYXVsdERhcmtDb2xvclNjaGVtZTogZixcbiAgICAgIG1vZGVTdG9yYWdlS2V5OiBuLFxuICAgICAgLi4uRVxuICAgIH0pXG4gIH07XG59XG5mdW5jdGlvbiBvZihlID0gXCJcIikge1xuICBmdW5jdGlvbiB0KC4uLm4pIHtcbiAgICBpZiAoIW4ubGVuZ3RoKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgY29uc3QgbyA9IG5bMF07XG4gICAgcmV0dXJuIHR5cGVvZiBvID09IFwic3RyaW5nXCIgJiYgIW8ubWF0Y2goLygjfFxcKHxcXCl8KC0/KFxcZCpcXC4pP1xcZCspKHB4fGVtfCV8ZXh8Y2h8cmVtfHZ3fHZofHZtaW58dm1heHxjbXxtbXxpbnxwdHxwYykpfF4oLT8oXFxkKlxcLik/XFxkKykkfChcXGQrIFxcZCsgXFxkKykvKSA/IGAsIHZhcigtLSR7ZSA/IGAke2V9LWAgOiBcIlwifSR7b30ke3QoLi4ubi5zbGljZSgxKSl9KWAgOiBgLCAke299YDtcbiAgfVxuICByZXR1cm4gKG4sIC4uLm8pID0+IGB2YXIoLS0ke2UgPyBgJHtlfS1gIDogXCJcIn0ke259JHt0KC4uLm8pfSlgO1xufVxuY29uc3QgSmkgPSAoZSwgdCwgciwgbiA9IFtdKSA9PiB7XG4gIGxldCBvID0gZTtcbiAgdC5mb3JFYWNoKChpLCBzKSA9PiB7XG4gICAgcyA9PT0gdC5sZW5ndGggLSAxID8gQXJyYXkuaXNBcnJheShvKSA/IG9bTnVtYmVyKGkpXSA9IHIgOiBvICYmIHR5cGVvZiBvID09IFwib2JqZWN0XCIgJiYgKG9baV0gPSByKSA6IG8gJiYgdHlwZW9mIG8gPT0gXCJvYmplY3RcIiAmJiAob1tpXSB8fCAob1tpXSA9IG4uaW5jbHVkZXMoaSkgPyBbXSA6IHt9KSwgbyA9IG9baV0pO1xuICB9KTtcbn0sIGFmID0gKGUsIHQsIHIpID0+IHtcbiAgZnVuY3Rpb24gbihvLCBpID0gW10sIHMgPSBbXSkge1xuICAgIE9iamVjdC5lbnRyaWVzKG8pLmZvckVhY2goKFtjLCBsXSkgPT4ge1xuICAgICAgKCFyIHx8ICFyKFsuLi5pLCBjXSkpICYmIGwgIT0gbnVsbCAmJiAodHlwZW9mIGwgPT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhsKS5sZW5ndGggPiAwID8gbihsLCBbLi4uaSwgY10sIEFycmF5LmlzQXJyYXkobCkgPyBbLi4ucywgY10gOiBzKSA6IHQoWy4uLmksIGNdLCBsLCBzKSk7XG4gICAgfSk7XG4gIH1cbiAgbihlKTtcbn0sIHNmID0gKGUsIHQpID0+IHR5cGVvZiB0ID09IFwibnVtYmVyXCIgPyBbXCJsaW5lSGVpZ2h0XCIsIFwiZm9udFdlaWdodFwiLCBcIm9wYWNpdHlcIiwgXCJ6SW5kZXhcIl0uc29tZSgobikgPT4gZS5pbmNsdWRlcyhuKSkgfHwgZVtlLmxlbmd0aCAtIDFdLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJvcGFjaXR5XCIpID8gdCA6IGAke3R9cHhgIDogdDtcbmZ1bmN0aW9uIHRvKGUsIHQpIHtcbiAgY29uc3Qge1xuICAgIHByZWZpeDogcixcbiAgICBzaG91bGRTa2lwR2VuZXJhdGluZ1ZhcjogblxuICB9ID0gdCB8fCB7fSwgbyA9IHt9LCBpID0ge30sIHMgPSB7fTtcbiAgcmV0dXJuIGFmKFxuICAgIGUsXG4gICAgKGMsIGwsIHUpID0+IHtcbiAgICAgIGlmICgodHlwZW9mIGwgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbCA9PSBcIm51bWJlclwiKSAmJiAoIW4gfHwgIW4oYywgbCkpKSB7XG4gICAgICAgIGNvbnN0IHAgPSBgLS0ke3IgPyBgJHtyfS1gIDogXCJcIn0ke2Muam9pbihcIi1cIil9YCwgbSA9IHNmKGMsIGwpO1xuICAgICAgICBPYmplY3QuYXNzaWduKG8sIHtcbiAgICAgICAgICBbcF06IG1cbiAgICAgICAgfSksIEppKGksIGMsIGB2YXIoJHtwfSlgLCB1KSwgSmkocywgYywgYHZhcigke3B9LCAke219KWAsIHUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgKGMpID0+IGNbMF0gPT09IFwidmFyc1wiXG4gICAgLy8gc2tpcCAndmFycy8qJyBwYXRoc1xuICApLCB7XG4gICAgY3NzOiBvLFxuICAgIHZhcnM6IGksXG4gICAgdmFyc1dpdGhEZWZhdWx0czogc1xuICB9O1xufVxuZnVuY3Rpb24gY2YoZSwgdCA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBnZXRTZWxlY3RvcjogciA9IFMsXG4gICAgZGlzYWJsZUNzc0NvbG9yU2NoZW1lOiBuLFxuICAgIGNvbG9yU2NoZW1lU2VsZWN0b3I6IG9cbiAgfSA9IHQsIHtcbiAgICBjb2xvclNjaGVtZXM6IGkgPSB7fSxcbiAgICBjb21wb25lbnRzOiBzLFxuICAgIGRlZmF1bHRDb2xvclNjaGVtZTogYyA9IFwibGlnaHRcIixcbiAgICAuLi5sXG4gIH0gPSBlLCB7XG4gICAgdmFyczogdSxcbiAgICBjc3M6IHAsXG4gICAgdmFyc1dpdGhEZWZhdWx0czogbVxuICB9ID0gdG8obCwgdCk7XG4gIGxldCBnID0gbTtcbiAgY29uc3QgeCA9IHt9LCB7XG4gICAgW2NdOiB5LFxuICAgIC4uLmZcbiAgfSA9IGk7XG4gIGlmIChPYmplY3QuZW50cmllcyhmIHx8IHt9KS5mb3JFYWNoKChbVCwgYl0pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB2YXJzOiBoLFxuICAgICAgY3NzOiB3LFxuICAgICAgdmFyc1dpdGhEZWZhdWx0czoga1xuICAgIH0gPSB0byhiLCB0KTtcbiAgICBnID0gdHQoZywgayksIHhbVF0gPSB7XG4gICAgICBjc3M6IHcsXG4gICAgICB2YXJzOiBoXG4gICAgfTtcbiAgfSksIHkpIHtcbiAgICBjb25zdCB7XG4gICAgICBjc3M6IFQsXG4gICAgICB2YXJzOiBiLFxuICAgICAgdmFyc1dpdGhEZWZhdWx0czogaFxuICAgIH0gPSB0byh5LCB0KTtcbiAgICBnID0gdHQoZywgaCksIHhbY10gPSB7XG4gICAgICBjc3M6IFQsXG4gICAgICB2YXJzOiBiXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBTKFQsIGIpIHtcbiAgICB2YXIgdywgaztcbiAgICBsZXQgaCA9IG87XG4gICAgaWYgKG8gPT09IFwiY2xhc3NcIiAmJiAoaCA9IFwiLiVzXCIpLCBvID09PSBcImRhdGFcIiAmJiAoaCA9IFwiW2RhdGEtJXNdXCIpLCBvICE9IG51bGwgJiYgby5zdGFydHNXaXRoKFwiZGF0YS1cIikgJiYgIW8uaW5jbHVkZXMoXCIlc1wiKSAmJiAoaCA9IGBbJHtvfT1cIiVzXCJdYCksIFQpIHtcbiAgICAgIGlmIChoID09PSBcIm1lZGlhXCIpXG4gICAgICAgIHJldHVybiBlLmRlZmF1bHRDb2xvclNjaGVtZSA9PT0gVCA/IFwiOnJvb3RcIiA6IHtcbiAgICAgICAgICBbYEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6ICR7KChrID0gKHcgPSBpW1RdKSA9PSBudWxsID8gdm9pZCAwIDogdy5wYWxldHRlKSA9PSBudWxsID8gdm9pZCAwIDogay5tb2RlKSB8fCBUfSlgXToge1xuICAgICAgICAgICAgXCI6cm9vdFwiOiBiXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgaWYgKGgpXG4gICAgICAgIHJldHVybiBlLmRlZmF1bHRDb2xvclNjaGVtZSA9PT0gVCA/IGA6cm9vdCwgJHtoLnJlcGxhY2UoXCIlc1wiLCBTdHJpbmcoVCkpfWAgOiBoLnJlcGxhY2UoXCIlc1wiLCBTdHJpbmcoVCkpO1xuICAgIH1cbiAgICByZXR1cm4gXCI6cm9vdFwiO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFyczogZyxcbiAgICBnZW5lcmF0ZVRoZW1lVmFyczogKCkgPT4ge1xuICAgICAgbGV0IFQgPSB7XG4gICAgICAgIC4uLnVcbiAgICAgIH07XG4gICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoeCkuZm9yRWFjaCgoWywge1xuICAgICAgICB2YXJzOiBiXG4gICAgICB9XSkgPT4ge1xuICAgICAgICBUID0gdHQoVCwgYik7XG4gICAgICB9KSwgVDtcbiAgICB9LFxuICAgIGdlbmVyYXRlU3R5bGVTaGVldHM6ICgpID0+IHtcbiAgICAgIHZhciBMLCBCO1xuICAgICAgY29uc3QgVCA9IFtdLCBiID0gZS5kZWZhdWx0Q29sb3JTY2hlbWUgfHwgXCJsaWdodFwiO1xuICAgICAgZnVuY3Rpb24gaChkLCBBKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKEEpLmxlbmd0aCAmJiBULnB1c2godHlwZW9mIGQgPT0gXCJzdHJpbmdcIiA/IHtcbiAgICAgICAgICBbZF06IHtcbiAgICAgICAgICAgIC4uLkFcbiAgICAgICAgICB9XG4gICAgICAgIH0gOiBkKTtcbiAgICAgIH1cbiAgICAgIGgocih2b2lkIDAsIHtcbiAgICAgICAgLi4ucFxuICAgICAgfSksIHApO1xuICAgICAgY29uc3Qge1xuICAgICAgICBbYl06IHcsXG4gICAgICAgIC4uLmtcbiAgICAgIH0gPSB4O1xuICAgICAgaWYgKHcpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNzczogZFxuICAgICAgICB9ID0gdywgQSA9IChCID0gKEwgPSBpW2JdKSA9PSBudWxsID8gdm9pZCAwIDogTC5wYWxldHRlKSA9PSBudWxsID8gdm9pZCAwIDogQi5tb2RlLCBEID0gIW4gJiYgQSA/IHtcbiAgICAgICAgICBjb2xvclNjaGVtZTogQSxcbiAgICAgICAgICAuLi5kXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgLi4uZFxuICAgICAgICB9O1xuICAgICAgICBoKHIoYiwge1xuICAgICAgICAgIC4uLkRcbiAgICAgICAgfSksIEQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGspLmZvckVhY2goKFtkLCB7XG4gICAgICAgIGNzczogQVxuICAgICAgfV0pID0+IHtcbiAgICAgICAgdmFyIFcsIHo7XG4gICAgICAgIGNvbnN0IEQgPSAoeiA9IChXID0gaVtkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IFcucGFsZXR0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHoubW9kZSwgaiA9ICFuICYmIEQgPyB7XG4gICAgICAgICAgY29sb3JTY2hlbWU6IEQsXG4gICAgICAgICAgLi4uQVxuICAgICAgICB9IDoge1xuICAgICAgICAgIC4uLkFcbiAgICAgICAgfTtcbiAgICAgICAgaChyKGQsIHtcbiAgICAgICAgICAuLi5qXG4gICAgICAgIH0pLCBqKTtcbiAgICAgIH0pLCBUO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGxmKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gZSA9PT0gXCJtZWRpYVwiID8gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiByICE9PSBcImxpZ2h0XCIgJiYgciAhPT0gXCJkYXJrXCIgJiYgY29uc29sZS5lcnJvcihgTVVJOiBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lKSBzdXBwb3J0cyBvbmx5ICdsaWdodCcgb3IgJ2RhcmsnLCBidXQgcmVjZWl2ZSAnJHtyfScuYCksIGBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiAke3J9KWApIDogZSA/IGUuc3RhcnRzV2l0aChcImRhdGEtXCIpICYmICFlLmluY2x1ZGVzKFwiJXNcIikgPyBgWyR7ZX09XCIke3J9XCJdICZgIDogZSA9PT0gXCJjbGFzc1wiID8gYC4ke3J9ICZgIDogZSA9PT0gXCJkYXRhXCIgPyBgW2RhdGEtJHtyfV0gJmAgOiBgJHtlLnJlcGxhY2UoXCIlc1wiLCByKX0gJmAgOiBcIiZcIjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGxzKCkge1xuICByZXR1cm4ge1xuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byBzdHlsZSB0aGUgdGV4dC5cbiAgICB0ZXh0OiB7XG4gICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgdGV4dC5cbiAgICAgIHByaW1hcnk6IFwicmdiYSgwLCAwLCAwLCAwLjg3KVwiLFxuICAgICAgLy8gU2Vjb25kYXJ5IHRleHQuXG4gICAgICBzZWNvbmRhcnk6IFwicmdiYSgwLCAwLCAwLCAwLjYpXCIsXG4gICAgICAvLyBEaXNhYmxlZCB0ZXh0IGhhdmUgZXZlbiBsb3dlciB2aXN1YWwgcHJvbWluZW5jZS5cbiAgICAgIGRpc2FibGVkOiBcInJnYmEoMCwgMCwgMCwgMC4zOClcIlxuICAgIH0sXG4gICAgLy8gVGhlIGNvbG9yIHVzZWQgdG8gZGl2aWRlIGRpZmZlcmVudCBlbGVtZW50cy5cbiAgICBkaXZpZGVyOiBcInJnYmEoMCwgMCwgMCwgMC4xMilcIixcbiAgICAvLyBUaGUgYmFja2dyb3VuZCBjb2xvcnMgdXNlZCB0byBzdHlsZSB0aGUgc3VyZmFjZXMuXG4gICAgLy8gQ29uc2lzdGVuY3kgYmV0d2VlbiB0aGVzZSB2YWx1ZXMgaXMgaW1wb3J0YW50LlxuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgIHBhcGVyOiBFci53aGl0ZSxcbiAgICAgIGRlZmF1bHQ6IEVyLndoaXRlXG4gICAgfSxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gc3R5bGUgdGhlIGFjdGlvbiBlbGVtZW50cy5cbiAgICBhY3Rpb246IHtcbiAgICAgIC8vIFRoZSBjb2xvciBvZiBhbiBhY3RpdmUgYWN0aW9uIGxpa2UgYW4gaWNvbiBidXR0b24uXG4gICAgICBhY3RpdmU6IFwicmdiYSgwLCAwLCAwLCAwLjU0KVwiLFxuICAgICAgLy8gVGhlIGNvbG9yIG9mIGFuIGhvdmVyZWQgYWN0aW9uLlxuICAgICAgaG92ZXI6IFwicmdiYSgwLCAwLCAwLCAwLjA0KVwiLFxuICAgICAgaG92ZXJPcGFjaXR5OiAwLjA0LFxuICAgICAgLy8gVGhlIGNvbG9yIG9mIGEgc2VsZWN0ZWQgYWN0aW9uLlxuICAgICAgc2VsZWN0ZWQ6IFwicmdiYSgwLCAwLCAwLCAwLjA4KVwiLFxuICAgICAgc2VsZWN0ZWRPcGFjaXR5OiAwLjA4LFxuICAgICAgLy8gVGhlIGNvbG9yIG9mIGEgZGlzYWJsZWQgYWN0aW9uLlxuICAgICAgZGlzYWJsZWQ6IFwicmdiYSgwLCAwLCAwLCAwLjI2KVwiLFxuICAgICAgLy8gVGhlIGJhY2tncm91bmQgY29sb3Igb2YgYSBkaXNhYmxlZCBhY3Rpb24uXG4gICAgICBkaXNhYmxlZEJhY2tncm91bmQ6IFwicmdiYSgwLCAwLCAwLCAwLjEyKVwiLFxuICAgICAgZGlzYWJsZWRPcGFjaXR5OiAwLjM4LFxuICAgICAgZm9jdXM6IFwicmdiYSgwLCAwLCAwLCAwLjEyKVwiLFxuICAgICAgZm9jdXNPcGFjaXR5OiAwLjEyLFxuICAgICAgYWN0aXZhdGVkT3BhY2l0eTogMC4xMlxuICAgIH1cbiAgfTtcbn1cbmNvbnN0IHVmID0gbHMoKTtcbmZ1bmN0aW9uIHVzKCkge1xuICByZXR1cm4ge1xuICAgIHRleHQ6IHtcbiAgICAgIHByaW1hcnk6IEVyLndoaXRlLFxuICAgICAgc2Vjb25kYXJ5OiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KVwiLFxuICAgICAgZGlzYWJsZWQ6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpXCIsXG4gICAgICBpY29uOiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KVwiXG4gICAgfSxcbiAgICBkaXZpZGVyOiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMilcIixcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICBwYXBlcjogXCIjMTIxMjEyXCIsXG4gICAgICBkZWZhdWx0OiBcIiMxMjEyMTJcIlxuICAgIH0sXG4gICAgYWN0aW9uOiB7XG4gICAgICBhY3RpdmU6IEVyLndoaXRlLFxuICAgICAgaG92ZXI6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA4KVwiLFxuICAgICAgaG92ZXJPcGFjaXR5OiAwLjA4LFxuICAgICAgc2VsZWN0ZWQ6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE2KVwiLFxuICAgICAgc2VsZWN0ZWRPcGFjaXR5OiAwLjE2LFxuICAgICAgZGlzYWJsZWQ6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpXCIsXG4gICAgICBkaXNhYmxlZEJhY2tncm91bmQ6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKVwiLFxuICAgICAgZGlzYWJsZWRPcGFjaXR5OiAwLjM4LFxuICAgICAgZm9jdXM6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKVwiLFxuICAgICAgZm9jdXNPcGFjaXR5OiAwLjEyLFxuICAgICAgYWN0aXZhdGVkT3BhY2l0eTogMC4yNFxuICAgIH1cbiAgfTtcbn1cbmNvbnN0IFFpID0gdXMoKTtcbmZ1bmN0aW9uIFppKGUsIHQsIHIsIG4pIHtcbiAgY29uc3QgbyA9IG4ubGlnaHQgfHwgbiwgaSA9IG4uZGFyayB8fCBuICogMS41O1xuICBlW3RdIHx8IChlLmhhc093blByb3BlcnR5KHIpID8gZVt0XSA9IGVbcl0gOiB0ID09PSBcImxpZ2h0XCIgPyBlLmxpZ2h0ID0gX28oZS5tYWluLCBvKSA6IHQgPT09IFwiZGFya1wiICYmIChlLmRhcmsgPSBJbyhlLm1haW4sIGkpKSk7XG59XG5mdW5jdGlvbiBmZihlID0gXCJsaWdodFwiKSB7XG4gIHJldHVybiBlID09PSBcImRhcmtcIiA/IHtcbiAgICBtYWluOiBZdFsyMDBdLFxuICAgIGxpZ2h0OiBZdFs1MF0sXG4gICAgZGFyazogWXRbNDAwXVxuICB9IDoge1xuICAgIG1haW46IFl0WzcwMF0sXG4gICAgbGlnaHQ6IFl0WzQwMF0sXG4gICAgZGFyazogWXRbODAwXVxuICB9O1xufVxuZnVuY3Rpb24gZGYoZSA9IFwibGlnaHRcIikge1xuICByZXR1cm4gZSA9PT0gXCJkYXJrXCIgPyB7XG4gICAgbWFpbjogVXRbMjAwXSxcbiAgICBsaWdodDogVXRbNTBdLFxuICAgIGRhcms6IFV0WzQwMF1cbiAgfSA6IHtcbiAgICBtYWluOiBVdFs1MDBdLFxuICAgIGxpZ2h0OiBVdFszMDBdLFxuICAgIGRhcms6IFV0WzcwMF1cbiAgfTtcbn1cbmZ1bmN0aW9uIHBmKGUgPSBcImxpZ2h0XCIpIHtcbiAgcmV0dXJuIGUgPT09IFwiZGFya1wiID8ge1xuICAgIG1haW46IFd0WzUwMF0sXG4gICAgbGlnaHQ6IFd0WzMwMF0sXG4gICAgZGFyazogV3RbNzAwXVxuICB9IDoge1xuICAgIG1haW46IFd0WzcwMF0sXG4gICAgbGlnaHQ6IFd0WzQwMF0sXG4gICAgZGFyazogV3RbODAwXVxuICB9O1xufVxuZnVuY3Rpb24gbWYoZSA9IFwibGlnaHRcIikge1xuICByZXR1cm4gZSA9PT0gXCJkYXJrXCIgPyB7XG4gICAgbWFpbjogSHRbNDAwXSxcbiAgICBsaWdodDogSHRbMzAwXSxcbiAgICBkYXJrOiBIdFs3MDBdXG4gIH0gOiB7XG4gICAgbWFpbjogSHRbNzAwXSxcbiAgICBsaWdodDogSHRbNTAwXSxcbiAgICBkYXJrOiBIdFs5MDBdXG4gIH07XG59XG5mdW5jdGlvbiBoZihlID0gXCJsaWdodFwiKSB7XG4gIHJldHVybiBlID09PSBcImRhcmtcIiA/IHtcbiAgICBtYWluOiBxdFs0MDBdLFxuICAgIGxpZ2h0OiBxdFszMDBdLFxuICAgIGRhcms6IHF0WzcwMF1cbiAgfSA6IHtcbiAgICBtYWluOiBxdFs4MDBdLFxuICAgIGxpZ2h0OiBxdFs1MDBdLFxuICAgIGRhcms6IHF0WzkwMF1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdmKGUgPSBcImxpZ2h0XCIpIHtcbiAgcmV0dXJuIGUgPT09IFwiZGFya1wiID8ge1xuICAgIG1haW46IGZyWzQwMF0sXG4gICAgbGlnaHQ6IGZyWzMwMF0sXG4gICAgZGFyazogZnJbNzAwXVxuICB9IDoge1xuICAgIG1haW46IFwiI2VkNmMwMlwiLFxuICAgIC8vIGNsb3Nlc3QgdG8gb3JhbmdlWzgwMF0gdGhhdCBwYXNzIDM6MS5cbiAgICBsaWdodDogZnJbNTAwXSxcbiAgICBkYXJrOiBmcls5MDBdXG4gIH07XG59XG5mdW5jdGlvbiBVbyhlKSB7XG4gIGNvbnN0IHtcbiAgICBtb2RlOiB0ID0gXCJsaWdodFwiLFxuICAgIGNvbnRyYXN0VGhyZXNob2xkOiByID0gMyxcbiAgICB0b25hbE9mZnNldDogbiA9IDAuMixcbiAgICAuLi5vXG4gIH0gPSBlLCBpID0gZS5wcmltYXJ5IHx8IGZmKHQpLCBzID0gZS5zZWNvbmRhcnkgfHwgZGYodCksIGMgPSBlLmVycm9yIHx8IHBmKHQpLCBsID0gZS5pbmZvIHx8IG1mKHQpLCB1ID0gZS5zdWNjZXNzIHx8IGhmKHQpLCBwID0gZS53YXJuaW5nIHx8IGdmKHQpO1xuICBmdW5jdGlvbiBtKGYpIHtcbiAgICBjb25zdCBTID0gRmkoZiwgUWkudGV4dC5wcmltYXJ5KSA+PSByID8gUWkudGV4dC5wcmltYXJ5IDogdWYudGV4dC5wcmltYXJ5O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IEUgPSBGaShmLCBTKTtcbiAgICAgIEUgPCAzICYmIGNvbnNvbGUuZXJyb3IoW2BNVUk6IFRoZSBjb250cmFzdCByYXRpbyBvZiAke0V9OjEgZm9yICR7U30gb24gJHtmfWAsIFwiZmFsbHMgYmVsb3cgdGhlIFdDQUcgcmVjb21tZW5kZWQgYWJzb2x1dGUgbWluaW11bSBjb250cmFzdCByYXRpbyBvZiAzOjEuXCIsIFwiaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jdmlzdWFsLWF1ZGlvLWNvbnRyYXN0LWNvbnRyYXN0XCJdLmpvaW4oYFxuYCkpO1xuICAgIH1cbiAgICByZXR1cm4gUztcbiAgfVxuICBjb25zdCBnID0gKHtcbiAgICBjb2xvcjogZixcbiAgICBuYW1lOiBTLFxuICAgIG1haW5TaGFkZTogRSA9IDUwMCxcbiAgICBsaWdodFNoYWRlOiBQID0gMzAwLFxuICAgIGRhcmtTaGFkZTogVCA9IDcwMFxuICB9KSA9PiB7XG4gICAgaWYgKGYgPSB7XG4gICAgICAuLi5mXG4gICAgfSwgIWYubWFpbiAmJiBmW0VdICYmIChmLm1haW4gPSBmW0VdKSwgIWYuaGFzT3duUHJvcGVydHkoXCJtYWluXCIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGBNVUk6IFRoZSBjb2xvciR7UyA/IGAgKCR7U30pYCA6IFwiXCJ9IHByb3ZpZGVkIHRvIGF1Z21lbnRDb2xvcihjb2xvcikgaXMgaW52YWxpZC5cblRoZSBjb2xvciBvYmplY3QgbmVlZHMgdG8gaGF2ZSBhIFxcYG1haW5cXGAgcHJvcGVydHkgb3IgYSBcXGAke0V9XFxgIHByb3BlcnR5LmAgOiBrdCgxMSwgUyA/IGAgKCR7U30pYCA6IFwiXCIsIEUpKTtcbiAgICBpZiAodHlwZW9mIGYubWFpbiAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGBNVUk6IFRoZSBjb2xvciR7UyA/IGAgKCR7U30pYCA6IFwiXCJ9IHByb3ZpZGVkIHRvIGF1Z21lbnRDb2xvcihjb2xvcikgaXMgaW52YWxpZC5cblxcYGNvbG9yLm1haW5cXGAgc2hvdWxkIGJlIGEgc3RyaW5nLCBidXQgXFxgJHtKU09OLnN0cmluZ2lmeShmLm1haW4pfVxcYCB3YXMgcHJvdmlkZWQgaW5zdGVhZC5cblxuRGlkIHlvdSBpbnRlbmQgdG8gdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGFwcHJvYWNoZXM/XG5cbmltcG9ydCB7IGdyZWVuIH0gZnJvbSBcIkBtdWkvbWF0ZXJpYWwvY29sb3JzXCI7XG5cbmNvbnN0IHRoZW1lMSA9IGNyZWF0ZVRoZW1lKHsgcGFsZXR0ZToge1xuICBwcmltYXJ5OiBncmVlbixcbn0gfSk7XG5cbmNvbnN0IHRoZW1lMiA9IGNyZWF0ZVRoZW1lKHsgcGFsZXR0ZToge1xuICBwcmltYXJ5OiB7IG1haW46IGdyZWVuWzUwMF0gfSxcbn0gfSk7YCA6IGt0KDEyLCBTID8gYCAoJHtTfSlgIDogXCJcIiwgSlNPTi5zdHJpbmdpZnkoZi5tYWluKSkpO1xuICAgIHJldHVybiBaaShmLCBcImxpZ2h0XCIsIFAsIG4pLCBaaShmLCBcImRhcmtcIiwgVCwgbiksIGYuY29udHJhc3RUZXh0IHx8IChmLmNvbnRyYXN0VGV4dCA9IG0oZi5tYWluKSksIGY7XG4gIH07XG4gIGxldCB4O1xuICByZXR1cm4gdCA9PT0gXCJsaWdodFwiID8geCA9IGxzKCkgOiB0ID09PSBcImRhcmtcIiAmJiAoeCA9IHVzKCkpLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHggfHwgY29uc29sZS5lcnJvcihgTVVJOiBUaGUgcGFsZXR0ZSBtb2RlIFxcYCR7dH1cXGAgaXMgbm90IHN1cHBvcnRlZC5gKSksIHR0KHtcbiAgICAvLyBBIGNvbGxlY3Rpb24gb2YgY29tbW9uIGNvbG9ycy5cbiAgICBjb21tb246IHtcbiAgICAgIC4uLkVyXG4gICAgfSxcbiAgICAvLyBwcmV2ZW50IG11dGFibGUgb2JqZWN0LlxuICAgIC8vIFRoZSBwYWxldHRlIG1vZGUsIGNhbiBiZSBsaWdodCBvciBkYXJrLlxuICAgIG1vZGU6IHQsXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHJlcHJlc2VudCBwcmltYXJ5IGludGVyZmFjZSBlbGVtZW50cyBmb3IgYSB1c2VyLlxuICAgIHByaW1hcnk6IGcoe1xuICAgICAgY29sb3I6IGksXG4gICAgICBuYW1lOiBcInByaW1hcnlcIlxuICAgIH0pLFxuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byByZXByZXNlbnQgc2Vjb25kYXJ5IGludGVyZmFjZSBlbGVtZW50cyBmb3IgYSB1c2VyLlxuICAgIHNlY29uZGFyeTogZyh7XG4gICAgICBjb2xvcjogcyxcbiAgICAgIG5hbWU6IFwic2Vjb25kYXJ5XCIsXG4gICAgICBtYWluU2hhZGU6IFwiQTQwMFwiLFxuICAgICAgbGlnaHRTaGFkZTogXCJBMjAwXCIsXG4gICAgICBkYXJrU2hhZGU6IFwiQTcwMFwiXG4gICAgfSksXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHJlcHJlc2VudCBpbnRlcmZhY2UgZWxlbWVudHMgdGhhdCB0aGUgdXNlciBzaG91bGQgYmUgbWFkZSBhd2FyZSBvZi5cbiAgICBlcnJvcjogZyh7XG4gICAgICBjb2xvcjogYyxcbiAgICAgIG5hbWU6IFwiZXJyb3JcIlxuICAgIH0pLFxuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byByZXByZXNlbnQgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIGFjdGlvbnMgb3IgaW1wb3J0YW50IG1lc3NhZ2VzLlxuICAgIHdhcm5pbmc6IGcoe1xuICAgICAgY29sb3I6IHAsXG4gICAgICBuYW1lOiBcIndhcm5pbmdcIlxuICAgIH0pLFxuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byBwcmVzZW50IGluZm9ybWF0aW9uIHRvIHRoZSB1c2VyIHRoYXQgaXMgbmV1dHJhbCBhbmQgbm90IG5lY2Vzc2FyaWx5IGltcG9ydGFudC5cbiAgICBpbmZvOiBnKHtcbiAgICAgIGNvbG9yOiBsLFxuICAgICAgbmFtZTogXCJpbmZvXCJcbiAgICB9KSxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gaW5kaWNhdGUgdGhlIHN1Y2Nlc3NmdWwgY29tcGxldGlvbiBvZiBhbiBhY3Rpb24gdGhhdCB1c2VyIHRyaWdnZXJlZC5cbiAgICBzdWNjZXNzOiBnKHtcbiAgICAgIGNvbG9yOiB1LFxuICAgICAgbmFtZTogXCJzdWNjZXNzXCJcbiAgICB9KSxcbiAgICAvLyBUaGUgZ3JleSBjb2xvcnMuXG4gICAgZ3JleTogb2MsXG4gICAgLy8gVXNlZCBieSBgZ2V0Q29udHJhc3RUZXh0KClgIHRvIG1heGltaXplIHRoZSBjb250cmFzdCBiZXR3ZWVuXG4gICAgLy8gdGhlIGJhY2tncm91bmQgYW5kIHRoZSB0ZXh0LlxuICAgIGNvbnRyYXN0VGhyZXNob2xkOiByLFxuICAgIC8vIFRha2VzIGEgYmFja2dyb3VuZCBjb2xvciBhbmQgcmV0dXJucyB0aGUgdGV4dCBjb2xvciB0aGF0IG1heGltaXplcyB0aGUgY29udHJhc3QuXG4gICAgZ2V0Q29udHJhc3RUZXh0OiBtLFxuICAgIC8vIEdlbmVyYXRlIGEgcmljaCBjb2xvciBvYmplY3QuXG4gICAgYXVnbWVudENvbG9yOiBnLFxuICAgIC8vIFVzZWQgYnkgdGhlIGZ1bmN0aW9ucyBiZWxvdyB0byBzaGlmdCBhIGNvbG9yJ3MgbHVtaW5hbmNlIGJ5IGFwcHJveGltYXRlbHlcbiAgICAvLyB0d28gaW5kZXhlcyB3aXRoaW4gaXRzIHRvbmFsIHBhbGV0dGUuXG4gICAgLy8gRS5nLiwgc2hpZnQgZnJvbSBSZWQgNTAwIHRvIFJlZCAzMDAgb3IgUmVkIDcwMC5cbiAgICB0b25hbE9mZnNldDogbixcbiAgICAvLyBUaGUgbGlnaHQgYW5kIGRhcmsgbW9kZSBvYmplY3QuXG4gICAgLi4ueFxuICB9LCBvKTtcbn1cbmZ1bmN0aW9uIHlmKGUpIHtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgobikgPT4ge1xuICAgIGNvbnN0IFtvLCBpXSA9IG47XG4gICAgdHlwZW9mIGkgPT0gXCJvYmplY3RcIiAmJiAodFtvXSA9IGAke2kuZm9udFN0eWxlID8gYCR7aS5mb250U3R5bGV9IGAgOiBcIlwifSR7aS5mb250VmFyaWFudCA/IGAke2kuZm9udFZhcmlhbnR9IGAgOiBcIlwifSR7aS5mb250V2VpZ2h0ID8gYCR7aS5mb250V2VpZ2h0fSBgIDogXCJcIn0ke2kuZm9udFN0cmV0Y2ggPyBgJHtpLmZvbnRTdHJldGNofSBgIDogXCJcIn0ke2kuZm9udFNpemUgfHwgXCJcIn0ke2kubGluZUhlaWdodCA/IGAvJHtpLmxpbmVIZWlnaHR9IGAgOiBcIlwifSR7aS5mb250RmFtaWx5IHx8IFwiXCJ9YCk7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gYmYoZSwgdCkge1xuICByZXR1cm4ge1xuICAgIHRvb2xiYXI6IHtcbiAgICAgIG1pbkhlaWdodDogNTYsXG4gICAgICBbZS51cChcInhzXCIpXToge1xuICAgICAgICBcIkBtZWRpYSAob3JpZW50YXRpb246IGxhbmRzY2FwZSlcIjoge1xuICAgICAgICAgIG1pbkhlaWdodDogNDhcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtlLnVwKFwic21cIildOiB7XG4gICAgICAgIG1pbkhlaWdodDogNjRcbiAgICAgIH1cbiAgICB9LFxuICAgIC4uLnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHZmKGUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoZSAqIDFlNSkgLyAxZTU7XG59XG5jb25zdCBlYSA9IHtcbiAgdGV4dFRyYW5zZm9ybTogXCJ1cHBlcmNhc2VcIlxufSwgdGEgPSAnXCJSb2JvdG9cIiwgXCJIZWx2ZXRpY2FcIiwgXCJBcmlhbFwiLCBzYW5zLXNlcmlmJztcbmZ1bmN0aW9uIGZzKGUsIHQpIHtcbiAgY29uc3Qge1xuICAgIGZvbnRGYW1pbHk6IHIgPSB0YSxcbiAgICAvLyBUaGUgZGVmYXVsdCBmb250IHNpemUgb2YgdGhlIE1hdGVyaWFsIFNwZWNpZmljYXRpb24uXG4gICAgZm9udFNpemU6IG4gPSAxNCxcbiAgICAvLyBweFxuICAgIGZvbnRXZWlnaHRMaWdodDogbyA9IDMwMCxcbiAgICBmb250V2VpZ2h0UmVndWxhcjogaSA9IDQwMCxcbiAgICBmb250V2VpZ2h0TWVkaXVtOiBzID0gNTAwLFxuICAgIGZvbnRXZWlnaHRCb2xkOiBjID0gNzAwLFxuICAgIC8vIFRlbGwgTVVJIHdoYXQncyB0aGUgZm9udC1zaXplIG9uIHRoZSBodG1sIGVsZW1lbnQuXG4gICAgLy8gMTZweCBpcyB0aGUgZGVmYXVsdCBmb250LXNpemUgdXNlZCBieSBicm93c2Vycy5cbiAgICBodG1sRm9udFNpemU6IGwgPSAxNixcbiAgICAvLyBBcHBseSB0aGUgQ1NTIHByb3BlcnRpZXMgdG8gYWxsIHRoZSB2YXJpYW50cy5cbiAgICBhbGxWYXJpYW50czogdSxcbiAgICBweFRvUmVtOiBwLFxuICAgIC4uLm1cbiAgfSA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQoZSkgOiB0O1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHR5cGVvZiBuICE9IFwibnVtYmVyXCIgJiYgY29uc29sZS5lcnJvcihcIk1VSTogYGZvbnRTaXplYCBpcyByZXF1aXJlZCB0byBiZSBhIG51bWJlci5cIiksIHR5cGVvZiBsICE9IFwibnVtYmVyXCIgJiYgY29uc29sZS5lcnJvcihcIk1VSTogYGh0bWxGb250U2l6ZWAgaXMgcmVxdWlyZWQgdG8gYmUgYSBudW1iZXIuXCIpKTtcbiAgY29uc3QgZyA9IG4gLyAxNCwgeCA9IHAgfHwgKChTKSA9PiBgJHtTIC8gbCAqIGd9cmVtYCksIHkgPSAoUywgRSwgUCwgVCwgYikgPT4gKHtcbiAgICBmb250RmFtaWx5OiByLFxuICAgIGZvbnRXZWlnaHQ6IFMsXG4gICAgZm9udFNpemU6IHgoRSksXG4gICAgLy8gVW5pdGxlc3MgZm9sbG93aW5nIGh0dHBzOi8vbWV5ZXJ3ZWIuY29tL2VyaWMvdGhvdWdodHMvMjAwNi8wMi8wOC91bml0bGVzcy1saW5lLWhlaWdodHMvXG4gICAgbGluZUhlaWdodDogUCxcbiAgICAvLyBUaGUgbGV0dGVyIHNwYWNpbmcgd2FzIGRlc2lnbmVkIGZvciB0aGUgUm9ib3RvIGZvbnQtZmFtaWx5LiBVc2luZyB0aGUgc2FtZSBsZXR0ZXItc3BhY2luZ1xuICAgIC8vIGFjcm9zcyBmb250LWZhbWlsaWVzIGNhbiBjYXVzZSBpc3N1ZXMgd2l0aCB0aGUga2VybmluZy5cbiAgICAuLi5yID09PSB0YSA/IHtcbiAgICAgIGxldHRlclNwYWNpbmc6IGAke3ZmKFQgLyBFKX1lbWBcbiAgICB9IDoge30sXG4gICAgLi4uYixcbiAgICAuLi51XG4gIH0pLCBmID0ge1xuICAgIGgxOiB5KG8sIDk2LCAxLjE2NywgLTEuNSksXG4gICAgaDI6IHkobywgNjAsIDEuMiwgLTAuNSksXG4gICAgaDM6IHkoaSwgNDgsIDEuMTY3LCAwKSxcbiAgICBoNDogeShpLCAzNCwgMS4yMzUsIDAuMjUpLFxuICAgIGg1OiB5KGksIDI0LCAxLjMzNCwgMCksXG4gICAgaDY6IHkocywgMjAsIDEuNiwgMC4xNSksXG4gICAgc3VidGl0bGUxOiB5KGksIDE2LCAxLjc1LCAwLjE1KSxcbiAgICBzdWJ0aXRsZTI6IHkocywgMTQsIDEuNTcsIDAuMSksXG4gICAgYm9keTE6IHkoaSwgMTYsIDEuNSwgMC4xNSksXG4gICAgYm9keTI6IHkoaSwgMTQsIDEuNDMsIDAuMTUpLFxuICAgIGJ1dHRvbjogeShzLCAxNCwgMS43NSwgMC40LCBlYSksXG4gICAgY2FwdGlvbjogeShpLCAxMiwgMS42NiwgMC40KSxcbiAgICBvdmVybGluZTogeShpLCAxMiwgMi42NiwgMSwgZWEpLFxuICAgIC8vIFRPRE8gdjY6IFJlbW92ZSBoYW5kbGluZyBvZiAnaW5oZXJpdCcgdmFyaWFudCBmcm9tIHRoZSB0aGVtZSBhcyBpdCBpcyBhbHJlYWR5IGhhbmRsZWQgaW4gTWF0ZXJpYWwgVUkncyBUeXBvZ3JhcGh5IGNvbXBvbmVudC4gQWxzbywgcmVtZW1iZXIgdG8gcmVtb3ZlIHRoZSBhc3NvY2lhdGVkIHR5cGVzLlxuICAgIGluaGVyaXQ6IHtcbiAgICAgIGZvbnRGYW1pbHk6IFwiaW5oZXJpdFwiLFxuICAgICAgZm9udFdlaWdodDogXCJpbmhlcml0XCIsXG4gICAgICBmb250U2l6ZTogXCJpbmhlcml0XCIsXG4gICAgICBsaW5lSGVpZ2h0OiBcImluaGVyaXRcIixcbiAgICAgIGxldHRlclNwYWNpbmc6IFwiaW5oZXJpdFwiXG4gICAgfVxuICB9O1xuICByZXR1cm4gdHQoe1xuICAgIGh0bWxGb250U2l6ZTogbCxcbiAgICBweFRvUmVtOiB4LFxuICAgIGZvbnRGYW1pbHk6IHIsXG4gICAgZm9udFNpemU6IG4sXG4gICAgZm9udFdlaWdodExpZ2h0OiBvLFxuICAgIGZvbnRXZWlnaHRSZWd1bGFyOiBpLFxuICAgIGZvbnRXZWlnaHRNZWRpdW06IHMsXG4gICAgZm9udFdlaWdodEJvbGQ6IGMsXG4gICAgLi4uZlxuICB9LCBtLCB7XG4gICAgY2xvbmU6ICExXG4gICAgLy8gTm8gbmVlZCB0byBjbG9uZSBkZWVwXG4gIH0pO1xufVxuY29uc3QgeGYgPSAwLjIsIFNmID0gMC4xNCwgRWYgPSAwLjEyO1xuZnVuY3Rpb24gJGUoLi4uZSkge1xuICByZXR1cm4gW2Ake2VbMF19cHggJHtlWzFdfXB4ICR7ZVsyXX1weCAke2VbM119cHggcmdiYSgwLDAsMCwke3hmfSlgLCBgJHtlWzRdfXB4ICR7ZVs1XX1weCAke2VbNl19cHggJHtlWzddfXB4IHJnYmEoMCwwLDAsJHtTZn0pYCwgYCR7ZVs4XX1weCAke2VbOV19cHggJHtlWzEwXX1weCAke2VbMTFdfXB4IHJnYmEoMCwwLDAsJHtFZn0pYF0uam9pbihcIixcIik7XG59XG5jb25zdCBDZiA9IFtcIm5vbmVcIiwgJGUoMCwgMiwgMSwgLTEsIDAsIDEsIDEsIDAsIDAsIDEsIDMsIDApLCAkZSgwLCAzLCAxLCAtMiwgMCwgMiwgMiwgMCwgMCwgMSwgNSwgMCksICRlKDAsIDMsIDMsIC0yLCAwLCAzLCA0LCAwLCAwLCAxLCA4LCAwKSwgJGUoMCwgMiwgNCwgLTEsIDAsIDQsIDUsIDAsIDAsIDEsIDEwLCAwKSwgJGUoMCwgMywgNSwgLTEsIDAsIDUsIDgsIDAsIDAsIDEsIDE0LCAwKSwgJGUoMCwgMywgNSwgLTEsIDAsIDYsIDEwLCAwLCAwLCAxLCAxOCwgMCksICRlKDAsIDQsIDUsIC0yLCAwLCA3LCAxMCwgMSwgMCwgMiwgMTYsIDEpLCAkZSgwLCA1LCA1LCAtMywgMCwgOCwgMTAsIDEsIDAsIDMsIDE0LCAyKSwgJGUoMCwgNSwgNiwgLTMsIDAsIDksIDEyLCAxLCAwLCAzLCAxNiwgMiksICRlKDAsIDYsIDYsIC0zLCAwLCAxMCwgMTQsIDEsIDAsIDQsIDE4LCAzKSwgJGUoMCwgNiwgNywgLTQsIDAsIDExLCAxNSwgMSwgMCwgNCwgMjAsIDMpLCAkZSgwLCA3LCA4LCAtNCwgMCwgMTIsIDE3LCAyLCAwLCA1LCAyMiwgNCksICRlKDAsIDcsIDgsIC00LCAwLCAxMywgMTksIDIsIDAsIDUsIDI0LCA0KSwgJGUoMCwgNywgOSwgLTQsIDAsIDE0LCAyMSwgMiwgMCwgNSwgMjYsIDQpLCAkZSgwLCA4LCA5LCAtNSwgMCwgMTUsIDIyLCAyLCAwLCA2LCAyOCwgNSksICRlKDAsIDgsIDEwLCAtNSwgMCwgMTYsIDI0LCAyLCAwLCA2LCAzMCwgNSksICRlKDAsIDgsIDExLCAtNSwgMCwgMTcsIDI2LCAyLCAwLCA2LCAzMiwgNSksICRlKDAsIDksIDExLCAtNSwgMCwgMTgsIDI4LCAyLCAwLCA3LCAzNCwgNiksICRlKDAsIDksIDEyLCAtNiwgMCwgMTksIDI5LCAyLCAwLCA3LCAzNiwgNiksICRlKDAsIDEwLCAxMywgLTYsIDAsIDIwLCAzMSwgMywgMCwgOCwgMzgsIDcpLCAkZSgwLCAxMCwgMTMsIC02LCAwLCAyMSwgMzMsIDMsIDAsIDgsIDQwLCA3KSwgJGUoMCwgMTAsIDE0LCAtNiwgMCwgMjIsIDM1LCAzLCAwLCA4LCA0MiwgNyksICRlKDAsIDExLCAxNCwgLTcsIDAsIDIzLCAzNiwgMywgMCwgOSwgNDQsIDgpLCAkZSgwLCAxMSwgMTUsIC03LCAwLCAyNCwgMzgsIDMsIDAsIDksIDQ2LCA4KV0sIFRmID0ge1xuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vbiBlYXNpbmcgY3VydmUuXG4gIGVhc2VJbk91dDogXCJjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpXCIsXG4gIC8vIE9iamVjdHMgZW50ZXIgdGhlIHNjcmVlbiBhdCBmdWxsIHZlbG9jaXR5IGZyb20gb2ZmLXNjcmVlbiBhbmRcbiAgLy8gc2xvd2x5IGRlY2VsZXJhdGUgdG8gYSByZXN0aW5nIHBvaW50LlxuICBlYXNlT3V0OiBcImN1YmljLWJlemllcigwLjAsIDAsIDAuMiwgMSlcIixcbiAgLy8gT2JqZWN0cyBsZWF2ZSB0aGUgc2NyZWVuIGF0IGZ1bGwgdmVsb2NpdHkuIFRoZXkgZG8gbm90IGRlY2VsZXJhdGUgd2hlbiBvZmYtc2NyZWVuLlxuICBlYXNlSW46IFwiY3ViaWMtYmV6aWVyKDAuNCwgMCwgMSwgMSlcIixcbiAgLy8gVGhlIHNoYXJwIGN1cnZlIGlzIHVzZWQgYnkgb2JqZWN0cyB0aGF0IG1heSByZXR1cm4gdG8gdGhlIHNjcmVlbiBhdCBhbnkgdGltZS5cbiAgc2hhcnA6IFwiY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC42LCAxKVwiXG59LCBkcyA9IHtcbiAgc2hvcnRlc3Q6IDE1MCxcbiAgc2hvcnRlcjogMjAwLFxuICBzaG9ydDogMjUwLFxuICAvLyBtb3N0IGJhc2ljIHJlY29tbWVuZGVkIHRpbWluZ1xuICBzdGFuZGFyZDogMzAwLFxuICAvLyB0aGlzIGlzIHRvIGJlIHVzZWQgaW4gY29tcGxleCBhbmltYXRpb25zXG4gIGNvbXBsZXg6IDM3NSxcbiAgLy8gcmVjb21tZW5kZWQgd2hlbiBzb21ldGhpbmcgaXMgZW50ZXJpbmcgc2NyZWVuXG4gIGVudGVyaW5nU2NyZWVuOiAyMjUsXG4gIC8vIHJlY29tbWVuZGVkIHdoZW4gc29tZXRoaW5nIGlzIGxlYXZpbmcgc2NyZWVuXG4gIGxlYXZpbmdTY3JlZW46IDE5NVxufTtcbmZ1bmN0aW9uIHJhKGUpIHtcbiAgcmV0dXJuIGAke01hdGgucm91bmQoZSl9bXNgO1xufVxuZnVuY3Rpb24gd2YoZSkge1xuICBpZiAoIWUpXG4gICAgcmV0dXJuIDA7XG4gIGNvbnN0IHQgPSBlIC8gMzY7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLnJvdW5kKCg0ICsgMTUgKiB0ICoqIDAuMjUgKyB0IC8gNSkgKiAxMCksIDNlMyk7XG59XG5mdW5jdGlvbiBPZihlKSB7XG4gIGNvbnN0IHQgPSB7XG4gICAgLi4uVGYsXG4gICAgLi4uZS5lYXNpbmdcbiAgfSwgciA9IHtcbiAgICAuLi5kcyxcbiAgICAuLi5lLmR1cmF0aW9uXG4gIH07XG4gIHJldHVybiB7XG4gICAgZ2V0QXV0b0hlaWdodER1cmF0aW9uOiB3ZixcbiAgICBjcmVhdGU6IChvID0gW1wiYWxsXCJdLCBpID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZHVyYXRpb246IHMgPSByLnN0YW5kYXJkLFxuICAgICAgICBlYXNpbmc6IGMgPSB0LmVhc2VJbk91dCxcbiAgICAgICAgZGVsYXk6IGwgPSAwLFxuICAgICAgICAuLi51XG4gICAgICB9ID0gaTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgcCA9IChnKSA9PiB0eXBlb2YgZyA9PSBcInN0cmluZ1wiLCBtID0gKGcpID0+ICFOdW1iZXIuaXNOYU4ocGFyc2VGbG9hdChnKSk7XG4gICAgICAgICFwKG8pICYmICFBcnJheS5pc0FycmF5KG8pICYmIGNvbnNvbGUuZXJyb3IoJ01VSTogQXJndW1lbnQgXCJwcm9wc1wiIG11c3QgYmUgYSBzdHJpbmcgb3IgQXJyYXkuJyksICFtKHMpICYmICFwKHMpICYmIGNvbnNvbGUuZXJyb3IoYE1VSTogQXJndW1lbnQgXCJkdXJhdGlvblwiIG11c3QgYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgYnV0IGZvdW5kICR7c30uYCksIHAoYykgfHwgY29uc29sZS5lcnJvcignTVVJOiBBcmd1bWVudCBcImVhc2luZ1wiIG11c3QgYmUgYSBzdHJpbmcuJyksICFtKGwpICYmICFwKGwpICYmIGNvbnNvbGUuZXJyb3IoJ01VSTogQXJndW1lbnQgXCJkZWxheVwiIG11c3QgYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcuJyksIHR5cGVvZiBpICE9IFwib2JqZWN0XCIgJiYgY29uc29sZS5lcnJvcihbXCJNVUk6IFNlY29uZyBhcmd1bWVudCBvZiB0cmFuc2l0aW9uLmNyZWF0ZSBtdXN0IGJlIGFuIG9iamVjdC5cIiwgXCJBcmd1bWVudHMgc2hvdWxkIGJlIGVpdGhlciBgY3JlYXRlKCdwcm9wMScsIG9wdGlvbnMpYCBvciBgY3JlYXRlKFsncHJvcDEnLCAncHJvcDInXSwgb3B0aW9ucylgXCJdLmpvaW4oYFxuYCkpLCBPYmplY3Qua2V5cyh1KS5sZW5ndGggIT09IDAgJiYgY29uc29sZS5lcnJvcihgTVVJOiBVbnJlY29nbml6ZWQgYXJndW1lbnQocykgWyR7T2JqZWN0LmtleXModSkuam9pbihcIixcIil9XS5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShvKSA/IG8gOiBbb10pLm1hcCgocCkgPT4gYCR7cH0gJHt0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gcyA6IHJhKHMpfSAke2N9ICR7dHlwZW9mIGwgPT0gXCJzdHJpbmdcIiA/IGwgOiByYShsKX1gKS5qb2luKFwiLFwiKTtcbiAgICB9LFxuICAgIC4uLmUsXG4gICAgZWFzaW5nOiB0LFxuICAgIGR1cmF0aW9uOiByXG4gIH07XG59XG5jb25zdCBSZiA9IHtcbiAgbW9iaWxlU3RlcHBlcjogMWUzLFxuICBmYWI6IDEwNTAsXG4gIHNwZWVkRGlhbDogMTA1MCxcbiAgYXBwQmFyOiAxMTAwLFxuICBkcmF3ZXI6IDEyMDAsXG4gIG1vZGFsOiAxMzAwLFxuICBzbmFja2JhcjogMTQwMCxcbiAgdG9vbHRpcDogMTUwMFxufTtcbmZ1bmN0aW9uICRmKGUpIHtcbiAgcmV0dXJuIGd0KGUpIHx8IHR5cGVvZiBlID4gXCJ1XCIgfHwgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZSA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgZSA9PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkoZSk7XG59XG5mdW5jdGlvbiBwcyhlID0ge30pIHtcbiAgY29uc3QgdCA9IHtcbiAgICAuLi5lXG4gIH07XG4gIGZ1bmN0aW9uIHIobikge1xuICAgIGNvbnN0IG8gPSBPYmplY3QuZW50cmllcyhuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IFtzLCBjXSA9IG9baV07XG4gICAgICAhJGYoYykgfHwgcy5zdGFydHNXaXRoKFwidW5zdGFibGVfXCIpID8gZGVsZXRlIG5bc10gOiBndChjKSAmJiAobltzXSA9IHtcbiAgICAgICAgLi4uY1xuICAgICAgfSwgcihuW3NdKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByKHQpLCBgaW1wb3J0IHsgdW5zdGFibGVfY3JlYXRlQnJlYWtwb2ludHMgYXMgY3JlYXRlQnJlYWtwb2ludHMsIGNyZWF0ZVRyYW5zaXRpb25zIH0gZnJvbSAnQG11aS9tYXRlcmlhbC9zdHlsZXMnO1xuXG5jb25zdCB0aGVtZSA9ICR7SlNPTi5zdHJpbmdpZnkodCwgbnVsbCwgMil9O1xuXG50aGVtZS5icmVha3BvaW50cyA9IGNyZWF0ZUJyZWFrcG9pbnRzKHRoZW1lLmJyZWFrcG9pbnRzIHx8IHt9KTtcbnRoZW1lLnRyYW5zaXRpb25zID0gY3JlYXRlVHJhbnNpdGlvbnModGhlbWUudHJhbnNpdGlvbnMgfHwge30pO1xuXG5leHBvcnQgZGVmYXVsdCB0aGVtZTtgO1xufVxuZnVuY3Rpb24gZm8oZSA9IHt9LCAuLi50KSB7XG4gIGNvbnN0IHtcbiAgICBicmVha3BvaW50czogcixcbiAgICBtaXhpbnM6IG4gPSB7fSxcbiAgICBzcGFjaW5nOiBvLFxuICAgIHBhbGV0dGU6IGkgPSB7fSxcbiAgICB0cmFuc2l0aW9uczogcyA9IHt9LFxuICAgIHR5cG9ncmFwaHk6IGMgPSB7fSxcbiAgICBzaGFwZTogbCxcbiAgICAuLi51XG4gIH0gPSBlO1xuICBpZiAoZS52YXJzKVxuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk1VSTogYHZhcnNgIGlzIGEgcHJpdmF0ZSBmaWVsZCB1c2VkIGZvciBDU1MgdmFyaWFibGVzIHN1cHBvcnQuXFxuUGxlYXNlIHVzZSBhbm90aGVyIG5hbWUuXCIgOiBrdCgyMCkpO1xuICBjb25zdCBwID0gVW8oaSksIG0gPSBObyhlKTtcbiAgbGV0IGcgPSB0dChtLCB7XG4gICAgbWl4aW5zOiBiZihtLmJyZWFrcG9pbnRzLCBuKSxcbiAgICBwYWxldHRlOiBwLFxuICAgIC8vIERvbid0IHVzZSBbLi4uc2hhZG93c10gdW50aWwgeW91J3ZlIHZlcmlmaWVkIGl0cyB0cmFuc3BpbGVkIGNvZGUgaXMgbm90IGludm9raW5nIHRoZSBpdGVyYXRvciBwcm90b2NvbC5cbiAgICBzaGFkb3dzOiBDZi5zbGljZSgpLFxuICAgIHR5cG9ncmFwaHk6IGZzKHAsIGMpLFxuICAgIHRyYW5zaXRpb25zOiBPZihzKSxcbiAgICB6SW5kZXg6IHtcbiAgICAgIC4uLlJmXG4gICAgfVxuICB9KTtcbiAgaWYgKGcgPSB0dChnLCB1KSwgZyA9IHQucmVkdWNlKCh4LCB5KSA9PiB0dCh4LCB5KSwgZyksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IHggPSBbXCJhY3RpdmVcIiwgXCJjaGVja2VkXCIsIFwiY29tcGxldGVkXCIsIFwiZGlzYWJsZWRcIiwgXCJlcnJvclwiLCBcImV4cGFuZGVkXCIsIFwiZm9jdXNlZFwiLCBcImZvY3VzVmlzaWJsZVwiLCBcInJlcXVpcmVkXCIsIFwic2VsZWN0ZWRcIl0sIHkgPSAoZiwgUykgPT4ge1xuICAgICAgbGV0IEU7XG4gICAgICBmb3IgKEUgaW4gZikge1xuICAgICAgICBjb25zdCBQID0gZltFXTtcbiAgICAgICAgaWYgKHguaW5jbHVkZXMoRSkgJiYgT2JqZWN0LmtleXMoUCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IFQgPSBWZShcIlwiLCBFKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoW2BNVUk6IFRoZSBcXGAke1N9XFxgIGNvbXBvbmVudCBpbmNyZWFzZXMgdGhlIENTUyBzcGVjaWZpY2l0eSBvZiB0aGUgXFxgJHtFfVxcYCBpbnRlcm5hbCBzdGF0ZS5gLCBcIllvdSBjYW4gbm90IG92ZXJyaWRlIGl0IGxpa2UgdGhpczogXCIsIEpTT04uc3RyaW5naWZ5KGYsIG51bGwsIDIpLCBcIlwiLCBgSW5zdGVhZCwgeW91IG5lZWQgdG8gdXNlIHRoZSAnJi4ke1R9JyBzeW50YXg6YCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICByb290OiB7XG4gICAgICAgICAgICAgICAgW2AmLiR7VH1gXTogUFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBudWxsLCAyKSwgXCJcIiwgXCJodHRwczovL211aS5jb20vci9zdGF0ZS1jbGFzc2VzLWd1aWRlXCJdLmpvaW4oYFxuYCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmW0VdID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5rZXlzKGcuY29tcG9uZW50cykuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgY29uc3QgUyA9IGcuY29tcG9uZW50c1tmXS5zdHlsZU92ZXJyaWRlcztcbiAgICAgIFMgJiYgZi5zdGFydHNXaXRoKFwiTXVpXCIpICYmIHkoUywgZik7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGcudW5zdGFibGVfc3hDb25maWcgPSB7XG4gICAgLi4uRHIsXG4gICAgLi4udSA9PSBudWxsID8gdm9pZCAwIDogdS51bnN0YWJsZV9zeENvbmZpZ1xuICB9LCBnLnVuc3RhYmxlX3N4ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBBdCh7XG4gICAgICBzeDogeSxcbiAgICAgIHRoZW1lOiB0aGlzXG4gICAgfSk7XG4gIH0sIGcudG9SdW50aW1lU291cmNlID0gcHMsIGc7XG59XG5mdW5jdGlvbiBQZihlKSB7XG4gIGxldCB0O1xuICByZXR1cm4gZSA8IDEgPyB0ID0gNS4xMTkxNiAqIGUgKiogMiA6IHQgPSA0LjUgKiBNYXRoLmxvZyhlICsgMSkgKyAyLCBNYXRoLnJvdW5kKHQgKiAxMCkgLyAxZTM7XG59XG5jb25zdCBrZiA9IFsuLi5BcnJheSgyNSldLm1hcCgoZSwgdCkgPT4ge1xuICBpZiAodCA9PT0gMClcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIGNvbnN0IHIgPSBQZih0KTtcbiAgcmV0dXJuIGBsaW5lYXItZ3JhZGllbnQocmdiYSgyNTUgMjU1IDI1NSAvICR7cn0pLCByZ2JhKDI1NSAyNTUgMjU1IC8gJHtyfSkpYDtcbn0pO1xuZnVuY3Rpb24gbXMoZSkge1xuICByZXR1cm4ge1xuICAgIGlucHV0UGxhY2Vob2xkZXI6IGUgPT09IFwiZGFya1wiID8gMC41IDogMC40MixcbiAgICBpbnB1dFVuZGVybGluZTogZSA9PT0gXCJkYXJrXCIgPyAwLjcgOiAwLjQyLFxuICAgIHN3aXRjaFRyYWNrRGlzYWJsZWQ6IGUgPT09IFwiZGFya1wiID8gMC4yIDogMC4xMixcbiAgICBzd2l0Y2hUcmFjazogZSA9PT0gXCJkYXJrXCIgPyAwLjMgOiAwLjM4XG4gIH07XG59XG5mdW5jdGlvbiBocyhlKSB7XG4gIHJldHVybiBlID09PSBcImRhcmtcIiA/IGtmIDogW107XG59XG5mdW5jdGlvbiBBZihlKSB7XG4gIGNvbnN0IHtcbiAgICBwYWxldHRlOiB0ID0ge1xuICAgICAgbW9kZTogXCJsaWdodFwiXG4gICAgfSxcbiAgICAvLyBuZWVkIHRvIGNhc3QgdG8gYXZvaWQgbW9kdWxlIGF1Z21lbnRhdGlvbiB0ZXN0XG4gICAgb3BhY2l0eTogcixcbiAgICBvdmVybGF5czogbixcbiAgICAuLi5vXG4gIH0gPSBlLCBpID0gVW8odCk7XG4gIHJldHVybiB7XG4gICAgcGFsZXR0ZTogaSxcbiAgICBvcGFjaXR5OiB7XG4gICAgICAuLi5tcyhpLm1vZGUpLFxuICAgICAgLi4uclxuICAgIH0sXG4gICAgb3ZlcmxheXM6IG4gfHwgaHMoaS5tb2RlKSxcbiAgICAuLi5vXG4gIH07XG59XG5mdW5jdGlvbiBOZihlKSB7XG4gIHZhciB0O1xuICByZXR1cm4gISFlWzBdLm1hdGNoKC8oY3NzVmFyUHJlZml4fGNvbG9yU2NoZW1lU2VsZWN0b3J8cm9vdFNlbGVjdG9yfHR5cG9ncmFwaHl8bWl4aW5zfGJyZWFrcG9pbnRzfGRpcmVjdGlvbnx0cmFuc2l0aW9ucykvKSB8fCAhIWVbMF0ubWF0Y2goL3N4Q29uZmlnJC8pIHx8IC8vIGVuZHMgd2l0aCBzeENvbmZpZ1xuICBlWzBdID09PSBcInBhbGV0dGVcIiAmJiAhISgodCA9IGVbMV0pICE9IG51bGwgJiYgdC5tYXRjaCgvKG1vZGV8Y29udHJhc3RUaHJlc2hvbGR8dG9uYWxPZmZzZXQpLykpO1xufVxuY29uc3QgTWYgPSAoZSkgPT4gWy4uLlsuLi5BcnJheSgyNSldLm1hcCgodCwgcikgPT4gYC0tJHtlID8gYCR7ZX0tYCA6IFwiXCJ9b3ZlcmxheXMtJHtyfWApLCBgLS0ke2UgPyBgJHtlfS1gIDogXCJcIn1wYWxldHRlLUFwcEJhci1kYXJrQmdgLCBgLS0ke2UgPyBgJHtlfS1gIDogXCJcIn1wYWxldHRlLUFwcEJhci1kYXJrQ29sb3JgXSwgSWYgPSAoZSkgPT4gKHQsIHIpID0+IHtcbiAgY29uc3QgbiA9IGUucm9vdFNlbGVjdG9yIHx8IFwiOnJvb3RcIiwgbyA9IGUuY29sb3JTY2hlbWVTZWxlY3RvcjtcbiAgbGV0IGkgPSBvO1xuICBpZiAobyA9PT0gXCJjbGFzc1wiICYmIChpID0gXCIuJXNcIiksIG8gPT09IFwiZGF0YVwiICYmIChpID0gXCJbZGF0YS0lc11cIiksIG8gIT0gbnVsbCAmJiBvLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSAmJiAhby5pbmNsdWRlcyhcIiVzXCIpICYmIChpID0gYFske299PVwiJXNcIl1gKSwgZS5kZWZhdWx0Q29sb3JTY2hlbWUgPT09IHQpIHtcbiAgICBpZiAodCA9PT0gXCJkYXJrXCIpIHtcbiAgICAgIGNvbnN0IHMgPSB7fTtcbiAgICAgIHJldHVybiBNZihlLmNzc1ZhclByZWZpeCkuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBzW2NdID0gcltjXSwgZGVsZXRlIHJbY107XG4gICAgICB9KSwgaSA9PT0gXCJtZWRpYVwiID8ge1xuICAgICAgICBbbl06IHIsXG4gICAgICAgIFwiQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIjoge1xuICAgICAgICAgIFtuXTogc1xuICAgICAgICB9XG4gICAgICB9IDogaSA/IHtcbiAgICAgICAgW2kucmVwbGFjZShcIiVzXCIsIHQpXTogcyxcbiAgICAgICAgW2Ake259LCAke2kucmVwbGFjZShcIiVzXCIsIHQpfWBdOiByXG4gICAgICB9IDoge1xuICAgICAgICBbbl06IHtcbiAgICAgICAgICAuLi5yLFxuICAgICAgICAgIC4uLnNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGkgJiYgaSAhPT0gXCJtZWRpYVwiKVxuICAgICAgcmV0dXJuIGAke259LCAke2kucmVwbGFjZShcIiVzXCIsIFN0cmluZyh0KSl9YDtcbiAgfSBlbHNlIGlmICh0KSB7XG4gICAgaWYgKGkgPT09IFwibWVkaWFcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtgQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogJHtTdHJpbmcodCl9KWBdOiB7XG4gICAgICAgICAgW25dOiByXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgaWYgKGkpXG4gICAgICByZXR1cm4gaS5yZXBsYWNlKFwiJXNcIiwgU3RyaW5nKHQpKTtcbiAgfVxuICByZXR1cm4gbjtcbn07XG5mdW5jdGlvbiBfZihlLCB0KSB7XG4gIHQuZm9yRWFjaCgocikgPT4ge1xuICAgIGVbcl0gfHwgKGVbcl0gPSB7fSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gJChlLCB0LCByKSB7XG4gICFlW3RdICYmIHIgJiYgKGVbdF0gPSByKTtcbn1cbmZ1bmN0aW9uIHlyKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlICE9IFwic3RyaW5nXCIgfHwgIWUuc3RhcnRzV2l0aChcImhzbFwiKSA/IGUgOiBLYShlKTtcbn1cbmZ1bmN0aW9uIEN0KGUsIHQpIHtcbiAgYCR7dH1DaGFubmVsYCBpbiBlIHx8IChlW2Ake3R9Q2hhbm5lbGBdID0gZ3IoeXIoZVt0XSksIGBNVUk6IENhbid0IGNyZWF0ZSBcXGBwYWxldHRlLiR7dH1DaGFubmVsXFxgIGJlY2F1c2UgXFxgcGFsZXR0ZS4ke3R9XFxgIGlzIG5vdCBvbmUgb2YgdGhlc2UgZm9ybWF0czogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKS5cblRvIHN1cHByZXNzIHRoaXMgd2FybmluZywgeW91IG5lZWQgdG8gZXhwbGljaXRseSBwcm92aWRlIHRoZSBcXGBwYWxldHRlLiR7dH1DaGFubmVsXFxgIGFzIGEgc3RyaW5nIChpbiByZ2IgZm9ybWF0LCBmb3IgZXhhbXBsZSBcIjEyIDEyIDEyXCIpIG9yIHVuZGVmaW5lZCBpZiB5b3Ugd2FudCB0byByZW1vdmUgdGhlIGNoYW5uZWwgdG9rZW4uYCkpO1xufVxuZnVuY3Rpb24gamYoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJudW1iZXJcIiA/IGAke2V9cHhgIDogdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgfHwgQXJyYXkuaXNBcnJheShlKSA/IGUgOiBcIjhweFwiO1xufVxuY29uc3QgcHQgPSAoZSkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBlKCk7XG4gIH0gY2F0Y2gge1xuICB9XG59LCBEZiA9IChlID0gXCJtdWlcIikgPT4gb2YoZSk7XG5mdW5jdGlvbiBybyhlLCB0LCByLCBuKSB7XG4gIGlmICghdClcbiAgICByZXR1cm47XG4gIHQgPSB0ID09PSAhMCA/IHt9IDogdDtcbiAgY29uc3QgbyA9IG4gPT09IFwiZGFya1wiID8gXCJkYXJrXCIgOiBcImxpZ2h0XCI7XG4gIGlmICghcikge1xuICAgIGVbbl0gPSBBZih7XG4gICAgICAuLi50LFxuICAgICAgcGFsZXR0ZToge1xuICAgICAgICBtb2RlOiBvLFxuICAgICAgICAuLi50ID09IG51bGwgPyB2b2lkIDAgOiB0LnBhbGV0dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge1xuICAgIHBhbGV0dGU6IGksXG4gICAgLi4uc1xuICB9ID0gZm8oe1xuICAgIC4uLnIsXG4gICAgcGFsZXR0ZToge1xuICAgICAgbW9kZTogbyxcbiAgICAgIC4uLnQgPT0gbnVsbCA/IHZvaWQgMCA6IHQucGFsZXR0ZVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBlW25dID0ge1xuICAgIC4uLnQsXG4gICAgcGFsZXR0ZTogaSxcbiAgICBvcGFjaXR5OiB7XG4gICAgICAuLi5tcyhvKSxcbiAgICAgIC4uLnQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub3BhY2l0eVxuICAgIH0sXG4gICAgb3ZlcmxheXM6ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm92ZXJsYXlzKSB8fCBocyhvKVxuICB9LCBzO1xufVxuZnVuY3Rpb24gTGYoZSA9IHt9LCAuLi50KSB7XG4gIGNvbnN0IHtcbiAgICBjb2xvclNjaGVtZXM6IHIgPSB7XG4gICAgICBsaWdodDogITBcbiAgICB9LFxuICAgIGRlZmF1bHRDb2xvclNjaGVtZTogbixcbiAgICBkaXNhYmxlQ3NzQ29sb3JTY2hlbWU6IG8gPSAhMSxcbiAgICBjc3NWYXJQcmVmaXg6IGkgPSBcIm11aVwiLFxuICAgIHNob3VsZFNraXBHZW5lcmF0aW5nVmFyOiBzID0gTmYsXG4gICAgY29sb3JTY2hlbWVTZWxlY3RvcjogYyA9IHIubGlnaHQgJiYgci5kYXJrID8gXCJtZWRpYVwiIDogdm9pZCAwLFxuICAgIHJvb3RTZWxlY3RvcjogbCA9IFwiOnJvb3RcIixcbiAgICAuLi51XG4gIH0gPSBlLCBwID0gT2JqZWN0LmtleXMocilbMF0sIG0gPSBuIHx8IChyLmxpZ2h0ICYmIHAgIT09IFwibGlnaHRcIiA/IFwibGlnaHRcIiA6IHApLCBnID0gRGYoaSksIHtcbiAgICBbbV06IHgsXG4gICAgbGlnaHQ6IHksXG4gICAgZGFyazogZixcbiAgICAuLi5TXG4gIH0gPSByLCBFID0ge1xuICAgIC4uLlNcbiAgfTtcbiAgbGV0IFAgPSB4O1xuICBpZiAoKG0gPT09IFwiZGFya1wiICYmICEoXCJkYXJrXCIgaW4gcikgfHwgbSA9PT0gXCJsaWdodFwiICYmICEoXCJsaWdodFwiIGluIHIpKSAmJiAoUCA9ICEwKSwgIVApXG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGBNVUk6IFRoZSBcXGBjb2xvclNjaGVtZXMuJHttfVxcYCBvcHRpb24gaXMgZWl0aGVyIG1pc3Npbmcgb3IgaW52YWxpZC5gIDoga3QoMjEsIG0pKTtcbiAgY29uc3QgVCA9IHJvKEUsIFAsIHUsIG0pO1xuICB5ICYmICFFLmxpZ2h0ICYmIHJvKEUsIHksIHZvaWQgMCwgXCJsaWdodFwiKSwgZiAmJiAhRS5kYXJrICYmIHJvKEUsIGYsIHZvaWQgMCwgXCJkYXJrXCIpO1xuICBsZXQgYiA9IHtcbiAgICBkZWZhdWx0Q29sb3JTY2hlbWU6IG0sXG4gICAgLi4uVCxcbiAgICBjc3NWYXJQcmVmaXg6IGksXG4gICAgY29sb3JTY2hlbWVTZWxlY3RvcjogYyxcbiAgICByb290U2VsZWN0b3I6IGwsXG4gICAgZ2V0Q3NzVmFyOiBnLFxuICAgIGNvbG9yU2NoZW1lczogRSxcbiAgICBmb250OiB7XG4gICAgICAuLi55ZihULnR5cG9ncmFwaHkpLFxuICAgICAgLi4uVC5mb250XG4gICAgfSxcbiAgICBzcGFjaW5nOiBqZih1LnNwYWNpbmcpXG4gIH07XG4gIE9iamVjdC5rZXlzKGIuY29sb3JTY2hlbWVzKS5mb3JFYWNoKChCKSA9PiB7XG4gICAgY29uc3QgZCA9IGIuY29sb3JTY2hlbWVzW0JdLnBhbGV0dGUsIEEgPSAoRCkgPT4ge1xuICAgICAgY29uc3QgaiA9IEQuc3BsaXQoXCItXCIpLCBXID0galsxXSwgeiA9IGpbMl07XG4gICAgICByZXR1cm4gZyhELCBkW1ddW3pdKTtcbiAgICB9O1xuICAgIGlmIChkLm1vZGUgPT09IFwibGlnaHRcIiAmJiAoJChkLmNvbW1vbiwgXCJiYWNrZ3JvdW5kXCIsIFwiI2ZmZlwiKSwgJChkLmNvbW1vbiwgXCJvbkJhY2tncm91bmRcIiwgXCIjMDAwXCIpKSwgZC5tb2RlID09PSBcImRhcmtcIiAmJiAoJChkLmNvbW1vbiwgXCJiYWNrZ3JvdW5kXCIsIFwiIzAwMFwiKSwgJChkLmNvbW1vbiwgXCJvbkJhY2tncm91bmRcIiwgXCIjZmZmXCIpKSwgX2YoZCwgW1wiQWxlcnRcIiwgXCJBcHBCYXJcIiwgXCJBdmF0YXJcIiwgXCJCdXR0b25cIiwgXCJDaGlwXCIsIFwiRmlsbGVkSW5wdXRcIiwgXCJMaW5lYXJQcm9ncmVzc1wiLCBcIlNrZWxldG9uXCIsIFwiU2xpZGVyXCIsIFwiU25hY2tiYXJDb250ZW50XCIsIFwiU3BlZWREaWFsQWN0aW9uXCIsIFwiU3RlcENvbm5lY3RvclwiLCBcIlN0ZXBDb250ZW50XCIsIFwiU3dpdGNoXCIsIFwiVGFibGVDZWxsXCIsIFwiVG9vbHRpcFwiXSksIGQubW9kZSA9PT0gXCJsaWdodFwiKSB7XG4gICAgICAkKGQuQWxlcnQsIFwiZXJyb3JDb2xvclwiLCBDZShkLmVycm9yLmxpZ2h0LCAwLjYpKSwgJChkLkFsZXJ0LCBcImluZm9Db2xvclwiLCBDZShkLmluZm8ubGlnaHQsIDAuNikpLCAkKGQuQWxlcnQsIFwic3VjY2Vzc0NvbG9yXCIsIENlKGQuc3VjY2Vzcy5saWdodCwgMC42KSksICQoZC5BbGVydCwgXCJ3YXJuaW5nQ29sb3JcIiwgQ2UoZC53YXJuaW5nLmxpZ2h0LCAwLjYpKSwgJChkLkFsZXJ0LCBcImVycm9yRmlsbGVkQmdcIiwgQShcInBhbGV0dGUtZXJyb3ItbWFpblwiKSksICQoZC5BbGVydCwgXCJpbmZvRmlsbGVkQmdcIiwgQShcInBhbGV0dGUtaW5mby1tYWluXCIpKSwgJChkLkFsZXJ0LCBcInN1Y2Nlc3NGaWxsZWRCZ1wiLCBBKFwicGFsZXR0ZS1zdWNjZXNzLW1haW5cIikpLCAkKGQuQWxlcnQsIFwid2FybmluZ0ZpbGxlZEJnXCIsIEEoXCJwYWxldHRlLXdhcm5pbmctbWFpblwiKSksICQoZC5BbGVydCwgXCJlcnJvckZpbGxlZENvbG9yXCIsIHB0KCgpID0+IGQuZ2V0Q29udHJhc3RUZXh0KGQuZXJyb3IubWFpbikpKSwgJChkLkFsZXJ0LCBcImluZm9GaWxsZWRDb2xvclwiLCBwdCgoKSA9PiBkLmdldENvbnRyYXN0VGV4dChkLmluZm8ubWFpbikpKSwgJChkLkFsZXJ0LCBcInN1Y2Nlc3NGaWxsZWRDb2xvclwiLCBwdCgoKSA9PiBkLmdldENvbnRyYXN0VGV4dChkLnN1Y2Nlc3MubWFpbikpKSwgJChkLkFsZXJ0LCBcIndhcm5pbmdGaWxsZWRDb2xvclwiLCBwdCgoKSA9PiBkLmdldENvbnRyYXN0VGV4dChkLndhcm5pbmcubWFpbikpKSwgJChkLkFsZXJ0LCBcImVycm9yU3RhbmRhcmRCZ1wiLCBUZShkLmVycm9yLmxpZ2h0LCAwLjkpKSwgJChkLkFsZXJ0LCBcImluZm9TdGFuZGFyZEJnXCIsIFRlKGQuaW5mby5saWdodCwgMC45KSksICQoZC5BbGVydCwgXCJzdWNjZXNzU3RhbmRhcmRCZ1wiLCBUZShkLnN1Y2Nlc3MubGlnaHQsIDAuOSkpLCAkKGQuQWxlcnQsIFwid2FybmluZ1N0YW5kYXJkQmdcIiwgVGUoZC53YXJuaW5nLmxpZ2h0LCAwLjkpKSwgJChkLkFsZXJ0LCBcImVycm9ySWNvbkNvbG9yXCIsIEEoXCJwYWxldHRlLWVycm9yLW1haW5cIikpLCAkKGQuQWxlcnQsIFwiaW5mb0ljb25Db2xvclwiLCBBKFwicGFsZXR0ZS1pbmZvLW1haW5cIikpLCAkKGQuQWxlcnQsIFwic3VjY2Vzc0ljb25Db2xvclwiLCBBKFwicGFsZXR0ZS1zdWNjZXNzLW1haW5cIikpLCAkKGQuQWxlcnQsIFwid2FybmluZ0ljb25Db2xvclwiLCBBKFwicGFsZXR0ZS13YXJuaW5nLW1haW5cIikpLCAkKGQuQXBwQmFyLCBcImRlZmF1bHRCZ1wiLCBBKFwicGFsZXR0ZS1ncmV5LTEwMFwiKSksICQoZC5BdmF0YXIsIFwiZGVmYXVsdEJnXCIsIEEoXCJwYWxldHRlLWdyZXktNDAwXCIpKSwgJChkLkJ1dHRvbiwgXCJpbmhlcml0Q29udGFpbmVkQmdcIiwgQShcInBhbGV0dGUtZ3JleS0zMDBcIikpLCAkKGQuQnV0dG9uLCBcImluaGVyaXRDb250YWluZWRIb3ZlckJnXCIsIEEoXCJwYWxldHRlLWdyZXktQTEwMFwiKSksICQoZC5DaGlwLCBcImRlZmF1bHRCb3JkZXJcIiwgQShcInBhbGV0dGUtZ3JleS00MDBcIikpLCAkKGQuQ2hpcCwgXCJkZWZhdWx0QXZhdGFyQ29sb3JcIiwgQShcInBhbGV0dGUtZ3JleS03MDBcIikpLCAkKGQuQ2hpcCwgXCJkZWZhdWx0SWNvbkNvbG9yXCIsIEEoXCJwYWxldHRlLWdyZXktNzAwXCIpKSwgJChkLkZpbGxlZElucHV0LCBcImJnXCIsIFwicmdiYSgwLCAwLCAwLCAwLjA2KVwiKSwgJChkLkZpbGxlZElucHV0LCBcImhvdmVyQmdcIiwgXCJyZ2JhKDAsIDAsIDAsIDAuMDkpXCIpLCAkKGQuRmlsbGVkSW5wdXQsIFwiZGlzYWJsZWRCZ1wiLCBcInJnYmEoMCwgMCwgMCwgMC4xMilcIiksICQoZC5MaW5lYXJQcm9ncmVzcywgXCJwcmltYXJ5QmdcIiwgVGUoZC5wcmltYXJ5Lm1haW4sIDAuNjIpKSwgJChkLkxpbmVhclByb2dyZXNzLCBcInNlY29uZGFyeUJnXCIsIFRlKGQuc2Vjb25kYXJ5Lm1haW4sIDAuNjIpKSwgJChkLkxpbmVhclByb2dyZXNzLCBcImVycm9yQmdcIiwgVGUoZC5lcnJvci5tYWluLCAwLjYyKSksICQoZC5MaW5lYXJQcm9ncmVzcywgXCJpbmZvQmdcIiwgVGUoZC5pbmZvLm1haW4sIDAuNjIpKSwgJChkLkxpbmVhclByb2dyZXNzLCBcInN1Y2Nlc3NCZ1wiLCBUZShkLnN1Y2Nlc3MubWFpbiwgMC42MikpLCAkKGQuTGluZWFyUHJvZ3Jlc3MsIFwid2FybmluZ0JnXCIsIFRlKGQud2FybmluZy5tYWluLCAwLjYyKSksICQoZC5Ta2VsZXRvbiwgXCJiZ1wiLCBgcmdiYSgke0EoXCJwYWxldHRlLXRleHQtcHJpbWFyeUNoYW5uZWxcIil9IC8gMC4xMSlgKSwgJChkLlNsaWRlciwgXCJwcmltYXJ5VHJhY2tcIiwgVGUoZC5wcmltYXJ5Lm1haW4sIDAuNjIpKSwgJChkLlNsaWRlciwgXCJzZWNvbmRhcnlUcmFja1wiLCBUZShkLnNlY29uZGFyeS5tYWluLCAwLjYyKSksICQoZC5TbGlkZXIsIFwiZXJyb3JUcmFja1wiLCBUZShkLmVycm9yLm1haW4sIDAuNjIpKSwgJChkLlNsaWRlciwgXCJpbmZvVHJhY2tcIiwgVGUoZC5pbmZvLm1haW4sIDAuNjIpKSwgJChkLlNsaWRlciwgXCJzdWNjZXNzVHJhY2tcIiwgVGUoZC5zdWNjZXNzLm1haW4sIDAuNjIpKSwgJChkLlNsaWRlciwgXCJ3YXJuaW5nVHJhY2tcIiwgVGUoZC53YXJuaW5nLm1haW4sIDAuNjIpKTtcbiAgICAgIGNvbnN0IEQgPSBKcihkLmJhY2tncm91bmQuZGVmYXVsdCwgMC44KTtcbiAgICAgICQoZC5TbmFja2JhckNvbnRlbnQsIFwiYmdcIiwgRCksICQoZC5TbmFja2JhckNvbnRlbnQsIFwiY29sb3JcIiwgcHQoKCkgPT4gZC5nZXRDb250cmFzdFRleHQoRCkpKSwgJChkLlNwZWVkRGlhbEFjdGlvbiwgXCJmYWJIb3ZlckJnXCIsIEpyKGQuYmFja2dyb3VuZC5wYXBlciwgMC4xNSkpLCAkKGQuU3RlcENvbm5lY3RvciwgXCJib3JkZXJcIiwgQShcInBhbGV0dGUtZ3JleS00MDBcIikpLCAkKGQuU3RlcENvbnRlbnQsIFwiYm9yZGVyXCIsIEEoXCJwYWxldHRlLWdyZXktNDAwXCIpKSwgJChkLlN3aXRjaCwgXCJkZWZhdWx0Q29sb3JcIiwgQShcInBhbGV0dGUtY29tbW9uLXdoaXRlXCIpKSwgJChkLlN3aXRjaCwgXCJkZWZhdWx0RGlzYWJsZWRDb2xvclwiLCBBKFwicGFsZXR0ZS1ncmV5LTEwMFwiKSksICQoZC5Td2l0Y2gsIFwicHJpbWFyeURpc2FibGVkQ29sb3JcIiwgVGUoZC5wcmltYXJ5Lm1haW4sIDAuNjIpKSwgJChkLlN3aXRjaCwgXCJzZWNvbmRhcnlEaXNhYmxlZENvbG9yXCIsIFRlKGQuc2Vjb25kYXJ5Lm1haW4sIDAuNjIpKSwgJChkLlN3aXRjaCwgXCJlcnJvckRpc2FibGVkQ29sb3JcIiwgVGUoZC5lcnJvci5tYWluLCAwLjYyKSksICQoZC5Td2l0Y2gsIFwiaW5mb0Rpc2FibGVkQ29sb3JcIiwgVGUoZC5pbmZvLm1haW4sIDAuNjIpKSwgJChkLlN3aXRjaCwgXCJzdWNjZXNzRGlzYWJsZWRDb2xvclwiLCBUZShkLnN1Y2Nlc3MubWFpbiwgMC42MikpLCAkKGQuU3dpdGNoLCBcIndhcm5pbmdEaXNhYmxlZENvbG9yXCIsIFRlKGQud2FybmluZy5tYWluLCAwLjYyKSksICQoZC5UYWJsZUNlbGwsIFwiYm9yZGVyXCIsIFRlKFhyKGQuZGl2aWRlciwgMSksIDAuODgpKSwgJChkLlRvb2x0aXAsIFwiYmdcIiwgWHIoZC5ncmV5WzcwMF0sIDAuOTIpKTtcbiAgICB9XG4gICAgaWYgKGQubW9kZSA9PT0gXCJkYXJrXCIpIHtcbiAgICAgICQoZC5BbGVydCwgXCJlcnJvckNvbG9yXCIsIFRlKGQuZXJyb3IubGlnaHQsIDAuNikpLCAkKGQuQWxlcnQsIFwiaW5mb0NvbG9yXCIsIFRlKGQuaW5mby5saWdodCwgMC42KSksICQoZC5BbGVydCwgXCJzdWNjZXNzQ29sb3JcIiwgVGUoZC5zdWNjZXNzLmxpZ2h0LCAwLjYpKSwgJChkLkFsZXJ0LCBcIndhcm5pbmdDb2xvclwiLCBUZShkLndhcm5pbmcubGlnaHQsIDAuNikpLCAkKGQuQWxlcnQsIFwiZXJyb3JGaWxsZWRCZ1wiLCBBKFwicGFsZXR0ZS1lcnJvci1kYXJrXCIpKSwgJChkLkFsZXJ0LCBcImluZm9GaWxsZWRCZ1wiLCBBKFwicGFsZXR0ZS1pbmZvLWRhcmtcIikpLCAkKGQuQWxlcnQsIFwic3VjY2Vzc0ZpbGxlZEJnXCIsIEEoXCJwYWxldHRlLXN1Y2Nlc3MtZGFya1wiKSksICQoZC5BbGVydCwgXCJ3YXJuaW5nRmlsbGVkQmdcIiwgQShcInBhbGV0dGUtd2FybmluZy1kYXJrXCIpKSwgJChkLkFsZXJ0LCBcImVycm9yRmlsbGVkQ29sb3JcIiwgcHQoKCkgPT4gZC5nZXRDb250cmFzdFRleHQoZC5lcnJvci5kYXJrKSkpLCAkKGQuQWxlcnQsIFwiaW5mb0ZpbGxlZENvbG9yXCIsIHB0KCgpID0+IGQuZ2V0Q29udHJhc3RUZXh0KGQuaW5mby5kYXJrKSkpLCAkKGQuQWxlcnQsIFwic3VjY2Vzc0ZpbGxlZENvbG9yXCIsIHB0KCgpID0+IGQuZ2V0Q29udHJhc3RUZXh0KGQuc3VjY2Vzcy5kYXJrKSkpLCAkKGQuQWxlcnQsIFwid2FybmluZ0ZpbGxlZENvbG9yXCIsIHB0KCgpID0+IGQuZ2V0Q29udHJhc3RUZXh0KGQud2FybmluZy5kYXJrKSkpLCAkKGQuQWxlcnQsIFwiZXJyb3JTdGFuZGFyZEJnXCIsIENlKGQuZXJyb3IubGlnaHQsIDAuOSkpLCAkKGQuQWxlcnQsIFwiaW5mb1N0YW5kYXJkQmdcIiwgQ2UoZC5pbmZvLmxpZ2h0LCAwLjkpKSwgJChkLkFsZXJ0LCBcInN1Y2Nlc3NTdGFuZGFyZEJnXCIsIENlKGQuc3VjY2Vzcy5saWdodCwgMC45KSksICQoZC5BbGVydCwgXCJ3YXJuaW5nU3RhbmRhcmRCZ1wiLCBDZShkLndhcm5pbmcubGlnaHQsIDAuOSkpLCAkKGQuQWxlcnQsIFwiZXJyb3JJY29uQ29sb3JcIiwgQShcInBhbGV0dGUtZXJyb3ItbWFpblwiKSksICQoZC5BbGVydCwgXCJpbmZvSWNvbkNvbG9yXCIsIEEoXCJwYWxldHRlLWluZm8tbWFpblwiKSksICQoZC5BbGVydCwgXCJzdWNjZXNzSWNvbkNvbG9yXCIsIEEoXCJwYWxldHRlLXN1Y2Nlc3MtbWFpblwiKSksICQoZC5BbGVydCwgXCJ3YXJuaW5nSWNvbkNvbG9yXCIsIEEoXCJwYWxldHRlLXdhcm5pbmctbWFpblwiKSksICQoZC5BcHBCYXIsIFwiZGVmYXVsdEJnXCIsIEEoXCJwYWxldHRlLWdyZXktOTAwXCIpKSwgJChkLkFwcEJhciwgXCJkYXJrQmdcIiwgQShcInBhbGV0dGUtYmFja2dyb3VuZC1wYXBlclwiKSksICQoZC5BcHBCYXIsIFwiZGFya0NvbG9yXCIsIEEoXCJwYWxldHRlLXRleHQtcHJpbWFyeVwiKSksICQoZC5BdmF0YXIsIFwiZGVmYXVsdEJnXCIsIEEoXCJwYWxldHRlLWdyZXktNjAwXCIpKSwgJChkLkJ1dHRvbiwgXCJpbmhlcml0Q29udGFpbmVkQmdcIiwgQShcInBhbGV0dGUtZ3JleS04MDBcIikpLCAkKGQuQnV0dG9uLCBcImluaGVyaXRDb250YWluZWRIb3ZlckJnXCIsIEEoXCJwYWxldHRlLWdyZXktNzAwXCIpKSwgJChkLkNoaXAsIFwiZGVmYXVsdEJvcmRlclwiLCBBKFwicGFsZXR0ZS1ncmV5LTcwMFwiKSksICQoZC5DaGlwLCBcImRlZmF1bHRBdmF0YXJDb2xvclwiLCBBKFwicGFsZXR0ZS1ncmV5LTMwMFwiKSksICQoZC5DaGlwLCBcImRlZmF1bHRJY29uQ29sb3JcIiwgQShcInBhbGV0dGUtZ3JleS0zMDBcIikpLCAkKGQuRmlsbGVkSW5wdXQsIFwiYmdcIiwgXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDkpXCIpLCAkKGQuRmlsbGVkSW5wdXQsIFwiaG92ZXJCZ1wiLCBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMylcIiksICQoZC5GaWxsZWRJbnB1dCwgXCJkaXNhYmxlZEJnXCIsIFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKVwiKSwgJChkLkxpbmVhclByb2dyZXNzLCBcInByaW1hcnlCZ1wiLCBDZShkLnByaW1hcnkubWFpbiwgMC41KSksICQoZC5MaW5lYXJQcm9ncmVzcywgXCJzZWNvbmRhcnlCZ1wiLCBDZShkLnNlY29uZGFyeS5tYWluLCAwLjUpKSwgJChkLkxpbmVhclByb2dyZXNzLCBcImVycm9yQmdcIiwgQ2UoZC5lcnJvci5tYWluLCAwLjUpKSwgJChkLkxpbmVhclByb2dyZXNzLCBcImluZm9CZ1wiLCBDZShkLmluZm8ubWFpbiwgMC41KSksICQoZC5MaW5lYXJQcm9ncmVzcywgXCJzdWNjZXNzQmdcIiwgQ2UoZC5zdWNjZXNzLm1haW4sIDAuNSkpLCAkKGQuTGluZWFyUHJvZ3Jlc3MsIFwid2FybmluZ0JnXCIsIENlKGQud2FybmluZy5tYWluLCAwLjUpKSwgJChkLlNrZWxldG9uLCBcImJnXCIsIGByZ2JhKCR7QShcInBhbGV0dGUtdGV4dC1wcmltYXJ5Q2hhbm5lbFwiKX0gLyAwLjEzKWApLCAkKGQuU2xpZGVyLCBcInByaW1hcnlUcmFja1wiLCBDZShkLnByaW1hcnkubWFpbiwgMC41KSksICQoZC5TbGlkZXIsIFwic2Vjb25kYXJ5VHJhY2tcIiwgQ2UoZC5zZWNvbmRhcnkubWFpbiwgMC41KSksICQoZC5TbGlkZXIsIFwiZXJyb3JUcmFja1wiLCBDZShkLmVycm9yLm1haW4sIDAuNSkpLCAkKGQuU2xpZGVyLCBcImluZm9UcmFja1wiLCBDZShkLmluZm8ubWFpbiwgMC41KSksICQoZC5TbGlkZXIsIFwic3VjY2Vzc1RyYWNrXCIsIENlKGQuc3VjY2Vzcy5tYWluLCAwLjUpKSwgJChkLlNsaWRlciwgXCJ3YXJuaW5nVHJhY2tcIiwgQ2UoZC53YXJuaW5nLm1haW4sIDAuNSkpO1xuICAgICAgY29uc3QgRCA9IEpyKGQuYmFja2dyb3VuZC5kZWZhdWx0LCAwLjk4KTtcbiAgICAgICQoZC5TbmFja2JhckNvbnRlbnQsIFwiYmdcIiwgRCksICQoZC5TbmFja2JhckNvbnRlbnQsIFwiY29sb3JcIiwgcHQoKCkgPT4gZC5nZXRDb250cmFzdFRleHQoRCkpKSwgJChkLlNwZWVkRGlhbEFjdGlvbiwgXCJmYWJIb3ZlckJnXCIsIEpyKGQuYmFja2dyb3VuZC5wYXBlciwgMC4xNSkpLCAkKGQuU3RlcENvbm5lY3RvciwgXCJib3JkZXJcIiwgQShcInBhbGV0dGUtZ3JleS02MDBcIikpLCAkKGQuU3RlcENvbnRlbnQsIFwiYm9yZGVyXCIsIEEoXCJwYWxldHRlLWdyZXktNjAwXCIpKSwgJChkLlN3aXRjaCwgXCJkZWZhdWx0Q29sb3JcIiwgQShcInBhbGV0dGUtZ3JleS0zMDBcIikpLCAkKGQuU3dpdGNoLCBcImRlZmF1bHREaXNhYmxlZENvbG9yXCIsIEEoXCJwYWxldHRlLWdyZXktNjAwXCIpKSwgJChkLlN3aXRjaCwgXCJwcmltYXJ5RGlzYWJsZWRDb2xvclwiLCBDZShkLnByaW1hcnkubWFpbiwgMC41NSkpLCAkKGQuU3dpdGNoLCBcInNlY29uZGFyeURpc2FibGVkQ29sb3JcIiwgQ2UoZC5zZWNvbmRhcnkubWFpbiwgMC41NSkpLCAkKGQuU3dpdGNoLCBcImVycm9yRGlzYWJsZWRDb2xvclwiLCBDZShkLmVycm9yLm1haW4sIDAuNTUpKSwgJChkLlN3aXRjaCwgXCJpbmZvRGlzYWJsZWRDb2xvclwiLCBDZShkLmluZm8ubWFpbiwgMC41NSkpLCAkKGQuU3dpdGNoLCBcInN1Y2Nlc3NEaXNhYmxlZENvbG9yXCIsIENlKGQuc3VjY2Vzcy5tYWluLCAwLjU1KSksICQoZC5Td2l0Y2gsIFwid2FybmluZ0Rpc2FibGVkQ29sb3JcIiwgQ2UoZC53YXJuaW5nLm1haW4sIDAuNTUpKSwgJChkLlRhYmxlQ2VsbCwgXCJib3JkZXJcIiwgQ2UoWHIoZC5kaXZpZGVyLCAxKSwgMC42OCkpLCAkKGQuVG9vbHRpcCwgXCJiZ1wiLCBYcihkLmdyZXlbNzAwXSwgMC45MikpO1xuICAgIH1cbiAgICBDdChkLmJhY2tncm91bmQsIFwiZGVmYXVsdFwiKSwgQ3QoZC5iYWNrZ3JvdW5kLCBcInBhcGVyXCIpLCBDdChkLmNvbW1vbiwgXCJiYWNrZ3JvdW5kXCIpLCBDdChkLmNvbW1vbiwgXCJvbkJhY2tncm91bmRcIiksIEN0KGQsIFwiZGl2aWRlclwiKSwgT2JqZWN0LmtleXMoZCkuZm9yRWFjaCgoRCkgPT4ge1xuICAgICAgY29uc3QgaiA9IGRbRF07XG4gICAgICBEICE9PSBcInRvbmFsT2Zmc2V0XCIgJiYgaiAmJiB0eXBlb2YgaiA9PSBcIm9iamVjdFwiICYmIChqLm1haW4gJiYgJChkW0RdLCBcIm1haW5DaGFubmVsXCIsIGdyKHlyKGoubWFpbikpKSwgai5saWdodCAmJiAkKGRbRF0sIFwibGlnaHRDaGFubmVsXCIsIGdyKHlyKGoubGlnaHQpKSksIGouZGFyayAmJiAkKGRbRF0sIFwiZGFya0NoYW5uZWxcIiwgZ3IoeXIoai5kYXJrKSkpLCBqLmNvbnRyYXN0VGV4dCAmJiAkKGRbRF0sIFwiY29udHJhc3RUZXh0Q2hhbm5lbFwiLCBncih5cihqLmNvbnRyYXN0VGV4dCkpKSwgRCA9PT0gXCJ0ZXh0XCIgJiYgKEN0KGRbRF0sIFwicHJpbWFyeVwiKSwgQ3QoZFtEXSwgXCJzZWNvbmRhcnlcIikpLCBEID09PSBcImFjdGlvblwiICYmIChqLmFjdGl2ZSAmJiBDdChkW0RdLCBcImFjdGl2ZVwiKSwgai5zZWxlY3RlZCAmJiBDdChkW0RdLCBcInNlbGVjdGVkXCIpKSk7XG4gICAgfSk7XG4gIH0pLCBiID0gdC5yZWR1Y2UoKEIsIGQpID0+IHR0KEIsIGQpLCBiKTtcbiAgY29uc3QgaCA9IHtcbiAgICBwcmVmaXg6IGksXG4gICAgZGlzYWJsZUNzc0NvbG9yU2NoZW1lOiBvLFxuICAgIHNob3VsZFNraXBHZW5lcmF0aW5nVmFyOiBzLFxuICAgIGdldFNlbGVjdG9yOiBJZihiKVxuICB9LCB7XG4gICAgdmFyczogdyxcbiAgICBnZW5lcmF0ZVRoZW1lVmFyczogayxcbiAgICBnZW5lcmF0ZVN0eWxlU2hlZXRzOiBMXG4gIH0gPSBjZihiLCBoKTtcbiAgcmV0dXJuIGIudmFycyA9IHcsIE9iamVjdC5lbnRyaWVzKGIuY29sb3JTY2hlbWVzW2IuZGVmYXVsdENvbG9yU2NoZW1lXSkuZm9yRWFjaCgoW0IsIGRdKSA9PiB7XG4gICAgYltCXSA9IGQ7XG4gIH0pLCBiLmdlbmVyYXRlVGhlbWVWYXJzID0gaywgYi5nZW5lcmF0ZVN0eWxlU2hlZXRzID0gTCwgYi5nZW5lcmF0ZVNwYWNpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQmEodS5zcGFjaW5nLCBrbyh0aGlzKSk7XG4gIH0sIGIuZ2V0Q29sb3JTY2hlbWVTZWxlY3RvciA9IGxmKGMpLCBiLnNwYWNpbmcgPSBiLmdlbmVyYXRlU3BhY2luZygpLCBiLnNob3VsZFNraXBHZW5lcmF0aW5nVmFyID0gcywgYi51bnN0YWJsZV9zeENvbmZpZyA9IHtcbiAgICAuLi5EcixcbiAgICAuLi51ID09IG51bGwgPyB2b2lkIDAgOiB1LnVuc3RhYmxlX3N4Q29uZmlnXG4gIH0sIGIudW5zdGFibGVfc3ggPSBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIEF0KHtcbiAgICAgIHN4OiBkLFxuICAgICAgdGhlbWU6IHRoaXNcbiAgICB9KTtcbiAgfSwgYi50b1J1bnRpbWVTb3VyY2UgPSBwcywgYjtcbn1cbmZ1bmN0aW9uIG5hKGUsIHQsIHIpIHtcbiAgZS5jb2xvclNjaGVtZXMgJiYgciAmJiAoZS5jb2xvclNjaGVtZXNbdF0gPSB7XG4gICAgLi4uciAhPT0gITAgJiYgcixcbiAgICBwYWxldHRlOiBVbyh7XG4gICAgICAuLi5yID09PSAhMCA/IHt9IDogci5wYWxldHRlLFxuICAgICAgbW9kZTogdFxuICAgIH0pXG4gICAgLy8gY2FzdCB0eXBlIHRvIHNraXAgbW9kdWxlIGF1Z21lbnRhdGlvbiB0ZXN0XG4gIH0pO1xufVxuZnVuY3Rpb24gRm4oZSA9IHt9LCAuLi50KSB7XG4gIGNvbnN0IHtcbiAgICBwYWxldHRlOiByLFxuICAgIGNzc1ZhcmlhYmxlczogbiA9ICExLFxuICAgIGNvbG9yU2NoZW1lczogbyA9IHIgPyB2b2lkIDAgOiB7XG4gICAgICBsaWdodDogITBcbiAgICB9LFxuICAgIGRlZmF1bHRDb2xvclNjaGVtZTogaSA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIubW9kZSxcbiAgICAuLi5zXG4gIH0gPSBlLCBjID0gaSB8fCBcImxpZ2h0XCIsIGwgPSBvID09IG51bGwgPyB2b2lkIDAgOiBvW2NdLCB1ID0ge1xuICAgIC4uLm8sXG4gICAgLi4uciA/IHtcbiAgICAgIFtjXToge1xuICAgICAgICAuLi50eXBlb2YgbCAhPSBcImJvb2xlYW5cIiAmJiBsLFxuICAgICAgICBwYWxldHRlOiByXG4gICAgICB9XG4gICAgfSA6IHZvaWQgMFxuICB9O1xuICBpZiAobiA9PT0gITEpIHtcbiAgICBpZiAoIShcImNvbG9yU2NoZW1lc1wiIGluIGUpKVxuICAgICAgcmV0dXJuIGZvKGUsIC4uLnQpO1xuICAgIGxldCBwID0gcjtcbiAgICBcInBhbGV0dGVcIiBpbiBlIHx8IHVbY10gJiYgKHVbY10gIT09ICEwID8gcCA9IHVbY10ucGFsZXR0ZSA6IGMgPT09IFwiZGFya1wiICYmIChwID0ge1xuICAgICAgbW9kZTogXCJkYXJrXCJcbiAgICB9KSk7XG4gICAgY29uc3QgbSA9IGZvKHtcbiAgICAgIC4uLmUsXG4gICAgICBwYWxldHRlOiBwXG4gICAgfSwgLi4udCk7XG4gICAgcmV0dXJuIG0uZGVmYXVsdENvbG9yU2NoZW1lID0gYywgbS5jb2xvclNjaGVtZXMgPSB1LCBtLnBhbGV0dGUubW9kZSA9PT0gXCJsaWdodFwiICYmIChtLmNvbG9yU2NoZW1lcy5saWdodCA9IHtcbiAgICAgIC4uLnUubGlnaHQgIT09ICEwICYmIHUubGlnaHQsXG4gICAgICBwYWxldHRlOiBtLnBhbGV0dGVcbiAgICB9LCBuYShtLCBcImRhcmtcIiwgdS5kYXJrKSksIG0ucGFsZXR0ZS5tb2RlID09PSBcImRhcmtcIiAmJiAobS5jb2xvclNjaGVtZXMuZGFyayA9IHtcbiAgICAgIC4uLnUuZGFyayAhPT0gITAgJiYgdS5kYXJrLFxuICAgICAgcGFsZXR0ZTogbS5wYWxldHRlXG4gICAgfSwgbmEobSwgXCJsaWdodFwiLCB1LmxpZ2h0KSksIG07XG4gIH1cbiAgcmV0dXJuICFyICYmICEoXCJsaWdodFwiIGluIHUpICYmIGMgPT09IFwibGlnaHRcIiAmJiAodS5saWdodCA9ICEwKSwgTGYoe1xuICAgIC4uLnMsXG4gICAgY29sb3JTY2hlbWVzOiB1LFxuICAgIGRlZmF1bHRDb2xvclNjaGVtZTogYyxcbiAgICAuLi50eXBlb2YgbiAhPSBcImJvb2xlYW5cIiAmJiBuXG4gIH0sIC4uLnQpO1xufVxuY29uc3QgZ3MgPSBGbigpO1xuZnVuY3Rpb24gTHIoKSB7XG4gIGNvbnN0IGUgPSBGYShncyk7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgQy51c2VEZWJ1Z1ZhbHVlKGUpLCBlW3d0XSB8fCBlO1xufVxuZnVuY3Rpb24gQmYoZSkge1xuICByZXR1cm4gZSAhPT0gXCJvd25lclN0YXRlXCIgJiYgZSAhPT0gXCJ0aGVtZVwiICYmIGUgIT09IFwic3hcIiAmJiBlICE9PSBcImFzXCI7XG59XG5jb25zdCB5cyA9IChlKSA9PiBCZihlKSAmJiBlICE9PSBcImNsYXNzZXNcIiwgbGUgPSBUdSh7XG4gIHRoZW1lSWQ6IHd0LFxuICBkZWZhdWx0VGhlbWU6IGdzLFxuICByb290U2hvdWxkRm9yd2FyZFByb3A6IHlzXG59KTtcbmZ1bmN0aW9uIG9hKHtcbiAgdGhlbWU6IGUsXG4gIC4uLnRcbn0pIHtcbiAgY29uc3QgciA9IHd0IGluIGUgPyBlW3d0XSA6IHZvaWQgMDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChSciwge1xuICAgIC4uLnQsXG4gICAgdGhlbWVJZDogciA/IHd0IDogdm9pZCAwLFxuICAgIHRoZW1lOiByIHx8IGVcbiAgfSk7XG59XG5jb25zdCBRciA9IHtcbiAgYXR0cmlidXRlOiBcImRhdGEtbXVpLWNvbG9yLXNjaGVtZVwiLFxuICBjb2xvclNjaGVtZVN0b3JhZ2VLZXk6IFwibXVpLWNvbG9yLXNjaGVtZVwiLFxuICBkZWZhdWx0TGlnaHRDb2xvclNjaGVtZTogXCJsaWdodFwiLFxuICBkZWZhdWx0RGFya0NvbG9yU2NoZW1lOiBcImRhcmtcIixcbiAgbW9kZVN0b3JhZ2VLZXk6IFwibXVpLW1vZGVcIlxufSwge1xuICBDc3NWYXJzUHJvdmlkZXI6IFZmLFxuICB1c2VDb2xvclNjaGVtZTogem0sXG4gIGdldEluaXRDb2xvclNjaGVtZVNjcmlwdDogV21cbn0gPSBuZih7XG4gIHRoZW1lSWQ6IHd0LFxuICAvLyBAdHMtaWdub3JlIGlnbm9yZSBtb2R1bGUgYXVnbWVudGF0aW9uIHRlc3RzXG4gIHRoZW1lOiAoKSA9PiBGbih7XG4gICAgY3NzVmFyaWFibGVzOiAhMFxuICB9KSxcbiAgY29sb3JTY2hlbWVTdG9yYWdlS2V5OiBRci5jb2xvclNjaGVtZVN0b3JhZ2VLZXksXG4gIG1vZGVTdG9yYWdlS2V5OiBRci5tb2RlU3RvcmFnZUtleSxcbiAgZGVmYXVsdENvbG9yU2NoZW1lOiB7XG4gICAgbGlnaHQ6IFFyLmRlZmF1bHRMaWdodENvbG9yU2NoZW1lLFxuICAgIGRhcms6IFFyLmRlZmF1bHREYXJrQ29sb3JTY2hlbWVcbiAgfSxcbiAgcmVzb2x2ZVRoZW1lOiAoZSkgPT4ge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICAuLi5lLFxuICAgICAgdHlwb2dyYXBoeTogZnMoZS5wYWxldHRlLCBlLnR5cG9ncmFwaHkpXG4gICAgfTtcbiAgICByZXR1cm4gdC51bnN0YWJsZV9zeCA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBBdCh7XG4gICAgICAgIHN4OiBuLFxuICAgICAgICB0aGVtZTogdGhpc1xuICAgICAgfSk7XG4gICAgfSwgdDtcbiAgfVxufSksIEZmID0gVmY7XG5mdW5jdGlvbiB6Zih7XG4gIHRoZW1lOiBlLFxuICAuLi50XG59KSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyAvKiBAX19QVVJFX18gKi8gTi5qc3gob2EsIHtcbiAgICB0aGVtZTogZSxcbiAgICAuLi50XG4gIH0pIDogXCJjb2xvclNjaGVtZXNcIiBpbiAod3QgaW4gZSA/IGVbd3RdIDogZSkgPyAvKiBAX19QVVJFX18gKi8gTi5qc3goRmYsIHtcbiAgICB0aGVtZTogZSxcbiAgICAuLi50XG4gIH0pIDogLyogQF9fUFVSRV9fICovIE4uanN4KG9hLCB7XG4gICAgdGhlbWU6IGUsXG4gICAgLi4udFxuICB9KTtcbn1cbmZ1bmN0aW9uIFdmKCkge1xuICByZXR1cm4gemE7XG59XG5jb25zdCBxZSA9IEp1O1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChhLm5vZGUsIGEub2JqZWN0LmlzUmVxdWlyZWQpO1xuZnVuY3Rpb24gSGUoZSkge1xuICByZXR1cm4gWHUoZSk7XG59XG5mdW5jdGlvbiBVZihlKSB7XG4gIHJldHVybiBWZShcIk11aVN2Z0ljb25cIiwgZSk7XG59XG5GZShcIk11aVN2Z0ljb25cIiwgW1wicm9vdFwiLCBcImNvbG9yUHJpbWFyeVwiLCBcImNvbG9yU2Vjb25kYXJ5XCIsIFwiY29sb3JBY3Rpb25cIiwgXCJjb2xvckVycm9yXCIsIFwiY29sb3JEaXNhYmxlZFwiLCBcImZvbnRTaXplSW5oZXJpdFwiLCBcImZvbnRTaXplU21hbGxcIiwgXCJmb250U2l6ZU1lZGl1bVwiLCBcImZvbnRTaXplTGFyZ2VcIl0pO1xuY29uc3QgWWYgPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgY29sb3I6IHQsXG4gICAgZm9udFNpemU6IHIsXG4gICAgY2xhc3NlczogblxuICB9ID0gZSwgbyA9IHtcbiAgICByb290OiBbXCJyb290XCIsIHQgIT09IFwiaW5oZXJpdFwiICYmIGBjb2xvciR7ZWUodCl9YCwgYGZvbnRTaXplJHtlZShyKX1gXVxuICB9O1xuICByZXR1cm4gR2UobywgVWYsIG4pO1xufSwgSGYgPSBsZShcInN2Z1wiLCB7XG4gIG5hbWU6IFwiTXVpU3ZnSWNvblwiLFxuICBzbG90OiBcIlJvb3RcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJTdGF0ZTogclxuICAgIH0gPSBlO1xuICAgIHJldHVybiBbdC5yb290LCByLmNvbG9yICE9PSBcImluaGVyaXRcIiAmJiB0W2Bjb2xvciR7ZWUoci5jb2xvcil9YF0sIHRbYGZvbnRTaXplJHtlZShyLmZvbnRTaXplKX1gXV07XG4gIH1cbn0pKHFlKCh7XG4gIHRoZW1lOiBlXG59KSA9PiB7XG4gIHZhciB0LCByLCBuLCBvLCBpLCBzLCBjLCBsLCB1LCBwLCBtLCBnLCB4LCB5O1xuICByZXR1cm4ge1xuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICAgIHdpZHRoOiBcIjFlbVwiLFxuICAgIGhlaWdodDogXCIxZW1cIixcbiAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgIGZsZXhTaHJpbms6IDAsXG4gICAgdHJhbnNpdGlvbjogKG8gPSAodCA9IGUudHJhbnNpdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiB0LmNyZWF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uY2FsbCh0LCBcImZpbGxcIiwge1xuICAgICAgZHVyYXRpb246IChuID0gKHIgPSAoZS52YXJzID8/IGUpLnRyYW5zaXRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogci5kdXJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IG4uc2hvcnRlclxuICAgIH0pLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIHByb3BzOiAoZikgPT4gIWYuaGFzU3ZnQXNDaGlsZCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAvLyB0aGUgPHN2Zz4gd2lsbCBkZWZpbmUgdGhlIHByb3BlcnR5IHRoYXQgaGFzIGBjdXJyZW50Q29sb3JgXG4gICAgICAgICAgLy8gZm9yIGV4YW1wbGUgaGVyb2ljb25zIHVzZXMgZmlsbD1cIm5vbmVcIiBhbmQgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZm9udFNpemU6IFwiaW5oZXJpdFwiXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZm9udFNpemU6IFwiaW5oZXJpdFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZm9udFNpemU6IFwic21hbGxcIlxuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGZvbnRTaXplOiAoKHMgPSAoaSA9IGUudHlwb2dyYXBoeSkgPT0gbnVsbCA/IHZvaWQgMCA6IGkucHhUb1JlbSkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuY2FsbChpLCAyMCkpIHx8IFwiMS4yNXJlbVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZm9udFNpemU6IFwibWVkaXVtXCJcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBmb250U2l6ZTogKChsID0gKGMgPSBlLnR5cG9ncmFwaHkpID09IG51bGwgPyB2b2lkIDAgOiBjLnB4VG9SZW0pID09IG51bGwgPyB2b2lkIDAgOiBsLmNhbGwoYywgMjQpKSB8fCBcIjEuNXJlbVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZm9udFNpemU6IFwibGFyZ2VcIlxuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGZvbnRTaXplOiAoKHAgPSAodSA9IGUudHlwb2dyYXBoeSkgPT0gbnVsbCA/IHZvaWQgMCA6IHUucHhUb1JlbSkgPT0gbnVsbCA/IHZvaWQgMCA6IHAuY2FsbCh1LCAzNSkpIHx8IFwiMi4xODc1cmVtXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFRPRE8gdjUgZGVwcmVjYXRlIGNvbG9yIHByb3AsIHY2IHJlbW92ZSBmb3Igc3hcbiAgICAgIC4uLk9iamVjdC5lbnRyaWVzKChlLnZhcnMgPz8gZSkucGFsZXR0ZSkuZmlsdGVyKChbLCBmXSkgPT4gZiAmJiBmLm1haW4pLm1hcCgoW2ZdKSA9PiB7XG4gICAgICAgIHZhciBTLCBFO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBjb2xvcjogZlxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yOiAoRSA9IChTID0gKGUudmFycyA/PyBlKS5wYWxldHRlKSA9PSBudWxsID8gdm9pZCAwIDogU1tmXSkgPT0gbnVsbCA/IHZvaWQgMCA6IEUubWFpblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGNvbG9yOiBcImFjdGlvblwiXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6IChnID0gKG0gPSAoZS52YXJzID8/IGUpLnBhbGV0dGUpID09IG51bGwgPyB2b2lkIDAgOiBtLmFjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IGcuYWN0aXZlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgY29sb3I6IFwiZGlzYWJsZWRcIlxuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGNvbG9yOiAoeSA9ICh4ID0gKGUudmFycyA/PyBlKS5wYWxldHRlKSA9PSBudWxsID8gdm9pZCAwIDogeC5hY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiB5LmRpc2FibGVkXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9O1xufSkpLCB5biA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCBuID0gSGUoe1xuICAgIHByb3BzOiB0LFxuICAgIG5hbWU6IFwiTXVpU3ZnSWNvblwiXG4gIH0pLCB7XG4gICAgY2hpbGRyZW46IG8sXG4gICAgY2xhc3NOYW1lOiBpLFxuICAgIGNvbG9yOiBzID0gXCJpbmhlcml0XCIsXG4gICAgY29tcG9uZW50OiBjID0gXCJzdmdcIixcbiAgICBmb250U2l6ZTogbCA9IFwibWVkaXVtXCIsXG4gICAgaHRtbENvbG9yOiB1LFxuICAgIGluaGVyaXRWaWV3Qm94OiBwID0gITEsXG4gICAgdGl0bGVBY2Nlc3M6IG0sXG4gICAgdmlld0JveDogZyA9IFwiMCAwIDI0IDI0XCIsXG4gICAgLi4ueFxuICB9ID0gbiwgeSA9IC8qIEBfX1BVUkVfXyAqLyBDLmlzVmFsaWRFbGVtZW50KG8pICYmIG8udHlwZSA9PT0gXCJzdmdcIiwgZiA9IHtcbiAgICAuLi5uLFxuICAgIGNvbG9yOiBzLFxuICAgIGNvbXBvbmVudDogYyxcbiAgICBmb250U2l6ZTogbCxcbiAgICBpbnN0YW5jZUZvbnRTaXplOiB0LmZvbnRTaXplLFxuICAgIGluaGVyaXRWaWV3Qm94OiBwLFxuICAgIHZpZXdCb3g6IGcsXG4gICAgaGFzU3ZnQXNDaGlsZDogeVxuICB9LCBTID0ge307XG4gIHAgfHwgKFMudmlld0JveCA9IGcpO1xuICBjb25zdCBFID0gWWYoZik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3hzKEhmLCB7XG4gICAgYXM6IGMsXG4gICAgY2xhc3NOYW1lOiBzZShFLnJvb3QsIGkpLFxuICAgIGZvY3VzYWJsZTogXCJmYWxzZVwiLFxuICAgIGNvbG9yOiB1LFxuICAgIFwiYXJpYS1oaWRkZW5cIjogbSA/IHZvaWQgMCA6ICEwLFxuICAgIHJvbGU6IG0gPyBcImltZ1wiIDogdm9pZCAwLFxuICAgIHJlZjogcixcbiAgICAuLi5TLFxuICAgIC4uLngsXG4gICAgLi4ueSAmJiBvLnByb3BzLFxuICAgIG93bmVyU3RhdGU6IGYsXG4gICAgY2hpbGRyZW46IFt5ID8gby5wcm9wcy5jaGlsZHJlbiA6IG8sIG0gPyAvKiBAX19QVVJFX18gKi8gTi5qc3goXCJ0aXRsZVwiLCB7XG4gICAgICBjaGlsZHJlbjogbVxuICAgIH0pIDogbnVsbF1cbiAgfSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoeW4ucHJvcFR5cGVzID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiAgICBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4gICAgIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICAqIE5vZGUgcGFzc2VkIGludG8gdGhlIFNWRyBlbGVtZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LlxuICAgKiBJdCBzdXBwb3J0cyBib3RoIGRlZmF1bHQgYW5kIGN1c3RvbSB0aGVtZSBjb2xvcnMsIHdoaWNoIGNhbiBiZSBhZGRlZCBhcyBzaG93biBpbiB0aGVcbiAgICogW3BhbGV0dGUgY3VzdG9taXphdGlvbiBndWlkZV0oaHR0cHM6Ly9tdWkuY29tL21hdGVyaWFsLXVpL2N1c3RvbWl6YXRpb24vcGFsZXR0ZS8jY3VzdG9tLWNvbG9ycykuXG4gICAqIFlvdSBjYW4gdXNlIHRoZSBgaHRtbENvbG9yYCBwcm9wIHRvIGFwcGx5IGEgY29sb3IgYXR0cmlidXRlIHRvIHRoZSBTVkcgZWxlbWVudC5cbiAgICogQGRlZmF1bHQgJ2luaGVyaXQnXG4gICAqL1xuICBjb2xvcjogYS5vbmVPZlR5cGUoW2Eub25lT2YoW1wiaW5oZXJpdFwiLCBcImFjdGlvblwiLCBcImRpc2FibGVkXCIsIFwicHJpbWFyeVwiLCBcInNlY29uZGFyeVwiLCBcImVycm9yXCIsIFwiaW5mb1wiLCBcInN1Y2Nlc3NcIiwgXCJ3YXJuaW5nXCJdKSwgYS5zdHJpbmddKSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogYS5lbGVtZW50VHlwZSxcbiAgLyoqXG4gICAqIFRoZSBmb250U2l6ZSBhcHBsaWVkIHRvIHRoZSBpY29uLiBEZWZhdWx0cyB0byAyNHB4LCBidXQgY2FuIGJlIGNvbmZpZ3VyZSB0byBpbmhlcml0IGZvbnQgc2l6ZS5cbiAgICogQGRlZmF1bHQgJ21lZGl1bSdcbiAgICovXG4gIGZvbnRTaXplOiBhLm9uZU9mVHlwZShbYS5vbmVPZihbXCJpbmhlcml0XCIsIFwibGFyZ2VcIiwgXCJtZWRpdW1cIiwgXCJzbWFsbFwiXSksIGEuc3RyaW5nXSksXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgY29sb3IgYXR0cmlidXRlIHRvIHRoZSBTVkcgZWxlbWVudC5cbiAgICovXG4gIGh0bWxDb2xvcjogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByb290IG5vZGUgd2lsbCBpbmhlcml0IHRoZSBjdXN0b20gYGNvbXBvbmVudGAncyB2aWV3Qm94IGFuZCB0aGUgYHZpZXdCb3hgXG4gICAqIHByb3Agd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBVc2VmdWwgd2hlbiB5b3Ugd2FudCB0byByZWZlcmVuY2UgYSBjdXN0b20gYGNvbXBvbmVudGAgYW5kIGhhdmUgYFN2Z0ljb25gIHBhc3MgdGhhdFxuICAgKiBgY29tcG9uZW50YCdzIHZpZXdCb3ggdG8gdGhlIHJvb3Qgbm9kZS5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGluaGVyaXRWaWV3Qm94OiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUaGUgc2hhcGUtcmVuZGVyaW5nIGF0dHJpYnV0ZS4gVGhlIGJlaGF2aW9yIG9mIHRoZSBkaWZmZXJlbnQgb3B0aW9ucyBpcyBkZXNjcmliZWQgb24gdGhlXG4gICAqIFtNRE4gV2ViIERvY3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc2hhcGUtcmVuZGVyaW5nKS5cbiAgICogSWYgeW91IGFyZSBoYXZpbmcgaXNzdWVzIHdpdGggYmx1cnJ5IGljb25zIHlvdSBzaG91bGQgaW52ZXN0aWdhdGUgdGhpcyBwcm9wLlxuICAgKi9cbiAgc2hhcGVSZW5kZXJpbmc6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSksXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIGh1bWFuLXJlYWRhYmxlIHRpdGxlIGZvciB0aGUgZWxlbWVudCB0aGF0IGNvbnRhaW5zIGl0LlxuICAgKiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHLWFjY2Vzcy8jRXF1aXZhbGVudFxuICAgKi9cbiAgdGl0bGVBY2Nlc3M6IGEuc3RyaW5nLFxuICAvKipcbiAgICogQWxsb3dzIHlvdSB0byByZWRlZmluZSB3aGF0IHRoZSBjb29yZGluYXRlcyB3aXRob3V0IHVuaXRzIG1lYW4gaW5zaWRlIGFuIFNWRyBlbGVtZW50LlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIFNWRyBlbGVtZW50IGlzIDUwMCAod2lkdGgpIGJ5IDIwMCAoaGVpZ2h0KSxcbiAgICogYW5kIHlvdSBwYXNzIHZpZXdCb3g9XCIwIDAgNTAgMjBcIixcbiAgICogdGhpcyBtZWFucyB0aGF0IHRoZSBjb29yZGluYXRlcyBpbnNpZGUgdGhlIFNWRyB3aWxsIGdvIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciAoMCwwKVxuICAgKiB0byBib3R0b20gcmlnaHQgKDUwLDIwKSBhbmQgZWFjaCB1bml0IHdpbGwgYmUgd29ydGggMTBweC5cbiAgICogQGRlZmF1bHQgJzAgMCAyNCAyNCdcbiAgICovXG4gIHZpZXdCb3g6IGEuc3RyaW5nXG59KTtcbnluLm11aU5hbWUgPSBcIlN2Z0ljb25cIjtcbmZ1bmN0aW9uIHNyKGUsIHQpIHtcbiAgZnVuY3Rpb24gcihuLCBvKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeCh5biwge1xuICAgICAgXCJkYXRhLXRlc3RpZFwiOiBgJHt0fUljb25gLFxuICAgICAgcmVmOiBvLFxuICAgICAgLi4ubixcbiAgICAgIGNoaWxkcmVuOiBlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoci5kaXNwbGF5TmFtZSA9IGAke3R9SWNvbmApLCByLm11aU5hbWUgPSB5bi5tdWlOYW1lLCAvKiBAX19QVVJFX18gKi8gQy5tZW1vKC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYocikpO1xufVxuZnVuY3Rpb24gYnMoZSwgdCkge1xuICBpZiAoZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciByID0ge307XG4gIGZvciAodmFyIG4gaW4gZSkgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgbikpIHtcbiAgICBpZiAodC5pbmNsdWRlcyhuKSkgY29udGludWU7XG4gICAgcltuXSA9IGVbbl07XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBwbyhlLCB0KSB7XG4gIHJldHVybiBwbyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbihyLCBuKSB7XG4gICAgcmV0dXJuIHIuX19wcm90b19fID0gbiwgcjtcbiAgfSwgcG8oZSwgdCk7XG59XG5mdW5jdGlvbiB2cyhlLCB0KSB7XG4gIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSksIGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZSwgcG8oZSwgdCk7XG59XG5jb25zdCBpYSA9IHtcbiAgZGlzYWJsZWQ6ICExXG59O1xudmFyIHFmID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gYS5vbmVPZlR5cGUoW2EubnVtYmVyLCBhLnNoYXBlKHtcbiAgZW50ZXI6IGEubnVtYmVyLFxuICBleGl0OiBhLm51bWJlcixcbiAgYXBwZWFyOiBhLm51bWJlclxufSkuaXNSZXF1aXJlZF0pIDogbnVsbDtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBhLm9uZU9mVHlwZShbYS5zdHJpbmcsIGEuc2hhcGUoe1xuICBlbnRlcjogYS5zdHJpbmcsXG4gIGV4aXQ6IGEuc3RyaW5nLFxuICBhY3RpdmU6IGEuc3RyaW5nXG59KSwgYS5zaGFwZSh7XG4gIGVudGVyOiBhLnN0cmluZyxcbiAgZW50ZXJEb25lOiBhLnN0cmluZyxcbiAgZW50ZXJBY3RpdmU6IGEuc3RyaW5nLFxuICBleGl0OiBhLnN0cmluZyxcbiAgZXhpdERvbmU6IGEuc3RyaW5nLFxuICBleGl0QWN0aXZlOiBhLnN0cmluZ1xufSldKTtcbmNvbnN0IGJuID0geXQuY3JlYXRlQ29udGV4dChudWxsKTtcbnZhciBHZiA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQuc2Nyb2xsVG9wO1xufSwgYnIgPSBcInVubW91bnRlZFwiLCBfdCA9IFwiZXhpdGVkXCIsIGp0ID0gXCJlbnRlcmluZ1wiLCBLdCA9IFwiZW50ZXJlZFwiLCBtbyA9IFwiZXhpdGluZ1wiLCBFdCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihlKSB7XG4gIHZzKHQsIGUpO1xuICBmdW5jdGlvbiB0KG4sIG8pIHtcbiAgICB2YXIgaTtcbiAgICBpID0gZS5jYWxsKHRoaXMsIG4sIG8pIHx8IHRoaXM7XG4gICAgdmFyIHMgPSBvLCBjID0gcyAmJiAhcy5pc01vdW50aW5nID8gbi5lbnRlciA6IG4uYXBwZWFyLCBsO1xuICAgIHJldHVybiBpLmFwcGVhclN0YXR1cyA9IG51bGwsIG4uaW4gPyBjID8gKGwgPSBfdCwgaS5hcHBlYXJTdGF0dXMgPSBqdCkgOiBsID0gS3QgOiBuLnVubW91bnRPbkV4aXQgfHwgbi5tb3VudE9uRW50ZXIgPyBsID0gYnIgOiBsID0gX3QsIGkuc3RhdGUgPSB7XG4gICAgICBzdGF0dXM6IGxcbiAgICB9LCBpLm5leHRDYWxsYmFjayA9IG51bGwsIGk7XG4gIH1cbiAgdC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbihvLCBpKSB7XG4gICAgdmFyIHMgPSBvLmluO1xuICAgIHJldHVybiBzICYmIGkuc3RhdHVzID09PSBiciA/IHtcbiAgICAgIHN0YXR1czogX3RcbiAgICB9IDogbnVsbDtcbiAgfTtcbiAgdmFyIHIgPSB0LnByb3RvdHlwZTtcbiAgcmV0dXJuIHIuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyghMCwgdGhpcy5hcHBlYXJTdGF0dXMpO1xuICB9LCByLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgaSA9IG51bGw7XG4gICAgaWYgKG8gIT09IHRoaXMucHJvcHMpIHtcbiAgICAgIHZhciBzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG4gICAgICB0aGlzLnByb3BzLmluID8gcyAhPT0ganQgJiYgcyAhPT0gS3QgJiYgKGkgPSBqdCkgOiAocyA9PT0ganQgfHwgcyA9PT0gS3QpICYmIChpID0gbW8pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyghMSwgaSk7XG4gIH0sIHIuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbmNlbE5leHRDYWxsYmFjaygpO1xuICB9LCByLmdldFRpbWVvdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG8gPSB0aGlzLnByb3BzLnRpbWVvdXQsIGksIHMsIGM7XG4gICAgcmV0dXJuIGkgPSBzID0gYyA9IG8sIG8gIT0gbnVsbCAmJiB0eXBlb2YgbyAhPSBcIm51bWJlclwiICYmIChpID0gby5leGl0LCBzID0gby5lbnRlciwgYyA9IG8uYXBwZWFyICE9PSB2b2lkIDAgPyBvLmFwcGVhciA6IHMpLCB7XG4gICAgICBleGl0OiBpLFxuICAgICAgZW50ZXI6IHMsXG4gICAgICBhcHBlYXI6IGNcbiAgICB9O1xuICB9LCByLnVwZGF0ZVN0YXR1cyA9IGZ1bmN0aW9uKG8sIGkpIHtcbiAgICBpZiAobyA9PT0gdm9pZCAwICYmIChvID0gITEpLCBpICE9PSBudWxsKVxuICAgICAgaWYgKHRoaXMuY2FuY2VsTmV4dENhbGxiYWNrKCksIGkgPT09IGp0KSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnVubW91bnRPbkV4aXQgfHwgdGhpcy5wcm9wcy5tb3VudE9uRW50ZXIpIHtcbiAgICAgICAgICB2YXIgcyA9IHRoaXMucHJvcHMubm9kZVJlZiA/IHRoaXMucHJvcHMubm9kZVJlZi5jdXJyZW50IDogV3IuZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgICAgcyAmJiBHZihzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlcmZvcm1FbnRlcihvKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aGlzLnBlcmZvcm1FeGl0KCk7XG4gICAgZWxzZSB0aGlzLnByb3BzLnVubW91bnRPbkV4aXQgJiYgdGhpcy5zdGF0ZS5zdGF0dXMgPT09IF90ICYmIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc3RhdHVzOiBiclxuICAgIH0pO1xuICB9LCByLnBlcmZvcm1FbnRlciA9IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgaSA9IHRoaXMsIHMgPSB0aGlzLnByb3BzLmVudGVyLCBjID0gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0LmlzTW91bnRpbmcgOiBvLCBsID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gW2NdIDogW1dyLmZpbmRET01Ob2RlKHRoaXMpLCBjXSwgdSA9IGxbMF0sIHAgPSBsWzFdLCBtID0gdGhpcy5nZXRUaW1lb3V0cygpLCBnID0gYyA/IG0uYXBwZWFyIDogbS5lbnRlcjtcbiAgICBpZiAoIW8gJiYgIXMgfHwgaWEuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBLdFxuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGkucHJvcHMub25FbnRlcmVkKHUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJvcHMub25FbnRlcih1LCBwKSwgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgc3RhdHVzOiBqdFxuICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgaS5wcm9wcy5vbkVudGVyaW5nKHUsIHApLCBpLm9uVHJhbnNpdGlvbkVuZChnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaS5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgIHN0YXR1czogS3RcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaS5wcm9wcy5vbkVudGVyZWQodSwgcCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIHIucGVyZm9ybUV4aXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbyA9IHRoaXMsIGkgPSB0aGlzLnByb3BzLmV4aXQsIHMgPSB0aGlzLmdldFRpbWVvdXRzKCksIGMgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyB2b2lkIDAgOiBXci5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICBpZiAoIWkgfHwgaWEuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBfdFxuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIG8ucHJvcHMub25FeGl0ZWQoYyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbkV4aXQoYyksIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgIHN0YXR1czogbW9cbiAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgIG8ucHJvcHMub25FeGl0aW5nKGMpLCBvLm9uVHJhbnNpdGlvbkVuZChzLmV4aXQsIGZ1bmN0aW9uKCkge1xuICAgICAgICBvLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBfdFxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBvLnByb3BzLm9uRXhpdGVkKGMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCByLmNhbmNlbE5leHRDYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubmV4dENhbGxiYWNrICE9PSBudWxsICYmICh0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwoKSwgdGhpcy5uZXh0Q2FsbGJhY2sgPSBudWxsKTtcbiAgfSwgci5zYWZlU2V0U3RhdGUgPSBmdW5jdGlvbihvLCBpKSB7XG4gICAgaSA9IHRoaXMuc2V0TmV4dENhbGxiYWNrKGkpLCB0aGlzLnNldFN0YXRlKG8sIGkpO1xuICB9LCByLnNldE5leHRDYWxsYmFjayA9IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgaSA9IHRoaXMsIHMgPSAhMDtcbiAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbihjKSB7XG4gICAgICBzICYmIChzID0gITEsIGkubmV4dENhbGxiYWNrID0gbnVsbCwgbyhjKSk7XG4gICAgfSwgdGhpcy5uZXh0Q2FsbGJhY2suY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICBzID0gITE7XG4gICAgfSwgdGhpcy5uZXh0Q2FsbGJhY2s7XG4gIH0sIHIub25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24obywgaSkge1xuICAgIHRoaXMuc2V0TmV4dENhbGxiYWNrKGkpO1xuICAgIHZhciBzID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gdGhpcy5wcm9wcy5ub2RlUmVmLmN1cnJlbnQgOiBXci5maW5kRE9NTm9kZSh0aGlzKSwgYyA9IG8gPT0gbnVsbCAmJiAhdGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcjtcbiAgICBpZiAoIXMgfHwgYykge1xuICAgICAgc2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyKSB7XG4gICAgICB2YXIgbCA9IHRoaXMucHJvcHMubm9kZVJlZiA/IFt0aGlzLm5leHRDYWxsYmFja10gOiBbcywgdGhpcy5uZXh0Q2FsbGJhY2tdLCB1ID0gbFswXSwgcCA9IGxbMV07XG4gICAgICB0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyKHUsIHApO1xuICAgIH1cbiAgICBvICE9IG51bGwgJiYgc2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywgbyk7XG4gIH0sIHIucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG8gPSB0aGlzLnN0YXRlLnN0YXR1cztcbiAgICBpZiAobyA9PT0gYnIpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgaSA9IHRoaXMucHJvcHMsIHMgPSBpLmNoaWxkcmVuO1xuICAgIGkuaW4sIGkubW91bnRPbkVudGVyLCBpLnVubW91bnRPbkV4aXQsIGkuYXBwZWFyLCBpLmVudGVyLCBpLmV4aXQsIGkudGltZW91dCwgaS5hZGRFbmRMaXN0ZW5lciwgaS5vbkVudGVyLCBpLm9uRW50ZXJpbmcsIGkub25FbnRlcmVkLCBpLm9uRXhpdCwgaS5vbkV4aXRpbmcsIGkub25FeGl0ZWQsIGkubm9kZVJlZjtcbiAgICB2YXIgYyA9IGJzKGksIFtcImNoaWxkcmVuXCIsIFwiaW5cIiwgXCJtb3VudE9uRW50ZXJcIiwgXCJ1bm1vdW50T25FeGl0XCIsIFwiYXBwZWFyXCIsIFwiZW50ZXJcIiwgXCJleGl0XCIsIFwidGltZW91dFwiLCBcImFkZEVuZExpc3RlbmVyXCIsIFwib25FbnRlclwiLCBcIm9uRW50ZXJpbmdcIiwgXCJvbkVudGVyZWRcIiwgXCJvbkV4aXRcIiwgXCJvbkV4aXRpbmdcIiwgXCJvbkV4aXRlZFwiLCBcIm5vZGVSZWZcIl0pO1xuICAgIHJldHVybiAoXG4gICAgICAvLyBhbGxvd3MgZm9yIG5lc3RlZCBUcmFuc2l0aW9uc1xuICAgICAgLyogQF9fUFVSRV9fICovIHl0LmNyZWF0ZUVsZW1lbnQoYm4uUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0sIHR5cGVvZiBzID09IFwiZnVuY3Rpb25cIiA/IHMobywgYykgOiB5dC5jbG9uZUVsZW1lbnQoeXQuQ2hpbGRyZW4ub25seShzKSwgYykpXG4gICAgKTtcbiAgfSwgdDtcbn0oeXQuQ29tcG9uZW50KTtcbkV0LmNvbnRleHRUeXBlID0gYm47XG5FdC5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIC8qKlxuICAgKiBBIFJlYWN0IHJlZmVyZW5jZSB0byBET00gZWxlbWVudCB0aGF0IG5lZWQgdG8gdHJhbnNpdGlvbjpcbiAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUxMTI3MTMwLzQ2NzE5MzJcbiAgICpcbiAgICogICAtIFdoZW4gYG5vZGVSZWZgIHByb3AgaXMgdXNlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAqICAgICAgKGUuZy4gYG9uRW50ZXJgKSBiZWNhdXNlIHVzZXIgYWxyZWFkeSBoYXMgZGlyZWN0IGFjY2VzcyB0byB0aGUgbm9kZS5cbiAgICogICAtIFdoZW4gY2hhbmdpbmcgYGtleWAgcHJvcCBvZiBgVHJhbnNpdGlvbmAgaW4gYSBgVHJhbnNpdGlvbkdyb3VwYCBhIG5ld1xuICAgKiAgICAgYG5vZGVSZWZgIG5lZWQgdG8gYmUgcHJvdmlkZWQgdG8gYFRyYW5zaXRpb25gIHdpdGggY2hhbmdlZCBga2V5YCBwcm9wXG4gICAqICAgICAoc2VlXG4gICAqICAgICBbdGVzdC9DU1NUcmFuc2l0aW9uLXRlc3QuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvYmxvYi8xMzQzNWY4OTdiM2FiNzFmNmUxOWQ3MjRmMTQ1NTk2ZjU5MTA1ODFjL3Rlc3QvQ1NTVHJhbnNpdGlvbi10ZXN0LmpzI0wzNjItTDQzNykpLlxuICAgKi9cbiAgbm9kZVJlZjogYS5zaGFwZSh7XG4gICAgY3VycmVudDogdHlwZW9mIEVsZW1lbnQgPiBcInVcIiA/IGEuYW55IDogZnVuY3Rpb24oZSwgdCwgciwgbiwgbywgaSkge1xuICAgICAgdmFyIHMgPSBlW3RdO1xuICAgICAgcmV0dXJuIGEuaW5zdGFuY2VPZihzICYmIFwib3duZXJEb2N1bWVudFwiIGluIHMgPyBzLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuRWxlbWVudCA6IEVsZW1lbnQpKGUsIHQsIHIsIG4sIG8sIGkpO1xuICAgIH1cbiAgfSksXG4gIC8qKlxuICAgKiBBIGBmdW5jdGlvbmAgY2hpbGQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBhIFJlYWN0IGVsZW1lbnQuIFRoaXMgZnVuY3Rpb24gaXNcbiAgICogY2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiBzdGF0dXMgKGAnZW50ZXJpbmcnYCwgYCdlbnRlcmVkJ2AsXG4gICAqIGAnZXhpdGluZydgLCBgJ2V4aXRlZCdgKSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gYXBwbHkgY29udGV4dFxuICAgKiBzcGVjaWZpYyBwcm9wcyB0byBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogYGBganN4XG4gICAqIDxUcmFuc2l0aW9uIGluPXt0aGlzLnN0YXRlLmlufSB0aW1lb3V0PXsxNTB9PlxuICAgKiAgIHtzdGF0ZSA9PiAoXG4gICAqICAgICA8TXlDb21wb25lbnQgY2xhc3NOYW1lPXtgZmFkZSBmYWRlLSR7c3RhdGV9YH0gLz5cbiAgICogICApfVxuICAgKiA8L1RyYW5zaXRpb24+XG4gICAqIGBgYFxuICAgKi9cbiAgY2hpbGRyZW46IGEub25lT2ZUeXBlKFthLmZ1bmMuaXNSZXF1aXJlZCwgYS5lbGVtZW50LmlzUmVxdWlyZWRdKS5pc1JlcXVpcmVkLFxuICAvKipcbiAgICogU2hvdyB0aGUgY29tcG9uZW50OyB0cmlnZ2VycyB0aGUgZW50ZXIgb3IgZXhpdCBzdGF0ZXNcbiAgICovXG4gIGluOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgaXMgbW91bnRlZCBpbW1lZGlhdGVseSBhbG9uZyB3aXRoXG4gICAqIHRoZSBwYXJlbnQgYFRyYW5zaXRpb25gIGNvbXBvbmVudC4gSWYgeW91IHdhbnQgdG8gXCJsYXp5IG1vdW50XCIgdGhlIGNvbXBvbmVudCBvbiB0aGVcbiAgICogZmlyc3QgYGluPXt0cnVlfWAgeW91IGNhbiBzZXQgYG1vdW50T25FbnRlcmAuIEFmdGVyIHRoZSBmaXJzdCBlbnRlciB0cmFuc2l0aW9uIHRoZSBjb21wb25lbnQgd2lsbCBzdGF5XG4gICAqIG1vdW50ZWQsIGV2ZW4gb24gXCJleGl0ZWRcIiwgdW5sZXNzIHlvdSBhbHNvIHNwZWNpZnkgYHVubW91bnRPbkV4aXRgLlxuICAgKi9cbiAgbW91bnRPbkVudGVyOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgc3RheXMgbW91bnRlZCBhZnRlciBpdCByZWFjaGVzIHRoZSBgJ2V4aXRlZCdgIHN0YXRlLlxuICAgKiBTZXQgYHVubW91bnRPbkV4aXRgIGlmIHlvdSdkIHByZWZlciB0byB1bm1vdW50IHRoZSBjb21wb25lbnQgYWZ0ZXIgaXQgZmluaXNoZXMgZXhpdGluZy5cbiAgICovXG4gIHVubW91bnRPbkV4aXQ6IGEuYm9vbCxcbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGNoaWxkIGNvbXBvbmVudCBkb2VzIG5vdCBwZXJmb3JtIHRoZSBlbnRlciB0cmFuc2l0aW9uIHdoZW5cbiAgICogaXQgZmlyc3QgbW91bnRzLCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZiBgaW5gLiBJZiB5b3Ugd2FudCB0aGlzXG4gICAqIGJlaGF2aW9yLCBzZXQgYm90aCBgYXBwZWFyYCBhbmQgYGluYCB0byBgdHJ1ZWAuXG4gICAqXG4gICAqID4gKipOb3RlKio6IHRoZXJlIGFyZSBubyBzcGVjaWFsIGFwcGVhciBzdGF0ZXMgbGlrZSBgYXBwZWFyaW5nYC9gYXBwZWFyZWRgLCB0aGlzIHByb3BcbiAgICogPiBvbmx5IGFkZHMgYW4gYWRkaXRpb25hbCBlbnRlciB0cmFuc2l0aW9uLiBIb3dldmVyLCBpbiB0aGVcbiAgICogPiBgPENTU1RyYW5zaXRpb24+YCBjb21wb25lbnQgdGhhdCBmaXJzdCBlbnRlciB0cmFuc2l0aW9uIGRvZXMgcmVzdWx0IGluXG4gICAqID4gYWRkaXRpb25hbCBgLmFwcGVhci0qYCBjbGFzc2VzLCB0aGF0IHdheSB5b3UgY2FuIGNob29zZSB0byBzdHlsZSBpdFxuICAgKiA+IGRpZmZlcmVudGx5LlxuICAgKi9cbiAgYXBwZWFyOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBlbnRlciB0cmFuc2l0aW9ucy5cbiAgICovXG4gIGVudGVyOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBleGl0IHRyYW5zaXRpb25zLlxuICAgKi9cbiAgZXhpdDogYS5ib29sLFxuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uLCBpbiBtaWxsaXNlY29uZHMuXG4gICAqIFJlcXVpcmVkIHVubGVzcyBgYWRkRW5kTGlzdGVuZXJgIGlzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBZb3UgbWF5IHNwZWNpZnkgYSBzaW5nbGUgdGltZW91dCBmb3IgYWxsIHRyYW5zaXRpb25zOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogdGltZW91dD17NTAwfVxuICAgKiBgYGBcbiAgICpcbiAgICogb3IgaW5kaXZpZHVhbGx5OlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogdGltZW91dD17e1xuICAgKiAgYXBwZWFyOiA1MDAsXG4gICAqICBlbnRlcjogMzAwLFxuICAgKiAgZXhpdDogNTAwLFxuICAgKiB9fVxuICAgKiBgYGBcbiAgICpcbiAgICogLSBgYXBwZWFyYCBkZWZhdWx0cyB0byB0aGUgdmFsdWUgb2YgYGVudGVyYFxuICAgKiAtIGBlbnRlcmAgZGVmYXVsdHMgdG8gYDBgXG4gICAqIC0gYGV4aXRgIGRlZmF1bHRzIHRvIGAwYFxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyIHwgeyBlbnRlcj86IG51bWJlciwgZXhpdD86IG51bWJlciwgYXBwZWFyPzogbnVtYmVyIH19XG4gICAqL1xuICB0aW1lb3V0OiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIHIgPSBxZjtcbiAgICB0LmFkZEVuZExpc3RlbmVyIHx8IChyID0gci5pc1JlcXVpcmVkKTtcbiAgICBmb3IgKHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgbyA9IG5ldyBBcnJheShuID4gMSA/IG4gLSAxIDogMCksIGkgPSAxOyBpIDwgbjsgaSsrKVxuICAgICAgb1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIHIuYXBwbHkodm9pZCAwLCBbdF0uY29uY2F0KG8pKTtcbiAgfSxcbiAgLyoqXG4gICAqIEFkZCBhIGN1c3RvbSB0cmFuc2l0aW9uIGVuZCB0cmlnZ2VyLiBDYWxsZWQgd2l0aCB0aGUgdHJhbnNpdGlvbmluZ1xuICAgKiBET00gbm9kZSBhbmQgYSBgZG9uZWAgY2FsbGJhY2suIEFsbG93cyBmb3IgbW9yZSBmaW5lIGdyYWluZWQgdHJhbnNpdGlvbiBlbmRcbiAgICogbG9naWMuIFRpbWVvdXRzIGFyZSBzdGlsbCB1c2VkIGFzIGEgZmFsbGJhY2sgaWYgcHJvdmlkZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiBhZGRFbmRMaXN0ZW5lcj17KG5vZGUsIGRvbmUpID0+IHtcbiAgICogICAvLyB1c2UgdGhlIGNzcyB0cmFuc2l0aW9uZW5kIGV2ZW50IHRvIG1hcmsgdGhlIGZpbmlzaCBvZiBhIHRyYW5zaXRpb25cbiAgICogICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBkb25lLCBmYWxzZSk7XG4gICAqIH19XG4gICAqIGBgYFxuICAgKi9cbiAgYWRkRW5kTGlzdGVuZXI6IGEuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgXCJlbnRlcmluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbCkgLT4gdm9pZFxuICAgKi9cbiAgb25FbnRlcjogYS5mdW5jLFxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZW50ZXJpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyaW5nOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJlbnRlcmVkXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKSAtPiB2b2lkXG4gICAqL1xuICBvbkVudGVyZWQ6IGEuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgXCJleGl0aW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXQ6IGEuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImV4aXRpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdGluZzogYS5mdW5jLFxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZXhpdGVkXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWRcbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdGVkOiBhLmZ1bmNcbn0gOiB7fTtcbmZ1bmN0aW9uIEd0KCkge1xufVxuRXQuZGVmYXVsdFByb3BzID0ge1xuICBpbjogITEsXG4gIG1vdW50T25FbnRlcjogITEsXG4gIHVubW91bnRPbkV4aXQ6ICExLFxuICBhcHBlYXI6ICExLFxuICBlbnRlcjogITAsXG4gIGV4aXQ6ICEwLFxuICBvbkVudGVyOiBHdCxcbiAgb25FbnRlcmluZzogR3QsXG4gIG9uRW50ZXJlZDogR3QsXG4gIG9uRXhpdDogR3QsXG4gIG9uRXhpdGluZzogR3QsXG4gIG9uRXhpdGVkOiBHdFxufTtcbkV0LlVOTU9VTlRFRCA9IGJyO1xuRXQuRVhJVEVEID0gX3Q7XG5FdC5FTlRFUklORyA9IGp0O1xuRXQuRU5URVJFRCA9IEt0O1xuRXQuRVhJVElORyA9IG1vO1xuZnVuY3Rpb24gS2YoZSkge1xuICBpZiAoZSA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gWW8oZSwgdCkge1xuICB2YXIgciA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdCAmJiBubihpKSA/IHQoaSkgOiBpO1xuICB9LCBuID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBlICYmIFFzLm1hcChlLCBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIG87XG4gIH0pLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgIG5bby5rZXldID0gcihvKTtcbiAgfSksIG47XG59XG5mdW5jdGlvbiBYZihlLCB0KSB7XG4gIGUgPSBlIHx8IHt9LCB0ID0gdCB8fCB7fTtcbiAgZnVuY3Rpb24gcihwKSB7XG4gICAgcmV0dXJuIHAgaW4gdCA/IHRbcF0gOiBlW3BdO1xuICB9XG4gIHZhciBuID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIG8gPSBbXTtcbiAgZm9yICh2YXIgaSBpbiBlKVxuICAgIGkgaW4gdCA/IG8ubGVuZ3RoICYmIChuW2ldID0gbywgbyA9IFtdKSA6IG8ucHVzaChpKTtcbiAgdmFyIHMsIGMgPSB7fTtcbiAgZm9yICh2YXIgbCBpbiB0KSB7XG4gICAgaWYgKG5bbF0pXG4gICAgICBmb3IgKHMgPSAwOyBzIDwgbltsXS5sZW5ndGg7IHMrKykge1xuICAgICAgICB2YXIgdSA9IG5bbF1bc107XG4gICAgICAgIGNbbltsXVtzXV0gPSByKHUpO1xuICAgICAgfVxuICAgIGNbbF0gPSByKGwpO1xuICB9XG4gIGZvciAocyA9IDA7IHMgPCBvLmxlbmd0aDsgcysrKVxuICAgIGNbb1tzXV0gPSByKG9bc10pO1xuICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIEx0KGUsIHQsIHIpIHtcbiAgcmV0dXJuIHJbdF0gIT0gbnVsbCA/IHJbdF0gOiBlLnByb3BzW3RdO1xufVxuZnVuY3Rpb24gSmYoZSwgdCkge1xuICByZXR1cm4gWW8oZS5jaGlsZHJlbiwgZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBvbihyLCB7XG4gICAgICBvbkV4aXRlZDogdC5iaW5kKG51bGwsIHIpLFxuICAgICAgaW46ICEwLFxuICAgICAgYXBwZWFyOiBMdChyLCBcImFwcGVhclwiLCBlKSxcbiAgICAgIGVudGVyOiBMdChyLCBcImVudGVyXCIsIGUpLFxuICAgICAgZXhpdDogTHQociwgXCJleGl0XCIsIGUpXG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gUWYoZSwgdCwgcikge1xuICB2YXIgbiA9IFlvKGUuY2hpbGRyZW4pLCBvID0gWGYodCwgbik7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgcyA9IG9baV07XG4gICAgaWYgKG5uKHMpKSB7XG4gICAgICB2YXIgYyA9IGkgaW4gdCwgbCA9IGkgaW4gbiwgdSA9IHRbaV0sIHAgPSBubih1KSAmJiAhdS5wcm9wcy5pbjtcbiAgICAgIGwgJiYgKCFjIHx8IHApID8gb1tpXSA9IG9uKHMsIHtcbiAgICAgICAgb25FeGl0ZWQ6IHIuYmluZChudWxsLCBzKSxcbiAgICAgICAgaW46ICEwLFxuICAgICAgICBleGl0OiBMdChzLCBcImV4aXRcIiwgZSksXG4gICAgICAgIGVudGVyOiBMdChzLCBcImVudGVyXCIsIGUpXG4gICAgICB9KSA6ICFsICYmIGMgJiYgIXAgPyBvW2ldID0gb24ocywge1xuICAgICAgICBpbjogITFcbiAgICAgIH0pIDogbCAmJiBjICYmIG5uKHUpICYmIChvW2ldID0gb24ocywge1xuICAgICAgICBvbkV4aXRlZDogci5iaW5kKG51bGwsIHMpLFxuICAgICAgICBpbjogdS5wcm9wcy5pbixcbiAgICAgICAgZXhpdDogTHQocywgXCJleGl0XCIsIGUpLFxuICAgICAgICBlbnRlcjogTHQocywgXCJlbnRlclwiLCBlKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSksIG87XG59XG52YXIgWmYgPSBPYmplY3QudmFsdWVzIHx8IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLm1hcChmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGVbdF07XG4gIH0pO1xufSwgZWQgPSB7XG4gIGNvbXBvbmVudDogXCJkaXZcIixcbiAgY2hpbGRGYWN0b3J5OiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbn0sIEhvID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKGUpIHtcbiAgdnModCwgZSk7XG4gIGZ1bmN0aW9uIHQobiwgbykge1xuICAgIHZhciBpO1xuICAgIGkgPSBlLmNhbGwodGhpcywgbiwgbykgfHwgdGhpcztcbiAgICB2YXIgcyA9IGkuaGFuZGxlRXhpdGVkLmJpbmQoS2YoaSkpO1xuICAgIHJldHVybiBpLnN0YXRlID0ge1xuICAgICAgY29udGV4dFZhbHVlOiB7XG4gICAgICAgIGlzTW91bnRpbmc6ICEwXG4gICAgICB9LFxuICAgICAgaGFuZGxlRXhpdGVkOiBzLFxuICAgICAgZmlyc3RSZW5kZXI6ICEwXG4gICAgfSwgaTtcbiAgfVxuICB2YXIgciA9IHQucHJvdG90eXBlO1xuICByZXR1cm4gci5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW91bnRlZCA9ICEwLCB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGNvbnRleHRWYWx1ZToge1xuICAgICAgICBpc01vdW50aW5nOiAhMVxuICAgICAgfVxuICAgIH0pO1xuICB9LCByLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb3VudGVkID0gITE7XG4gIH0sIHQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24obywgaSkge1xuICAgIHZhciBzID0gaS5jaGlsZHJlbiwgYyA9IGkuaGFuZGxlRXhpdGVkLCBsID0gaS5maXJzdFJlbmRlcjtcbiAgICByZXR1cm4ge1xuICAgICAgY2hpbGRyZW46IGwgPyBKZihvLCBjKSA6IFFmKG8sIHMsIGMpLFxuICAgICAgZmlyc3RSZW5kZXI6ICExXG4gICAgfTtcbiAgfSwgci5oYW5kbGVFeGl0ZWQgPSBmdW5jdGlvbihvLCBpKSB7XG4gICAgdmFyIHMgPSBZbyh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICBvLmtleSBpbiBzIHx8IChvLnByb3BzLm9uRXhpdGVkICYmIG8ucHJvcHMub25FeGl0ZWQoaSksIHRoaXMubW91bnRlZCAmJiB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBsID0gZm4oe30sIGMuY2hpbGRyZW4pO1xuICAgICAgcmV0dXJuIGRlbGV0ZSBsW28ua2V5XSwge1xuICAgICAgICBjaGlsZHJlbjogbFxuICAgICAgfTtcbiAgICB9KSk7XG4gIH0sIHIucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG8gPSB0aGlzLnByb3BzLCBpID0gby5jb21wb25lbnQsIHMgPSBvLmNoaWxkRmFjdG9yeSwgYyA9IGJzKG8sIFtcImNvbXBvbmVudFwiLCBcImNoaWxkRmFjdG9yeVwiXSksIGwgPSB0aGlzLnN0YXRlLmNvbnRleHRWYWx1ZSwgdSA9IFpmKHRoaXMuc3RhdGUuY2hpbGRyZW4pLm1hcChzKTtcbiAgICByZXR1cm4gZGVsZXRlIGMuYXBwZWFyLCBkZWxldGUgYy5lbnRlciwgZGVsZXRlIGMuZXhpdCwgaSA9PT0gbnVsbCA/IC8qIEBfX1BVUkVfXyAqLyB5dC5jcmVhdGVFbGVtZW50KGJuLlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogbFxuICAgIH0sIHUpIDogLyogQF9fUFVSRV9fICovIHl0LmNyZWF0ZUVsZW1lbnQoYm4uUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBsXG4gICAgfSwgLyogQF9fUFVSRV9fICovIHl0LmNyZWF0ZUVsZW1lbnQoaSwgYywgdSkpO1xuICB9LCB0O1xufSh5dC5Db21wb25lbnQpO1xuSG8ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAvKipcbiAgICogYDxUcmFuc2l0aW9uR3JvdXA+YCByZW5kZXJzIGEgYDxkaXY+YCBieSBkZWZhdWx0LiBZb3UgY2FuIGNoYW5nZSB0aGlzXG4gICAqIGJlaGF2aW9yIGJ5IHByb3ZpZGluZyBhIGBjb21wb25lbnRgIHByb3AuXG4gICAqIElmIHlvdSB1c2UgUmVhY3QgdjE2KyBhbmQgd291bGQgbGlrZSB0byBhdm9pZCBhIHdyYXBwaW5nIGA8ZGl2PmAgZWxlbWVudFxuICAgKiB5b3UgY2FuIHBhc3MgaW4gYGNvbXBvbmVudD17bnVsbH1gLiBUaGlzIGlzIHVzZWZ1bCBpZiB0aGUgd3JhcHBpbmcgZGl2XG4gICAqIGJvcmtzIHlvdXIgY3NzIHN0eWxlcy5cbiAgICovXG4gIGNvbXBvbmVudDogYS5hbnksXG4gIC8qKlxuICAgKiBBIHNldCBvZiBgPFRyYW5zaXRpb24+YCBjb21wb25lbnRzLCB0aGF0IGFyZSB0b2dnbGVkIGBpbmAgYW5kIG91dCBhcyB0aGV5XG4gICAqIGxlYXZlLiB0aGUgYDxUcmFuc2l0aW9uR3JvdXA+YCB3aWxsIGluamVjdCBzcGVjaWZpYyB0cmFuc2l0aW9uIHByb3BzLCBzb1xuICAgKiByZW1lbWJlciB0byBzcHJlYWQgdGhlbSB0aHJvdWdoIGlmIHlvdSBhcmUgd3JhcHBpbmcgdGhlIGA8VHJhbnNpdGlvbj5gIGFzXG4gICAqIHdpdGggb3VyIGA8RmFkZT5gIGV4YW1wbGUuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgY29tcG9uZW50IGlzIG1lYW50IGZvciBtdWx0aXBsZSBgVHJhbnNpdGlvbmAgb3IgYENTU1RyYW5zaXRpb25gXG4gICAqIGNoaWxkcmVuLCBzb21ldGltZXMgeW91IG1heSB3YW50IHRvIGhhdmUgYSBzaW5nbGUgdHJhbnNpdGlvbiBjaGlsZCB3aXRoXG4gICAqIGNvbnRlbnQgdGhhdCB5b3Ugd2FudCB0byBiZSB0cmFuc2l0aW9uZWQgb3V0IGFuZCBpbiB3aGVuIHlvdSBjaGFuZ2UgaXRcbiAgICogKGUuZy4gcm91dGVzLCBpbWFnZXMgZXRjLikgSW4gdGhhdCBjYXNlIHlvdSBjYW4gY2hhbmdlIHRoZSBga2V5YCBwcm9wIG9mXG4gICAqIHRoZSB0cmFuc2l0aW9uIGNoaWxkIGFzIHlvdSBjaGFuZ2UgaXRzIGNvbnRlbnQsIHRoaXMgd2lsbCBjYXVzZVxuICAgKiBgVHJhbnNpdGlvbkdyb3VwYCB0byB0cmFuc2l0aW9uIHRoZSBjaGlsZCBvdXQgYW5kIGJhY2sgaW4uXG4gICAqL1xuICBjaGlsZHJlbjogYS5ub2RlLFxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBwcm9wIHRoYXQgZW5hYmxlcyBvciBkaXNhYmxlcyBhcHBlYXIgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgYXBwZWFyOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIHByb3AgdGhhdCBlbmFibGVzIG9yIGRpc2FibGVzIGVudGVyIGFuaW1hdGlvbnNcbiAgICogZm9yIGFsbCBjaGlsZHJlbi4gTm90ZSB0aGF0IHNwZWNpZnlpbmcgdGhpcyB3aWxsIG92ZXJyaWRlIGFueSBkZWZhdWx0cyBzZXRcbiAgICogb24gaW5kaXZpZHVhbCBjaGlsZHJlbiBUcmFuc2l0aW9ucy5cbiAgICovXG4gIGVudGVyOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIHByb3AgdGhhdCBlbmFibGVzIG9yIGRpc2FibGVzIGV4aXQgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgZXhpdDogYS5ib29sLFxuICAvKipcbiAgICogWW91IG1heSBuZWVkIHRvIGFwcGx5IHJlYWN0aXZlIHVwZGF0ZXMgdG8gYSBjaGlsZCBhcyBpdCBpcyBleGl0aW5nLlxuICAgKiBUaGlzIGlzIGdlbmVyYWxseSBkb25lIGJ5IHVzaW5nIGBjbG9uZUVsZW1lbnRgIGhvd2V2ZXIgaW4gdGhlIGNhc2Ugb2YgYW4gZXhpdGluZ1xuICAgKiBjaGlsZCB0aGUgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYW5kIG5vdCBhY2Nlc3NpYmxlIHRvIHRoZSBjb25zdW1lci5cbiAgICpcbiAgICogSWYgeW91IGRvIG5lZWQgdG8gdXBkYXRlIGEgY2hpbGQgYXMgaXQgbGVhdmVzIHlvdSBjYW4gcHJvdmlkZSBhIGBjaGlsZEZhY3RvcnlgXG4gICAqIHRvIHdyYXAgZXZlcnkgY2hpbGQsIGV2ZW4gdGhlIG9uZXMgdGhhdCBhcmUgbGVhdmluZy5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24oY2hpbGQ6IFJlYWN0RWxlbWVudCkgLT4gUmVhY3RFbGVtZW50XG4gICAqL1xuICBjaGlsZEZhY3Rvcnk6IGEuZnVuY1xufSA6IHt9O1xuSG8uZGVmYXVsdFByb3BzID0gZWQ7XG5jb25zdCB0ZCA9IChlKSA9PiBlLnNjcm9sbFRvcDtcbmZ1bmN0aW9uIHZuKGUsIHQpIHtcbiAgY29uc3Qge1xuICAgIHRpbWVvdXQ6IHIsXG4gICAgZWFzaW5nOiBuLFxuICAgIHN0eWxlOiBvID0ge31cbiAgfSA9IGU7XG4gIHJldHVybiB7XG4gICAgZHVyYXRpb246IG8udHJhbnNpdGlvbkR1cmF0aW9uID8/ICh0eXBlb2YgciA9PSBcIm51bWJlclwiID8gciA6IHJbdC5tb2RlXSB8fCAwKSxcbiAgICBlYXNpbmc6IG8udHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uID8/ICh0eXBlb2YgbiA9PSBcIm9iamVjdFwiID8gblt0Lm1vZGVdIDogbiksXG4gICAgZGVsYXk6IG8udHJhbnNpdGlvbkRlbGF5XG4gIH07XG59XG5mdW5jdGlvbiByZChlKSB7XG4gIHJldHVybiBWZShcIk11aUNvbGxhcHNlXCIsIGUpO1xufVxuRmUoXCJNdWlDb2xsYXBzZVwiLCBbXCJyb290XCIsIFwiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCIsIFwiZW50ZXJlZFwiLCBcImhpZGRlblwiLCBcIndyYXBwZXJcIiwgXCJ3cmFwcGVySW5uZXJcIl0pO1xuY29uc3QgbmQgPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgb3JpZW50YXRpb246IHQsXG4gICAgY2xhc3NlczogclxuICB9ID0gZSwgbiA9IHtcbiAgICByb290OiBbXCJyb290XCIsIGAke3R9YF0sXG4gICAgZW50ZXJlZDogW1wiZW50ZXJlZFwiXSxcbiAgICBoaWRkZW46IFtcImhpZGRlblwiXSxcbiAgICB3cmFwcGVyOiBbXCJ3cmFwcGVyXCIsIGAke3R9YF0sXG4gICAgd3JhcHBlcklubmVyOiBbXCJ3cmFwcGVySW5uZXJcIiwgYCR7dH1gXVxuICB9O1xuICByZXR1cm4gR2UobiwgcmQsIHIpO1xufSwgb2QgPSBsZShcImRpdlwiLCB7XG4gIG5hbWU6IFwiTXVpQ29sbGFwc2VcIixcbiAgc2xvdDogXCJSb290XCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyU3RhdGU6IHJcbiAgICB9ID0gZTtcbiAgICByZXR1cm4gW3Qucm9vdCwgdFtyLm9yaWVudGF0aW9uXSwgci5zdGF0ZSA9PT0gXCJlbnRlcmVkXCIgJiYgdC5lbnRlcmVkLCByLnN0YXRlID09PSBcImV4aXRlZFwiICYmICFyLmluICYmIHIuY29sbGFwc2VkU2l6ZSA9PT0gXCIwcHhcIiAmJiB0LmhpZGRlbl07XG4gIH1cbn0pKHFlKCh7XG4gIHRoZW1lOiBlXG59KSA9PiAoe1xuICBoZWlnaHQ6IDAsXG4gIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICB0cmFuc2l0aW9uOiBlLnRyYW5zaXRpb25zLmNyZWF0ZShcImhlaWdodFwiKSxcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6IHtcbiAgICAgIG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIHRyYW5zaXRpb246IGUudHJhbnNpdGlvbnMuY3JlYXRlKFwid2lkdGhcIilcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgc3RhdGU6IFwiZW50ZXJlZFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgIG92ZXJmbG93OiBcInZpc2libGVcIlxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiB7XG4gICAgICBzdGF0ZTogXCJlbnRlcmVkXCIsXG4gICAgICBvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogXCJhdXRvXCJcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiB0LnN0YXRlID09PSBcImV4aXRlZFwiICYmICF0LmluICYmIHQuY29sbGFwc2VkU2l6ZSA9PT0gXCIwcHhcIixcbiAgICBzdHlsZToge1xuICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIlxuICAgIH1cbiAgfV1cbn0pKSksIGlkID0gbGUoXCJkaXZcIiwge1xuICBuYW1lOiBcIk11aUNvbGxhcHNlXCIsXG4gIHNsb3Q6IFwiV3JhcHBlclwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHQud3JhcHBlclxufSkoe1xuICAvLyBIYWNrIHRvIGdldCBjaGlsZHJlbiB3aXRoIGEgbmVnYXRpdmUgbWFyZ2luIHRvIG5vdCBmYWxzaWZ5IHRoZSBoZWlnaHQgY29tcHV0YXRpb24uXG4gIGRpc3BsYXk6IFwiZmxleFwiLFxuICB3aWR0aDogXCIxMDAlXCIsXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiB7XG4gICAgICBvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogXCJhdXRvXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiXG4gICAgfVxuICB9XVxufSksIGFkID0gbGUoXCJkaXZcIiwge1xuICBuYW1lOiBcIk11aUNvbGxhcHNlXCIsXG4gIHNsb3Q6IFwiV3JhcHBlcklubmVyXCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4gdC53cmFwcGVySW5uZXJcbn0pKHtcbiAgd2lkdGg6IFwiMTAwJVwiLFxuICB2YXJpYW50czogW3tcbiAgICBwcm9wczoge1xuICAgICAgb3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6IFwiYXV0b1wiLFxuICAgICAgaGVpZ2h0OiBcIjEwMCVcIlxuICAgIH1cbiAgfV1cbn0pLCB4biA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCBuID0gSGUoe1xuICAgIHByb3BzOiB0LFxuICAgIG5hbWU6IFwiTXVpQ29sbGFwc2VcIlxuICB9KSwge1xuICAgIGFkZEVuZExpc3RlbmVyOiBvLFxuICAgIGNoaWxkcmVuOiBpLFxuICAgIGNsYXNzTmFtZTogcyxcbiAgICBjb2xsYXBzZWRTaXplOiBjID0gXCIwcHhcIixcbiAgICBjb21wb25lbnQ6IGwsXG4gICAgZWFzaW5nOiB1LFxuICAgIGluOiBwLFxuICAgIG9uRW50ZXI6IG0sXG4gICAgb25FbnRlcmVkOiBnLFxuICAgIG9uRW50ZXJpbmc6IHgsXG4gICAgb25FeGl0OiB5LFxuICAgIG9uRXhpdGVkOiBmLFxuICAgIG9uRXhpdGluZzogUyxcbiAgICBvcmllbnRhdGlvbjogRSA9IFwidmVydGljYWxcIixcbiAgICBzdHlsZTogUCxcbiAgICB0aW1lb3V0OiBUID0gZHMuc3RhbmRhcmQsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3Byb3AtdHlwZXNcbiAgICBUcmFuc2l0aW9uQ29tcG9uZW50OiBiID0gRXQsXG4gICAgLi4uaFxuICB9ID0gbiwgdyA9IHtcbiAgICAuLi5uLFxuICAgIG9yaWVudGF0aW9uOiBFLFxuICAgIGNvbGxhcHNlZFNpemU6IGNcbiAgfSwgayA9IG5kKHcpLCBMID0gTHIoKSwgQiA9IER0KCksIGQgPSBDLnVzZVJlZihudWxsKSwgQSA9IEMudXNlUmVmKCksIEQgPSB0eXBlb2YgYyA9PSBcIm51bWJlclwiID8gYCR7Y31weGAgOiBjLCBqID0gRSA9PT0gXCJob3Jpem9udGFsXCIsIFcgPSBqID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIiwgeiA9IEMudXNlUmVmKG51bGwpLCBVID0gYXQociwgeiksIFYgPSAoXykgPT4gKHEpID0+IHtcbiAgICBpZiAoXykge1xuICAgICAgY29uc3QgRyA9IHouY3VycmVudDtcbiAgICAgIHEgPT09IHZvaWQgMCA/IF8oRykgOiBfKEcsIHEpO1xuICAgIH1cbiAgfSwgdGUgPSAoKSA9PiBkLmN1cnJlbnQgPyBkLmN1cnJlbnRbaiA/IFwiY2xpZW50V2lkdGhcIiA6IFwiY2xpZW50SGVpZ2h0XCJdIDogMCwgRiA9IFYoKF8sIHEpID0+IHtcbiAgICBkLmN1cnJlbnQgJiYgaiAmJiAoZC5jdXJyZW50LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiKSwgXy5zdHlsZVtXXSA9IEQsIG0gJiYgbShfLCBxKTtcbiAgfSksIFIgPSBWKChfLCBxKSA9PiB7XG4gICAgY29uc3QgRyA9IHRlKCk7XG4gICAgZC5jdXJyZW50ICYmIGogJiYgKGQuY3VycmVudC5zdHlsZS5wb3NpdGlvbiA9IFwiXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGR1cmF0aW9uOiByZSxcbiAgICAgIGVhc2luZzogWlxuICAgIH0gPSB2bih7XG4gICAgICBzdHlsZTogUCxcbiAgICAgIHRpbWVvdXQ6IFQsXG4gICAgICBlYXNpbmc6IHVcbiAgICB9LCB7XG4gICAgICBtb2RlOiBcImVudGVyXCJcbiAgICB9KTtcbiAgICBpZiAoVCA9PT0gXCJhdXRvXCIpIHtcbiAgICAgIGNvbnN0IGFlID0gTC50cmFuc2l0aW9ucy5nZXRBdXRvSGVpZ2h0RHVyYXRpb24oRyk7XG4gICAgICBfLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke2FlfW1zYCwgQS5jdXJyZW50ID0gYWU7XG4gICAgfSBlbHNlXG4gICAgICBfLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHR5cGVvZiByZSA9PSBcInN0cmluZ1wiID8gcmUgOiBgJHtyZX1tc2A7XG4gICAgXy5zdHlsZVtXXSA9IGAke0d9cHhgLCBfLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9IFosIHggJiYgeChfLCBxKTtcbiAgfSksIEkgPSBWKChfLCBxKSA9PiB7XG4gICAgXy5zdHlsZVtXXSA9IFwiYXV0b1wiLCBnICYmIGcoXywgcSk7XG4gIH0pLCBKID0gVigoXykgPT4ge1xuICAgIF8uc3R5bGVbV10gPSBgJHt0ZSgpfXB4YCwgeSAmJiB5KF8pO1xuICB9KSwgUSA9IFYoZiksIEggPSBWKChfKSA9PiB7XG4gICAgY29uc3QgcSA9IHRlKCksIHtcbiAgICAgIGR1cmF0aW9uOiBHLFxuICAgICAgZWFzaW5nOiByZVxuICAgIH0gPSB2bih7XG4gICAgICBzdHlsZTogUCxcbiAgICAgIHRpbWVvdXQ6IFQsXG4gICAgICBlYXNpbmc6IHVcbiAgICB9LCB7XG4gICAgICBtb2RlOiBcImV4aXRcIlxuICAgIH0pO1xuICAgIGlmIChUID09PSBcImF1dG9cIikge1xuICAgICAgY29uc3QgWiA9IEwudHJhbnNpdGlvbnMuZ2V0QXV0b0hlaWdodER1cmF0aW9uKHEpO1xuICAgICAgXy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHtafW1zYCwgQS5jdXJyZW50ID0gWjtcbiAgICB9IGVsc2VcbiAgICAgIF8uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdHlwZW9mIEcgPT0gXCJzdHJpbmdcIiA/IEcgOiBgJHtHfW1zYDtcbiAgICBfLnN0eWxlW1ddID0gRCwgXy5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSByZSwgUyAmJiBTKF8pO1xuICB9KSwgWCA9IChfKSA9PiB7XG4gICAgVCA9PT0gXCJhdXRvXCIgJiYgQi5zdGFydChBLmN1cnJlbnQgfHwgMCwgXyksIG8gJiYgbyh6LmN1cnJlbnQsIF8pO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KGIsIHtcbiAgICBpbjogcCxcbiAgICBvbkVudGVyOiBGLFxuICAgIG9uRW50ZXJlZDogSSxcbiAgICBvbkVudGVyaW5nOiBSLFxuICAgIG9uRXhpdDogSixcbiAgICBvbkV4aXRlZDogUSxcbiAgICBvbkV4aXRpbmc6IEgsXG4gICAgYWRkRW5kTGlzdGVuZXI6IFgsXG4gICAgbm9kZVJlZjogeixcbiAgICB0aW1lb3V0OiBUID09PSBcImF1dG9cIiA/IG51bGwgOiBULFxuICAgIC4uLmgsXG4gICAgY2hpbGRyZW46IChfLCB7XG4gICAgICBvd25lclN0YXRlOiBxLFxuICAgICAgLi4uR1xuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChvZCwge1xuICAgICAgYXM6IGwsXG4gICAgICBjbGFzc05hbWU6IHNlKGsucm9vdCwgcywge1xuICAgICAgICBlbnRlcmVkOiBrLmVudGVyZWQsXG4gICAgICAgIGV4aXRlZDogIXAgJiYgRCA9PT0gXCIwcHhcIiAmJiBrLmhpZGRlblxuICAgICAgfVtfXSksXG4gICAgICBzdHlsZToge1xuICAgICAgICBbaiA/IFwibWluV2lkdGhcIiA6IFwibWluSGVpZ2h0XCJdOiBELFxuICAgICAgICAuLi5QXG4gICAgICB9LFxuICAgICAgcmVmOiBVLFxuICAgICAgb3duZXJTdGF0ZToge1xuICAgICAgICAuLi53LFxuICAgICAgICBzdGF0ZTogX1xuICAgICAgfSxcbiAgICAgIC4uLkcsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KGlkLCB7XG4gICAgICAgIG93bmVyU3RhdGU6IHtcbiAgICAgICAgICAuLi53LFxuICAgICAgICAgIHN0YXRlOiBfXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzTmFtZTogay53cmFwcGVyLFxuICAgICAgICByZWY6IGQsXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goYWQsIHtcbiAgICAgICAgICBvd25lclN0YXRlOiB7XG4gICAgICAgICAgICAuLi53LFxuICAgICAgICAgICAgc3RhdGU6IF9cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsYXNzTmFtZTogay53cmFwcGVySW5uZXIsXG4gICAgICAgICAgY2hpbGRyZW46IGlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoeG4ucHJvcFR5cGVzID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiAgICBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4gICAgIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICAqIEFkZCBhIGN1c3RvbSB0cmFuc2l0aW9uIGVuZCB0cmlnZ2VyLiBDYWxsZWQgd2l0aCB0aGUgdHJhbnNpdGlvbmluZyBET01cbiAgICogbm9kZSBhbmQgYSBkb25lIGNhbGxiYWNrLiBBbGxvd3MgZm9yIG1vcmUgZmluZSBncmFpbmVkIHRyYW5zaXRpb24gZW5kXG4gICAqIGxvZ2ljLiBOb3RlOiBUaW1lb3V0cyBhcmUgc3RpbGwgdXNlZCBhcyBhIGZhbGxiYWNrIGlmIHByb3ZpZGVkLlxuICAgKi9cbiAgYWRkRW5kTGlzdGVuZXI6IGEuZnVuYyxcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG5vZGUgdG8gYmUgY29sbGFwc2VkLlxuICAgKi9cbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFRoZSB3aWR0aCAoaG9yaXpvbnRhbCkgb3IgaGVpZ2h0ICh2ZXJ0aWNhbCkgb2YgdGhlIGNvbnRhaW5lciB3aGVuIGNvbGxhcHNlZC5cbiAgICogQGRlZmF1bHQgJzBweCdcbiAgICovXG4gIGNvbGxhcHNlZFNpemU6IGEub25lT2ZUeXBlKFthLm51bWJlciwgYS5zdHJpbmddKSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogSmEsXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNpdGlvbiB0aW1pbmcgZnVuY3Rpb24uXG4gICAqIFlvdSBtYXkgc3BlY2lmeSBhIHNpbmdsZSBlYXNpbmcgb3IgYSBvYmplY3QgY29udGFpbmluZyBlbnRlciBhbmQgZXhpdCB2YWx1ZXMuXG4gICAqL1xuICBlYXNpbmc6IGEub25lT2ZUeXBlKFthLnNoYXBlKHtcbiAgICBlbnRlcjogYS5zdHJpbmcsXG4gICAgZXhpdDogYS5zdHJpbmdcbiAgfSksIGEuc3RyaW5nXSksXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgd2lsbCB0cmFuc2l0aW9uIGluLlxuICAgKi9cbiAgaW46IGEuYm9vbCxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRW50ZXI6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRW50ZXJlZDogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FbnRlcmluZzogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FeGl0OiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkV4aXRlZDogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FeGl0aW5nOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNpdGlvbiBvcmllbnRhdGlvbi5cbiAgICogQGRlZmF1bHQgJ3ZlcnRpY2FsJ1xuICAgKi9cbiAgb3JpZW50YXRpb246IGEub25lT2YoW1wiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCJdKSxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0eWxlOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gcHJvcCB0aGF0IGFsbG93cyBkZWZpbmluZyBzeXN0ZW0gb3ZlcnJpZGVzIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgc3g6IGEub25lT2ZUeXBlKFthLmFycmF5T2YoYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3QsIGEuYm9vbF0pKSwgYS5mdW5jLCBhLm9iamVjdF0pLFxuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIGZvciB0aGUgdHJhbnNpdGlvbiwgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBZb3UgbWF5IHNwZWNpZnkgYSBzaW5nbGUgdGltZW91dCBmb3IgYWxsIHRyYW5zaXRpb25zLCBvciBpbmRpdmlkdWFsbHkgd2l0aCBhbiBvYmplY3QuXG4gICAqXG4gICAqIFNldCB0byAnYXV0bycgdG8gYXV0b21hdGljYWxseSBjYWxjdWxhdGUgdHJhbnNpdGlvbiB0aW1lIGJhc2VkIG9uIGhlaWdodC5cbiAgICogQGRlZmF1bHQgZHVyYXRpb24uc3RhbmRhcmRcbiAgICovXG4gIHRpbWVvdXQ6IGEub25lT2ZUeXBlKFthLm9uZU9mKFtcImF1dG9cIl0pLCBhLm51bWJlciwgYS5zaGFwZSh7XG4gICAgYXBwZWFyOiBhLm51bWJlcixcbiAgICBlbnRlcjogYS5udW1iZXIsXG4gICAgZXhpdDogYS5udW1iZXJcbiAgfSldKVxufSk7XG54biAmJiAoeG4ubXVpU3VwcG9ydEF1dG8gPSAhMCk7XG5mdW5jdGlvbiBCdChlLCB0KSB7XG4gIGNvbnN0IHtcbiAgICBjbGFzc05hbWU6IHIsXG4gICAgZWxlbWVudFR5cGU6IG4sXG4gICAgb3duZXJTdGF0ZTogbyxcbiAgICBleHRlcm5hbEZvcndhcmRlZFByb3BzOiBpLFxuICAgIGludGVybmFsRm9yd2FyZGVkUHJvcHM6IHMsXG4gICAgc2hvdWxkRm9yd2FyZENvbXBvbmVudFByb3A6IGMgPSAhMSxcbiAgICAuLi5sXG4gIH0gPSB0LCB7XG4gICAgY29tcG9uZW50OiB1LFxuICAgIHNsb3RzOiBwID0ge1xuICAgICAgW2VdOiB2b2lkIDBcbiAgICB9LFxuICAgIHNsb3RQcm9wczogbSA9IHtcbiAgICAgIFtlXTogdm9pZCAwXG4gICAgfSxcbiAgICAuLi5nXG4gIH0gPSBpLCB4ID0gcFtlXSB8fCBuLCB5ID0gcnMobVtlXSwgbyksIHtcbiAgICBwcm9wczoge1xuICAgICAgY29tcG9uZW50OiBmLFxuICAgICAgLi4uU1xuICAgIH0sXG4gICAgaW50ZXJuYWxSZWY6IEVcbiAgfSA9IHRzKHtcbiAgICBjbGFzc05hbWU6IHIsXG4gICAgLi4ubCxcbiAgICBleHRlcm5hbEZvcndhcmRlZFByb3BzOiBlID09PSBcInJvb3RcIiA/IGcgOiB2b2lkIDAsXG4gICAgZXh0ZXJuYWxTbG90UHJvcHM6IHlcbiAgfSksIFAgPSBhdChFLCB5ID09IG51bGwgPyB2b2lkIDAgOiB5LnJlZiwgdC5yZWYpLCBUID0gZSA9PT0gXCJyb290XCIgPyBmIHx8IHUgOiBmLCBiID0gZXMoeCwge1xuICAgIC4uLmUgPT09IFwicm9vdFwiICYmICF1ICYmICFwW2VdICYmIHMsXG4gICAgLi4uZSAhPT0gXCJyb290XCIgJiYgIXBbZV0gJiYgcyxcbiAgICAuLi5TLFxuICAgIC4uLlQgJiYgIWMgJiYge1xuICAgICAgYXM6IFRcbiAgICB9LFxuICAgIC4uLlQgJiYgYyAmJiB7XG4gICAgICBjb21wb25lbnQ6IFRcbiAgICB9LFxuICAgIHJlZjogUFxuICB9LCBvKTtcbiAgcmV0dXJuIFt4LCBiXTtcbn1cbmNsYXNzIFNuIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY3IodGhpcywgXCJtb3VudEVmZmVjdFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnNob3VsZE1vdW50ICYmICF0aGlzLmRpZE1vdW50ICYmIHRoaXMucmVmLmN1cnJlbnQgIT09IG51bGwgJiYgKHRoaXMuZGlkTW91bnQgPSAhMCwgdGhpcy5tb3VudGVkLnJlc29sdmUoKSk7XG4gICAgfSk7XG4gICAgdGhpcy5yZWYgPSB7XG4gICAgICBjdXJyZW50OiBudWxsXG4gICAgfSwgdGhpcy5tb3VudGVkID0gbnVsbCwgdGhpcy5kaWRNb3VudCA9ICExLCB0aGlzLnNob3VsZE1vdW50ID0gITEsIHRoaXMuc2V0U2hvdWxkTW91bnQgPSBudWxsO1xuICB9XG4gIC8qKiBSZWFjdCByZWYgdG8gdGhlIHJpcHBsZSBpbnN0YW5jZSAqL1xuICAvKiogSWYgdGhlIHJpcHBsZSBjb21wb25lbnQgc2hvdWxkIGJlIG1vdW50ZWQgKi9cbiAgLyoqIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSByaXBwbGUgY29tcG9uZW50IGlzIG1vdW50ZWQgKi9cbiAgLyoqIElmIHRoZSByaXBwbGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgKi9cbiAgLyoqIFJlYWN0IHN0YXRlIGhvb2sgc2V0dGVyICovXG4gIHN0YXRpYyBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBTbigpO1xuICB9XG4gIHN0YXRpYyB1c2UoKSB7XG4gICAgY29uc3QgdCA9IFphKFNuLmNyZWF0ZSkuY3VycmVudCwgW3IsIG5dID0gQy51c2VTdGF0ZSghMSk7XG4gICAgcmV0dXJuIHQuc2hvdWxkTW91bnQgPSByLCB0LnNldFNob3VsZE1vdW50ID0gbiwgQy51c2VFZmZlY3QodC5tb3VudEVmZmVjdCwgW3JdKSwgdDtcbiAgfVxuICBtb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VudGVkIHx8ICh0aGlzLm1vdW50ZWQgPSBjZCgpLCB0aGlzLnNob3VsZE1vdW50ID0gITAsIHRoaXMuc2V0U2hvdWxkTW91bnQodGhpcy5zaG91bGRNb3VudCkpLCB0aGlzLm1vdW50ZWQ7XG4gIH1cbiAgLyogUmlwcGxlIEFQSSAqL1xuICBzdGFydCguLi50KSB7XG4gICAgdGhpcy5tb3VudCgpLnRoZW4oKCkgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICByZXR1cm4gKHIgPSB0aGlzLnJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogci5zdGFydCguLi50KTtcbiAgICB9KTtcbiAgfVxuICBzdG9wKC4uLnQpIHtcbiAgICB0aGlzLm1vdW50KCkudGhlbigoKSA9PiB7XG4gICAgICB2YXIgcjtcbiAgICAgIHJldHVybiAociA9IHRoaXMucmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiByLnN0b3AoLi4udCk7XG4gICAgfSk7XG4gIH1cbiAgcHVsc2F0ZSguLi50KSB7XG4gICAgdGhpcy5tb3VudCgpLnRoZW4oKCkgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICByZXR1cm4gKHIgPSB0aGlzLnJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogci5wdWxzYXRlKC4uLnQpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzZCgpIHtcbiAgcmV0dXJuIFNuLnVzZSgpO1xufVxuZnVuY3Rpb24gY2QoKSB7XG4gIGxldCBlLCB0O1xuICBjb25zdCByID0gbmV3IFByb21pc2UoKG4sIG8pID0+IHtcbiAgICBlID0gbiwgdCA9IG87XG4gIH0pO1xuICByZXR1cm4gci5yZXNvbHZlID0gZSwgci5yZWplY3QgPSB0LCByO1xufVxuZnVuY3Rpb24geHMoZSkge1xuICBjb25zdCB7XG4gICAgY2xhc3NOYW1lOiB0LFxuICAgIGNsYXNzZXM6IHIsXG4gICAgcHVsc2F0ZTogbiA9ICExLFxuICAgIHJpcHBsZVg6IG8sXG4gICAgcmlwcGxlWTogaSxcbiAgICByaXBwbGVTaXplOiBzLFxuICAgIGluOiBjLFxuICAgIG9uRXhpdGVkOiBsLFxuICAgIHRpbWVvdXQ6IHVcbiAgfSA9IGUsIFtwLCBtXSA9IEMudXNlU3RhdGUoITEpLCBnID0gc2UodCwgci5yaXBwbGUsIHIucmlwcGxlVmlzaWJsZSwgbiAmJiByLnJpcHBsZVB1bHNhdGUpLCB4ID0ge1xuICAgIHdpZHRoOiBzLFxuICAgIGhlaWdodDogcyxcbiAgICB0b3A6IC0ocyAvIDIpICsgaSxcbiAgICBsZWZ0OiAtKHMgLyAyKSArIG9cbiAgfSwgeSA9IHNlKHIuY2hpbGQsIHAgJiYgci5jaGlsZExlYXZpbmcsIG4gJiYgci5jaGlsZFB1bHNhdGUpO1xuICByZXR1cm4gIWMgJiYgIXAgJiYgbSghMCksIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWMgJiYgbCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBmID0gc2V0VGltZW91dChsLCB1KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChmKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbbCwgYywgdV0pLCAvKiBAX19QVVJFX18gKi8gTi5qc3goXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IGcsXG4gICAgc3R5bGU6IHgsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiB5XG4gICAgfSlcbiAgfSk7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHhzLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBAaWdub3JlIC0gaW5qZWN0ZWQgZnJvbSBUcmFuc2l0aW9uR3JvdXBcbiAgICovXG4gIGluOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBAaWdub3JlIC0gaW5qZWN0ZWQgZnJvbSBUcmFuc2l0aW9uR3JvdXBcbiAgICovXG4gIG9uRXhpdGVkOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByaXBwbGUgcHVsc2F0ZXMsIHR5cGljYWxseSBpbmRpY2F0aW5nIHRoZSBrZXlib2FyZCBmb2N1cyBzdGF0ZSBvZiBhbiBlbGVtZW50LlxuICAgKi9cbiAgcHVsc2F0ZTogYS5ib29sLFxuICAvKipcbiAgICogRGlhbWV0ZXIgb2YgdGhlIHJpcHBsZS5cbiAgICovXG4gIHJpcHBsZVNpemU6IGEubnVtYmVyLFxuICAvKipcbiAgICogSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgcmlwcGxlIGNlbnRlci5cbiAgICovXG4gIHJpcHBsZVg6IGEubnVtYmVyLFxuICAvKipcbiAgICogVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIHJpcHBsZSBjZW50ZXIuXG4gICAqL1xuICByaXBwbGVZOiBhLm51bWJlcixcbiAgLyoqXG4gICAqIGV4aXQgZGVsYXlcbiAgICovXG4gIHRpbWVvdXQ6IGEubnVtYmVyLmlzUmVxdWlyZWRcbn0pO1xuY29uc3QgbnQgPSBGZShcIk11aVRvdWNoUmlwcGxlXCIsIFtcInJvb3RcIiwgXCJyaXBwbGVcIiwgXCJyaXBwbGVWaXNpYmxlXCIsIFwicmlwcGxlUHVsc2F0ZVwiLCBcImNoaWxkXCIsIFwiY2hpbGRMZWF2aW5nXCIsIFwiY2hpbGRQdWxzYXRlXCJdKSwgaG8gPSA1NTAsIGxkID0gODAsIHVkID0gSXJgXG4gIDAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xuICAgIG9wYWNpdHk6IDAuMTtcbiAgfVxuXG4gIDEwMCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gICAgb3BhY2l0eTogMC4zO1xuICB9XG5gLCBmZCA9IElyYFxuICAwJSB7XG4gICAgb3BhY2l0eTogMTtcbiAgfVxuXG4gIDEwMCUge1xuICAgIG9wYWNpdHk6IDA7XG4gIH1cbmAsIGRkID0gSXJgXG4gIDAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xuICB9XG5cbiAgNTAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTIpO1xuICB9XG5cbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcbiAgfVxuYCwgcGQgPSBsZShcInNwYW5cIiwge1xuICBuYW1lOiBcIk11aVRvdWNoUmlwcGxlXCIsXG4gIHNsb3Q6IFwiUm9vdFwiXG59KSh7XG4gIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgekluZGV4OiAwLFxuICB0b3A6IDAsXG4gIHJpZ2h0OiAwLFxuICBib3R0b206IDAsXG4gIGxlZnQ6IDAsXG4gIGJvcmRlclJhZGl1czogXCJpbmhlcml0XCJcbn0pLCBtZCA9IGxlKHhzLCB7XG4gIG5hbWU6IFwiTXVpVG91Y2hSaXBwbGVcIixcbiAgc2xvdDogXCJSaXBwbGVcIlxufSlgXG4gIG9wYWNpdHk6IDA7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcblxuICAmLiR7bnQucmlwcGxlVmlzaWJsZX0ge1xuICAgIG9wYWNpdHk6IDAuMztcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xuICAgIGFuaW1hdGlvbi1uYW1lOiAke3VkfTtcbiAgICBhbmltYXRpb24tZHVyYXRpb246ICR7aG99bXM7XG4gICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogJHsoe1xuICB0aGVtZTogZVxufSkgPT4gZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZUluT3V0fTtcbiAgfVxuXG4gICYuJHtudC5yaXBwbGVQdWxzYXRlfSB7XG4gICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAkeyh7XG4gIHRoZW1lOiBlXG59KSA9PiBlLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXJ9bXM7XG4gIH1cblxuICAmIC4ke250LmNoaWxkfSB7XG4gICAgb3BhY2l0eTogMTtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIGJhY2tncm91bmQtY29sb3I6IGN1cnJlbnRDb2xvcjtcbiAgfVxuXG4gICYgLiR7bnQuY2hpbGRMZWF2aW5nfSB7XG4gICAgb3BhY2l0eTogMDtcbiAgICBhbmltYXRpb24tbmFtZTogJHtmZH07XG4gICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAke2hvfW1zO1xuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ICR7KHtcbiAgdGhlbWU6IGVcbn0pID0+IGUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VJbk91dH07XG4gIH1cblxuICAmIC4ke250LmNoaWxkUHVsc2F0ZX0ge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAvKiBAbm9mbGlwICovXG4gICAgbGVmdDogMHB4O1xuICAgIHRvcDogMDtcbiAgICBhbmltYXRpb24tbmFtZTogJHtkZH07XG4gICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAyNTAwbXM7XG4gICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogJHsoe1xuICB0aGVtZTogZVxufSkgPT4gZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZUluT3V0fTtcbiAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcbiAgICBhbmltYXRpb24tZGVsYXk6IDIwMG1zO1xuICB9XG5gLCBTcyA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCBuID0gSGUoe1xuICAgIHByb3BzOiB0LFxuICAgIG5hbWU6IFwiTXVpVG91Y2hSaXBwbGVcIlxuICB9KSwge1xuICAgIGNlbnRlcjogbyA9ICExLFxuICAgIGNsYXNzZXM6IGkgPSB7fSxcbiAgICBjbGFzc05hbWU6IHMsXG4gICAgLi4uY1xuICB9ID0gbiwgW2wsIHVdID0gQy51c2VTdGF0ZShbXSksIHAgPSBDLnVzZVJlZigwKSwgbSA9IEMudXNlUmVmKG51bGwpO1xuICBDLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbS5jdXJyZW50ICYmIChtLmN1cnJlbnQoKSwgbS5jdXJyZW50ID0gbnVsbCk7XG4gIH0sIFtsXSk7XG4gIGNvbnN0IGcgPSBDLnVzZVJlZighMSksIHggPSBEdCgpLCB5ID0gQy51c2VSZWYobnVsbCksIGYgPSBDLnVzZVJlZihudWxsKSwgUyA9IEMudXNlQ2FsbGJhY2soKGIpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwdWxzYXRlOiBoLFxuICAgICAgcmlwcGxlWDogdyxcbiAgICAgIHJpcHBsZVk6IGssXG4gICAgICByaXBwbGVTaXplOiBMLFxuICAgICAgY2I6IEJcbiAgICB9ID0gYjtcbiAgICB1KChkKSA9PiBbLi4uZCwgLyogQF9fUFVSRV9fICovIE4uanN4KG1kLCB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgIHJpcHBsZTogc2UoaS5yaXBwbGUsIG50LnJpcHBsZSksXG4gICAgICAgIHJpcHBsZVZpc2libGU6IHNlKGkucmlwcGxlVmlzaWJsZSwgbnQucmlwcGxlVmlzaWJsZSksXG4gICAgICAgIHJpcHBsZVB1bHNhdGU6IHNlKGkucmlwcGxlUHVsc2F0ZSwgbnQucmlwcGxlUHVsc2F0ZSksXG4gICAgICAgIGNoaWxkOiBzZShpLmNoaWxkLCBudC5jaGlsZCksXG4gICAgICAgIGNoaWxkTGVhdmluZzogc2UoaS5jaGlsZExlYXZpbmcsIG50LmNoaWxkTGVhdmluZyksXG4gICAgICAgIGNoaWxkUHVsc2F0ZTogc2UoaS5jaGlsZFB1bHNhdGUsIG50LmNoaWxkUHVsc2F0ZSlcbiAgICAgIH0sXG4gICAgICB0aW1lb3V0OiBobyxcbiAgICAgIHB1bHNhdGU6IGgsXG4gICAgICByaXBwbGVYOiB3LFxuICAgICAgcmlwcGxlWTogayxcbiAgICAgIHJpcHBsZVNpemU6IExcbiAgICB9LCBwLmN1cnJlbnQpXSksIHAuY3VycmVudCArPSAxLCBtLmN1cnJlbnQgPSBCO1xuICB9LCBbaV0pLCBFID0gQy51c2VDYWxsYmFjaygoYiA9IHt9LCBoID0ge30sIHcgPSAoKSA9PiB7XG4gIH0pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwdWxzYXRlOiBrID0gITEsXG4gICAgICBjZW50ZXI6IEwgPSBvIHx8IGgucHVsc2F0ZSxcbiAgICAgIGZha2VFbGVtZW50OiBCID0gITFcbiAgICAgIC8vIEZvciB0ZXN0IHB1cnBvc2VzXG4gICAgfSA9IGg7XG4gICAgaWYgKChiID09IG51bGwgPyB2b2lkIDAgOiBiLnR5cGUpID09PSBcIm1vdXNlZG93blwiICYmIGcuY3VycmVudCkge1xuICAgICAgZy5jdXJyZW50ID0gITE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIChiID09IG51bGwgPyB2b2lkIDAgOiBiLnR5cGUpID09PSBcInRvdWNoc3RhcnRcIiAmJiAoZy5jdXJyZW50ID0gITApO1xuICAgIGNvbnN0IGQgPSBCID8gbnVsbCA6IGYuY3VycmVudCwgQSA9IGQgPyBkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgICBsZXQgRCwgaiwgVztcbiAgICBpZiAoTCB8fCBiID09PSB2b2lkIDAgfHwgYi5jbGllbnRYID09PSAwICYmIGIuY2xpZW50WSA9PT0gMCB8fCAhYi5jbGllbnRYICYmICFiLnRvdWNoZXMpXG4gICAgICBEID0gTWF0aC5yb3VuZChBLndpZHRoIC8gMiksIGogPSBNYXRoLnJvdW5kKEEuaGVpZ2h0IC8gMik7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFg6IHosXG4gICAgICAgIGNsaWVudFk6IFVcbiAgICAgIH0gPSBiLnRvdWNoZXMgJiYgYi50b3VjaGVzLmxlbmd0aCA+IDAgPyBiLnRvdWNoZXNbMF0gOiBiO1xuICAgICAgRCA9IE1hdGgucm91bmQoeiAtIEEubGVmdCksIGogPSBNYXRoLnJvdW5kKFUgLSBBLnRvcCk7XG4gICAgfVxuICAgIGlmIChMKVxuICAgICAgVyA9IE1hdGguc3FydCgoMiAqIEEud2lkdGggKiogMiArIEEuaGVpZ2h0ICoqIDIpIC8gMyksIFcgJSAyID09PSAwICYmIChXICs9IDEpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgeiA9IE1hdGgubWF4KE1hdGguYWJzKChkID8gZC5jbGllbnRXaWR0aCA6IDApIC0gRCksIEQpICogMiArIDIsIFUgPSBNYXRoLm1heChNYXRoLmFicygoZCA/IGQuY2xpZW50SGVpZ2h0IDogMCkgLSBqKSwgaikgKiAyICsgMjtcbiAgICAgIFcgPSBNYXRoLnNxcnQoeiAqKiAyICsgVSAqKiAyKTtcbiAgICB9XG4gICAgYiAhPSBudWxsICYmIGIudG91Y2hlcyA/IHkuY3VycmVudCA9PT0gbnVsbCAmJiAoeS5jdXJyZW50ID0gKCkgPT4ge1xuICAgICAgUyh7XG4gICAgICAgIHB1bHNhdGU6IGssXG4gICAgICAgIHJpcHBsZVg6IEQsXG4gICAgICAgIHJpcHBsZVk6IGosXG4gICAgICAgIHJpcHBsZVNpemU6IFcsXG4gICAgICAgIGNiOiB3XG4gICAgICB9KTtcbiAgICB9LCB4LnN0YXJ0KGxkLCAoKSA9PiB7XG4gICAgICB5LmN1cnJlbnQgJiYgKHkuY3VycmVudCgpLCB5LmN1cnJlbnQgPSBudWxsKTtcbiAgICB9KSkgOiBTKHtcbiAgICAgIHB1bHNhdGU6IGssXG4gICAgICByaXBwbGVYOiBELFxuICAgICAgcmlwcGxlWTogaixcbiAgICAgIHJpcHBsZVNpemU6IFcsXG4gICAgICBjYjogd1xuICAgIH0pO1xuICB9LCBbbywgUywgeF0pLCBQID0gQy51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgRSh7fSwge1xuICAgICAgcHVsc2F0ZTogITBcbiAgICB9KTtcbiAgfSwgW0VdKSwgVCA9IEMudXNlQ2FsbGJhY2soKGIsIGgpID0+IHtcbiAgICBpZiAoeC5jbGVhcigpLCAoYiA9PSBudWxsID8gdm9pZCAwIDogYi50eXBlKSA9PT0gXCJ0b3VjaGVuZFwiICYmIHkuY3VycmVudCkge1xuICAgICAgeS5jdXJyZW50KCksIHkuY3VycmVudCA9IG51bGwsIHguc3RhcnQoMCwgKCkgPT4ge1xuICAgICAgICBUKGIsIGgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHkuY3VycmVudCA9IG51bGwsIHUoKHcpID0+IHcubGVuZ3RoID4gMCA/IHcuc2xpY2UoMSkgOiB3KSwgbS5jdXJyZW50ID0gaDtcbiAgfSwgW3hdKTtcbiAgcmV0dXJuIEMudXNlSW1wZXJhdGl2ZUhhbmRsZShyLCAoKSA9PiAoe1xuICAgIHB1bHNhdGU6IFAsXG4gICAgc3RhcnQ6IEUsXG4gICAgc3RvcDogVFxuICB9KSwgW1AsIEUsIFRdKSwgLyogQF9fUFVSRV9fICovIE4uanN4KHBkLCB7XG4gICAgY2xhc3NOYW1lOiBzZShudC5yb290LCBpLnJvb3QsIHMpLFxuICAgIHJlZjogZixcbiAgICAuLi5jLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goSG8sIHtcbiAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgIGV4aXQ6ICEwLFxuICAgICAgY2hpbGRyZW46IGxcbiAgICB9KVxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChTcy5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByaXBwbGUgc3RhcnRzIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGNvbXBvbmVudFxuICAgKiByYXRoZXIgdGhhbiBhdCB0aGUgcG9pbnQgb2YgaW50ZXJhY3Rpb24uXG4gICAqL1xuICBjZW50ZXI6IGEuYm9vbCxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBhLnN0cmluZ1xufSk7XG5mdW5jdGlvbiBoZChlKSB7XG4gIHJldHVybiBWZShcIk11aUJ1dHRvbkJhc2VcIiwgZSk7XG59XG5jb25zdCBnZCA9IEZlKFwiTXVpQnV0dG9uQmFzZVwiLCBbXCJyb290XCIsIFwiZGlzYWJsZWRcIiwgXCJmb2N1c1Zpc2libGVcIl0pLCB5ZCA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBkaXNhYmxlZDogdCxcbiAgICBmb2N1c1Zpc2libGU6IHIsXG4gICAgZm9jdXNWaXNpYmxlQ2xhc3NOYW1lOiBuLFxuICAgIGNsYXNzZXM6IG9cbiAgfSA9IGUsIHMgPSBHZSh7XG4gICAgcm9vdDogW1wicm9vdFwiLCB0ICYmIFwiZGlzYWJsZWRcIiwgciAmJiBcImZvY3VzVmlzaWJsZVwiXVxuICB9LCBoZCwgbyk7XG4gIHJldHVybiByICYmIG4gJiYgKHMucm9vdCArPSBgICR7bn1gKSwgcztcbn0sIGJkID0gbGUoXCJidXR0b25cIiwge1xuICBuYW1lOiBcIk11aUJ1dHRvbkJhc2VcIixcbiAgc2xvdDogXCJSb290XCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4gdC5yb290XG59KSh7XG4gIGRpc3BsYXk6IFwiaW5saW5lLWZsZXhcIixcbiAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAvLyBSZXNldCBkZWZhdWx0IHZhbHVlXG4gIC8vIFdlIGRpc2FibGUgdGhlIGZvY3VzIHJpbmcgZm9yIG1vdXNlLCB0b3VjaCBhbmQga2V5Ym9hcmQgdXNlcnMuXG4gIG91dGxpbmU6IDAsXG4gIGJvcmRlcjogMCxcbiAgbWFyZ2luOiAwLFxuICAvLyBSZW1vdmUgdGhlIG1hcmdpbiBpbiBTYWZhcmlcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBwYWRkaW5nOiAwLFxuICAvLyBSZW1vdmUgdGhlIHBhZGRpbmcgaW4gRmlyZWZveFxuICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgTW96QXBwZWFyYW5jZTogXCJub25lXCIsXG4gIC8vIFJlc2V0XG4gIFdlYmtpdEFwcGVhcmFuY2U6IFwibm9uZVwiLFxuICAvLyBSZXNldFxuICB0ZXh0RGVjb3JhdGlvbjogXCJub25lXCIsXG4gIC8vIFNvIHdlIHRha2UgcHJlY2VkZW50IG92ZXIgdGhlIHN0eWxlIG9mIGEgbmF0aXZlIDxhIC8+IGVsZW1lbnQuXG4gIGNvbG9yOiBcImluaGVyaXRcIixcbiAgXCImOjotbW96LWZvY3VzLWlubmVyXCI6IHtcbiAgICBib3JkZXJTdHlsZTogXCJub25lXCJcbiAgICAvLyBSZW1vdmUgRmlyZWZveCBkb3R0ZWQgb3V0bGluZS5cbiAgfSxcbiAgW2AmLiR7Z2QuZGlzYWJsZWR9YF06IHtcbiAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAvLyBEaXNhYmxlIGxpbmsgaW50ZXJhY3Rpb25zXG4gICAgY3Vyc29yOiBcImRlZmF1bHRcIlxuICB9LFxuICBcIkBtZWRpYSBwcmludFwiOiB7XG4gICAgY29sb3JBZGp1c3Q6IFwiZXhhY3RcIlxuICB9XG59KSwgJHIgPSAvKiBAX19QVVJFX18gKi8gQy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsIHIpIHtcbiAgY29uc3QgbiA9IEhlKHtcbiAgICBwcm9wczogdCxcbiAgICBuYW1lOiBcIk11aUJ1dHRvbkJhc2VcIlxuICB9KSwge1xuICAgIGFjdGlvbjogbyxcbiAgICBjZW50ZXJSaXBwbGU6IGkgPSAhMSxcbiAgICBjaGlsZHJlbjogcyxcbiAgICBjbGFzc05hbWU6IGMsXG4gICAgY29tcG9uZW50OiBsID0gXCJidXR0b25cIixcbiAgICBkaXNhYmxlZDogdSA9ICExLFxuICAgIGRpc2FibGVSaXBwbGU6IHAgPSAhMSxcbiAgICBkaXNhYmxlVG91Y2hSaXBwbGU6IG0gPSAhMSxcbiAgICBmb2N1c1JpcHBsZTogZyA9ICExLFxuICAgIGZvY3VzVmlzaWJsZUNsYXNzTmFtZTogeCxcbiAgICBMaW5rQ29tcG9uZW50OiB5ID0gXCJhXCIsXG4gICAgb25CbHVyOiBmLFxuICAgIG9uQ2xpY2s6IFMsXG4gICAgb25Db250ZXh0TWVudTogRSxcbiAgICBvbkRyYWdMZWF2ZTogUCxcbiAgICBvbkZvY3VzOiBULFxuICAgIG9uRm9jdXNWaXNpYmxlOiBiLFxuICAgIG9uS2V5RG93bjogaCxcbiAgICBvbktleVVwOiB3LFxuICAgIG9uTW91c2VEb3duOiBrLFxuICAgIG9uTW91c2VMZWF2ZTogTCxcbiAgICBvbk1vdXNlVXA6IEIsXG4gICAgb25Ub3VjaEVuZDogZCxcbiAgICBvblRvdWNoTW92ZTogQSxcbiAgICBvblRvdWNoU3RhcnQ6IEQsXG4gICAgdGFiSW5kZXg6IGogPSAwLFxuICAgIFRvdWNoUmlwcGxlUHJvcHM6IFcsXG4gICAgdG91Y2hSaXBwbGVSZWY6IHosXG4gICAgdHlwZTogVSxcbiAgICAuLi5WXG4gIH0gPSBuLCB0ZSA9IEMudXNlUmVmKG51bGwpLCBGID0gc2QoKSwgUiA9IGF0KEYucmVmLCB6KSwgW0ksIEpdID0gQy51c2VTdGF0ZSghMSk7XG4gIHUgJiYgSSAmJiBKKCExKSwgQy51c2VJbXBlcmF0aXZlSGFuZGxlKG8sICgpID0+ICh7XG4gICAgZm9jdXNWaXNpYmxlOiAoKSA9PiB7XG4gICAgICBKKCEwKSwgdGUuY3VycmVudC5mb2N1cygpO1xuICAgIH1cbiAgfSksIFtdKTtcbiAgY29uc3QgUSA9IEYuc2hvdWxkTW91bnQgJiYgIXAgJiYgIXU7XG4gIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBJICYmIGcgJiYgIXAgJiYgRi5wdWxzYXRlKCk7XG4gIH0sIFtwLCBnLCBJLCBGXSk7XG4gIGNvbnN0IEggPSBUdChGLCBcInN0YXJ0XCIsIGssIG0pLCBYID0gVHQoRiwgXCJzdG9wXCIsIEUsIG0pLCBfID0gVHQoRiwgXCJzdG9wXCIsIFAsIG0pLCBxID0gVHQoRiwgXCJzdG9wXCIsIEIsIG0pLCBHID0gVHQoRiwgXCJzdG9wXCIsIChNKSA9PiB7XG4gICAgSSAmJiBNLnByZXZlbnREZWZhdWx0KCksIEwgJiYgTChNKTtcbiAgfSwgbSksIHJlID0gVHQoRiwgXCJzdGFydFwiLCBELCBtKSwgWiA9IFR0KEYsIFwic3RvcFwiLCBkLCBtKSwgYWUgPSBUdChGLCBcInN0b3BcIiwgQSwgbSksIE8gPSBUdChGLCBcInN0b3BcIiwgKE0pID0+IHtcbiAgICBobihNLnRhcmdldCkgfHwgSighMSksIGYgJiYgZihNKTtcbiAgfSwgITEpLCB5ZSA9IFF0KChNKSA9PiB7XG4gICAgdGUuY3VycmVudCB8fCAodGUuY3VycmVudCA9IE0uY3VycmVudFRhcmdldCksIGhuKE0udGFyZ2V0KSAmJiAoSighMCksIGIgJiYgYihNKSksIFQgJiYgVChNKTtcbiAgfSksIEVlID0gKCkgPT4ge1xuICAgIGNvbnN0IE0gPSB0ZS5jdXJyZW50O1xuICAgIHJldHVybiBsICYmIGwgIT09IFwiYnV0dG9uXCIgJiYgIShNLnRhZ05hbWUgPT09IFwiQVwiICYmIE0uaHJlZik7XG4gIH0sIE1lID0gUXQoKE0pID0+IHtcbiAgICBnICYmICFNLnJlcGVhdCAmJiBJICYmIE0ua2V5ID09PSBcIiBcIiAmJiBGLnN0b3AoTSwgKCkgPT4ge1xuICAgICAgRi5zdGFydChNKTtcbiAgICB9KSwgTS50YXJnZXQgPT09IE0uY3VycmVudFRhcmdldCAmJiBFZSgpICYmIE0ua2V5ID09PSBcIiBcIiAmJiBNLnByZXZlbnREZWZhdWx0KCksIGggJiYgaChNKSwgTS50YXJnZXQgPT09IE0uY3VycmVudFRhcmdldCAmJiBFZSgpICYmIE0ua2V5ID09PSBcIkVudGVyXCIgJiYgIXUgJiYgKE0ucHJldmVudERlZmF1bHQoKSwgUyAmJiBTKE0pKTtcbiAgfSksIFFlID0gUXQoKE0pID0+IHtcbiAgICBnICYmIE0ua2V5ID09PSBcIiBcIiAmJiBJICYmICFNLmRlZmF1bHRQcmV2ZW50ZWQgJiYgRi5zdG9wKE0sICgpID0+IHtcbiAgICAgIEYucHVsc2F0ZShNKTtcbiAgICB9KSwgdyAmJiB3KE0pLCBTICYmIE0udGFyZ2V0ID09PSBNLmN1cnJlbnRUYXJnZXQgJiYgRWUoKSAmJiBNLmtleSA9PT0gXCIgXCIgJiYgIU0uZGVmYXVsdFByZXZlbnRlZCAmJiBTKE0pO1xuICB9KTtcbiAgbGV0IHZlID0gbDtcbiAgdmUgPT09IFwiYnV0dG9uXCIgJiYgKFYuaHJlZiB8fCBWLnRvKSAmJiAodmUgPSB5KTtcbiAgY29uc3QgUGUgPSB7fTtcbiAgdmUgPT09IFwiYnV0dG9uXCIgPyAoUGUudHlwZSA9IFUgPT09IHZvaWQgMCA/IFwiYnV0dG9uXCIgOiBVLCBQZS5kaXNhYmxlZCA9IHUpIDogKCFWLmhyZWYgJiYgIVYudG8gJiYgKFBlLnJvbGUgPSBcImJ1dHRvblwiKSwgdSAmJiAoUGVbXCJhcmlhLWRpc2FibGVkXCJdID0gdSkpO1xuICBjb25zdCB6ZSA9IGF0KHIsIHRlKSwgTGUgPSB7XG4gICAgLi4ubixcbiAgICBjZW50ZXJSaXBwbGU6IGksXG4gICAgY29tcG9uZW50OiBsLFxuICAgIGRpc2FibGVkOiB1LFxuICAgIGRpc2FibGVSaXBwbGU6IHAsXG4gICAgZGlzYWJsZVRvdWNoUmlwcGxlOiBtLFxuICAgIGZvY3VzUmlwcGxlOiBnLFxuICAgIHRhYkluZGV4OiBqLFxuICAgIGZvY3VzVmlzaWJsZTogSVxuICB9LCB2ID0geWQoTGUpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4cyhiZCwge1xuICAgIGFzOiB2ZSxcbiAgICBjbGFzc05hbWU6IHNlKHYucm9vdCwgYyksXG4gICAgb3duZXJTdGF0ZTogTGUsXG4gICAgb25CbHVyOiBPLFxuICAgIG9uQ2xpY2s6IFMsXG4gICAgb25Db250ZXh0TWVudTogWCxcbiAgICBvbkZvY3VzOiB5ZSxcbiAgICBvbktleURvd246IE1lLFxuICAgIG9uS2V5VXA6IFFlLFxuICAgIG9uTW91c2VEb3duOiBILFxuICAgIG9uTW91c2VMZWF2ZTogRyxcbiAgICBvbk1vdXNlVXA6IHEsXG4gICAgb25EcmFnTGVhdmU6IF8sXG4gICAgb25Ub3VjaEVuZDogWixcbiAgICBvblRvdWNoTW92ZTogYWUsXG4gICAgb25Ub3VjaFN0YXJ0OiByZSxcbiAgICByZWY6IHplLFxuICAgIHRhYkluZGV4OiB1ID8gLTEgOiBqLFxuICAgIHR5cGU6IFUsXG4gICAgLi4uUGUsXG4gICAgLi4uVixcbiAgICBjaGlsZHJlbjogW3MsIFEgPyAvKiBAX19QVVJFX18gKi8gTi5qc3goU3MsIHtcbiAgICAgIHJlZjogUixcbiAgICAgIGNlbnRlcjogaSxcbiAgICAgIC4uLldcbiAgICB9KSA6IG51bGxdXG4gIH0pO1xufSk7XG5mdW5jdGlvbiBUdChlLCB0LCByLCBuID0gITEpIHtcbiAgcmV0dXJuIFF0KChvKSA9PiAociAmJiByKG8pLCBuIHx8IGVbdF0obyksICEwKSk7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKCRyLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgICAgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBBIHJlZiBmb3IgaW1wZXJhdGl2ZSBhY3Rpb25zLlxuICAgKiBJdCBjdXJyZW50bHkgb25seSBzdXBwb3J0cyBgZm9jdXNWaXNpYmxlKClgIGFjdGlvbi5cbiAgICovXG4gIGFjdGlvbjogTG8sXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByaXBwbGVzIGFyZSBjZW50ZXJlZC5cbiAgICogVGhleSB3b24ndCBzdGFydCBhdCB0aGUgY3Vyc29yIGludGVyYWN0aW9uIHBvc2l0aW9uLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY2VudGVyUmlwcGxlOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogSmEsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgaXMgZGlzYWJsZWQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlZDogYS5ib29sLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcmlwcGxlIGVmZmVjdCBpcyBkaXNhYmxlZC5cbiAgICpcbiAgICog4pqg77iPIFdpdGhvdXQgYSByaXBwbGUgdGhlcmUgaXMgbm8gc3R5bGluZyBmb3IgOmZvY3VzLXZpc2libGUgYnkgZGVmYXVsdC4gQmUgc3VyZVxuICAgKiB0byBoaWdobGlnaHQgdGhlIGVsZW1lbnQgYnkgYXBwbHlpbmcgc2VwYXJhdGUgc3R5bGVzIHdpdGggdGhlIGAuTXVpLWZvY3VzVmlzaWJsZWAgY2xhc3MuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlUmlwcGxlOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB0b3VjaCByaXBwbGUgZWZmZWN0IGlzIGRpc2FibGVkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZVRvdWNoUmlwcGxlOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGJ1dHRvbiB3aWxsIGhhdmUgYSBrZXlib2FyZCBmb2N1cyByaXBwbGUuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBmb2N1c1JpcHBsZTogYS5ib29sLFxuICAvKipcbiAgICogVGhpcyBwcm9wIGNhbiBoZWxwIGlkZW50aWZ5IHdoaWNoIGVsZW1lbnQgaGFzIGtleWJvYXJkIGZvY3VzLlxuICAgKiBUaGUgY2xhc3MgbmFtZSB3aWxsIGJlIGFwcGxpZWQgd2hlbiB0aGUgZWxlbWVudCBnYWlucyB0aGUgZm9jdXMgdGhyb3VnaCBrZXlib2FyZCBpbnRlcmFjdGlvbi5cbiAgICogSXQncyBhIHBvbHlmaWxsIGZvciB0aGUgW0NTUyA6Zm9jdXMtdmlzaWJsZSBzZWxlY3Rvcl0oaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3NlbGVjdG9ycy00LyN0aGUtZm9jdXMtdmlzaWJsZS1wc2V1ZG8pLlxuICAgKiBUaGUgcmF0aW9uYWxlIGZvciB1c2luZyB0aGlzIGZlYXR1cmUgW2lzIGV4cGxhaW5lZCBoZXJlXShodHRwczovL2dpdGh1Yi5jb20vV0lDRy9mb2N1cy12aXNpYmxlL2Jsb2IvSEVBRC9leHBsYWluZXIubWQpLlxuICAgKiBBIFtwb2x5ZmlsbCBjYW4gYmUgdXNlZF0oaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvZm9jdXMtdmlzaWJsZSkgdG8gYXBwbHkgYSBgZm9jdXMtdmlzaWJsZWAgY2xhc3MgdG8gb3RoZXIgY29tcG9uZW50c1xuICAgKiBpZiBuZWVkZWQuXG4gICAqL1xuICBmb2N1c1Zpc2libGVDbGFzc05hbWU6IGEuc3RyaW5nLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgaHJlZjogYS5hbnksXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgdG8gcmVuZGVyIGEgbGluayB3aGVuIHRoZSBgaHJlZmAgcHJvcCBpcyBwcm92aWRlZC5cbiAgICogQGRlZmF1bHQgJ2EnXG4gICAqL1xuICBMaW5rQ29tcG9uZW50OiBhLmVsZW1lbnRUeXBlLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25CbHVyOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkNsaWNrOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkNvbnRleHRNZW51OiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkRyYWdMZWF2ZTogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Gb2N1czogYS5mdW5jLFxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGZvY3VzZWQgd2l0aCBhIGtleWJvYXJkLlxuICAgKiBXZSB0cmlnZ2VyIGEgYG9uRm9jdXNgIGNhbGxiYWNrIHRvby5cbiAgICovXG4gIG9uRm9jdXNWaXNpYmxlOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbktleURvd246IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uS2V5VXA6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uTW91c2VEb3duOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbk1vdXNlTGVhdmU6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uTW91c2VVcDogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Ub3VjaEVuZDogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Ub3VjaE1vdmU6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uVG91Y2hTdGFydDogYS5mdW5jLFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSksXG4gIC8qKlxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB0YWJJbmRleDogYS5udW1iZXIsXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBgVG91Y2hSaXBwbGVgIGVsZW1lbnQuXG4gICAqL1xuICBUb3VjaFJpcHBsZVByb3BzOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIEEgcmVmIHRoYXQgcG9pbnRzIHRvIHRoZSBgVG91Y2hSaXBwbGVgIGVsZW1lbnQuXG4gICAqL1xuICB0b3VjaFJpcHBsZVJlZjogYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5zaGFwZSh7XG4gICAgY3VycmVudDogYS5zaGFwZSh7XG4gICAgICBwdWxzYXRlOiBhLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIHN0YXJ0OiBhLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIHN0b3A6IGEuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSlcbiAgfSldKSxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHR5cGU6IGEub25lT2ZUeXBlKFthLm9uZU9mKFtcImJ1dHRvblwiLCBcInJlc2V0XCIsIFwic3VibWl0XCJdKSwgYS5zdHJpbmddKVxufSk7XG5mdW5jdGlvbiB2ZChlKSB7XG4gIHJldHVybiB0eXBlb2YgZS5tYWluID09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiB4ZChlLCB0ID0gW10pIHtcbiAgaWYgKCF2ZChlKSlcbiAgICByZXR1cm4gITE7XG4gIGZvciAoY29uc3QgciBvZiB0KVxuICAgIGlmICghZS5oYXNPd25Qcm9wZXJ0eShyKSB8fCB0eXBlb2YgZVtyXSAhPSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBQdChlID0gW10pIHtcbiAgcmV0dXJuIChbLCB0XSkgPT4gdCAmJiB4ZCh0LCBlKTtcbn1cbmZ1bmN0aW9uIFNkKGUpIHtcbiAgcmV0dXJuIFZlKFwiTXVpQ2lyY3VsYXJQcm9ncmVzc1wiLCBlKTtcbn1cbkZlKFwiTXVpQ2lyY3VsYXJQcm9ncmVzc1wiLCBbXCJyb290XCIsIFwiZGV0ZXJtaW5hdGVcIiwgXCJpbmRldGVybWluYXRlXCIsIFwiY29sb3JQcmltYXJ5XCIsIFwiY29sb3JTZWNvbmRhcnlcIiwgXCJzdmdcIiwgXCJjaXJjbGVcIiwgXCJjaXJjbGVEZXRlcm1pbmF0ZVwiLCBcImNpcmNsZUluZGV0ZXJtaW5hdGVcIiwgXCJjaXJjbGVEaXNhYmxlU2hyaW5rXCJdKTtcbmNvbnN0ICR0ID0gNDQsIGdvID0gSXJgXG4gIDAlIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgfVxuXG4gIDEwMCUge1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG4gIH1cbmAsIHlvID0gSXJgXG4gIDAlIHtcbiAgICBzdHJva2UtZGFzaGFycmF5OiAxcHgsIDIwMHB4O1xuICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAwO1xuICB9XG5cbiAgNTAlIHtcbiAgICBzdHJva2UtZGFzaGFycmF5OiAxMDBweCwgMjAwcHg7XG4gICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IC0xNXB4O1xuICB9XG5cbiAgMTAwJSB7XG4gICAgc3Ryb2tlLWRhc2hhcnJheTogMXB4LCAyMDBweDtcbiAgICBzdHJva2UtZGFzaG9mZnNldDogLTEyNnB4O1xuICB9XG5gLCBFZCA9IHR5cGVvZiBnbyAhPSBcInN0cmluZ1wiID8gJG9gXG4gICAgICAgIGFuaW1hdGlvbjogJHtnb30gMS40cyBsaW5lYXIgaW5maW5pdGU7XG4gICAgICBgIDogbnVsbCwgQ2QgPSB0eXBlb2YgeW8gIT0gXCJzdHJpbmdcIiA/ICRvYFxuICAgICAgICBhbmltYXRpb246ICR7eW99IDEuNHMgZWFzZS1pbi1vdXQgaW5maW5pdGU7XG4gICAgICBgIDogbnVsbCwgVGQgPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xhc3NlczogdCxcbiAgICB2YXJpYW50OiByLFxuICAgIGNvbG9yOiBuLFxuICAgIGRpc2FibGVTaHJpbms6IG9cbiAgfSA9IGUsIGkgPSB7XG4gICAgcm9vdDogW1wicm9vdFwiLCByLCBgY29sb3Ike2VlKG4pfWBdLFxuICAgIHN2ZzogW1wic3ZnXCJdLFxuICAgIGNpcmNsZTogW1wiY2lyY2xlXCIsIGBjaXJjbGUke2VlKHIpfWAsIG8gJiYgXCJjaXJjbGVEaXNhYmxlU2hyaW5rXCJdXG4gIH07XG4gIHJldHVybiBHZShpLCBTZCwgdCk7XG59LCB3ZCA9IGxlKFwic3BhblwiLCB7XG4gIG5hbWU6IFwiTXVpQ2lyY3VsYXJQcm9ncmVzc1wiLFxuICBzbG90OiBcIlJvb3RcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJTdGF0ZTogclxuICAgIH0gPSBlO1xuICAgIHJldHVybiBbdC5yb290LCB0W3IudmFyaWFudF0sIHRbYGNvbG9yJHtlZShyLmNvbG9yKX1gXV07XG4gIH1cbn0pKHFlKCh7XG4gIHRoZW1lOiBlXG59KSA9PiAoe1xuICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICB2YXJpYW50czogW3tcbiAgICBwcm9wczoge1xuICAgICAgdmFyaWFudDogXCJkZXRlcm1pbmF0ZVwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgdHJhbnNpdGlvbjogZS50cmFuc2l0aW9ucy5jcmVhdGUoXCJ0cmFuc2Zvcm1cIilcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgdmFyaWFudDogXCJpbmRldGVybWluYXRlXCJcbiAgICB9LFxuICAgIHN0eWxlOiBFZCB8fCB7XG4gICAgICBhbmltYXRpb246IGAke2dvfSAxLjRzIGxpbmVhciBpbmZpbml0ZWBcbiAgICB9XG4gIH0sIC4uLk9iamVjdC5lbnRyaWVzKGUucGFsZXR0ZSkuZmlsdGVyKFB0KCkpLm1hcCgoW3RdKSA9PiAoe1xuICAgIHByb3BzOiB7XG4gICAgICBjb2xvcjogdFxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGVbdF0ubWFpblxuICAgIH1cbiAgfSkpXVxufSkpKSwgT2QgPSBsZShcInN2Z1wiLCB7XG4gIG5hbWU6IFwiTXVpQ2lyY3VsYXJQcm9ncmVzc1wiLFxuICBzbG90OiBcIlN2Z1wiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHQuc3ZnXG59KSh7XG4gIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAvLyBLZWVwcyB0aGUgcHJvZ3Jlc3MgY2VudGVyZWRcbn0pLCBSZCA9IGxlKFwiY2lyY2xlXCIsIHtcbiAgbmFtZTogXCJNdWlDaXJjdWxhclByb2dyZXNzXCIsXG4gIHNsb3Q6IFwiQ2lyY2xlXCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyU3RhdGU6IHJcbiAgICB9ID0gZTtcbiAgICByZXR1cm4gW3QuY2lyY2xlLCB0W2BjaXJjbGUke2VlKHIudmFyaWFudCl9YF0sIHIuZGlzYWJsZVNocmluayAmJiB0LmNpcmNsZURpc2FibGVTaHJpbmtdO1xuICB9XG59KShxZSgoe1xuICB0aGVtZTogZVxufSkgPT4gKHtcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICB2YXJpYW50czogW3tcbiAgICBwcm9wczoge1xuICAgICAgdmFyaWFudDogXCJkZXRlcm1pbmF0ZVwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgdHJhbnNpdGlvbjogZS50cmFuc2l0aW9ucy5jcmVhdGUoXCJzdHJva2UtZGFzaG9mZnNldFwiKVxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiB7XG4gICAgICB2YXJpYW50OiBcImluZGV0ZXJtaW5hdGVcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIC8vIFNvbWUgZGVmYXVsdCB2YWx1ZSB0aGF0IGxvb2tzIGZpbmUgd2FpdGluZyBmb3IgdGhlIGFuaW1hdGlvbiB0byBraWNrcyBpbi5cbiAgICAgIHN0cm9rZURhc2hhcnJheTogXCI4MHB4LCAyMDBweFwiLFxuICAgICAgc3Ryb2tlRGFzaG9mZnNldDogMFxuICAgICAgLy8gQWRkIHRoZSB1bml0IHRvIGZpeCBhIEVkZ2UgMTYgYW5kIGJlbG93IGJ1Zy5cbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiB0LnZhcmlhbnQgPT09IFwiaW5kZXRlcm1pbmF0ZVwiICYmICF0LmRpc2FibGVTaHJpbmssXG4gICAgc3R5bGU6IENkIHx8IHtcbiAgICAgIC8vIEF0IHJ1bnRpbWUgZm9yIFBpZ21lbnQgQ1NTLCBgYnVmZmVyQW5pbWF0aW9uYCB3aWxsIGJlIG51bGwgYW5kIHRoZSBnZW5lcmF0ZWQga2V5ZnJhbWUgd2lsbCBiZSB1c2VkLlxuICAgICAgYW5pbWF0aW9uOiBgJHt5b30gMS40cyBlYXNlLWluLW91dCBpbmZpbml0ZWBcbiAgICB9XG4gIH1dXG59KSkpLCBFcyA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCBuID0gSGUoe1xuICAgIHByb3BzOiB0LFxuICAgIG5hbWU6IFwiTXVpQ2lyY3VsYXJQcm9ncmVzc1wiXG4gIH0pLCB7XG4gICAgY2xhc3NOYW1lOiBvLFxuICAgIGNvbG9yOiBpID0gXCJwcmltYXJ5XCIsXG4gICAgZGlzYWJsZVNocmluazogcyA9ICExLFxuICAgIHNpemU6IGMgPSA0MCxcbiAgICBzdHlsZTogbCxcbiAgICB0aGlja25lc3M6IHUgPSAzLjYsXG4gICAgdmFsdWU6IHAgPSAwLFxuICAgIHZhcmlhbnQ6IG0gPSBcImluZGV0ZXJtaW5hdGVcIixcbiAgICAuLi5nXG4gIH0gPSBuLCB4ID0ge1xuICAgIC4uLm4sXG4gICAgY29sb3I6IGksXG4gICAgZGlzYWJsZVNocmluazogcyxcbiAgICBzaXplOiBjLFxuICAgIHRoaWNrbmVzczogdSxcbiAgICB2YWx1ZTogcCxcbiAgICB2YXJpYW50OiBtXG4gIH0sIHkgPSBUZCh4KSwgZiA9IHt9LCBTID0ge30sIEUgPSB7fTtcbiAgaWYgKG0gPT09IFwiZGV0ZXJtaW5hdGVcIikge1xuICAgIGNvbnN0IFAgPSAyICogTWF0aC5QSSAqICgoJHQgLSB1KSAvIDIpO1xuICAgIGYuc3Ryb2tlRGFzaGFycmF5ID0gUC50b0ZpeGVkKDMpLCBFW1wiYXJpYS12YWx1ZW5vd1wiXSA9IE1hdGgucm91bmQocCksIGYuc3Ryb2tlRGFzaG9mZnNldCA9IGAkeygoMTAwIC0gcCkgLyAxMDAgKiBQKS50b0ZpeGVkKDMpfXB4YCwgUy50cmFuc2Zvcm0gPSBcInJvdGF0ZSgtOTBkZWcpXCI7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeCh3ZCwge1xuICAgIGNsYXNzTmFtZTogc2UoeS5yb290LCBvKSxcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6IGMsXG4gICAgICBoZWlnaHQ6IGMsXG4gICAgICAuLi5TLFxuICAgICAgLi4ubFxuICAgIH0sXG4gICAgb3duZXJTdGF0ZTogeCxcbiAgICByZWY6IHIsXG4gICAgcm9sZTogXCJwcm9ncmVzc2JhclwiLFxuICAgIC4uLkUsXG4gICAgLi4uZyxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KE9kLCB7XG4gICAgICBjbGFzc05hbWU6IHkuc3ZnLFxuICAgICAgb3duZXJTdGF0ZTogeCxcbiAgICAgIHZpZXdCb3g6IGAkeyR0IC8gMn0gJHskdCAvIDJ9ICR7JHR9ICR7JHR9YCxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goUmQsIHtcbiAgICAgICAgY2xhc3NOYW1lOiB5LmNpcmNsZSxcbiAgICAgICAgc3R5bGU6IGYsXG4gICAgICAgIG93bmVyU3RhdGU6IHgsXG4gICAgICAgIGN4OiAkdCxcbiAgICAgICAgY3k6ICR0LFxuICAgICAgICByOiAoJHQgLSB1KSAvIDIsXG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICBzdHJva2VXaWR0aDogdVxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChFcy5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCICAgIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiAgICAg4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIEl0IHN1cHBvcnRzIGJvdGggZGVmYXVsdCBhbmQgY3VzdG9tIHRoZW1lIGNvbG9ycywgd2hpY2ggY2FuIGJlIGFkZGVkIGFzIHNob3duIGluIHRoZVxuICAgKiBbcGFsZXR0ZSBjdXN0b21pemF0aW9uIGd1aWRlXShodHRwczovL211aS5jb20vbWF0ZXJpYWwtdWkvY3VzdG9taXphdGlvbi9wYWxldHRlLyNjdXN0b20tY29sb3JzKS5cbiAgICogQGRlZmF1bHQgJ3ByaW1hcnknXG4gICAqL1xuICBjb2xvcjogYS5vbmVPZlR5cGUoW2Eub25lT2YoW1wiaW5oZXJpdFwiLCBcInByaW1hcnlcIiwgXCJzZWNvbmRhcnlcIiwgXCJlcnJvclwiLCBcImluZm9cIiwgXCJzdWNjZXNzXCIsIFwid2FybmluZ1wiXSksIGEuc3RyaW5nXSksXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBzaHJpbmsgYW5pbWF0aW9uIGlzIGRpc2FibGVkLlxuICAgKiBUaGlzIG9ubHkgd29ya3MgaWYgdmFyaWFudCBpcyBgaW5kZXRlcm1pbmF0ZWAuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlU2hyaW5rOiBhcihhLmJvb2wsIChlKSA9PiBlLmRpc2FibGVTaHJpbmsgJiYgZS52YXJpYW50ICYmIGUudmFyaWFudCAhPT0gXCJpbmRldGVybWluYXRlXCIgPyBuZXcgRXJyb3IoXCJNVUk6IFlvdSBoYXZlIHByb3ZpZGVkIHRoZSBgZGlzYWJsZVNocmlua2AgcHJvcCB3aXRoIGEgdmFyaWFudCBvdGhlciB0aGFuIGBpbmRldGVybWluYXRlYC4gVGhpcyB3aWxsIGhhdmUgbm8gZWZmZWN0LlwiKSA6IG51bGwpLFxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICogSWYgdXNpbmcgYSBudW1iZXIsIHRoZSBwaXhlbCB1bml0IGlzIGFzc3VtZWQuXG4gICAqIElmIHVzaW5nIGEgc3RyaW5nLCB5b3UgbmVlZCB0byBwcm92aWRlIHRoZSBDU1MgdW5pdCwgZm9yIGV4YW1wbGUgJzNyZW0nLlxuICAgKiBAZGVmYXVsdCA0MFxuICAgKi9cbiAgc2l6ZTogYS5vbmVPZlR5cGUoW2EubnVtYmVyLCBhLnN0cmluZ10pLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3R5bGU6IGEub2JqZWN0LFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSksXG4gIC8qKlxuICAgKiBUaGUgdGhpY2tuZXNzIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBkZWZhdWx0IDMuNlxuICAgKi9cbiAgdGhpY2tuZXNzOiBhLm51bWJlcixcbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yIGZvciB0aGUgZGV0ZXJtaW5hdGUgdmFyaWFudC5cbiAgICogVmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHZhbHVlOiBhLm51bWJlcixcbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICogVXNlIGluZGV0ZXJtaW5hdGUgd2hlbiB0aGVyZSBpcyBubyBwcm9ncmVzcyB2YWx1ZS5cbiAgICogQGRlZmF1bHQgJ2luZGV0ZXJtaW5hdGUnXG4gICAqL1xuICB2YXJpYW50OiBhLm9uZU9mKFtcImRldGVybWluYXRlXCIsIFwiaW5kZXRlcm1pbmF0ZVwiXSlcbn0pO1xuZnVuY3Rpb24gJGQoZSkge1xuICByZXR1cm4gVmUoXCJNdWlJY29uQnV0dG9uXCIsIGUpO1xufVxuY29uc3QgYWEgPSBGZShcIk11aUljb25CdXR0b25cIiwgW1wicm9vdFwiLCBcImRpc2FibGVkXCIsIFwiY29sb3JJbmhlcml0XCIsIFwiY29sb3JQcmltYXJ5XCIsIFwiY29sb3JTZWNvbmRhcnlcIiwgXCJjb2xvckVycm9yXCIsIFwiY29sb3JJbmZvXCIsIFwiY29sb3JTdWNjZXNzXCIsIFwiY29sb3JXYXJuaW5nXCIsIFwiZWRnZVN0YXJ0XCIsIFwiZWRnZUVuZFwiLCBcInNpemVTbWFsbFwiLCBcInNpemVNZWRpdW1cIiwgXCJzaXplTGFyZ2VcIiwgXCJsb2FkaW5nXCIsIFwibG9hZGluZ0luZGljYXRvclwiLCBcImxvYWRpbmdXcmFwcGVyXCJdKSwgUGQgPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xhc3NlczogdCxcbiAgICBkaXNhYmxlZDogcixcbiAgICBjb2xvcjogbixcbiAgICBlZGdlOiBvLFxuICAgIHNpemU6IGksXG4gICAgbG9hZGluZzogc1xuICB9ID0gZSwgYyA9IHtcbiAgICByb290OiBbXCJyb290XCIsIHMgJiYgXCJsb2FkaW5nXCIsIHIgJiYgXCJkaXNhYmxlZFwiLCBuICE9PSBcImRlZmF1bHRcIiAmJiBgY29sb3Ike2VlKG4pfWAsIG8gJiYgYGVkZ2Uke2VlKG8pfWAsIGBzaXplJHtlZShpKX1gXSxcbiAgICBsb2FkaW5nSW5kaWNhdG9yOiBbXCJsb2FkaW5nSW5kaWNhdG9yXCJdLFxuICAgIGxvYWRpbmdXcmFwcGVyOiBbXCJsb2FkaW5nV3JhcHBlclwiXVxuICB9O1xuICByZXR1cm4gR2UoYywgJGQsIHQpO1xufSwga2QgPSBsZSgkciwge1xuICBuYW1lOiBcIk11aUljb25CdXR0b25cIixcbiAgc2xvdDogXCJSb290XCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyU3RhdGU6IHJcbiAgICB9ID0gZTtcbiAgICByZXR1cm4gW3Qucm9vdCwgci5sb2FkaW5nICYmIHQubG9hZGluZywgci5jb2xvciAhPT0gXCJkZWZhdWx0XCIgJiYgdFtgY29sb3Ike2VlKHIuY29sb3IpfWBdLCByLmVkZ2UgJiYgdFtgZWRnZSR7ZWUoci5lZGdlKX1gXSwgdFtgc2l6ZSR7ZWUoci5zaXplKX1gXV07XG4gIH1cbn0pKHFlKCh7XG4gIHRoZW1lOiBlXG59KSA9PiAoe1xuICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gIGZsZXg6IFwiMCAwIGF1dG9cIixcbiAgZm9udFNpemU6IGUudHlwb2dyYXBoeS5weFRvUmVtKDI0KSxcbiAgcGFkZGluZzogOCxcbiAgYm9yZGVyUmFkaXVzOiBcIjUwJVwiLFxuICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLmFjdGlvbi5hY3RpdmUsXG4gIHRyYW5zaXRpb246IGUudHJhbnNpdGlvbnMuY3JlYXRlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB7XG4gICAgZHVyYXRpb246IGUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlc3RcbiAgfSksXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiAodCkgPT4gIXQuZGlzYWJsZVJpcHBsZSxcbiAgICBzdHlsZToge1xuICAgICAgXCItLUljb25CdXR0b24taG92ZXJCZ1wiOiBlLnZhcnMgPyBgcmdiYSgke2UudmFycy5wYWxldHRlLmFjdGlvbi5hY3RpdmVDaGFubmVsfSAvICR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eX0pYCA6IERlKGUucGFsZXR0ZS5hY3Rpb24uYWN0aXZlLCBlLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksXG4gICAgICBcIiY6aG92ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidmFyKC0tSWNvbkJ1dHRvbi1ob3ZlckJnKVwiLFxuICAgICAgICAvLyBSZXNldCBvbiB0b3VjaCBkZXZpY2VzLCBpdCBkb2Vzbid0IGFkZCBzcGVjaWZpY2l0eVxuICAgICAgICBcIkBtZWRpYSAoaG92ZXI6IG5vbmUpXCI6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGVkZ2U6IFwic3RhcnRcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIG1hcmdpbkxlZnQ6IC0xMlxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiB7XG4gICAgICBlZGdlOiBcInN0YXJ0XCIsXG4gICAgICBzaXplOiBcInNtYWxsXCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBtYXJnaW5MZWZ0OiAtM1xuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiB7XG4gICAgICBlZGdlOiBcImVuZFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgbWFyZ2luUmlnaHQ6IC0xMlxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiB7XG4gICAgICBlZGdlOiBcImVuZFwiLFxuICAgICAgc2l6ZTogXCJzbWFsbFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgbWFyZ2luUmlnaHQ6IC0zXG4gICAgfVxuICB9XVxufSkpLCBxZSgoe1xuICB0aGVtZTogZVxufSkgPT4gKHtcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6IHtcbiAgICAgIGNvbG9yOiBcImluaGVyaXRcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiBcImluaGVyaXRcIlxuICAgIH1cbiAgfSwgLi4uT2JqZWN0LmVudHJpZXMoZS5wYWxldHRlKS5maWx0ZXIoUHQoKSkubWFwKChbdF0pID0+ICh7XG4gICAgcHJvcHM6IHtcbiAgICAgIGNvbG9yOiB0XG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZVt0XS5tYWluXG4gICAgfVxuICB9KSksIC4uLk9iamVjdC5lbnRyaWVzKGUucGFsZXR0ZSkuZmlsdGVyKFB0KCkpLm1hcCgoW3RdKSA9PiAoe1xuICAgIHByb3BzOiB7XG4gICAgICBjb2xvcjogdFxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIFwiLS1JY29uQnV0dG9uLWhvdmVyQmdcIjogZS52YXJzID8gYHJnYmEoJHsoZS52YXJzIHx8IGUpLnBhbGV0dGVbdF0ubWFpbkNoYW5uZWx9IC8gJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5fSlgIDogRGUoKGUudmFycyB8fCBlKS5wYWxldHRlW3RdLm1haW4sIGUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KVxuICAgIH1cbiAgfSkpLCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHNpemU6IFwic21hbGxcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmc6IDUsXG4gICAgICBmb250U2l6ZTogZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTgpXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHNpemU6IFwibGFyZ2VcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmc6IDEyLFxuICAgICAgZm9udFNpemU6IGUudHlwb2dyYXBoeS5weFRvUmVtKDI4KVxuICAgIH1cbiAgfV0sXG4gIFtgJi4ke2FhLmRpc2FibGVkfWBdOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRcbiAgfSxcbiAgW2AmLiR7YWEubG9hZGluZ31gXToge1xuICAgIGNvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgfVxufSkpKSwgQWQgPSBsZShcInNwYW5cIiwge1xuICBuYW1lOiBcIk11aUljb25CdXR0b25cIixcbiAgc2xvdDogXCJMb2FkaW5nSW5kaWNhdG9yXCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4gdC5sb2FkaW5nSW5kaWNhdG9yXG59KSgoe1xuICB0aGVtZTogZVxufSkgPT4gKHtcbiAgZGlzcGxheTogXCJub25lXCIsXG4gIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gIHZpc2liaWxpdHk6IFwidmlzaWJsZVwiLFxuICB0b3A6IFwiNTAlXCIsXG4gIGxlZnQ6IFwiNTAlXCIsXG4gIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSwgLTUwJSlcIixcbiAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWQsXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiB7XG4gICAgICBsb2FkaW5nOiAhMFxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiXG4gICAgfVxuICB9XVxufSkpLCBDcyA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCBuID0gSGUoe1xuICAgIHByb3BzOiB0LFxuICAgIG5hbWU6IFwiTXVpSWNvbkJ1dHRvblwiXG4gIH0pLCB7XG4gICAgZWRnZTogbyA9ICExLFxuICAgIGNoaWxkcmVuOiBpLFxuICAgIGNsYXNzTmFtZTogcyxcbiAgICBjb2xvcjogYyA9IFwiZGVmYXVsdFwiLFxuICAgIGRpc2FibGVkOiBsID0gITEsXG4gICAgZGlzYWJsZUZvY3VzUmlwcGxlOiB1ID0gITEsXG4gICAgc2l6ZTogcCA9IFwibWVkaXVtXCIsXG4gICAgaWQ6IG0sXG4gICAgbG9hZGluZzogZyA9IG51bGwsXG4gICAgbG9hZGluZ0luZGljYXRvcjogeCxcbiAgICAuLi55XG4gIH0gPSBuLCBmID0gUWEobSksIFMgPSB4ID8/IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChFcywge1xuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGYsXG4gICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgIHNpemU6IDE2XG4gIH0pLCBFID0ge1xuICAgIC4uLm4sXG4gICAgZWRnZTogbyxcbiAgICBjb2xvcjogYyxcbiAgICBkaXNhYmxlZDogbCxcbiAgICBkaXNhYmxlRm9jdXNSaXBwbGU6IHUsXG4gICAgbG9hZGluZzogZyxcbiAgICBsb2FkaW5nSW5kaWNhdG9yOiBTLFxuICAgIHNpemU6IHBcbiAgfSwgUCA9IFBkKEUpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4cyhrZCwge1xuICAgIGlkOiBmLFxuICAgIGNsYXNzTmFtZTogc2UoUC5yb290LCBzKSxcbiAgICBjZW50ZXJSaXBwbGU6ICEwLFxuICAgIGZvY3VzUmlwcGxlOiAhdSxcbiAgICBkaXNhYmxlZDogbCB8fCBnLFxuICAgIHJlZjogcixcbiAgICAuLi55LFxuICAgIG93bmVyU3RhdGU6IEUsXG4gICAgY2hpbGRyZW46IFt0eXBlb2YgZyA9PSBcImJvb2xlYW5cIiAmJiAvLyB1c2UgcGxhaW4gSFRNTCBzcGFuIHRvIG1pbmltaXplIHRoZSBydW50aW1lIG92ZXJoZWFkXG4gICAgLyogQF9fUFVSRV9fICovIE4uanN4KFwic3BhblwiLCB7XG4gICAgICBjbGFzc05hbWU6IFAubG9hZGluZ1dyYXBwZXIsXG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiBcImNvbnRlbnRzXCJcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KEFkLCB7XG4gICAgICAgIGNsYXNzTmFtZTogUC5sb2FkaW5nSW5kaWNhdG9yLFxuICAgICAgICBvd25lclN0YXRlOiBFLFxuICAgICAgICBjaGlsZHJlbjogZyAmJiBTXG4gICAgICB9KVxuICAgIH0pLCBpXVxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChDcy5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCICAgIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiAgICAg4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogVGhlIGljb24gdG8gZGlzcGxheS5cbiAgICovXG4gIGNoaWxkcmVuOiBhcihhLm5vZGUsIChlKSA9PiBDLkNoaWxkcmVuLnRvQXJyYXkoZS5jaGlsZHJlbikuc29tZSgocikgPT4gLyogQF9fUFVSRV9fICovIEMuaXNWYWxpZEVsZW1lbnQocikgJiYgci5wcm9wcy5vbkNsaWNrKSA/IG5ldyBFcnJvcihbXCJNVUk6IFlvdSBhcmUgcHJvdmlkaW5nIGFuIG9uQ2xpY2sgZXZlbnQgbGlzdGVuZXIgdG8gYSBjaGlsZCBvZiBhIGJ1dHRvbiBlbGVtZW50LlwiLCBcIlByZWZlciBhcHBseWluZyBpdCB0byB0aGUgSWNvbkJ1dHRvbiBkaXJlY3RseS5cIiwgXCJUaGlzIGd1YXJhbnRlZXMgdGhhdCB0aGUgd2hvbGUgPGJ1dHRvbj4gd2lsbCBiZSByZXNwb25zaXZlIHRvIGNsaWNrIGV2ZW50cy5cIl0uam9pbihgXG5gKSkgOiBudWxsKSxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LlxuICAgKiBJdCBzdXBwb3J0cyBib3RoIGRlZmF1bHQgYW5kIGN1c3RvbSB0aGVtZSBjb2xvcnMsIHdoaWNoIGNhbiBiZSBhZGRlZCBhcyBzaG93biBpbiB0aGVcbiAgICogW3BhbGV0dGUgY3VzdG9taXphdGlvbiBndWlkZV0oaHR0cHM6Ly9tdWkuY29tL21hdGVyaWFsLXVpL2N1c3RvbWl6YXRpb24vcGFsZXR0ZS8jY3VzdG9tLWNvbG9ycykuXG4gICAqIEBkZWZhdWx0ICdkZWZhdWx0J1xuICAgKi9cbiAgY29sb3I6IGEub25lT2ZUeXBlKFthLm9uZU9mKFtcImluaGVyaXRcIiwgXCJkZWZhdWx0XCIsIFwicHJpbWFyeVwiLCBcInNlY29uZGFyeVwiLCBcImVycm9yXCIsIFwiaW5mb1wiLCBcInN1Y2Nlc3NcIiwgXCJ3YXJuaW5nXCJdKSwgYS5zdHJpbmddKSxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVkOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSAga2V5Ym9hcmQgZm9jdXMgcmlwcGxlIGlzIGRpc2FibGVkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZUZvY3VzUmlwcGxlOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByaXBwbGUgZWZmZWN0IGlzIGRpc2FibGVkLlxuICAgKlxuICAgKiDimqDvuI8gV2l0aG91dCBhIHJpcHBsZSB0aGVyZSBpcyBubyBzdHlsaW5nIGZvciA6Zm9jdXMtdmlzaWJsZSBieSBkZWZhdWx0LiBCZSBzdXJlXG4gICAqIHRvIGhpZ2hsaWdodCB0aGUgZWxlbWVudCBieSBhcHBseWluZyBzZXBhcmF0ZSBzdHlsZXMgd2l0aCB0aGUgYC5NdWktZm9jdXNWaXNpYmxlYCBjbGFzcy5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVSaXBwbGU6IGEuYm9vbCxcbiAgLyoqXG4gICAqIElmIGdpdmVuLCB1c2VzIGEgbmVnYXRpdmUgbWFyZ2luIHRvIGNvdW50ZXJhY3QgdGhlIHBhZGRpbmcgb24gb25lXG4gICAqIHNpZGUgKHRoaXMgaXMgb2Z0ZW4gaGVscGZ1bCBmb3IgYWxpZ25pbmcgdGhlIGxlZnQgb3IgcmlnaHRcbiAgICogc2lkZSBvZiB0aGUgaWNvbiB3aXRoIGNvbnRlbnQgYWJvdmUgb3IgYmVsb3csIHdpdGhvdXQgcnVpbmluZyB0aGUgYm9yZGVyXG4gICAqIHNpemUgYW5kIHNoYXBlKS5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGVkZ2U6IGEub25lT2YoW1wiZW5kXCIsIFwic3RhcnRcIiwgITFdKSxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGlkOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxvYWRpbmcgaW5kaWNhdG9yIGlzIHZpc2libGUgYW5kIHRoZSBidXR0b24gaXMgZGlzYWJsZWQuXG4gICAqIElmIGB0cnVlIHwgZmFsc2VgLCB0aGUgbG9hZGluZyB3cmFwcGVyIGlzIGFsd2F5cyByZW5kZXJlZCBiZWZvcmUgdGhlIGNoaWxkcmVuIHRvIHByZXZlbnQgW0dvb2dsZSBUcmFuc2xhdGlvbiBDcmFzaF0oaHR0cHM6Ly9naXRodWIuY29tL211aS9tYXRlcmlhbC11aS9pc3N1ZXMvMjc4NTMpLlxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBsb2FkaW5nOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBFbGVtZW50IHBsYWNlZCBiZWZvcmUgdGhlIGNoaWxkcmVuIGlmIHRoZSBidXR0b24gaXMgaW4gbG9hZGluZyBzdGF0ZS5cbiAgICogVGhlIG5vZGUgc2hvdWxkIGNvbnRhaW4gYW4gZWxlbWVudCB3aXRoIGByb2xlPVwicHJvZ3Jlc3NiYXJcImAgd2l0aCBhbiBhY2Nlc3NpYmxlIG5hbWUuXG4gICAqIEJ5IGRlZmF1bHQsIGl0IHJlbmRlcnMgYSBgQ2lyY3VsYXJQcm9ncmVzc2AgdGhhdCBpcyBsYWJlbGVkIGJ5IHRoZSBidXR0b24gaXRzZWxmLlxuICAgKiBAZGVmYXVsdCA8Q2lyY3VsYXJQcm9ncmVzcyBjb2xvcj1cImluaGVyaXRcIiBzaXplPXsxNn0gLz5cbiAgICovXG4gIGxvYWRpbmdJbmRpY2F0b3I6IGEubm9kZSxcbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIGBzbWFsbGAgaXMgZXF1aXZhbGVudCB0byB0aGUgZGVuc2UgYnV0dG9uIHN0eWxpbmcuXG4gICAqIEBkZWZhdWx0ICdtZWRpdW0nXG4gICAqL1xuICBzaXplOiBhLm9uZU9mVHlwZShbYS5vbmVPZihbXCJzbWFsbFwiLCBcIm1lZGl1bVwiLCBcImxhcmdlXCJdKSwgYS5zdHJpbmddKSxcbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gcHJvcCB0aGF0IGFsbG93cyBkZWZpbmluZyBzeXN0ZW0gb3ZlcnJpZGVzIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgc3g6IGEub25lT2ZUeXBlKFthLmFycmF5T2YoYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3QsIGEuYm9vbF0pKSwgYS5mdW5jLCBhLm9iamVjdF0pXG59KTtcbmZ1bmN0aW9uIE5kKGUpIHtcbiAgcmV0dXJuIFZlKFwiTXVpVHlwb2dyYXBoeVwiLCBlKTtcbn1cbmNvbnN0IHNhID0gRmUoXCJNdWlUeXBvZ3JhcGh5XCIsIFtcInJvb3RcIiwgXCJoMVwiLCBcImgyXCIsIFwiaDNcIiwgXCJoNFwiLCBcImg1XCIsIFwiaDZcIiwgXCJzdWJ0aXRsZTFcIiwgXCJzdWJ0aXRsZTJcIiwgXCJib2R5MVwiLCBcImJvZHkyXCIsIFwiaW5oZXJpdFwiLCBcImJ1dHRvblwiLCBcImNhcHRpb25cIiwgXCJvdmVybGluZVwiLCBcImFsaWduTGVmdFwiLCBcImFsaWduUmlnaHRcIiwgXCJhbGlnbkNlbnRlclwiLCBcImFsaWduSnVzdGlmeVwiLCBcIm5vV3JhcFwiLCBcImd1dHRlckJvdHRvbVwiLCBcInBhcmFncmFwaFwiXSksIE1kID0ge1xuICBwcmltYXJ5OiAhMCxcbiAgc2Vjb25kYXJ5OiAhMCxcbiAgZXJyb3I6ICEwLFxuICBpbmZvOiAhMCxcbiAgc3VjY2VzczogITAsXG4gIHdhcm5pbmc6ICEwLFxuICB0ZXh0UHJpbWFyeTogITAsXG4gIHRleHRTZWNvbmRhcnk6ICEwLFxuICB0ZXh0RGlzYWJsZWQ6ICEwXG59LCBJZCA9IFdmKCksIF9kID0gKGUpID0+IHtcbiAgY29uc3Qge1xuICAgIGFsaWduOiB0LFxuICAgIGd1dHRlckJvdHRvbTogcixcbiAgICBub1dyYXA6IG4sXG4gICAgcGFyYWdyYXBoOiBvLFxuICAgIHZhcmlhbnQ6IGksXG4gICAgY2xhc3Nlczogc1xuICB9ID0gZSwgYyA9IHtcbiAgICByb290OiBbXCJyb290XCIsIGksIGUuYWxpZ24gIT09IFwiaW5oZXJpdFwiICYmIGBhbGlnbiR7ZWUodCl9YCwgciAmJiBcImd1dHRlckJvdHRvbVwiLCBuICYmIFwibm9XcmFwXCIsIG8gJiYgXCJwYXJhZ3JhcGhcIl1cbiAgfTtcbiAgcmV0dXJuIEdlKGMsIE5kLCBzKTtcbn0sIGpkID0gbGUoXCJzcGFuXCIsIHtcbiAgbmFtZTogXCJNdWlUeXBvZ3JhcGh5XCIsXG4gIHNsb3Q6IFwiUm9vdFwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lclN0YXRlOiByXG4gICAgfSA9IGU7XG4gICAgcmV0dXJuIFt0LnJvb3QsIHIudmFyaWFudCAmJiB0W3IudmFyaWFudF0sIHIuYWxpZ24gIT09IFwiaW5oZXJpdFwiICYmIHRbYGFsaWduJHtlZShyLmFsaWduKX1gXSwgci5ub1dyYXAgJiYgdC5ub1dyYXAsIHIuZ3V0dGVyQm90dG9tICYmIHQuZ3V0dGVyQm90dG9tLCByLnBhcmFncmFwaCAmJiB0LnBhcmFncmFwaF07XG4gIH1cbn0pKHFlKCh7XG4gIHRoZW1lOiBlXG59KSA9PiB7XG4gIHZhciB0O1xuICByZXR1cm4ge1xuICAgIG1hcmdpbjogMCxcbiAgICB2YXJpYW50czogW3tcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHZhcmlhbnQ6IFwiaW5oZXJpdFwiXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLy8gU29tZSBlbGVtZW50cywgbGlrZSA8YnV0dG9uPiBvbiBDaHJvbWUgaGF2ZSBkZWZhdWx0IGZvbnQgdGhhdCBkb2Vzbid0IGluaGVyaXQsIHJlc2V0IHRoaXMuXG4gICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiBcImluaGVyaXRcIixcbiAgICAgICAgbGV0dGVyU3BhY2luZzogXCJpbmhlcml0XCJcbiAgICAgIH1cbiAgICB9LCAuLi5PYmplY3QuZW50cmllcyhlLnR5cG9ncmFwaHkpLmZpbHRlcigoW3IsIG5dKSA9PiByICE9PSBcImluaGVyaXRcIiAmJiBuICYmIHR5cGVvZiBuID09IFwib2JqZWN0XCIpLm1hcCgoW3IsIG5dKSA9PiAoe1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdmFyaWFudDogclxuICAgICAgfSxcbiAgICAgIHN0eWxlOiBuXG4gICAgfSkpLCAuLi5PYmplY3QuZW50cmllcyhlLnBhbGV0dGUpLmZpbHRlcihQdCgpKS5tYXAoKFtyXSkgPT4gKHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiByXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZVtyXS5tYWluXG4gICAgICB9XG4gICAgfSkpLCAuLi5PYmplY3QuZW50cmllcygoKHQgPSBlLnBhbGV0dGUpID09IG51bGwgPyB2b2lkIDAgOiB0LnRleHQpIHx8IHt9KS5maWx0ZXIoKFssIHJdKSA9PiB0eXBlb2YgciA9PSBcInN0cmluZ1wiKS5tYXAoKFtyXSkgPT4gKHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiBgdGV4dCR7ZWUocil9YFxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGUudGV4dFtyXVxuICAgICAgfVxuICAgIH0pKSwge1xuICAgICAgcHJvcHM6ICh7XG4gICAgICAgIG93bmVyU3RhdGU6IHJcbiAgICAgIH0pID0+IHIuYWxpZ24gIT09IFwiaW5oZXJpdFwiLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgdGV4dEFsaWduOiBcInZhcigtLVR5cG9ncmFwaHktdGV4dEFsaWduKVwiXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcHJvcHM6ICh7XG4gICAgICAgIG93bmVyU3RhdGU6IHJcbiAgICAgIH0pID0+IHIubm9XcmFwLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcHJvcHM6ICh7XG4gICAgICAgIG93bmVyU3RhdGU6IHJcbiAgICAgIH0pID0+IHIuZ3V0dGVyQm90dG9tLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgbWFyZ2luQm90dG9tOiBcIjAuMzVlbVwiXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcHJvcHM6ICh7XG4gICAgICAgIG93bmVyU3RhdGU6IHJcbiAgICAgIH0pID0+IHIucGFyYWdyYXBoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgbWFyZ2luQm90dG9tOiAxNlxuICAgICAgfVxuICAgIH1dXG4gIH07XG59KSksIGNhID0ge1xuICBoMTogXCJoMVwiLFxuICBoMjogXCJoMlwiLFxuICBoMzogXCJoM1wiLFxuICBoNDogXCJoNFwiLFxuICBoNTogXCJoNVwiLFxuICBoNjogXCJoNlwiLFxuICBzdWJ0aXRsZTE6IFwiaDZcIixcbiAgc3VidGl0bGUyOiBcImg2XCIsXG4gIGJvZHkxOiBcInBcIixcbiAgYm9keTI6IFwicFwiLFxuICBpbmhlcml0OiBcInBcIlxufSwgYnQgPSAvKiBAX19QVVJFX18gKi8gQy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsIHIpIHtcbiAgY29uc3Qge1xuICAgIGNvbG9yOiBuLFxuICAgIC4uLm9cbiAgfSA9IEhlKHtcbiAgICBwcm9wczogdCxcbiAgICBuYW1lOiBcIk11aVR5cG9ncmFwaHlcIlxuICB9KSwgaSA9ICFNZFtuXSwgcyA9IElkKHtcbiAgICAuLi5vLFxuICAgIC4uLmkgJiYge1xuICAgICAgY29sb3I6IG5cbiAgICB9XG4gIH0pLCB7XG4gICAgYWxpZ246IGMgPSBcImluaGVyaXRcIixcbiAgICBjbGFzc05hbWU6IGwsXG4gICAgY29tcG9uZW50OiB1LFxuICAgIGd1dHRlckJvdHRvbTogcCA9ICExLFxuICAgIG5vV3JhcDogbSA9ICExLFxuICAgIHBhcmFncmFwaDogZyA9ICExLFxuICAgIHZhcmlhbnQ6IHggPSBcImJvZHkxXCIsXG4gICAgdmFyaWFudE1hcHBpbmc6IHkgPSBjYSxcbiAgICAuLi5mXG4gIH0gPSBzLCBTID0ge1xuICAgIC4uLnMsXG4gICAgYWxpZ246IGMsXG4gICAgY29sb3I6IG4sXG4gICAgY2xhc3NOYW1lOiBsLFxuICAgIGNvbXBvbmVudDogdSxcbiAgICBndXR0ZXJCb3R0b206IHAsXG4gICAgbm9XcmFwOiBtLFxuICAgIHBhcmFncmFwaDogZyxcbiAgICB2YXJpYW50OiB4LFxuICAgIHZhcmlhbnRNYXBwaW5nOiB5XG4gIH0sIEUgPSB1IHx8IChnID8gXCJwXCIgOiB5W3hdIHx8IGNhW3hdKSB8fCBcInNwYW5cIiwgUCA9IF9kKFMpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KGpkLCB7XG4gICAgYXM6IEUsXG4gICAgcmVmOiByLFxuICAgIGNsYXNzTmFtZTogc2UoUC5yb290LCBsKSxcbiAgICAuLi5mLFxuICAgIG93bmVyU3RhdGU6IFMsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLmMgIT09IFwiaW5oZXJpdFwiICYmIHtcbiAgICAgICAgXCItLVR5cG9ncmFwaHktdGV4dEFsaWduXCI6IGNcbiAgICAgIH0sXG4gICAgICAuLi5mLnN0eWxlXG4gICAgfVxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChidC5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCICAgIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiAgICAg4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogU2V0IHRoZSB0ZXh0LWFsaWduIG9uIHRoZSBjb21wb25lbnQuXG4gICAqIEBkZWZhdWx0ICdpbmhlcml0J1xuICAgKi9cbiAgYWxpZ246IGEub25lT2YoW1wiY2VudGVyXCIsIFwiaW5oZXJpdFwiLCBcImp1c3RpZnlcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0pLFxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBhLm5vZGUsXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjbGFzc2VzOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC5cbiAgICogSXQgc3VwcG9ydHMgYm90aCBkZWZhdWx0IGFuZCBjdXN0b20gdGhlbWUgY29sb3JzLCB3aGljaCBjYW4gYmUgYWRkZWQgYXMgc2hvd24gaW4gdGhlXG4gICAqIFtwYWxldHRlIGN1c3RvbWl6YXRpb24gZ3VpZGVdKGh0dHBzOi8vbXVpLmNvbS9tYXRlcmlhbC11aS9jdXN0b21pemF0aW9uL3BhbGV0dGUvI2N1c3RvbS1jb2xvcnMpLlxuICAgKi9cbiAgY29sb3I6IGEub25lT2ZUeXBlKFthLm9uZU9mKFtcInByaW1hcnlcIiwgXCJzZWNvbmRhcnlcIiwgXCJzdWNjZXNzXCIsIFwiZXJyb3JcIiwgXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcInRleHRQcmltYXJ5XCIsIFwidGV4dFNlY29uZGFyeVwiLCBcInRleHREaXNhYmxlZFwiXSksIGEuc3RyaW5nXSksXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IGEuZWxlbWVudFR5cGUsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB0ZXh0IHdpbGwgaGF2ZSBhIGJvdHRvbSBtYXJnaW4uXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBndXR0ZXJCb3R0b206IGEuYm9vbCxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHRleHQgd2lsbCBub3Qgd3JhcCwgYnV0IGluc3RlYWQgd2lsbCB0cnVuY2F0ZSB3aXRoIGEgdGV4dCBvdmVyZmxvdyBlbGxpcHNpcy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRleHQgb3ZlcmZsb3cgY2FuIG9ubHkgaGFwcGVuIHdpdGggYmxvY2sgb3IgaW5saW5lLWJsb2NrIGxldmVsIGVsZW1lbnRzXG4gICAqICh0aGUgZWxlbWVudCBuZWVkcyB0byBoYXZlIGEgd2lkdGggaW4gb3JkZXIgdG8gb3ZlcmZsb3cpLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgbm9XcmFwOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBlbGVtZW50IHdpbGwgYmUgYSBwYXJhZ3JhcGggZWxlbWVudC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgY29tcG9uZW50YCBwcm9wIGluc3RlYWQuIFRoaXMgcHJvcCB3aWxsIGJlIHJlbW92ZWQgaW4gdjcuIFNlZSBbTWlncmF0aW5nIGZyb20gZGVwcmVjYXRlZCBBUElzXShodHRwczovL211aS5jb20vbWF0ZXJpYWwtdWkvbWlncmF0aW9uL21pZ3JhdGluZy1mcm9tLWRlcHJlY2F0ZWQtYXBpcy8pIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBwYXJhZ3JhcGg6IGEuYm9vbCxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0eWxlOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gcHJvcCB0aGF0IGFsbG93cyBkZWZpbmluZyBzeXN0ZW0gb3ZlcnJpZGVzIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgc3g6IGEub25lT2ZUeXBlKFthLmFycmF5T2YoYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3QsIGEuYm9vbF0pKSwgYS5mdW5jLCBhLm9iamVjdF0pLFxuICAvKipcbiAgICogQXBwbGllcyB0aGUgdGhlbWUgdHlwb2dyYXBoeSBzdHlsZXMuXG4gICAqIEBkZWZhdWx0ICdib2R5MSdcbiAgICovXG4gIHZhcmlhbnQ6IGEub25lT2ZUeXBlKFthLm9uZU9mKFtcImJvZHkxXCIsIFwiYm9keTJcIiwgXCJidXR0b25cIiwgXCJjYXB0aW9uXCIsIFwiaDFcIiwgXCJoMlwiLCBcImgzXCIsIFwiaDRcIiwgXCJoNVwiLCBcImg2XCIsIFwiaW5oZXJpdFwiLCBcIm92ZXJsaW5lXCIsIFwic3VidGl0bGUxXCIsIFwic3VidGl0bGUyXCJdKSwgYS5zdHJpbmddKSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgbWFwcyB0aGUgdmFyaWFudCBwcm9wIHRvIGEgcmFuZ2Ugb2YgZGlmZmVyZW50IEhUTUwgZWxlbWVudCB0eXBlcy5cbiAgICogRm9yIGluc3RhbmNlLCBzdWJ0aXRsZTEgdG8gYDxoNj5gLlxuICAgKiBJZiB5b3Ugd2lzaCB0byBjaGFuZ2UgdGhhdCBtYXBwaW5nLCB5b3UgY2FuIHByb3ZpZGUgeW91ciBvd24uXG4gICAqIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gdXNlIHRoZSBgY29tcG9uZW50YCBwcm9wLlxuICAgKiBAZGVmYXVsdCB7XG4gICAqICAgaDE6ICdoMScsXG4gICAqICAgaDI6ICdoMicsXG4gICAqICAgaDM6ICdoMycsXG4gICAqICAgaDQ6ICdoNCcsXG4gICAqICAgaDU6ICdoNScsXG4gICAqICAgaDY6ICdoNicsXG4gICAqICAgc3VidGl0bGUxOiAnaDYnLFxuICAgKiAgIHN1YnRpdGxlMjogJ2g2JyxcbiAgICogICBib2R5MTogJ3AnLFxuICAgKiAgIGJvZHkyOiAncCcsXG4gICAqICAgaW5oZXJpdDogJ3AnLFxuICAgKiB9XG4gICAqL1xuICB2YXJpYW50TWFwcGluZzogYS5vYmplY3Rcbn0pO1xudmFyIEtlID0gXCJ0b3BcIiwgc3QgPSBcImJvdHRvbVwiLCBjdCA9IFwicmlnaHRcIiwgWGUgPSBcImxlZnRcIiwgcW8gPSBcImF1dG9cIiwgQnIgPSBbS2UsIHN0LCBjdCwgWGVdLCBlciA9IFwic3RhcnRcIiwgUHIgPSBcImVuZFwiLCBEZCA9IFwiY2xpcHBpbmdQYXJlbnRzXCIsIFRzID0gXCJ2aWV3cG9ydFwiLCBwciA9IFwicG9wcGVyXCIsIExkID0gXCJyZWZlcmVuY2VcIiwgbGEgPSAvKiBAX19QVVJFX18gKi8gQnIucmVkdWNlKGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIGUuY29uY2F0KFt0ICsgXCItXCIgKyBlciwgdCArIFwiLVwiICsgUHJdKTtcbn0sIFtdKSwgd3MgPSAvKiBAX19QVVJFX18gKi8gW10uY29uY2F0KEJyLCBbcW9dKS5yZWR1Y2UoZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gZS5jb25jYXQoW3QsIHQgKyBcIi1cIiArIGVyLCB0ICsgXCItXCIgKyBQcl0pO1xufSwgW10pLCBCZCA9IFwiYmVmb3JlUmVhZFwiLCBWZCA9IFwicmVhZFwiLCBGZCA9IFwiYWZ0ZXJSZWFkXCIsIHpkID0gXCJiZWZvcmVNYWluXCIsIFdkID0gXCJtYWluXCIsIFVkID0gXCJhZnRlck1haW5cIiwgWWQgPSBcImJlZm9yZVdyaXRlXCIsIEhkID0gXCJ3cml0ZVwiLCBxZCA9IFwiYWZ0ZXJXcml0ZVwiLCBHZCA9IFtCZCwgVmQsIEZkLCB6ZCwgV2QsIFVkLCBZZCwgSGQsIHFkXTtcbmZ1bmN0aW9uIFN0KGUpIHtcbiAgcmV0dXJuIGUgPyAoZS5ub2RlTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHJ0KGUpIHtcbiAgaWYgKGUgPT0gbnVsbClcbiAgICByZXR1cm4gd2luZG93O1xuICBpZiAoZS50b1N0cmluZygpICE9PSBcIltvYmplY3QgV2luZG93XVwiKSB7XG4gICAgdmFyIHQgPSBlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIHQgJiYgdC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB6dChlKSB7XG4gIHZhciB0ID0gcnQoZSkuRWxlbWVudDtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiB0IHx8IGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuZnVuY3Rpb24gaXQoZSkge1xuICB2YXIgdCA9IHJ0KGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gZSBpbnN0YW5jZW9mIHQgfHwgZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gR28oZSkge1xuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPiBcInVcIilcbiAgICByZXR1cm4gITE7XG4gIHZhciB0ID0gcnQoZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiB0IHx8IGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuZnVuY3Rpb24gS2QoZSkge1xuICB2YXIgdCA9IGUuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHQuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgIHZhciBuID0gdC5zdHlsZXNbcl0gfHwge30sIG8gPSB0LmF0dHJpYnV0ZXNbcl0gfHwge30sIGkgPSB0LmVsZW1lbnRzW3JdO1xuICAgICFpdChpKSB8fCAhU3QoaSkgfHwgKE9iamVjdC5hc3NpZ24oaS5zdHlsZSwgbiksIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgdmFyIGMgPSBvW3NdO1xuICAgICAgYyA9PT0gITEgPyBpLnJlbW92ZUF0dHJpYnV0ZShzKSA6IGkuc2V0QXR0cmlidXRlKHMsIGMgPT09ICEwID8gXCJcIiA6IGMpO1xuICAgIH0pKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBYZChlKSB7XG4gIHZhciB0ID0gZS5zdGF0ZSwgciA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiB0Lm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiBcIjBcIixcbiAgICAgIHRvcDogXCIwXCIsXG4gICAgICBtYXJnaW46IFwiMFwiXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgci5wb3BwZXIpLCB0LnN0eWxlcyA9IHIsIHQuZWxlbWVudHMuYXJyb3cgJiYgT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLmFycm93LnN0eWxlLCByLmFycm93KSwgZnVuY3Rpb24oKSB7XG4gICAgT2JqZWN0LmtleXModC5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgbyA9IHQuZWxlbWVudHNbbl0sIGkgPSB0LmF0dHJpYnV0ZXNbbl0gfHwge30sIHMgPSBPYmplY3Qua2V5cyh0LnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuKSA/IHQuc3R5bGVzW25dIDogcltuXSksIGMgPSBzLnJlZHVjZShmdW5jdGlvbihsLCB1KSB7XG4gICAgICAgIHJldHVybiBsW3VdID0gXCJcIiwgbDtcbiAgICAgIH0sIHt9KTtcbiAgICAgICFpdChvKSB8fCAhU3QobykgfHwgKE9iamVjdC5hc3NpZ24oby5zdHlsZSwgYyksIE9iamVjdC5rZXlzKGkpLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgICAgICBvLnJlbW92ZUF0dHJpYnV0ZShsKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfTtcbn1cbmNvbnN0IEpkID0ge1xuICBuYW1lOiBcImFwcGx5U3R5bGVzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJ3cml0ZVwiLFxuICBmbjogS2QsXG4gIGVmZmVjdDogWGQsXG4gIHJlcXVpcmVzOiBbXCJjb21wdXRlU3R5bGVzXCJdXG59O1xuZnVuY3Rpb24geHQoZSkge1xuICByZXR1cm4gZS5zcGxpdChcIi1cIilbMF07XG59XG52YXIgVnQgPSBNYXRoLm1heCwgRW4gPSBNYXRoLm1pbiwgdHIgPSBNYXRoLnJvdW5kO1xuZnVuY3Rpb24gYm8oKSB7XG4gIHZhciBlID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIHJldHVybiBlICE9IG51bGwgJiYgZS5icmFuZHMgJiYgQXJyYXkuaXNBcnJheShlLmJyYW5kcykgPyBlLmJyYW5kcy5tYXAoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LmJyYW5kICsgXCIvXCIgKyB0LnZlcnNpb247XG4gIH0pLmpvaW4oXCIgXCIpIDogbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cbmZ1bmN0aW9uIE9zKCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoYm8oKSk7XG59XG5mdW5jdGlvbiBycihlLCB0LCByKSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9ICExKSwgciA9PT0gdm9pZCAwICYmIChyID0gITEpO1xuICB2YXIgbiA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG8gPSAxLCBpID0gMTtcbiAgdCAmJiBpdChlKSAmJiAobyA9IGUub2Zmc2V0V2lkdGggPiAwICYmIHRyKG4ud2lkdGgpIC8gZS5vZmZzZXRXaWR0aCB8fCAxLCBpID0gZS5vZmZzZXRIZWlnaHQgPiAwICYmIHRyKG4uaGVpZ2h0KSAvIGUub2Zmc2V0SGVpZ2h0IHx8IDEpO1xuICB2YXIgcyA9IHp0KGUpID8gcnQoZSkgOiB3aW5kb3csIGMgPSBzLnZpc3VhbFZpZXdwb3J0LCBsID0gIU9zKCkgJiYgciwgdSA9IChuLmxlZnQgKyAobCAmJiBjID8gYy5vZmZzZXRMZWZ0IDogMCkpIC8gbywgcCA9IChuLnRvcCArIChsICYmIGMgPyBjLm9mZnNldFRvcCA6IDApKSAvIGksIG0gPSBuLndpZHRoIC8gbywgZyA9IG4uaGVpZ2h0IC8gaTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogbSxcbiAgICBoZWlnaHQ6IGcsXG4gICAgdG9wOiBwLFxuICAgIHJpZ2h0OiB1ICsgbSxcbiAgICBib3R0b206IHAgKyBnLFxuICAgIGxlZnQ6IHUsXG4gICAgeDogdSxcbiAgICB5OiBwXG4gIH07XG59XG5mdW5jdGlvbiBLbyhlKSB7XG4gIHZhciB0ID0gcnIoZSksIHIgPSBlLm9mZnNldFdpZHRoLCBuID0gZS5vZmZzZXRIZWlnaHQ7XG4gIHJldHVybiBNYXRoLmFicyh0LndpZHRoIC0gcikgPD0gMSAmJiAociA9IHQud2lkdGgpLCBNYXRoLmFicyh0LmhlaWdodCAtIG4pIDw9IDEgJiYgKG4gPSB0LmhlaWdodCksIHtcbiAgICB4OiBlLm9mZnNldExlZnQsXG4gICAgeTogZS5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHIsXG4gICAgaGVpZ2h0OiBuXG4gIH07XG59XG5mdW5jdGlvbiBScyhlLCB0KSB7XG4gIHZhciByID0gdC5nZXRSb290Tm9kZSAmJiB0LmdldFJvb3ROb2RlKCk7XG4gIGlmIChlLmNvbnRhaW5zKHQpKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKHIgJiYgR28ocikpIHtcbiAgICB2YXIgbiA9IHQ7XG4gICAgZG8ge1xuICAgICAgaWYgKG4gJiYgZS5pc1NhbWVOb2RlKG4pKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICB9IHdoaWxlIChuKTtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBSdChlKSB7XG4gIHJldHVybiBydChlKS5nZXRDb21wdXRlZFN0eWxlKGUpO1xufVxuZnVuY3Rpb24gUWQoZSkge1xuICByZXR1cm4gW1widGFibGVcIiwgXCJ0ZFwiLCBcInRoXCJdLmluZGV4T2YoU3QoZSkpID49IDA7XG59XG5mdW5jdGlvbiBJdChlKSB7XG4gIHJldHVybiAoKHp0KGUpID8gZS5vd25lckRvY3VtZW50IDogKFxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGUuZG9jdW1lbnRcbiAgKSkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiB6bihlKSB7XG4gIHJldHVybiBTdChlKSA9PT0gXCJodG1sXCIgPyBlIDogKFxuICAgIC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGUuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZS5wYXJlbnROb2RlIHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgKEdvKGUpID8gZS5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBJdChlKVxuICApO1xufVxuZnVuY3Rpb24gdWEoZSkge1xuICByZXR1cm4gIWl0KGUpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIFJ0KGUpLnBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBudWxsIDogZS5vZmZzZXRQYXJlbnQ7XG59XG5mdW5jdGlvbiBaZChlKSB7XG4gIHZhciB0ID0gL2ZpcmVmb3gvaS50ZXN0KGJvKCkpLCByID0gL1RyaWRlbnQvaS50ZXN0KGJvKCkpO1xuICBpZiAociAmJiBpdChlKSkge1xuICAgIHZhciBuID0gUnQoZSk7XG4gICAgaWYgKG4ucG9zaXRpb24gPT09IFwiZml4ZWRcIilcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBvID0gem4oZSk7XG4gIGZvciAoR28obykgJiYgKG8gPSBvLmhvc3QpOyBpdChvKSAmJiBbXCJodG1sXCIsIFwiYm9keVwiXS5pbmRleE9mKFN0KG8pKSA8IDA7ICkge1xuICAgIHZhciBpID0gUnQobyk7XG4gICAgaWYgKGkudHJhbnNmb3JtICE9PSBcIm5vbmVcIiB8fCBpLnBlcnNwZWN0aXZlICE9PSBcIm5vbmVcIiB8fCBpLmNvbnRhaW4gPT09IFwicGFpbnRcIiB8fCBbXCJ0cmFuc2Zvcm1cIiwgXCJwZXJzcGVjdGl2ZVwiXS5pbmRleE9mKGkud2lsbENoYW5nZSkgIT09IC0xIHx8IHQgJiYgaS53aWxsQ2hhbmdlID09PSBcImZpbHRlclwiIHx8IHQgJiYgaS5maWx0ZXIgJiYgaS5maWx0ZXIgIT09IFwibm9uZVwiKVxuICAgICAgcmV0dXJuIG87XG4gICAgbyA9IG8ucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIFZyKGUpIHtcbiAgZm9yICh2YXIgdCA9IHJ0KGUpLCByID0gdWEoZSk7IHIgJiYgUWQocikgJiYgUnQocikucG9zaXRpb24gPT09IFwic3RhdGljXCI7IClcbiAgICByID0gdWEocik7XG4gIHJldHVybiByICYmIChTdChyKSA9PT0gXCJodG1sXCIgfHwgU3QocikgPT09IFwiYm9keVwiICYmIFJ0KHIpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiKSA/IHQgOiByIHx8IFpkKGUpIHx8IHQ7XG59XG5mdW5jdGlvbiBYbyhlKSB7XG4gIHJldHVybiBbXCJ0b3BcIiwgXCJib3R0b21cIl0uaW5kZXhPZihlKSA+PSAwID8gXCJ4XCIgOiBcInlcIjtcbn1cbmZ1bmN0aW9uIHhyKGUsIHQsIHIpIHtcbiAgcmV0dXJuIFZ0KGUsIEVuKHQsIHIpKTtcbn1cbmZ1bmN0aW9uIGVwKGUsIHQsIHIpIHtcbiAgdmFyIG4gPSB4cihlLCB0LCByKTtcbiAgcmV0dXJuIG4gPiByID8gciA6IG47XG59XG5mdW5jdGlvbiAkcygpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIFBzKGUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sICRzKCksIGUpO1xufVxuZnVuY3Rpb24ga3MoZSwgdCkge1xuICByZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24ociwgbikge1xuICAgIHJldHVybiByW25dID0gZSwgcjtcbiAgfSwge30pO1xufVxudmFyIHRwID0gZnVuY3Rpb24odCwgcikge1xuICByZXR1cm4gdCA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQoT2JqZWN0LmFzc2lnbih7fSwgci5yZWN0cywge1xuICAgIHBsYWNlbWVudDogci5wbGFjZW1lbnRcbiAgfSkpIDogdCwgUHModHlwZW9mIHQgIT0gXCJudW1iZXJcIiA/IHQgOiBrcyh0LCBCcikpO1xufTtcbmZ1bmN0aW9uIHJwKGUpIHtcbiAgdmFyIHQsIHIgPSBlLnN0YXRlLCBuID0gZS5uYW1lLCBvID0gZS5vcHRpb25zLCBpID0gci5lbGVtZW50cy5hcnJvdywgcyA9IHIubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLCBjID0geHQoci5wbGFjZW1lbnQpLCBsID0gWG8oYyksIHUgPSBbWGUsIGN0XS5pbmRleE9mKGMpID49IDAsIHAgPSB1ID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgaWYgKCEoIWkgfHwgIXMpKSB7XG4gICAgdmFyIG0gPSB0cChvLnBhZGRpbmcsIHIpLCBnID0gS28oaSksIHggPSBsID09PSBcInlcIiA/IEtlIDogWGUsIHkgPSBsID09PSBcInlcIiA/IHN0IDogY3QsIGYgPSByLnJlY3RzLnJlZmVyZW5jZVtwXSArIHIucmVjdHMucmVmZXJlbmNlW2xdIC0gc1tsXSAtIHIucmVjdHMucG9wcGVyW3BdLCBTID0gc1tsXSAtIHIucmVjdHMucmVmZXJlbmNlW2xdLCBFID0gVnIoaSksIFAgPSBFID8gbCA9PT0gXCJ5XCIgPyBFLmNsaWVudEhlaWdodCB8fCAwIDogRS5jbGllbnRXaWR0aCB8fCAwIDogMCwgVCA9IGYgLyAyIC0gUyAvIDIsIGIgPSBtW3hdLCBoID0gUCAtIGdbcF0gLSBtW3ldLCB3ID0gUCAvIDIgLSBnW3BdIC8gMiArIFQsIGsgPSB4cihiLCB3LCBoKSwgTCA9IGw7XG4gICAgci5tb2RpZmllcnNEYXRhW25dID0gKHQgPSB7fSwgdFtMXSA9IGssIHQuY2VudGVyT2Zmc2V0ID0gayAtIHcsIHQpO1xuICB9XG59XG5mdW5jdGlvbiBucChlKSB7XG4gIHZhciB0ID0gZS5zdGF0ZSwgciA9IGUub3B0aW9ucywgbiA9IHIuZWxlbWVudCwgbyA9IG4gPT09IHZvaWQgMCA/IFwiW2RhdGEtcG9wcGVyLWFycm93XVwiIDogbjtcbiAgbyAhPSBudWxsICYmICh0eXBlb2YgbyA9PSBcInN0cmluZ1wiICYmIChvID0gdC5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihvKSwgIW8pIHx8IFJzKHQuZWxlbWVudHMucG9wcGVyLCBvKSAmJiAodC5lbGVtZW50cy5hcnJvdyA9IG8pKTtcbn1cbmNvbnN0IG9wID0ge1xuICBuYW1lOiBcImFycm93XCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIGZuOiBycCxcbiAgZWZmZWN0OiBucCxcbiAgcmVxdWlyZXM6IFtcInBvcHBlck9mZnNldHNcIl0sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcInByZXZlbnRPdmVyZmxvd1wiXVxufTtcbmZ1bmN0aW9uIG5yKGUpIHtcbiAgcmV0dXJuIGUuc3BsaXQoXCItXCIpWzFdO1xufVxudmFyIGlwID0ge1xuICB0b3A6IFwiYXV0b1wiLFxuICByaWdodDogXCJhdXRvXCIsXG4gIGJvdHRvbTogXCJhdXRvXCIsXG4gIGxlZnQ6IFwiYXV0b1wiXG59O1xuZnVuY3Rpb24gYXAoZSwgdCkge1xuICB2YXIgciA9IGUueCwgbiA9IGUueSwgbyA9IHQuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHRyKHIgKiBvKSAvIG8gfHwgMCxcbiAgICB5OiB0cihuICogbykgLyBvIHx8IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGZhKGUpIHtcbiAgdmFyIHQsIHIgPSBlLnBvcHBlciwgbiA9IGUucG9wcGVyUmVjdCwgbyA9IGUucGxhY2VtZW50LCBpID0gZS52YXJpYXRpb24sIHMgPSBlLm9mZnNldHMsIGMgPSBlLnBvc2l0aW9uLCBsID0gZS5ncHVBY2NlbGVyYXRpb24sIHUgPSBlLmFkYXB0aXZlLCBwID0gZS5yb3VuZE9mZnNldHMsIG0gPSBlLmlzRml4ZWQsIGcgPSBzLngsIHggPSBnID09PSB2b2lkIDAgPyAwIDogZywgeSA9IHMueSwgZiA9IHkgPT09IHZvaWQgMCA/IDAgOiB5LCBTID0gdHlwZW9mIHAgPT0gXCJmdW5jdGlvblwiID8gcCh7XG4gICAgeCxcbiAgICB5OiBmXG4gIH0pIDoge1xuICAgIHgsXG4gICAgeTogZlxuICB9O1xuICB4ID0gUy54LCBmID0gUy55O1xuICB2YXIgRSA9IHMuaGFzT3duUHJvcGVydHkoXCJ4XCIpLCBQID0gcy5oYXNPd25Qcm9wZXJ0eShcInlcIiksIFQgPSBYZSwgYiA9IEtlLCBoID0gd2luZG93O1xuICBpZiAodSkge1xuICAgIHZhciB3ID0gVnIociksIGsgPSBcImNsaWVudEhlaWdodFwiLCBMID0gXCJjbGllbnRXaWR0aFwiO1xuICAgIGlmICh3ID09PSBydChyKSAmJiAodyA9IEl0KHIpLCBSdCh3KS5wb3NpdGlvbiAhPT0gXCJzdGF0aWNcIiAmJiBjID09PSBcImFic29sdXRlXCIgJiYgKGsgPSBcInNjcm9sbEhlaWdodFwiLCBMID0gXCJzY3JvbGxXaWR0aFwiKSksIHcgPSB3LCBvID09PSBLZSB8fCAobyA9PT0gWGUgfHwgbyA9PT0gY3QpICYmIGkgPT09IFByKSB7XG4gICAgICBiID0gc3Q7XG4gICAgICB2YXIgQiA9IG0gJiYgdyA9PT0gaCAmJiBoLnZpc3VhbFZpZXdwb3J0ID8gaC52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAoXG4gICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICB3W2tdXG4gICAgICApO1xuICAgICAgZiAtPSBCIC0gbi5oZWlnaHQsIGYgKj0gbCA/IDEgOiAtMTtcbiAgICB9XG4gICAgaWYgKG8gPT09IFhlIHx8IChvID09PSBLZSB8fCBvID09PSBzdCkgJiYgaSA9PT0gUHIpIHtcbiAgICAgIFQgPSBjdDtcbiAgICAgIHZhciBkID0gbSAmJiB3ID09PSBoICYmIGgudmlzdWFsVmlld3BvcnQgPyBoLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogKFxuICAgICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgd1tMXVxuICAgICAgKTtcbiAgICAgIHggLT0gZCAtIG4ud2lkdGgsIHggKj0gbCA/IDEgOiAtMTtcbiAgICB9XG4gIH1cbiAgdmFyIEEgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogY1xuICB9LCB1ICYmIGlwKSwgRCA9IHAgPT09ICEwID8gYXAoe1xuICAgIHgsXG4gICAgeTogZlxuICB9LCBydChyKSkgOiB7XG4gICAgeCxcbiAgICB5OiBmXG4gIH07XG4gIGlmICh4ID0gRC54LCBmID0gRC55LCBsKSB7XG4gICAgdmFyIGo7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIEEsIChqID0ge30sIGpbYl0gPSBQID8gXCIwXCIgOiBcIlwiLCBqW1RdID0gRSA/IFwiMFwiIDogXCJcIiwgai50cmFuc2Zvcm0gPSAoaC5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIGYgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIGYgKyBcInB4LCAwKVwiLCBqKSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIEEsICh0ID0ge30sIHRbYl0gPSBQID8gZiArIFwicHhcIiA6IFwiXCIsIHRbVF0gPSBFID8geCArIFwicHhcIiA6IFwiXCIsIHQudHJhbnNmb3JtID0gXCJcIiwgdCkpO1xufVxuZnVuY3Rpb24gc3AoZSkge1xuICB2YXIgdCA9IGUuc3RhdGUsIHIgPSBlLm9wdGlvbnMsIG4gPSByLmdwdUFjY2VsZXJhdGlvbiwgbyA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgaSA9IHIuYWRhcHRpdmUsIHMgPSBpID09PSB2b2lkIDAgPyAhMCA6IGksIGMgPSByLnJvdW5kT2Zmc2V0cywgbCA9IGMgPT09IHZvaWQgMCA/ICEwIDogYywgdSA9IHtcbiAgICBwbGFjZW1lbnQ6IHh0KHQucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IG5yKHQucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHQuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHQucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogbyxcbiAgICBpc0ZpeGVkOiB0Lm9wdGlvbnMuc3RyYXRlZ3kgPT09IFwiZml4ZWRcIlxuICB9O1xuICB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsICYmICh0LnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0LnN0eWxlcy5wb3BwZXIsIGZhKE9iamVjdC5hc3NpZ24oe30sIHUsIHtcbiAgICBvZmZzZXRzOiB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICBwb3NpdGlvbjogdC5vcHRpb25zLnN0cmF0ZWd5LFxuICAgIGFkYXB0aXZlOiBzLFxuICAgIHJvdW5kT2Zmc2V0czogbFxuICB9KSkpKSwgdC5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwgJiYgKHQuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgdC5zdHlsZXMuYXJyb3csIGZhKE9iamVjdC5hc3NpZ24oe30sIHUsIHtcbiAgICBvZmZzZXRzOiB0Lm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICBhZGFwdGl2ZTogITEsXG4gICAgcm91bmRPZmZzZXRzOiBsXG4gIH0pKSkpLCB0LmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgIFwiZGF0YS1wb3BwZXItcGxhY2VtZW50XCI6IHQucGxhY2VtZW50XG4gIH0pO1xufVxuY29uc3QgY3AgPSB7XG4gIG5hbWU6IFwiY29tcHV0ZVN0eWxlc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwiYmVmb3JlV3JpdGVcIixcbiAgZm46IHNwLFxuICBkYXRhOiB7fVxufTtcbnZhciBaciA9IHtcbiAgcGFzc2l2ZTogITBcbn07XG5mdW5jdGlvbiBscChlKSB7XG4gIHZhciB0ID0gZS5zdGF0ZSwgciA9IGUuaW5zdGFuY2UsIG4gPSBlLm9wdGlvbnMsIG8gPSBuLnNjcm9sbCwgaSA9IG8gPT09IHZvaWQgMCA/ICEwIDogbywgcyA9IG4ucmVzaXplLCBjID0gcyA9PT0gdm9pZCAwID8gITAgOiBzLCBsID0gcnQodC5lbGVtZW50cy5wb3BwZXIpLCB1ID0gW10uY29uY2F0KHQuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHQuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuICByZXR1cm4gaSAmJiB1LmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgIHAuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCByLnVwZGF0ZSwgWnIpO1xuICB9KSwgYyAmJiBsLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgci51cGRhdGUsIFpyKSwgZnVuY3Rpb24oKSB7XG4gICAgaSAmJiB1LmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgcC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHIudXBkYXRlLCBacik7XG4gICAgfSksIGMgJiYgbC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHIudXBkYXRlLCBacik7XG4gIH07XG59XG5jb25zdCB1cCA9IHtcbiAgbmFtZTogXCJldmVudExpc3RlbmVyc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwid3JpdGVcIixcbiAgZm46IGZ1bmN0aW9uKCkge1xuICB9LFxuICBlZmZlY3Q6IGxwLFxuICBkYXRhOiB7fVxufTtcbnZhciBmcCA9IHtcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCIsXG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiXG59O1xuZnVuY3Rpb24gdW4oZSkge1xuICByZXR1cm4gZS5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBmcFt0XTtcbiAgfSk7XG59XG52YXIgZHAgPSB7XG4gIHN0YXJ0OiBcImVuZFwiLFxuICBlbmQ6IFwic3RhcnRcIlxufTtcbmZ1bmN0aW9uIGRhKGUpIHtcbiAgcmV0dXJuIGUucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gZHBbdF07XG4gIH0pO1xufVxuZnVuY3Rpb24gSm8oZSkge1xuICB2YXIgdCA9IHJ0KGUpLCByID0gdC5wYWdlWE9mZnNldCwgbiA9IHQucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogcixcbiAgICBzY3JvbGxUb3A6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIFFvKGUpIHtcbiAgcmV0dXJuIHJyKEl0KGUpKS5sZWZ0ICsgSm8oZSkuc2Nyb2xsTGVmdDtcbn1cbmZ1bmN0aW9uIHBwKGUsIHQpIHtcbiAgdmFyIHIgPSBydChlKSwgbiA9IEl0KGUpLCBvID0gci52aXN1YWxWaWV3cG9ydCwgaSA9IG4uY2xpZW50V2lkdGgsIHMgPSBuLmNsaWVudEhlaWdodCwgYyA9IDAsIGwgPSAwO1xuICBpZiAobykge1xuICAgIGkgPSBvLndpZHRoLCBzID0gby5oZWlnaHQ7XG4gICAgdmFyIHUgPSBPcygpO1xuICAgICh1IHx8ICF1ICYmIHQgPT09IFwiZml4ZWRcIikgJiYgKGMgPSBvLm9mZnNldExlZnQsIGwgPSBvLm9mZnNldFRvcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogaSxcbiAgICBoZWlnaHQ6IHMsXG4gICAgeDogYyArIFFvKGUpLFxuICAgIHk6IGxcbiAgfTtcbn1cbmZ1bmN0aW9uIG1wKGUpIHtcbiAgdmFyIHQsIHIgPSBJdChlKSwgbiA9IEpvKGUpLCBvID0gKHQgPSBlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiB0LmJvZHksIGkgPSBWdChyLnNjcm9sbFdpZHRoLCByLmNsaWVudFdpZHRoLCBvID8gby5zY3JvbGxXaWR0aCA6IDAsIG8gPyBvLmNsaWVudFdpZHRoIDogMCksIHMgPSBWdChyLnNjcm9sbEhlaWdodCwgci5jbGllbnRIZWlnaHQsIG8gPyBvLnNjcm9sbEhlaWdodCA6IDAsIG8gPyBvLmNsaWVudEhlaWdodCA6IDApLCBjID0gLW4uc2Nyb2xsTGVmdCArIFFvKGUpLCBsID0gLW4uc2Nyb2xsVG9wO1xuICByZXR1cm4gUnQobyB8fCByKS5kaXJlY3Rpb24gPT09IFwicnRsXCIgJiYgKGMgKz0gVnQoci5jbGllbnRXaWR0aCwgbyA/IG8uY2xpZW50V2lkdGggOiAwKSAtIGkpLCB7XG4gICAgd2lkdGg6IGksXG4gICAgaGVpZ2h0OiBzLFxuICAgIHg6IGMsXG4gICAgeTogbFxuICB9O1xufVxuZnVuY3Rpb24gWm8oZSkge1xuICB2YXIgdCA9IFJ0KGUpLCByID0gdC5vdmVyZmxvdywgbiA9IHQub3ZlcmZsb3dYLCBvID0gdC5vdmVyZmxvd1k7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3QociArIG8gKyBuKTtcbn1cbmZ1bmN0aW9uIEFzKGUpIHtcbiAgcmV0dXJuIFtcImh0bWxcIiwgXCJib2R5XCIsIFwiI2RvY3VtZW50XCJdLmluZGV4T2YoU3QoZSkpID49IDAgPyBlLm93bmVyRG9jdW1lbnQuYm9keSA6IGl0KGUpICYmIFpvKGUpID8gZSA6IEFzKHpuKGUpKTtcbn1cbmZ1bmN0aW9uIFNyKGUsIHQpIHtcbiAgdmFyIHI7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IFtdKTtcbiAgdmFyIG4gPSBBcyhlKSwgbyA9IG4gPT09ICgociA9IGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuYm9keSksIGkgPSBydChuKSwgcyA9IG8gPyBbaV0uY29uY2F0KGkudmlzdWFsVmlld3BvcnQgfHwgW10sIFpvKG4pID8gbiA6IFtdKSA6IG4sIGMgPSB0LmNvbmNhdChzKTtcbiAgcmV0dXJuIG8gPyBjIDogKFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICAgIGMuY29uY2F0KFNyKHpuKHMpKSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHZvKGUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGUsIHtcbiAgICBsZWZ0OiBlLngsXG4gICAgdG9wOiBlLnksXG4gICAgcmlnaHQ6IGUueCArIGUud2lkdGgsXG4gICAgYm90dG9tOiBlLnkgKyBlLmhlaWdodFxuICB9KTtcbn1cbmZ1bmN0aW9uIGhwKGUsIHQpIHtcbiAgdmFyIHIgPSBycihlLCAhMSwgdCA9PT0gXCJmaXhlZFwiKTtcbiAgcmV0dXJuIHIudG9wID0gci50b3AgKyBlLmNsaWVudFRvcCwgci5sZWZ0ID0gci5sZWZ0ICsgZS5jbGllbnRMZWZ0LCByLmJvdHRvbSA9IHIudG9wICsgZS5jbGllbnRIZWlnaHQsIHIucmlnaHQgPSByLmxlZnQgKyBlLmNsaWVudFdpZHRoLCByLndpZHRoID0gZS5jbGllbnRXaWR0aCwgci5oZWlnaHQgPSBlLmNsaWVudEhlaWdodCwgci54ID0gci5sZWZ0LCByLnkgPSByLnRvcCwgcjtcbn1cbmZ1bmN0aW9uIHBhKGUsIHQsIHIpIHtcbiAgcmV0dXJuIHQgPT09IFRzID8gdm8ocHAoZSwgcikpIDogenQodCkgPyBocCh0LCByKSA6IHZvKG1wKEl0KGUpKSk7XG59XG5mdW5jdGlvbiBncChlKSB7XG4gIHZhciB0ID0gU3Ioem4oZSkpLCByID0gW1wiYWJzb2x1dGVcIiwgXCJmaXhlZFwiXS5pbmRleE9mKFJ0KGUpLnBvc2l0aW9uKSA+PSAwLCBuID0gciAmJiBpdChlKSA/IFZyKGUpIDogZTtcbiAgcmV0dXJuIHp0KG4pID8gdC5maWx0ZXIoZnVuY3Rpb24obykge1xuICAgIHJldHVybiB6dChvKSAmJiBScyhvLCBuKSAmJiBTdChvKSAhPT0gXCJib2R5XCI7XG4gIH0pIDogW107XG59XG5mdW5jdGlvbiB5cChlLCB0LCByLCBuKSB7XG4gIHZhciBvID0gdCA9PT0gXCJjbGlwcGluZ1BhcmVudHNcIiA/IGdwKGUpIDogW10uY29uY2F0KHQpLCBpID0gW10uY29uY2F0KG8sIFtyXSksIHMgPSBpWzBdLCBjID0gaS5yZWR1Y2UoZnVuY3Rpb24obCwgdSkge1xuICAgIHZhciBwID0gcGEoZSwgdSwgbik7XG4gICAgcmV0dXJuIGwudG9wID0gVnQocC50b3AsIGwudG9wKSwgbC5yaWdodCA9IEVuKHAucmlnaHQsIGwucmlnaHQpLCBsLmJvdHRvbSA9IEVuKHAuYm90dG9tLCBsLmJvdHRvbSksIGwubGVmdCA9IFZ0KHAubGVmdCwgbC5sZWZ0KSwgbDtcbiAgfSwgcGEoZSwgcywgbikpO1xuICByZXR1cm4gYy53aWR0aCA9IGMucmlnaHQgLSBjLmxlZnQsIGMuaGVpZ2h0ID0gYy5ib3R0b20gLSBjLnRvcCwgYy54ID0gYy5sZWZ0LCBjLnkgPSBjLnRvcCwgYztcbn1cbmZ1bmN0aW9uIE5zKGUpIHtcbiAgdmFyIHQgPSBlLnJlZmVyZW5jZSwgciA9IGUuZWxlbWVudCwgbiA9IGUucGxhY2VtZW50LCBvID0gbiA/IHh0KG4pIDogbnVsbCwgaSA9IG4gPyBucihuKSA6IG51bGwsIHMgPSB0LnggKyB0LndpZHRoIC8gMiAtIHIud2lkdGggLyAyLCBjID0gdC55ICsgdC5oZWlnaHQgLyAyIC0gci5oZWlnaHQgLyAyLCBsO1xuICBzd2l0Y2ggKG8pIHtcbiAgICBjYXNlIEtlOlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogcyxcbiAgICAgICAgeTogdC55IC0gci5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIHN0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogcyxcbiAgICAgICAgeTogdC55ICsgdC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIGN0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54ICsgdC53aWR0aCxcbiAgICAgICAgeTogY1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWGU6XG4gICAgICBsID0ge1xuICAgICAgICB4OiB0LnggLSByLndpZHRoLFxuICAgICAgICB5OiBjXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IHQueCxcbiAgICAgICAgeTogdC55XG4gICAgICB9O1xuICB9XG4gIHZhciB1ID0gbyA/IFhvKG8pIDogbnVsbDtcbiAgaWYgKHUgIT0gbnVsbCkge1xuICAgIHZhciBwID0gdSA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICAgIHN3aXRjaCAoaSkge1xuICAgICAgY2FzZSBlcjpcbiAgICAgICAgbFt1XSA9IGxbdV0gLSAodFtwXSAvIDIgLSByW3BdIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQcjpcbiAgICAgICAgbFt1XSA9IGxbdV0gKyAodFtwXSAvIDIgLSByW3BdIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbDtcbn1cbmZ1bmN0aW9uIGtyKGUsIHQpIHtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0ge30pO1xuICB2YXIgciA9IHQsIG4gPSByLnBsYWNlbWVudCwgbyA9IG4gPT09IHZvaWQgMCA/IGUucGxhY2VtZW50IDogbiwgaSA9IHIuc3RyYXRlZ3ksIHMgPSBpID09PSB2b2lkIDAgPyBlLnN0cmF0ZWd5IDogaSwgYyA9IHIuYm91bmRhcnksIGwgPSBjID09PSB2b2lkIDAgPyBEZCA6IGMsIHUgPSByLnJvb3RCb3VuZGFyeSwgcCA9IHUgPT09IHZvaWQgMCA/IFRzIDogdSwgbSA9IHIuZWxlbWVudENvbnRleHQsIGcgPSBtID09PSB2b2lkIDAgPyBwciA6IG0sIHggPSByLmFsdEJvdW5kYXJ5LCB5ID0geCA9PT0gdm9pZCAwID8gITEgOiB4LCBmID0gci5wYWRkaW5nLCBTID0gZiA9PT0gdm9pZCAwID8gMCA6IGYsIEUgPSBQcyh0eXBlb2YgUyAhPSBcIm51bWJlclwiID8gUyA6IGtzKFMsIEJyKSksIFAgPSBnID09PSBwciA/IExkIDogcHIsIFQgPSBlLnJlY3RzLnBvcHBlciwgYiA9IGUuZWxlbWVudHNbeSA/IFAgOiBnXSwgaCA9IHlwKHp0KGIpID8gYiA6IGIuY29udGV4dEVsZW1lbnQgfHwgSXQoZS5lbGVtZW50cy5wb3BwZXIpLCBsLCBwLCBzKSwgdyA9IHJyKGUuZWxlbWVudHMucmVmZXJlbmNlKSwgayA9IE5zKHtcbiAgICByZWZlcmVuY2U6IHcsXG4gICAgZWxlbWVudDogVCxcbiAgICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiLFxuICAgIHBsYWNlbWVudDogb1xuICB9KSwgTCA9IHZvKE9iamVjdC5hc3NpZ24oe30sIFQsIGspKSwgQiA9IGcgPT09IHByID8gTCA6IHcsIGQgPSB7XG4gICAgdG9wOiBoLnRvcCAtIEIudG9wICsgRS50b3AsXG4gICAgYm90dG9tOiBCLmJvdHRvbSAtIGguYm90dG9tICsgRS5ib3R0b20sXG4gICAgbGVmdDogaC5sZWZ0IC0gQi5sZWZ0ICsgRS5sZWZ0LFxuICAgIHJpZ2h0OiBCLnJpZ2h0IC0gaC5yaWdodCArIEUucmlnaHRcbiAgfSwgQSA9IGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7XG4gIGlmIChnID09PSBwciAmJiBBKSB7XG4gICAgdmFyIEQgPSBBW29dO1xuICAgIE9iamVjdC5rZXlzKGQpLmZvckVhY2goZnVuY3Rpb24oaikge1xuICAgICAgdmFyIFcgPSBbY3QsIHN0XS5pbmRleE9mKGopID49IDAgPyAxIDogLTEsIHogPSBbS2UsIHN0XS5pbmRleE9mKGopID49IDAgPyBcInlcIiA6IFwieFwiO1xuICAgICAgZFtqXSArPSBEW3pdICogVztcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZDtcbn1cbmZ1bmN0aW9uIGJwKGUsIHQpIHtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0ge30pO1xuICB2YXIgciA9IHQsIG4gPSByLnBsYWNlbWVudCwgbyA9IHIuYm91bmRhcnksIGkgPSByLnJvb3RCb3VuZGFyeSwgcyA9IHIucGFkZGluZywgYyA9IHIuZmxpcFZhcmlhdGlvbnMsIGwgPSByLmFsbG93ZWRBdXRvUGxhY2VtZW50cywgdSA9IGwgPT09IHZvaWQgMCA/IHdzIDogbCwgcCA9IG5yKG4pLCBtID0gcCA/IGMgPyBsYSA6IGxhLmZpbHRlcihmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIG5yKHkpID09PSBwO1xuICB9KSA6IEJyLCBnID0gbS5maWx0ZXIoZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB1LmluZGV4T2YoeSkgPj0gMDtcbiAgfSk7XG4gIGcubGVuZ3RoID09PSAwICYmIChnID0gbSk7XG4gIHZhciB4ID0gZy5yZWR1Y2UoZnVuY3Rpb24oeSwgZikge1xuICAgIHJldHVybiB5W2ZdID0ga3IoZSwge1xuICAgICAgcGxhY2VtZW50OiBmLFxuICAgICAgYm91bmRhcnk6IG8sXG4gICAgICByb290Qm91bmRhcnk6IGksXG4gICAgICBwYWRkaW5nOiBzXG4gICAgfSlbeHQoZildLCB5O1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyh4KS5zb3J0KGZ1bmN0aW9uKHksIGYpIHtcbiAgICByZXR1cm4geFt5XSAtIHhbZl07XG4gIH0pO1xufVxuZnVuY3Rpb24gdnAoZSkge1xuICBpZiAoeHQoZSkgPT09IHFvKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHQgPSB1bihlKTtcbiAgcmV0dXJuIFtkYShlKSwgdCwgZGEodCldO1xufVxuZnVuY3Rpb24geHAoZSkge1xuICB2YXIgdCA9IGUuc3RhdGUsIHIgPSBlLm9wdGlvbnMsIG4gPSBlLm5hbWU7XG4gIGlmICghdC5tb2RpZmllcnNEYXRhW25dLl9za2lwKSB7XG4gICAgZm9yICh2YXIgbyA9IHIubWFpbkF4aXMsIGkgPSBvID09PSB2b2lkIDAgPyAhMCA6IG8sIHMgPSByLmFsdEF4aXMsIGMgPSBzID09PSB2b2lkIDAgPyAhMCA6IHMsIGwgPSByLmZhbGxiYWNrUGxhY2VtZW50cywgdSA9IHIucGFkZGluZywgcCA9IHIuYm91bmRhcnksIG0gPSByLnJvb3RCb3VuZGFyeSwgZyA9IHIuYWx0Qm91bmRhcnksIHggPSByLmZsaXBWYXJpYXRpb25zLCB5ID0geCA9PT0gdm9pZCAwID8gITAgOiB4LCBmID0gci5hbGxvd2VkQXV0b1BsYWNlbWVudHMsIFMgPSB0Lm9wdGlvbnMucGxhY2VtZW50LCBFID0geHQoUyksIFAgPSBFID09PSBTLCBUID0gbCB8fCAoUCB8fCAheSA/IFt1bihTKV0gOiB2cChTKSksIGIgPSBbU10uY29uY2F0KFQpLnJlZHVjZShmdW5jdGlvbihILCBYKSB7XG4gICAgICByZXR1cm4gSC5jb25jYXQoeHQoWCkgPT09IHFvID8gYnAodCwge1xuICAgICAgICBwbGFjZW1lbnQ6IFgsXG4gICAgICAgIGJvdW5kYXJ5OiBwLFxuICAgICAgICByb290Qm91bmRhcnk6IG0sXG4gICAgICAgIHBhZGRpbmc6IHUsXG4gICAgICAgIGZsaXBWYXJpYXRpb25zOiB5LFxuICAgICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGZcbiAgICAgIH0pIDogWCk7XG4gICAgfSwgW10pLCBoID0gdC5yZWN0cy5yZWZlcmVuY2UsIHcgPSB0LnJlY3RzLnBvcHBlciwgayA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIEwgPSAhMCwgQiA9IGJbMF0sIGQgPSAwOyBkIDwgYi5sZW5ndGg7IGQrKykge1xuICAgICAgdmFyIEEgPSBiW2RdLCBEID0geHQoQSksIGogPSBucihBKSA9PT0gZXIsIFcgPSBbS2UsIHN0XS5pbmRleE9mKEQpID49IDAsIHogPSBXID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIiwgVSA9IGtyKHQsIHtcbiAgICAgICAgcGxhY2VtZW50OiBBLFxuICAgICAgICBib3VuZGFyeTogcCxcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiBtLFxuICAgICAgICBhbHRCb3VuZGFyeTogZyxcbiAgICAgICAgcGFkZGluZzogdVxuICAgICAgfSksIFYgPSBXID8gaiA/IGN0IDogWGUgOiBqID8gc3QgOiBLZTtcbiAgICAgIGhbel0gPiB3W3pdICYmIChWID0gdW4oVikpO1xuICAgICAgdmFyIHRlID0gdW4oViksIEYgPSBbXTtcbiAgICAgIGlmIChpICYmIEYucHVzaChVW0RdIDw9IDApLCBjICYmIEYucHVzaChVW1ZdIDw9IDAsIFVbdGVdIDw9IDApLCBGLmV2ZXJ5KGZ1bmN0aW9uKEgpIHtcbiAgICAgICAgcmV0dXJuIEg7XG4gICAgICB9KSkge1xuICAgICAgICBCID0gQSwgTCA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGsuc2V0KEEsIEYpO1xuICAgIH1cbiAgICBpZiAoTClcbiAgICAgIGZvciAodmFyIFIgPSB5ID8gMyA6IDEsIEkgPSBmdW5jdGlvbihYKSB7XG4gICAgICAgIHZhciBfID0gYi5maW5kKGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgICB2YXIgRyA9IGsuZ2V0KHEpO1xuICAgICAgICAgIGlmIChHKVxuICAgICAgICAgICAgcmV0dXJuIEcuc2xpY2UoMCwgWCkuZXZlcnkoZnVuY3Rpb24ocmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoXylcbiAgICAgICAgICByZXR1cm4gQiA9IF8sIFwiYnJlYWtcIjtcbiAgICAgIH0sIEogPSBSOyBKID4gMDsgSi0tKSB7XG4gICAgICAgIHZhciBRID0gSShKKTtcbiAgICAgICAgaWYgKFEgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgICB9XG4gICAgdC5wbGFjZW1lbnQgIT09IEIgJiYgKHQubW9kaWZpZXJzRGF0YVtuXS5fc2tpcCA9ICEwLCB0LnBsYWNlbWVudCA9IEIsIHQucmVzZXQgPSAhMCk7XG4gIH1cbn1cbmNvbnN0IFNwID0ge1xuICBuYW1lOiBcImZsaXBcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgZm46IHhwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJvZmZzZXRcIl0sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogITFcbiAgfVxufTtcbmZ1bmN0aW9uIG1hKGUsIHQsIHIpIHtcbiAgcmV0dXJuIHIgPT09IHZvaWQgMCAmJiAociA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSksIHtcbiAgICB0b3A6IGUudG9wIC0gdC5oZWlnaHQgLSByLnksXG4gICAgcmlnaHQ6IGUucmlnaHQgLSB0LndpZHRoICsgci54LFxuICAgIGJvdHRvbTogZS5ib3R0b20gLSB0LmhlaWdodCArIHIueSxcbiAgICBsZWZ0OiBlLmxlZnQgLSB0LndpZHRoIC0gci54XG4gIH07XG59XG5mdW5jdGlvbiBoYShlKSB7XG4gIHJldHVybiBbS2UsIGN0LCBzdCwgWGVdLnNvbWUoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBlW3RdID49IDA7XG4gIH0pO1xufVxuZnVuY3Rpb24gRXAoZSkge1xuICB2YXIgdCA9IGUuc3RhdGUsIHIgPSBlLm5hbWUsIG4gPSB0LnJlY3RzLnJlZmVyZW5jZSwgbyA9IHQucmVjdHMucG9wcGVyLCBpID0gdC5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdywgcyA9IGtyKHQsIHtcbiAgICBlbGVtZW50Q29udGV4dDogXCJyZWZlcmVuY2VcIlxuICB9KSwgYyA9IGtyKHQsIHtcbiAgICBhbHRCb3VuZGFyeTogITBcbiAgfSksIGwgPSBtYShzLCBuKSwgdSA9IG1hKGMsIG8sIGkpLCBwID0gaGEobCksIG0gPSBoYSh1KTtcbiAgdC5tb2RpZmllcnNEYXRhW3JdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogbCxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiB1LFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBwLFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IG1cbiAgfSwgdC5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHQuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICBcImRhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW5cIjogcCxcbiAgICBcImRhdGEtcG9wcGVyLWVzY2FwZWRcIjogbVxuICB9KTtcbn1cbmNvbnN0IENwID0ge1xuICBuYW1lOiBcImhpZGVcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wicHJldmVudE92ZXJmbG93XCJdLFxuICBmbjogRXBcbn07XG5mdW5jdGlvbiBUcChlLCB0LCByKSB7XG4gIHZhciBuID0geHQoZSksIG8gPSBbWGUsIEtlXS5pbmRleE9mKG4pID49IDAgPyAtMSA6IDEsIGkgPSB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgPyByKE9iamVjdC5hc3NpZ24oe30sIHQsIHtcbiAgICBwbGFjZW1lbnQ6IGVcbiAgfSkpIDogciwgcyA9IGlbMF0sIGMgPSBpWzFdO1xuICByZXR1cm4gcyA9IHMgfHwgMCwgYyA9IChjIHx8IDApICogbywgW1hlLCBjdF0uaW5kZXhPZihuKSA+PSAwID8ge1xuICAgIHg6IGMsXG4gICAgeTogc1xuICB9IDoge1xuICAgIHg6IHMsXG4gICAgeTogY1xuICB9O1xufVxuZnVuY3Rpb24gd3AoZSkge1xuICB2YXIgdCA9IGUuc3RhdGUsIHIgPSBlLm9wdGlvbnMsIG4gPSBlLm5hbWUsIG8gPSByLm9mZnNldCwgaSA9IG8gPT09IHZvaWQgMCA/IFswLCAwXSA6IG8sIHMgPSB3cy5yZWR1Y2UoZnVuY3Rpb24ocCwgbSkge1xuICAgIHJldHVybiBwW21dID0gVHAobSwgdC5yZWN0cywgaSksIHA7XG4gIH0sIHt9KSwgYyA9IHNbdC5wbGFjZW1lbnRdLCBsID0gYy54LCB1ID0gYy55O1xuICB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsICYmICh0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IGwsIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0gdSksIHQubW9kaWZpZXJzRGF0YVtuXSA9IHM7XG59XG5jb25zdCBPcCA9IHtcbiAgbmFtZTogXCJvZmZzZXRcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgcmVxdWlyZXM6IFtcInBvcHBlck9mZnNldHNcIl0sXG4gIGZuOiB3cFxufTtcbmZ1bmN0aW9uIFJwKGUpIHtcbiAgdmFyIHQgPSBlLnN0YXRlLCByID0gZS5uYW1lO1xuICB0Lm1vZGlmaWVyc0RhdGFbcl0gPSBOcyh7XG4gICAgcmVmZXJlbmNlOiB0LnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiB0LnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiLFxuICAgIHBsYWNlbWVudDogdC5wbGFjZW1lbnRcbiAgfSk7XG59XG5jb25zdCAkcCA9IHtcbiAgbmFtZTogXCJwb3BwZXJPZmZzZXRzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJyZWFkXCIsXG4gIGZuOiBScCxcbiAgZGF0YToge31cbn07XG5mdW5jdGlvbiBQcChlKSB7XG4gIHJldHVybiBlID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XG59XG5mdW5jdGlvbiBrcChlKSB7XG4gIHZhciB0ID0gZS5zdGF0ZSwgciA9IGUub3B0aW9ucywgbiA9IGUubmFtZSwgbyA9IHIubWFpbkF4aXMsIGkgPSBvID09PSB2b2lkIDAgPyAhMCA6IG8sIHMgPSByLmFsdEF4aXMsIGMgPSBzID09PSB2b2lkIDAgPyAhMSA6IHMsIGwgPSByLmJvdW5kYXJ5LCB1ID0gci5yb290Qm91bmRhcnksIHAgPSByLmFsdEJvdW5kYXJ5LCBtID0gci5wYWRkaW5nLCBnID0gci50ZXRoZXIsIHggPSBnID09PSB2b2lkIDAgPyAhMCA6IGcsIHkgPSByLnRldGhlck9mZnNldCwgZiA9IHkgPT09IHZvaWQgMCA/IDAgOiB5LCBTID0ga3IodCwge1xuICAgIGJvdW5kYXJ5OiBsLFxuICAgIHJvb3RCb3VuZGFyeTogdSxcbiAgICBwYWRkaW5nOiBtLFxuICAgIGFsdEJvdW5kYXJ5OiBwXG4gIH0pLCBFID0geHQodC5wbGFjZW1lbnQpLCBQID0gbnIodC5wbGFjZW1lbnQpLCBUID0gIVAsIGIgPSBYbyhFKSwgaCA9IFBwKGIpLCB3ID0gdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsIGsgPSB0LnJlY3RzLnJlZmVyZW5jZSwgTCA9IHQucmVjdHMucG9wcGVyLCBCID0gdHlwZW9mIGYgPT0gXCJmdW5jdGlvblwiID8gZihPYmplY3QuYXNzaWduKHt9LCB0LnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiB0LnBsYWNlbWVudFxuICB9KSkgOiBmLCBkID0gdHlwZW9mIEIgPT0gXCJudW1iZXJcIiA/IHtcbiAgICBtYWluQXhpczogQixcbiAgICBhbHRBeGlzOiBCXG4gIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICBtYWluQXhpczogMCxcbiAgICBhbHRBeGlzOiAwXG4gIH0sIEIpLCBBID0gdC5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHQubW9kaWZpZXJzRGF0YS5vZmZzZXRbdC5wbGFjZW1lbnRdIDogbnVsbCwgRCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgaWYgKHcpIHtcbiAgICBpZiAoaSkge1xuICAgICAgdmFyIGosIFcgPSBiID09PSBcInlcIiA/IEtlIDogWGUsIHogPSBiID09PSBcInlcIiA/IHN0IDogY3QsIFUgPSBiID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCIsIFYgPSB3W2JdLCB0ZSA9IFYgKyBTW1ddLCBGID0gViAtIFNbel0sIFIgPSB4ID8gLUxbVV0gLyAyIDogMCwgSSA9IFAgPT09IGVyID8ga1tVXSA6IExbVV0sIEogPSBQID09PSBlciA/IC1MW1VdIDogLWtbVV0sIFEgPSB0LmVsZW1lbnRzLmFycm93LCBIID0geCAmJiBRID8gS28oUSkgOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sIFggPSB0Lm1vZGlmaWVyc0RhdGFbXCJhcnJvdyNwZXJzaXN0ZW50XCJdID8gdC5tb2RpZmllcnNEYXRhW1wiYXJyb3cjcGVyc2lzdGVudFwiXS5wYWRkaW5nIDogJHMoKSwgXyA9IFhbV10sIHEgPSBYW3pdLCBHID0geHIoMCwga1tVXSwgSFtVXSksIHJlID0gVCA/IGtbVV0gLyAyIC0gUiAtIEcgLSBfIC0gZC5tYWluQXhpcyA6IEkgLSBHIC0gXyAtIGQubWFpbkF4aXMsIFogPSBUID8gLWtbVV0gLyAyICsgUiArIEcgKyBxICsgZC5tYWluQXhpcyA6IEogKyBHICsgcSArIGQubWFpbkF4aXMsIGFlID0gdC5lbGVtZW50cy5hcnJvdyAmJiBWcih0LmVsZW1lbnRzLmFycm93KSwgTyA9IGFlID8gYiA9PT0gXCJ5XCIgPyBhZS5jbGllbnRUb3AgfHwgMCA6IGFlLmNsaWVudExlZnQgfHwgMCA6IDAsIHllID0gKGogPSBBID09IG51bGwgPyB2b2lkIDAgOiBBW2JdKSAhPSBudWxsID8gaiA6IDAsIEVlID0gViArIHJlIC0geWUgLSBPLCBNZSA9IFYgKyBaIC0geWUsIFFlID0geHIoeCA/IEVuKHRlLCBFZSkgOiB0ZSwgViwgeCA/IFZ0KEYsIE1lKSA6IEYpO1xuICAgICAgd1tiXSA9IFFlLCBEW2JdID0gUWUgLSBWO1xuICAgIH1cbiAgICBpZiAoYykge1xuICAgICAgdmFyIHZlLCBQZSA9IGIgPT09IFwieFwiID8gS2UgOiBYZSwgemUgPSBiID09PSBcInhcIiA/IHN0IDogY3QsIExlID0gd1toXSwgdiA9IGggPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgTSA9IExlICsgU1tQZV0sIFkgPSBMZSAtIFNbemVdLCBvZSA9IFtLZSwgWGVdLmluZGV4T2YoRSkgIT09IC0xLCBSZSA9ICh2ZSA9IEEgPT0gbnVsbCA/IHZvaWQgMCA6IEFbaF0pICE9IG51bGwgPyB2ZSA6IDAsIHVlID0gb2UgPyBNIDogTGUgLSBrW3ZdIC0gTFt2XSAtIFJlICsgZC5hbHRBeGlzLCBLID0gb2UgPyBMZSArIGtbdl0gKyBMW3ZdIC0gUmUgLSBkLmFsdEF4aXMgOiBZLCBiZSA9IHggJiYgb2UgPyBlcCh1ZSwgTGUsIEspIDogeHIoeCA/IHVlIDogTSwgTGUsIHggPyBLIDogWSk7XG4gICAgICB3W2hdID0gYmUsIERbaF0gPSBiZSAtIExlO1xuICAgIH1cbiAgICB0Lm1vZGlmaWVyc0RhdGFbbl0gPSBEO1xuICB9XG59XG5jb25zdCBBcCA9IHtcbiAgbmFtZTogXCJwcmV2ZW50T3ZlcmZsb3dcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgZm46IGtwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJvZmZzZXRcIl1cbn07XG5mdW5jdGlvbiBOcChlKSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZS5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZS5zY3JvbGxUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIE1wKGUpIHtcbiAgcmV0dXJuIGUgPT09IHJ0KGUpIHx8ICFpdChlKSA/IEpvKGUpIDogTnAoZSk7XG59XG5mdW5jdGlvbiBJcChlKSB7XG4gIHZhciB0ID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgciA9IHRyKHQud2lkdGgpIC8gZS5vZmZzZXRXaWR0aCB8fCAxLCBuID0gdHIodC5oZWlnaHQpIC8gZS5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIHIgIT09IDEgfHwgbiAhPT0gMTtcbn1cbmZ1bmN0aW9uIF9wKGUsIHQsIHIpIHtcbiAgciA9PT0gdm9pZCAwICYmIChyID0gITEpO1xuICB2YXIgbiA9IGl0KHQpLCBvID0gaXQodCkgJiYgSXAodCksIGkgPSBJdCh0KSwgcyA9IHJyKGUsIG8sIHIpLCBjID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH0sIGwgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIHJldHVybiAobiB8fCAhbiAmJiAhcikgJiYgKChTdCh0KSAhPT0gXCJib2R5XCIgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gIFpvKGkpKSAmJiAoYyA9IE1wKHQpKSwgaXQodCkgPyAobCA9IHJyKHQsICEwKSwgbC54ICs9IHQuY2xpZW50TGVmdCwgbC55ICs9IHQuY2xpZW50VG9wKSA6IGkgJiYgKGwueCA9IFFvKGkpKSksIHtcbiAgICB4OiBzLmxlZnQgKyBjLnNjcm9sbExlZnQgLSBsLngsXG4gICAgeTogcy50b3AgKyBjLnNjcm9sbFRvcCAtIGwueSxcbiAgICB3aWR0aDogcy53aWR0aCxcbiAgICBoZWlnaHQ6IHMuaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBqcChlKSB7XG4gIHZhciB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG4gPSBbXTtcbiAgZS5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICB0LnNldChpLm5hbWUsIGkpO1xuICB9KTtcbiAgZnVuY3Rpb24gbyhpKSB7XG4gICAgci5hZGQoaS5uYW1lKTtcbiAgICB2YXIgcyA9IFtdLmNvbmNhdChpLnJlcXVpcmVzIHx8IFtdLCBpLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHMuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICBpZiAoIXIuaGFzKGMpKSB7XG4gICAgICAgIHZhciBsID0gdC5nZXQoYyk7XG4gICAgICAgIGwgJiYgbyhsKTtcbiAgICAgIH1cbiAgICB9KSwgbi5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBlLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgIHIuaGFzKGkubmFtZSkgfHwgbyhpKTtcbiAgfSksIG47XG59XG5mdW5jdGlvbiBEcChlKSB7XG4gIHZhciB0ID0ganAoZSk7XG4gIHJldHVybiBHZC5yZWR1Y2UoZnVuY3Rpb24ociwgbikge1xuICAgIHJldHVybiByLmNvbmNhdCh0LmZpbHRlcihmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gby5waGFzZSA9PT0gbjtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIExwKGUpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdCB8fCAodCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHIpIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHQgPSB2b2lkIDAsIHIoZSgpKTtcbiAgICAgIH0pO1xuICAgIH0pKSwgdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIEJwKGUpIHtcbiAgdmFyIHQgPSBlLnJlZHVjZShmdW5jdGlvbihyLCBuKSB7XG4gICAgdmFyIG8gPSByW24ubmFtZV07XG4gICAgcmV0dXJuIHJbbi5uYW1lXSA9IG8gPyBPYmplY3QuYXNzaWduKHt9LCBvLCBuLCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBvLm9wdGlvbnMsIG4ub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBvLmRhdGEsIG4uZGF0YSlcbiAgICB9KSA6IG4sIHI7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLm1hcChmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIHRbcl07XG4gIH0pO1xufVxudmFyIGdhID0ge1xuICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiBcImFic29sdXRlXCJcbn07XG5mdW5jdGlvbiB5YSgpIHtcbiAgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoZSksIHIgPSAwOyByIDwgZTsgcisrKVxuICAgIHRbcl0gPSBhcmd1bWVudHNbcl07XG4gIHJldHVybiAhdC5zb21lKGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gIShuICYmIHR5cGVvZiBuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PSBcImZ1bmN0aW9uXCIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFZwKGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0ge30pO1xuICB2YXIgdCA9IGUsIHIgPSB0LmRlZmF1bHRNb2RpZmllcnMsIG4gPSByID09PSB2b2lkIDAgPyBbXSA6IHIsIG8gPSB0LmRlZmF1bHRPcHRpb25zLCBpID0gbyA9PT0gdm9pZCAwID8gZ2EgOiBvO1xuICByZXR1cm4gZnVuY3Rpb24oYywgbCwgdSkge1xuICAgIHUgPT09IHZvaWQgMCAmJiAodSA9IGkpO1xuICAgIHZhciBwID0ge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbVwiLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBnYSwgaSksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogYyxcbiAgICAgICAgcG9wcGVyOiBsXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfSwgbSA9IFtdLCBnID0gITEsIHggPSB7XG4gICAgICBzdGF0ZTogcCxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgdmFyIFAgPSB0eXBlb2YgRSA9PSBcImZ1bmN0aW9uXCIgPyBFKHAub3B0aW9ucykgOiBFO1xuICAgICAgICBmKCksIHAub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGksIHAub3B0aW9ucywgUCksIHAuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IHp0KGMpID8gU3IoYykgOiBjLmNvbnRleHRFbGVtZW50ID8gU3IoYy5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IFNyKGwpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBUID0gRHAoQnAoW10uY29uY2F0KG4sIHAub3B0aW9ucy5tb2RpZmllcnMpKSk7XG4gICAgICAgIHJldHVybiBwLm9yZGVyZWRNb2RpZmllcnMgPSBULmZpbHRlcihmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcmV0dXJuIGIuZW5hYmxlZDtcbiAgICAgICAgfSksIHkoKSwgeC51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghZykge1xuICAgICAgICAgIHZhciBFID0gcC5lbGVtZW50cywgUCA9IEUucmVmZXJlbmNlLCBUID0gRS5wb3BwZXI7XG4gICAgICAgICAgaWYgKHlhKFAsIFQpKSB7XG4gICAgICAgICAgICBwLnJlY3RzID0ge1xuICAgICAgICAgICAgICByZWZlcmVuY2U6IF9wKFAsIFZyKFQpLCBwLm9wdGlvbnMuc3RyYXRlZ3kgPT09IFwiZml4ZWRcIiksXG4gICAgICAgICAgICAgIHBvcHBlcjogS28oVClcbiAgICAgICAgICAgIH0sIHAucmVzZXQgPSAhMSwgcC5wbGFjZW1lbnQgPSBwLm9wdGlvbnMucGxhY2VtZW50LCBwLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwLm1vZGlmaWVyc0RhdGFbZC5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIGQuZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgcC5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICAgIGlmIChwLnJlc2V0ID09PSAhMCkge1xuICAgICAgICAgICAgICAgIHAucmVzZXQgPSAhMSwgYiA9IC0xO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBoID0gcC5vcmRlcmVkTW9kaWZpZXJzW2JdLCB3ID0gaC5mbiwgayA9IGgub3B0aW9ucywgTCA9IGsgPT09IHZvaWQgMCA/IHt9IDogaywgQiA9IGgubmFtZTtcbiAgICAgICAgICAgICAgdHlwZW9mIHcgPT0gXCJmdW5jdGlvblwiICYmIChwID0gdyh7XG4gICAgICAgICAgICAgICAgc3RhdGU6IHAsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogTCxcbiAgICAgICAgICAgICAgICBuYW1lOiBCLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB4XG4gICAgICAgICAgICAgIH0pIHx8IHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IExwKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oUykge1xuICAgICAgICAgIHguZm9yY2VVcGRhdGUoKSwgUyhwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmKCksIGcgPSAhMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICgheWEoYywgbCkpXG4gICAgICByZXR1cm4geDtcbiAgICB4LnNldE9wdGlvbnModSkudGhlbihmdW5jdGlvbihTKSB7XG4gICAgICAhZyAmJiB1Lm9uRmlyc3RVcGRhdGUgJiYgdS5vbkZpcnN0VXBkYXRlKFMpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHkoKSB7XG4gICAgICBwLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbihTKSB7XG4gICAgICAgIHZhciBFID0gUy5uYW1lLCBQID0gUy5vcHRpb25zLCBUID0gUCA9PT0gdm9pZCAwID8ge30gOiBQLCBiID0gUy5lZmZlY3Q7XG4gICAgICAgIGlmICh0eXBlb2YgYiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgaCA9IGIoe1xuICAgICAgICAgICAgc3RhdGU6IHAsXG4gICAgICAgICAgICBuYW1lOiBFLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHgsXG4gICAgICAgICAgICBvcHRpb25zOiBUXG4gICAgICAgICAgfSksIHcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG0ucHVzaChoIHx8IHcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZigpIHtcbiAgICAgIG0uZm9yRWFjaChmdW5jdGlvbihTKSB7XG4gICAgICAgIHJldHVybiBTKCk7XG4gICAgICB9KSwgbSA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbnZhciBGcCA9IFt1cCwgJHAsIGNwLCBKZCwgT3AsIFNwLCBBcCwgb3AsIENwXSwgenAgPSAvKiBAX19QVVJFX18gKi8gVnAoe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBGcFxufSk7XG5mdW5jdGlvbiBXcChlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKCkgOiBlO1xufVxuY29uc3QgQ24gPSAvKiBAX19QVVJFX18gKi8gQy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsIHIpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuOiBuLFxuICAgIGNvbnRhaW5lcjogbyxcbiAgICBkaXNhYmxlUG9ydGFsOiBpID0gITFcbiAgfSA9IHQsIFtzLCBjXSA9IEMudXNlU3RhdGUobnVsbCksIGwgPSBhdCgvKiBAX19QVVJFX18gKi8gQy5pc1ZhbGlkRWxlbWVudChuKSA/IEJvKG4pIDogbnVsbCwgcik7XG4gIGlmIChGdCgoKSA9PiB7XG4gICAgaSB8fCBjKFdwKG8pIHx8IGRvY3VtZW50LmJvZHkpO1xuICB9LCBbbywgaV0pLCBGdCgoKSA9PiB7XG4gICAgaWYgKHMgJiYgIWkpXG4gICAgICByZXR1cm4gdW8ociwgcyksICgpID0+IHtcbiAgICAgICAgdW8ociwgbnVsbCk7XG4gICAgICB9O1xuICB9LCBbciwgcywgaV0pLCBpKSB7XG4gICAgaWYgKC8qIEBfX1BVUkVfXyAqLyBDLmlzVmFsaWRFbGVtZW50KG4pKSB7XG4gICAgICBjb25zdCB1ID0ge1xuICAgICAgICByZWY6IGxcbiAgICAgIH07XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIEMuY2xvbmVFbGVtZW50KG4sIHUpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICByZXR1cm4gcyAmJiAvKiBAX19QVVJFX18gKi8gWnMuY3JlYXRlUG9ydGFsKG4sIHMpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKENuLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIFR5cGVTY3JpcHQgdHlwZXMgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBUaGUgY2hpbGRyZW4gdG8gcmVuZGVyIGludG8gdGhlIGBjb250YWluZXJgLlxuICAgKi9cbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgLyoqXG4gICAqIEFuIEhUTUwgZWxlbWVudCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgb25lLlxuICAgKiBUaGUgYGNvbnRhaW5lcmAgd2lsbCBoYXZlIHRoZSBwb3J0YWwgY2hpbGRyZW4gYXBwZW5kZWQgdG8gaXQuXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgY2FsbGJhY2ssIHdoaWNoIGlzIGNhbGxlZCBpbiBhIFJlYWN0IGxheW91dCBlZmZlY3QuXG4gICAqIFRoaXMgbGV0cyB5b3Ugc2V0IHRoZSBjb250YWluZXIgZnJvbSBhIHJlZiwgYW5kIGFsc28gbWFrZXMgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHBvc3NpYmxlLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpdCB1c2VzIHRoZSBib2R5IG9mIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgb2JqZWN0LFxuICAgKiBzbyBpdCdzIHNpbXBseSBgZG9jdW1lbnQuYm9keWAgbW9zdCBvZiB0aGUgdGltZS5cbiAgICovXG4gIGNvbnRhaW5lcjogYS5vbmVPZlR5cGUoW09yLCBhLmZ1bmNdKSxcbiAgLyoqXG4gICAqIFRoZSBgY2hpbGRyZW5gIHdpbGwgYmUgdW5kZXIgdGhlIERPTSBoaWVyYXJjaHkgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlUG9ydGFsOiBhLmJvb2xcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChDbi5wcm9wVHlwZXMgPSBEbyhDbi5wcm9wVHlwZXMpKTtcbmZ1bmN0aW9uIFVwKGUpIHtcbiAgcmV0dXJuIFZlKFwiTXVpUG9wcGVyXCIsIGUpO1xufVxuRmUoXCJNdWlQb3BwZXJcIiwgW1wicm9vdFwiXSk7XG5mdW5jdGlvbiBZcChlLCB0KSB7XG4gIGlmICh0ID09PSBcImx0clwiKVxuICAgIHJldHVybiBlO1xuICBzd2l0Y2ggKGUpIHtcbiAgICBjYXNlIFwiYm90dG9tLWVuZFwiOlxuICAgICAgcmV0dXJuIFwiYm90dG9tLXN0YXJ0XCI7XG4gICAgY2FzZSBcImJvdHRvbS1zdGFydFwiOlxuICAgICAgcmV0dXJuIFwiYm90dG9tLWVuZFwiO1xuICAgIGNhc2UgXCJ0b3AtZW5kXCI6XG4gICAgICByZXR1cm4gXCJ0b3Atc3RhcnRcIjtcbiAgICBjYXNlIFwidG9wLXN0YXJ0XCI6XG4gICAgICByZXR1cm4gXCJ0b3AtZW5kXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBlO1xuICB9XG59XG5mdW5jdGlvbiBUbihlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKCkgOiBlO1xufVxuZnVuY3Rpb24gV24oZSkge1xuICByZXR1cm4gZS5ub2RlVHlwZSAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gSHAoZSkge1xuICByZXR1cm4gIVduKGUpO1xufVxuY29uc3QgcXAgPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xhc3NlczogdFxuICB9ID0gZTtcbiAgcmV0dXJuIEdlKHtcbiAgICByb290OiBbXCJyb290XCJdXG4gIH0sIFVwLCB0KTtcbn0sIEdwID0ge30sIEtwID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IHtcbiAgICBhbmNob3JFbDogbixcbiAgICBjaGlsZHJlbjogbyxcbiAgICBkaXJlY3Rpb246IGksXG4gICAgZGlzYWJsZVBvcnRhbDogcyxcbiAgICBtb2RpZmllcnM6IGMsXG4gICAgb3BlbjogbCxcbiAgICBwbGFjZW1lbnQ6IHUsXG4gICAgcG9wcGVyT3B0aW9uczogcCxcbiAgICBwb3BwZXJSZWY6IG0sXG4gICAgc2xvdFByb3BzOiBnID0ge30sXG4gICAgc2xvdHM6IHggPSB7fSxcbiAgICBUcmFuc2l0aW9uUHJvcHM6IHksXG4gICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCBsb2dpY1xuICAgIG93bmVyU3RhdGU6IGYsXG4gICAgLy8gcHJldmVudCBmcm9tIHNwcmVhZGluZyB0byBET00sIGl0IGNhbiBjb21lIGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgZS5nLiBTZWxlY3QuXG4gICAgLi4uU1xuICB9ID0gdCwgRSA9IEMudXNlUmVmKG51bGwpLCBQID0gYXQoRSwgciksIFQgPSBDLnVzZVJlZihudWxsKSwgYiA9IGF0KFQsIG0pLCBoID0gQy51c2VSZWYoYik7XG4gIEZ0KCgpID0+IHtcbiAgICBoLmN1cnJlbnQgPSBiO1xuICB9LCBbYl0pLCBDLnVzZUltcGVyYXRpdmVIYW5kbGUobSwgKCkgPT4gVC5jdXJyZW50LCBbXSk7XG4gIGNvbnN0IHcgPSBZcCh1LCBpKSwgW2ssIExdID0gQy51c2VTdGF0ZSh3KSwgW0IsIGRdID0gQy51c2VTdGF0ZShUbihuKSk7XG4gIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBULmN1cnJlbnQgJiYgVC5jdXJyZW50LmZvcmNlVXBkYXRlKCk7XG4gIH0pLCBDLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbiAmJiBkKFRuKG4pKTtcbiAgfSwgW25dKSwgRnQoKCkgPT4ge1xuICAgIGlmICghQiB8fCAhbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB6ID0gKHRlKSA9PiB7XG4gICAgICBMKHRlLnBsYWNlbWVudCk7XG4gICAgfTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEIgJiYgV24oQikgJiYgQi5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgY29uc3QgdGUgPSBCLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwidGVzdFwiICYmIHRlLnRvcCA9PT0gMCAmJiB0ZS5sZWZ0ID09PSAwICYmIHRlLnJpZ2h0ID09PSAwICYmIHRlLmJvdHRvbSA9PT0gMCAmJiBjb25zb2xlLndhcm4oW1wiTVVJOiBUaGUgYGFuY2hvckVsYCBwcm9wIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQgaXMgaW52YWxpZC5cIiwgXCJUaGUgYW5jaG9yIGVsZW1lbnQgc2hvdWxkIGJlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGxheW91dC5cIiwgXCJNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgcHJlc2VudCBpbiB0aGUgZG9jdW1lbnQgb3IgdGhhdCBpdCdzIG5vdCBkaXNwbGF5IG5vbmUuXCJdLmpvaW4oYFxuYCkpO1xuICAgIH1cbiAgICBsZXQgVSA9IFt7XG4gICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBhbHRCb3VuZGFyeTogc1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiZmxpcFwiLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBhbHRCb3VuZGFyeTogc1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwib25VcGRhdGVcIixcbiAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgcGhhc2U6IFwiYWZ0ZXJXcml0ZVwiLFxuICAgICAgZm46ICh7XG4gICAgICAgIHN0YXRlOiB0ZVxuICAgICAgfSkgPT4ge1xuICAgICAgICB6KHRlKTtcbiAgICAgIH1cbiAgICB9XTtcbiAgICBjICE9IG51bGwgJiYgKFUgPSBVLmNvbmNhdChjKSksIHAgJiYgcC5tb2RpZmllcnMgIT0gbnVsbCAmJiAoVSA9IFUuY29uY2F0KHAubW9kaWZpZXJzKSk7XG4gICAgY29uc3QgViA9IHpwKEIsIEUuY3VycmVudCwge1xuICAgICAgcGxhY2VtZW50OiB3LFxuICAgICAgLi4ucCxcbiAgICAgIG1vZGlmaWVyczogVVxuICAgIH0pO1xuICAgIHJldHVybiBoLmN1cnJlbnQoViksICgpID0+IHtcbiAgICAgIFYuZGVzdHJveSgpLCBoLmN1cnJlbnQobnVsbCk7XG4gICAgfTtcbiAgfSwgW0IsIHMsIGMsIGwsIHAsIHddKTtcbiAgY29uc3QgQSA9IHtcbiAgICBwbGFjZW1lbnQ6IGtcbiAgfTtcbiAgeSAhPT0gbnVsbCAmJiAoQS5UcmFuc2l0aW9uUHJvcHMgPSB5KTtcbiAgY29uc3QgRCA9IHFwKHQpLCBqID0geC5yb290ID8/IFwiZGl2XCIsIFcgPSBZdSh7XG4gICAgZWxlbWVudFR5cGU6IGosXG4gICAgZXh0ZXJuYWxTbG90UHJvcHM6IGcucm9vdCxcbiAgICBleHRlcm5hbEZvcndhcmRlZFByb3BzOiBTLFxuICAgIGFkZGl0aW9uYWxQcm9wczoge1xuICAgICAgcm9sZTogXCJ0b29sdGlwXCIsXG4gICAgICByZWY6IFBcbiAgICB9LFxuICAgIG93bmVyU3RhdGU6IHQsXG4gICAgY2xhc3NOYW1lOiBELnJvb3RcbiAgfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goaiwge1xuICAgIC4uLlcsXG4gICAgY2hpbGRyZW46IHR5cGVvZiBvID09IFwiZnVuY3Rpb25cIiA/IG8oQSkgOiBvXG4gIH0pO1xufSksIE1zID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IHtcbiAgICBhbmNob3JFbDogbixcbiAgICBjaGlsZHJlbjogbyxcbiAgICBjb250YWluZXI6IGksXG4gICAgZGlyZWN0aW9uOiBzID0gXCJsdHJcIixcbiAgICBkaXNhYmxlUG9ydGFsOiBjID0gITEsXG4gICAga2VlcE1vdW50ZWQ6IGwgPSAhMSxcbiAgICBtb2RpZmllcnM6IHUsXG4gICAgb3BlbjogcCxcbiAgICBwbGFjZW1lbnQ6IG0gPSBcImJvdHRvbVwiLFxuICAgIHBvcHBlck9wdGlvbnM6IGcgPSBHcCxcbiAgICBwb3BwZXJSZWY6IHgsXG4gICAgc3R5bGU6IHksXG4gICAgdHJhbnNpdGlvbjogZiA9ICExLFxuICAgIHNsb3RQcm9wczogUyA9IHt9LFxuICAgIHNsb3RzOiBFID0ge30sXG4gICAgLi4uUFxuICB9ID0gdCwgW1QsIGJdID0gQy51c2VTdGF0ZSghMCksIGggPSAoKSA9PiB7XG4gICAgYighMSk7XG4gIH0sIHcgPSAoKSA9PiB7XG4gICAgYighMCk7XG4gIH07XG4gIGlmICghbCAmJiAhcCAmJiAoIWYgfHwgVCkpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBrO1xuICBpZiAoaSlcbiAgICBrID0gaTtcbiAgZWxzZSBpZiAobikge1xuICAgIGNvbnN0IGQgPSBUbihuKTtcbiAgICBrID0gZCAmJiBXbihkKSA/IHppKGQpLmJvZHkgOiB6aShudWxsKS5ib2R5O1xuICB9XG4gIGNvbnN0IEwgPSAhcCAmJiBsICYmICghZiB8fCBUKSA/IFwibm9uZVwiIDogdm9pZCAwLCBCID0gZiA/IHtcbiAgICBpbjogcCxcbiAgICBvbkVudGVyOiBoLFxuICAgIG9uRXhpdGVkOiB3XG4gIH0gOiB2b2lkIDA7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goQ24sIHtcbiAgICBkaXNhYmxlUG9ydGFsOiBjLFxuICAgIGNvbnRhaW5lcjogayxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KEtwLCB7XG4gICAgICBhbmNob3JFbDogbixcbiAgICAgIGRpcmVjdGlvbjogcyxcbiAgICAgIGRpc2FibGVQb3J0YWw6IGMsXG4gICAgICBtb2RpZmllcnM6IHUsXG4gICAgICByZWY6IHIsXG4gICAgICBvcGVuOiBmID8gIVQgOiBwLFxuICAgICAgcGxhY2VtZW50OiBtLFxuICAgICAgcG9wcGVyT3B0aW9uczogZyxcbiAgICAgIHBvcHBlclJlZjogeCxcbiAgICAgIHNsb3RQcm9wczogUyxcbiAgICAgIHNsb3RzOiBFLFxuICAgICAgLi4uUCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIC8vIFByZXZlbnRzIHNjcm9sbCBpc3N1ZSwgd2FpdGluZyBmb3IgUG9wcGVyLmpzIHRvIGFkZCB0aGlzIHN0eWxlIG9uY2UgaW5pdGlhdGVkLlxuICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICAvLyBGaXggUG9wcGVyLmpzIGRpc3BsYXkgaXNzdWVcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBkaXNwbGF5OiBMLFxuICAgICAgICAuLi55XG4gICAgICB9LFxuICAgICAgVHJhbnNpdGlvblByb3BzOiBCLFxuICAgICAgY2hpbGRyZW46IG9cbiAgICB9KVxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChNcy5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBUeXBlU2NyaXB0IHR5cGVzIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4g4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogQW4gSFRNTCBlbGVtZW50LCBbdmlydHVhbEVsZW1lbnRdKGh0dHBzOi8vcG9wcGVyLmpzLm9yZy9kb2NzL3YyL3ZpcnR1YWwtZWxlbWVudHMvKSxcbiAgICogb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgZWl0aGVyLlxuICAgKiBJdCdzIHVzZWQgdG8gc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLlxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgcGFzc2VkIGFzIHRoZSByZWZlcmVuY2Ugb2JqZWN0IG9mIHRoZSBQb3BwZXIgaW5zdGFuY2UuXG4gICAqL1xuICBhbmNob3JFbDogYXIoYS5vbmVPZlR5cGUoW09yLCBhLm9iamVjdCwgYS5mdW5jXSksIChlKSA9PiB7XG4gICAgaWYgKGUub3Blbikge1xuICAgICAgY29uc3QgdCA9IFRuKGUuYW5jaG9yRWwpO1xuICAgICAgaWYgKHQgJiYgV24odCkgJiYgdC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBjb25zdCByID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIiAmJiByLnRvcCA9PT0gMCAmJiByLmxlZnQgPT09IDAgJiYgci5yaWdodCA9PT0gMCAmJiByLmJvdHRvbSA9PT0gMClcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFtcIk1VSTogVGhlIGBhbmNob3JFbGAgcHJvcCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGlzIGludmFsaWQuXCIsIFwiVGhlIGFuY2hvciBlbGVtZW50IHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBsYXlvdXQuXCIsIFwiTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHByZXNlbnQgaW4gdGhlIGRvY3VtZW50IG9yIHRoYXQgaXQncyBub3QgZGlzcGxheSBub25lLlwiXS5qb2luKGBcbmApKTtcbiAgICAgIH0gZWxzZSBpZiAoIXQgfHwgdHlwZW9mIHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9IFwiZnVuY3Rpb25cIiB8fCBIcCh0KSAmJiB0LmNvbnRleHRFbGVtZW50ICE9IG51bGwgJiYgdC5jb250ZXh0RWxlbWVudC5ub2RlVHlwZSAhPT0gMSlcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihbXCJNVUk6IFRoZSBgYW5jaG9yRWxgIHByb3AgcHJvdmlkZWQgdG8gdGhlIGNvbXBvbmVudCBpcyBpbnZhbGlkLlwiLCBcIkl0IHNob3VsZCBiZSBhbiBIVE1MIGVsZW1lbnQgaW5zdGFuY2Ugb3IgYSB2aXJ0dWFsRWxlbWVudCBcIiwgXCIoaHR0cHM6Ly9wb3BwZXIuanMub3JnL2RvY3MvdjIvdmlydHVhbC1lbGVtZW50cy8pLlwiXS5qb2luKGBcbmApKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pLFxuICAvKipcbiAgICogUG9wcGVyIHJlbmRlciBmdW5jdGlvbiBvciBub2RlLlxuICAgKi9cbiAgY2hpbGRyZW46IGEub25lT2ZUeXBlKFthLm5vZGUsIGEuZnVuY10pLFxuICAvKipcbiAgICogQW4gSFRNTCBlbGVtZW50IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBvbmUuXG4gICAqIFRoZSBgY29udGFpbmVyYCB3aWxsIGhhdmUgdGhlIHBvcnRhbCBjaGlsZHJlbiBhcHBlbmRlZCB0byBpdC5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBjYWxsYmFjaywgd2hpY2ggaXMgY2FsbGVkIGluIGEgUmVhY3QgbGF5b3V0IGVmZmVjdC5cbiAgICogVGhpcyBsZXRzIHlvdSBzZXQgdGhlIGNvbnRhaW5lciBmcm9tIGEgcmVmLCBhbmQgYWxzbyBtYWtlcyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcG9zc2libGUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgdGhlIGJvZHkgb2YgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBvYmplY3QsXG4gICAqIHNvIGl0J3Mgc2ltcGx5IGBkb2N1bWVudC5ib2R5YCBtb3N0IG9mIHRoZSB0aW1lLlxuICAgKi9cbiAgY29udGFpbmVyOiBhLm9uZU9mVHlwZShbT3IsIGEuZnVuY10pLFxuICAvKipcbiAgICogRGlyZWN0aW9uIG9mIHRoZSB0ZXh0LlxuICAgKiBAZGVmYXVsdCAnbHRyJ1xuICAgKi9cbiAgZGlyZWN0aW9uOiBhLm9uZU9mKFtcImx0clwiLCBcInJ0bFwiXSksXG4gIC8qKlxuICAgKiBUaGUgYGNoaWxkcmVuYCB3aWxsIGJlIHVuZGVyIHRoZSBET00gaGllcmFyY2h5IG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZVBvcnRhbDogYS5ib29sLFxuICAvKipcbiAgICogQWx3YXlzIGtlZXAgdGhlIGNoaWxkcmVuIGluIHRoZSBET00uXG4gICAqIFRoaXMgcHJvcCBjYW4gYmUgdXNlZnVsIGluIFNFTyBzaXR1YXRpb24gb3JcbiAgICogd2hlbiB5b3Ugd2FudCB0byBtYXhpbWl6ZSB0aGUgcmVzcG9uc2l2ZW5lc3Mgb2YgdGhlIFBvcHBlci5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGtlZXBNb3VudGVkOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBQb3BwZXIuanMgaXMgYmFzZWQgb24gYSBcInBsdWdpbi1saWtlXCIgYXJjaGl0ZWN0dXJlLFxuICAgKiBtb3N0IG9mIGl0cyBmZWF0dXJlcyBhcmUgZnVsbHkgZW5jYXBzdWxhdGVkIFwibW9kaWZpZXJzXCIuXG4gICAqXG4gICAqIEEgbW9kaWZpZXIgaXMgYSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBlYWNoIHRpbWUgUG9wcGVyLmpzIG5lZWRzIHRvXG4gICAqIGNvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIuXG4gICAqIEZvciB0aGlzIHJlYXNvbiwgbW9kaWZpZXJzIHNob3VsZCBiZSB2ZXJ5IHBlcmZvcm1hbnQgdG8gYXZvaWQgYm90dGxlbmVja3MuXG4gICAqIFRvIGxlYXJuIGhvdyB0byBjcmVhdGUgYSBtb2RpZmllciwgW3JlYWQgdGhlIG1vZGlmaWVycyBkb2N1bWVudGF0aW9uXShodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92Mi9tb2RpZmllcnMvKS5cbiAgICovXG4gIG1vZGlmaWVyczogYS5hcnJheU9mKGEuc2hhcGUoe1xuICAgIGRhdGE6IGEub2JqZWN0LFxuICAgIGVmZmVjdDogYS5mdW5jLFxuICAgIGVuYWJsZWQ6IGEuYm9vbCxcbiAgICBmbjogYS5mdW5jLFxuICAgIG5hbWU6IGEuYW55LFxuICAgIG9wdGlvbnM6IGEub2JqZWN0LFxuICAgIHBoYXNlOiBhLm9uZU9mKFtcImFmdGVyTWFpblwiLCBcImFmdGVyUmVhZFwiLCBcImFmdGVyV3JpdGVcIiwgXCJiZWZvcmVNYWluXCIsIFwiYmVmb3JlUmVhZFwiLCBcImJlZm9yZVdyaXRlXCIsIFwibWFpblwiLCBcInJlYWRcIiwgXCJ3cml0ZVwiXSksXG4gICAgcmVxdWlyZXM6IGEuYXJyYXlPZihhLnN0cmluZyksXG4gICAgcmVxdWlyZXNJZkV4aXN0czogYS5hcnJheU9mKGEuc3RyaW5nKVxuICB9KSksXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgaXMgc2hvd24uXG4gICAqL1xuICBvcGVuOiBhLmJvb2wuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIFBvcHBlciBwbGFjZW1lbnQuXG4gICAqIEBkZWZhdWx0ICdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6IGEub25lT2YoW1wiYXV0by1lbmRcIiwgXCJhdXRvLXN0YXJ0XCIsIFwiYXV0b1wiLCBcImJvdHRvbS1lbmRcIiwgXCJib3R0b20tc3RhcnRcIiwgXCJib3R0b21cIiwgXCJsZWZ0LWVuZFwiLCBcImxlZnQtc3RhcnRcIiwgXCJsZWZ0XCIsIFwicmlnaHQtZW5kXCIsIFwicmlnaHQtc3RhcnRcIiwgXCJyaWdodFwiLCBcInRvcC1lbmRcIiwgXCJ0b3Atc3RhcnRcIiwgXCJ0b3BcIl0pLFxuICAvKipcbiAgICogT3B0aW9ucyBwcm92aWRlZCB0byB0aGUgW2BQb3BwZXIuanNgXShodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92Mi9jb25zdHJ1Y3RvcnMvI29wdGlvbnMpIGluc3RhbmNlLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgcG9wcGVyT3B0aW9uczogYS5zaGFwZSh7XG4gICAgbW9kaWZpZXJzOiBhLmFycmF5LFxuICAgIG9uRmlyc3RVcGRhdGU6IGEuZnVuYyxcbiAgICBwbGFjZW1lbnQ6IGEub25lT2YoW1wiYXV0by1lbmRcIiwgXCJhdXRvLXN0YXJ0XCIsIFwiYXV0b1wiLCBcImJvdHRvbS1lbmRcIiwgXCJib3R0b20tc3RhcnRcIiwgXCJib3R0b21cIiwgXCJsZWZ0LWVuZFwiLCBcImxlZnQtc3RhcnRcIiwgXCJsZWZ0XCIsIFwicmlnaHQtZW5kXCIsIFwicmlnaHQtc3RhcnRcIiwgXCJyaWdodFwiLCBcInRvcC1lbmRcIiwgXCJ0b3Atc3RhcnRcIiwgXCJ0b3BcIl0pLFxuICAgIHN0cmF0ZWd5OiBhLm9uZU9mKFtcImFic29sdXRlXCIsIFwiZml4ZWRcIl0pXG4gIH0pLFxuICAvKipcbiAgICogQSByZWYgdGhhdCBwb2ludHMgdG8gdGhlIHVzZWQgcG9wcGVyIGluc3RhbmNlLlxuICAgKi9cbiAgcG9wcGVyUmVmOiBMbyxcbiAgLyoqXG4gICAqIFRoZSBwcm9wcyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlIHRoZSBQb3BwZXIuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBzbG90UHJvcHM6IGEuc2hhcGUoe1xuICAgIHJvb3Q6IGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0XSlcbiAgfSksXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlIHRoZSBQb3BwZXIuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBzbG90czogYS5zaGFwZSh7XG4gICAgcm9vdDogYS5lbGVtZW50VHlwZVxuICB9KSxcbiAgLyoqXG4gICAqIEhlbHAgc3VwcG9ydGluZyBhIHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvVHJhbnNpdGlvbiBjb21wb25lbnQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB0cmFuc2l0aW9uOiBhLmJvb2xcbn0pO1xuY29uc3QgWHAgPSBsZShNcywge1xuICBuYW1lOiBcIk11aVBvcHBlclwiLFxuICBzbG90OiBcIlJvb3RcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB0LnJvb3Rcbn0pKHt9KSwgZWkgPSAvKiBAX19QVVJFX18gKi8gQy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsIHIpIHtcbiAgY29uc3QgbiA9IGlzKCksIG8gPSBIZSh7XG4gICAgcHJvcHM6IHQsXG4gICAgbmFtZTogXCJNdWlQb3BwZXJcIlxuICB9KSwge1xuICAgIGFuY2hvckVsOiBpLFxuICAgIGNvbXBvbmVudDogcyxcbiAgICBjb21wb25lbnRzOiBjLFxuICAgIGNvbXBvbmVudHNQcm9wczogbCxcbiAgICBjb250YWluZXI6IHUsXG4gICAgZGlzYWJsZVBvcnRhbDogcCxcbiAgICBrZWVwTW91bnRlZDogbSxcbiAgICBtb2RpZmllcnM6IGcsXG4gICAgb3BlbjogeCxcbiAgICBwbGFjZW1lbnQ6IHksXG4gICAgcG9wcGVyT3B0aW9uczogZixcbiAgICBwb3BwZXJSZWY6IFMsXG4gICAgdHJhbnNpdGlvbjogRSxcbiAgICBzbG90czogUCxcbiAgICBzbG90UHJvcHM6IFQsXG4gICAgLi4uYlxuICB9ID0gbywgaCA9IChQID09IG51bGwgPyB2b2lkIDAgOiBQLnJvb3QpID8/IChjID09IG51bGwgPyB2b2lkIDAgOiBjLlJvb3QpLCB3ID0ge1xuICAgIGFuY2hvckVsOiBpLFxuICAgIGNvbnRhaW5lcjogdSxcbiAgICBkaXNhYmxlUG9ydGFsOiBwLFxuICAgIGtlZXBNb3VudGVkOiBtLFxuICAgIG1vZGlmaWVyczogZyxcbiAgICBvcGVuOiB4LFxuICAgIHBsYWNlbWVudDogeSxcbiAgICBwb3BwZXJPcHRpb25zOiBmLFxuICAgIHBvcHBlclJlZjogUyxcbiAgICB0cmFuc2l0aW9uOiBFLFxuICAgIC4uLmJcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChYcCwge1xuICAgIGFzOiBzLFxuICAgIGRpcmVjdGlvbjogbiA/IFwicnRsXCIgOiBcImx0clwiLFxuICAgIHNsb3RzOiB7XG4gICAgICByb290OiBoXG4gICAgfSxcbiAgICBzbG90UHJvcHM6IFQgPz8gbCxcbiAgICAuLi53LFxuICAgIHJlZjogclxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChlaS5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBUeXBlU2NyaXB0IHR5cGVzIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4g4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogQW4gSFRNTCBlbGVtZW50LCBbdmlydHVhbEVsZW1lbnRdKGh0dHBzOi8vcG9wcGVyLmpzLm9yZy9kb2NzL3YyL3ZpcnR1YWwtZWxlbWVudHMvKSxcbiAgICogb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgZWl0aGVyLlxuICAgKiBJdCdzIHVzZWQgdG8gc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLlxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgcGFzc2VkIGFzIHRoZSByZWZlcmVuY2Ugb2JqZWN0IG9mIHRoZSBQb3BwZXIgaW5zdGFuY2UuXG4gICAqL1xuICBhbmNob3JFbDogYS5vbmVPZlR5cGUoW09yLCBhLm9iamVjdCwgYS5mdW5jXSksXG4gIC8qKlxuICAgKiBQb3BwZXIgcmVuZGVyIGZ1bmN0aW9uIG9yIG5vZGUuXG4gICAqL1xuICBjaGlsZHJlbjogYS5vbmVPZlR5cGUoW2Eubm9kZSwgYS5mdW5jXSksXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IGEuZWxlbWVudFR5cGUsXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlIHRoZSBQb3BwZXIuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHVzZSB0aGUgYHNsb3RzYCBwcm9wIGluc3RlYWQuIFRoaXMgcHJvcCB3aWxsIGJlIHJlbW92ZWQgaW4gdjcuIFtIb3cgdG8gbWlncmF0ZV0oL21hdGVyaWFsLXVpL21pZ3JhdGlvbi9taWdyYXRpbmctZnJvbS1kZXByZWNhdGVkLWFwaXMvKS5cbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIGNvbXBvbmVudHM6IGEuc2hhcGUoe1xuICAgIFJvb3Q6IGEuZWxlbWVudFR5cGVcbiAgfSksXG4gIC8qKlxuICAgKiBUaGUgcHJvcHMgdXNlZCBmb3IgZWFjaCBzbG90IGluc2lkZSB0aGUgUG9wcGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgdGhlIGBzbG90UHJvcHNgIHByb3AgaW5zdGVhZC4gVGhpcyBwcm9wIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4gW0hvdyB0byBtaWdyYXRlXSgvbWF0ZXJpYWwtdWkvbWlncmF0aW9uL21pZ3JhdGluZy1mcm9tLWRlcHJlY2F0ZWQtYXBpcy8pLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgY29tcG9uZW50c1Byb3BzOiBhLnNoYXBlKHtcbiAgICByb290OiBhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdF0pXG4gIH0pLFxuICAvKipcbiAgICogQW4gSFRNTCBlbGVtZW50IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBvbmUuXG4gICAqIFRoZSBgY29udGFpbmVyYCB3aWxsIGhhdmUgdGhlIHBvcnRhbCBjaGlsZHJlbiBhcHBlbmRlZCB0byBpdC5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBjYWxsYmFjaywgd2hpY2ggaXMgY2FsbGVkIGluIGEgUmVhY3QgbGF5b3V0IGVmZmVjdC5cbiAgICogVGhpcyBsZXRzIHlvdSBzZXQgdGhlIGNvbnRhaW5lciBmcm9tIGEgcmVmLCBhbmQgYWxzbyBtYWtlcyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcG9zc2libGUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgdGhlIGJvZHkgb2YgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBvYmplY3QsXG4gICAqIHNvIGl0J3Mgc2ltcGx5IGBkb2N1bWVudC5ib2R5YCBtb3N0IG9mIHRoZSB0aW1lLlxuICAgKi9cbiAgY29udGFpbmVyOiBhLm9uZU9mVHlwZShbT3IsIGEuZnVuY10pLFxuICAvKipcbiAgICogVGhlIGBjaGlsZHJlbmAgd2lsbCBiZSB1bmRlciB0aGUgRE9NIGhpZXJhcmNoeSBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVQb3J0YWw6IGEuYm9vbCxcbiAgLyoqXG4gICAqIEFsd2F5cyBrZWVwIHRoZSBjaGlsZHJlbiBpbiB0aGUgRE9NLlxuICAgKiBUaGlzIHByb3AgY2FuIGJlIHVzZWZ1bCBpbiBTRU8gc2l0dWF0aW9uIG9yXG4gICAqIHdoZW4geW91IHdhbnQgdG8gbWF4aW1pemUgdGhlIHJlc3BvbnNpdmVuZXNzIG9mIHRoZSBQb3BwZXIuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBrZWVwTW91bnRlZDogYS5ib29sLFxuICAvKipcbiAgICogUG9wcGVyLmpzIGlzIGJhc2VkIG9uIGEgXCJwbHVnaW4tbGlrZVwiIGFyY2hpdGVjdHVyZSxcbiAgICogbW9zdCBvZiBpdHMgZmVhdHVyZXMgYXJlIGZ1bGx5IGVuY2Fwc3VsYXRlZCBcIm1vZGlmaWVyc1wiLlxuICAgKlxuICAgKiBBIG1vZGlmaWVyIGlzIGEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZWFjaCB0aW1lIFBvcHBlci5qcyBuZWVkcyB0b1xuICAgKiBjb21wdXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLlxuICAgKiBGb3IgdGhpcyByZWFzb24sIG1vZGlmaWVycyBzaG91bGQgYmUgdmVyeSBwZXJmb3JtYW50IHRvIGF2b2lkIGJvdHRsZW5lY2tzLlxuICAgKiBUbyBsZWFybiBob3cgdG8gY3JlYXRlIGEgbW9kaWZpZXIsIFtyZWFkIHRoZSBtb2RpZmllcnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9wb3BwZXIuanMub3JnL2RvY3MvdjIvbW9kaWZpZXJzLykuXG4gICAqL1xuICBtb2RpZmllcnM6IGEuYXJyYXlPZihhLnNoYXBlKHtcbiAgICBkYXRhOiBhLm9iamVjdCxcbiAgICBlZmZlY3Q6IGEuZnVuYyxcbiAgICBlbmFibGVkOiBhLmJvb2wsXG4gICAgZm46IGEuZnVuYyxcbiAgICBuYW1lOiBhLmFueSxcbiAgICBvcHRpb25zOiBhLm9iamVjdCxcbiAgICBwaGFzZTogYS5vbmVPZihbXCJhZnRlck1haW5cIiwgXCJhZnRlclJlYWRcIiwgXCJhZnRlcldyaXRlXCIsIFwiYmVmb3JlTWFpblwiLCBcImJlZm9yZVJlYWRcIiwgXCJiZWZvcmVXcml0ZVwiLCBcIm1haW5cIiwgXCJyZWFkXCIsIFwid3JpdGVcIl0pLFxuICAgIHJlcXVpcmVzOiBhLmFycmF5T2YoYS5zdHJpbmcpLFxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IGEuYXJyYXlPZihhLnN0cmluZylcbiAgfSkpLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IGlzIHNob3duLlxuICAgKi9cbiAgb3BlbjogYS5ib29sLmlzUmVxdWlyZWQsXG4gIC8qKlxuICAgKiBQb3BwZXIgcGxhY2VtZW50LlxuICAgKiBAZGVmYXVsdCAnYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiBhLm9uZU9mKFtcImF1dG8tZW5kXCIsIFwiYXV0by1zdGFydFwiLCBcImF1dG9cIiwgXCJib3R0b20tZW5kXCIsIFwiYm90dG9tLXN0YXJ0XCIsIFwiYm90dG9tXCIsIFwibGVmdC1lbmRcIiwgXCJsZWZ0LXN0YXJ0XCIsIFwibGVmdFwiLCBcInJpZ2h0LWVuZFwiLCBcInJpZ2h0LXN0YXJ0XCIsIFwicmlnaHRcIiwgXCJ0b3AtZW5kXCIsIFwidG9wLXN0YXJ0XCIsIFwidG9wXCJdKSxcbiAgLyoqXG4gICAqIE9wdGlvbnMgcHJvdmlkZWQgdG8gdGhlIFtgUG9wcGVyLmpzYF0oaHR0cHM6Ly9wb3BwZXIuanMub3JnL2RvY3MvdjIvY29uc3RydWN0b3JzLyNvcHRpb25zKSBpbnN0YW5jZS5cbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIHBvcHBlck9wdGlvbnM6IGEuc2hhcGUoe1xuICAgIG1vZGlmaWVyczogYS5hcnJheSxcbiAgICBvbkZpcnN0VXBkYXRlOiBhLmZ1bmMsXG4gICAgcGxhY2VtZW50OiBhLm9uZU9mKFtcImF1dG8tZW5kXCIsIFwiYXV0by1zdGFydFwiLCBcImF1dG9cIiwgXCJib3R0b20tZW5kXCIsIFwiYm90dG9tLXN0YXJ0XCIsIFwiYm90dG9tXCIsIFwibGVmdC1lbmRcIiwgXCJsZWZ0LXN0YXJ0XCIsIFwibGVmdFwiLCBcInJpZ2h0LWVuZFwiLCBcInJpZ2h0LXN0YXJ0XCIsIFwicmlnaHRcIiwgXCJ0b3AtZW5kXCIsIFwidG9wLXN0YXJ0XCIsIFwidG9wXCJdKSxcbiAgICBzdHJhdGVneTogYS5vbmVPZihbXCJhYnNvbHV0ZVwiLCBcImZpeGVkXCJdKVxuICB9KSxcbiAgLyoqXG4gICAqIEEgcmVmIHRoYXQgcG9pbnRzIHRvIHRoZSB1c2VkIHBvcHBlciBpbnN0YW5jZS5cbiAgICovXG4gIHBvcHBlclJlZjogTG8sXG4gIC8qKlxuICAgKiBUaGUgcHJvcHMgdXNlZCBmb3IgZWFjaCBzbG90IGluc2lkZSB0aGUgUG9wcGVyLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgc2xvdFByb3BzOiBhLnNoYXBlKHtcbiAgICByb290OiBhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdF0pXG4gIH0pLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudHMgdXNlZCBmb3IgZWFjaCBzbG90IGluc2lkZSB0aGUgUG9wcGVyLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgc2xvdHM6IGEuc2hhcGUoe1xuICAgIHJvb3Q6IGEuZWxlbWVudFR5cGVcbiAgfSksXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHByb3AgdGhhdCBhbGxvd3MgZGVmaW5pbmcgc3lzdGVtIG92ZXJyaWRlcyBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHN4OiBhLm9uZU9mVHlwZShbYS5hcnJheU9mKGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0LCBhLmJvb2xdKSksIGEuZnVuYywgYS5vYmplY3RdKSxcbiAgLyoqXG4gICAqIEhlbHAgc3VwcG9ydGluZyBhIHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAvVHJhbnNpdGlvbiBjb21wb25lbnQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB0cmFuc2l0aW9uOiBhLmJvb2xcbn0pO1xuZnVuY3Rpb24gSnAoZSkge1xuICByZXR1cm4gVmUoXCJNdWlMaXN0U3ViaGVhZGVyXCIsIGUpO1xufVxuRmUoXCJNdWlMaXN0U3ViaGVhZGVyXCIsIFtcInJvb3RcIiwgXCJjb2xvclByaW1hcnlcIiwgXCJjb2xvckluaGVyaXRcIiwgXCJndXR0ZXJzXCIsIFwiaW5zZXRcIiwgXCJzdGlja3lcIl0pO1xuY29uc3QgUXAgPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xhc3NlczogdCxcbiAgICBjb2xvcjogcixcbiAgICBkaXNhYmxlR3V0dGVyczogbixcbiAgICBpbnNldDogbyxcbiAgICBkaXNhYmxlU3RpY2t5OiBpXG4gIH0gPSBlLCBzID0ge1xuICAgIHJvb3Q6IFtcInJvb3RcIiwgciAhPT0gXCJkZWZhdWx0XCIgJiYgYGNvbG9yJHtlZShyKX1gLCAhbiAmJiBcImd1dHRlcnNcIiwgbyAmJiBcImluc2V0XCIsICFpICYmIFwic3RpY2t5XCJdXG4gIH07XG4gIHJldHVybiBHZShzLCBKcCwgdCk7XG59LCBacCA9IGxlKFwibGlcIiwge1xuICBuYW1lOiBcIk11aUxpc3RTdWJoZWFkZXJcIixcbiAgc2xvdDogXCJSb290XCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyU3RhdGU6IHJcbiAgICB9ID0gZTtcbiAgICByZXR1cm4gW3Qucm9vdCwgci5jb2xvciAhPT0gXCJkZWZhdWx0XCIgJiYgdFtgY29sb3Ike2VlKHIuY29sb3IpfWBdLCAhci5kaXNhYmxlR3V0dGVycyAmJiB0Lmd1dHRlcnMsIHIuaW5zZXQgJiYgdC5pbnNldCwgIXIuZGlzYWJsZVN0aWNreSAmJiB0LnN0aWNreV07XG4gIH1cbn0pKHFlKCh7XG4gIHRoZW1lOiBlXG59KSA9PiAoe1xuICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICBsaW5lSGVpZ2h0OiBcIjQ4cHhcIixcbiAgbGlzdFN0eWxlOiBcIm5vbmVcIixcbiAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS50ZXh0LnNlY29uZGFyeSxcbiAgZm9udEZhbWlseTogZS50eXBvZ3JhcGh5LmZvbnRGYW1pbHksXG4gIGZvbnRXZWlnaHQ6IGUudHlwb2dyYXBoeS5mb250V2VpZ2h0TWVkaXVtLFxuICBmb250U2l6ZTogZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTQpLFxuICB2YXJpYW50czogW3tcbiAgICBwcm9wczoge1xuICAgICAgY29sb3I6IFwicHJpbWFyeVwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5wcmltYXJ5Lm1haW5cbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgY29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiB0XG4gICAgfSkgPT4gIXQuZGlzYWJsZUd1dHRlcnMsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAxNixcbiAgICAgIHBhZGRpbmdSaWdodDogMTZcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiB0Lmluc2V0LFxuICAgIHN0eWxlOiB7XG4gICAgICBwYWRkaW5nTGVmdDogNzJcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiAhdC5kaXNhYmxlU3RpY2t5LFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogXCJzdGlja3lcIixcbiAgICAgIHRvcDogMCxcbiAgICAgIHpJbmRleDogMSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLmJhY2tncm91bmQucGFwZXJcbiAgICB9XG4gIH1dXG59KSkpLCB3biA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCBuID0gSGUoe1xuICAgIHByb3BzOiB0LFxuICAgIG5hbWU6IFwiTXVpTGlzdFN1YmhlYWRlclwiXG4gIH0pLCB7XG4gICAgY2xhc3NOYW1lOiBvLFxuICAgIGNvbG9yOiBpID0gXCJkZWZhdWx0XCIsXG4gICAgY29tcG9uZW50OiBzID0gXCJsaVwiLFxuICAgIGRpc2FibGVHdXR0ZXJzOiBjID0gITEsXG4gICAgZGlzYWJsZVN0aWNreTogbCA9ICExLFxuICAgIGluc2V0OiB1ID0gITEsXG4gICAgLi4ucFxuICB9ID0gbiwgbSA9IHtcbiAgICAuLi5uLFxuICAgIGNvbG9yOiBpLFxuICAgIGNvbXBvbmVudDogcyxcbiAgICBkaXNhYmxlR3V0dGVyczogYyxcbiAgICBkaXNhYmxlU3RpY2t5OiBsLFxuICAgIGluc2V0OiB1XG4gIH0sIGcgPSBRcChtKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChacCwge1xuICAgIGFzOiBzLFxuICAgIGNsYXNzTmFtZTogc2UoZy5yb290LCBvKSxcbiAgICByZWY6IHIsXG4gICAgb3duZXJTdGF0ZTogbSxcbiAgICAuLi5wXG4gIH0pO1xufSk7XG53biAmJiAod24ubXVpU2tpcExpc3RIaWdobGlnaHQgPSAhMCk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHduLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgICAgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LiBJdCBzdXBwb3J0cyB0aG9zZSB0aGVtZSBjb2xvcnMgdGhhdCBtYWtlIHNlbnNlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICogQGRlZmF1bHQgJ2RlZmF1bHQnXG4gICAqL1xuICBjb2xvcjogYS5vbmVPZihbXCJkZWZhdWx0XCIsIFwiaW5oZXJpdFwiLCBcInByaW1hcnlcIl0pLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgY29tcG9uZW50OiBhLmVsZW1lbnRUeXBlLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgTGlzdCBTdWJoZWFkZXIgd2lsbCBub3QgaGF2ZSBndXR0ZXJzLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZUd1dHRlcnM6IGEuYm9vbCxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIExpc3QgU3ViaGVhZGVyIHdpbGwgbm90IHN0aWNrIHRvIHRoZSB0b3AgZHVyaW5nIHNjcm9sbC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVTdGlja3k6IGEuYm9vbCxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIExpc3QgU3ViaGVhZGVyIGlzIGluZGVudGVkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaW5zZXQ6IGEuYm9vbCxcbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gcHJvcCB0aGF0IGFsbG93cyBkZWZpbmluZyBzeXN0ZW0gb3ZlcnJpZGVzIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgc3g6IGEub25lT2ZUeXBlKFthLmFycmF5T2YoYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3QsIGEuYm9vbF0pKSwgYS5mdW5jLCBhLm9iamVjdF0pXG59KTtcbmNvbnN0IGVtID0gc3IoLyogQF9fUFVSRV9fICovIE4uanN4KFwicGF0aFwiLCB7XG4gIGQ6IFwiTTEyIDJDNi40NyAyIDIgNi40NyAyIDEyczQuNDcgMTAgMTAgMTAgMTAtNC40NyAxMC0xMFMxNy41MyAyIDEyIDJ6bTUgMTMuNTlMMTUuNTkgMTcgMTIgMTMuNDEgOC40MSAxNyA3IDE1LjU5IDEwLjU5IDEyIDcgOC40MSA4LjQxIDcgMTIgMTAuNTkgMTUuNTkgNyAxNyA4LjQxIDEzLjQxIDEyIDE3IDE1LjU5elwiXG59KSwgXCJDYW5jZWxcIik7XG5mdW5jdGlvbiB0bShlKSB7XG4gIHJldHVybiBWZShcIk11aUNoaXBcIiwgZSk7XG59XG5jb25zdCBpZSA9IEZlKFwiTXVpQ2hpcFwiLCBbXCJyb290XCIsIFwic2l6ZVNtYWxsXCIsIFwic2l6ZU1lZGl1bVwiLCBcImNvbG9yRGVmYXVsdFwiLCBcImNvbG9yRXJyb3JcIiwgXCJjb2xvckluZm9cIiwgXCJjb2xvclByaW1hcnlcIiwgXCJjb2xvclNlY29uZGFyeVwiLCBcImNvbG9yU3VjY2Vzc1wiLCBcImNvbG9yV2FybmluZ1wiLCBcImRpc2FibGVkXCIsIFwiY2xpY2thYmxlXCIsIFwiY2xpY2thYmxlQ29sb3JQcmltYXJ5XCIsIFwiY2xpY2thYmxlQ29sb3JTZWNvbmRhcnlcIiwgXCJkZWxldGFibGVcIiwgXCJkZWxldGFibGVDb2xvclByaW1hcnlcIiwgXCJkZWxldGFibGVDb2xvclNlY29uZGFyeVwiLCBcIm91dGxpbmVkXCIsIFwiZmlsbGVkXCIsIFwib3V0bGluZWRQcmltYXJ5XCIsIFwib3V0bGluZWRTZWNvbmRhcnlcIiwgXCJmaWxsZWRQcmltYXJ5XCIsIFwiZmlsbGVkU2Vjb25kYXJ5XCIsIFwiYXZhdGFyXCIsIFwiYXZhdGFyU21hbGxcIiwgXCJhdmF0YXJNZWRpdW1cIiwgXCJhdmF0YXJDb2xvclByaW1hcnlcIiwgXCJhdmF0YXJDb2xvclNlY29uZGFyeVwiLCBcImljb25cIiwgXCJpY29uU21hbGxcIiwgXCJpY29uTWVkaXVtXCIsIFwiaWNvbkNvbG9yUHJpbWFyeVwiLCBcImljb25Db2xvclNlY29uZGFyeVwiLCBcImxhYmVsXCIsIFwibGFiZWxTbWFsbFwiLCBcImxhYmVsTWVkaXVtXCIsIFwiZGVsZXRlSWNvblwiLCBcImRlbGV0ZUljb25TbWFsbFwiLCBcImRlbGV0ZUljb25NZWRpdW1cIiwgXCJkZWxldGVJY29uQ29sb3JQcmltYXJ5XCIsIFwiZGVsZXRlSWNvbkNvbG9yU2Vjb25kYXJ5XCIsIFwiZGVsZXRlSWNvbk91dGxpbmVkQ29sb3JQcmltYXJ5XCIsIFwiZGVsZXRlSWNvbk91dGxpbmVkQ29sb3JTZWNvbmRhcnlcIiwgXCJkZWxldGVJY29uRmlsbGVkQ29sb3JQcmltYXJ5XCIsIFwiZGVsZXRlSWNvbkZpbGxlZENvbG9yU2Vjb25kYXJ5XCIsIFwiZm9jdXNWaXNpYmxlXCJdKSwgcm0gPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xhc3NlczogdCxcbiAgICBkaXNhYmxlZDogcixcbiAgICBzaXplOiBuLFxuICAgIGNvbG9yOiBvLFxuICAgIGljb25Db2xvcjogaSxcbiAgICBvbkRlbGV0ZTogcyxcbiAgICBjbGlja2FibGU6IGMsXG4gICAgdmFyaWFudDogbFxuICB9ID0gZSwgdSA9IHtcbiAgICByb290OiBbXCJyb290XCIsIGwsIHIgJiYgXCJkaXNhYmxlZFwiLCBgc2l6ZSR7ZWUobil9YCwgYGNvbG9yJHtlZShvKX1gLCBjICYmIFwiY2xpY2thYmxlXCIsIGMgJiYgYGNsaWNrYWJsZUNvbG9yJHtlZShvKX1gLCBzICYmIFwiZGVsZXRhYmxlXCIsIHMgJiYgYGRlbGV0YWJsZUNvbG9yJHtlZShvKX1gLCBgJHtsfSR7ZWUobyl9YF0sXG4gICAgbGFiZWw6IFtcImxhYmVsXCIsIGBsYWJlbCR7ZWUobil9YF0sXG4gICAgYXZhdGFyOiBbXCJhdmF0YXJcIiwgYGF2YXRhciR7ZWUobil9YCwgYGF2YXRhckNvbG9yJHtlZShvKX1gXSxcbiAgICBpY29uOiBbXCJpY29uXCIsIGBpY29uJHtlZShuKX1gLCBgaWNvbkNvbG9yJHtlZShpKX1gXSxcbiAgICBkZWxldGVJY29uOiBbXCJkZWxldGVJY29uXCIsIGBkZWxldGVJY29uJHtlZShuKX1gLCBgZGVsZXRlSWNvbkNvbG9yJHtlZShvKX1gLCBgZGVsZXRlSWNvbiR7ZWUobCl9Q29sb3Ike2VlKG8pfWBdXG4gIH07XG4gIHJldHVybiBHZSh1LCB0bSwgdCk7XG59LCBubSA9IGxlKFwiZGl2XCIsIHtcbiAgbmFtZTogXCJNdWlDaGlwXCIsXG4gIHNsb3Q6IFwiUm9vdFwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lclN0YXRlOiByXG4gICAgfSA9IGUsIHtcbiAgICAgIGNvbG9yOiBuLFxuICAgICAgaWNvbkNvbG9yOiBvLFxuICAgICAgY2xpY2thYmxlOiBpLFxuICAgICAgb25EZWxldGU6IHMsXG4gICAgICBzaXplOiBjLFxuICAgICAgdmFyaWFudDogbFxuICAgIH0gPSByO1xuICAgIHJldHVybiBbe1xuICAgICAgW2AmIC4ke2llLmF2YXRhcn1gXTogdC5hdmF0YXJcbiAgICB9LCB7XG4gICAgICBbYCYgLiR7aWUuYXZhdGFyfWBdOiB0W2BhdmF0YXIke2VlKGMpfWBdXG4gICAgfSwge1xuICAgICAgW2AmIC4ke2llLmF2YXRhcn1gXTogdFtgYXZhdGFyQ29sb3Ike2VlKG4pfWBdXG4gICAgfSwge1xuICAgICAgW2AmIC4ke2llLmljb259YF06IHQuaWNvblxuICAgIH0sIHtcbiAgICAgIFtgJiAuJHtpZS5pY29ufWBdOiB0W2BpY29uJHtlZShjKX1gXVxuICAgIH0sIHtcbiAgICAgIFtgJiAuJHtpZS5pY29ufWBdOiB0W2BpY29uQ29sb3Ike2VlKG8pfWBdXG4gICAgfSwge1xuICAgICAgW2AmIC4ke2llLmRlbGV0ZUljb259YF06IHQuZGVsZXRlSWNvblxuICAgIH0sIHtcbiAgICAgIFtgJiAuJHtpZS5kZWxldGVJY29ufWBdOiB0W2BkZWxldGVJY29uJHtlZShjKX1gXVxuICAgIH0sIHtcbiAgICAgIFtgJiAuJHtpZS5kZWxldGVJY29ufWBdOiB0W2BkZWxldGVJY29uQ29sb3Ike2VlKG4pfWBdXG4gICAgfSwge1xuICAgICAgW2AmIC4ke2llLmRlbGV0ZUljb259YF06IHRbYGRlbGV0ZUljb24ke2VlKGwpfUNvbG9yJHtlZShuKX1gXVxuICAgIH0sIHQucm9vdCwgdFtgc2l6ZSR7ZWUoYyl9YF0sIHRbYGNvbG9yJHtlZShuKX1gXSwgaSAmJiB0LmNsaWNrYWJsZSwgaSAmJiBuICE9PSBcImRlZmF1bHRcIiAmJiB0W2BjbGlja2FibGVDb2xvciR7ZWUobil9KWBdLCBzICYmIHQuZGVsZXRhYmxlLCBzICYmIG4gIT09IFwiZGVmYXVsdFwiICYmIHRbYGRlbGV0YWJsZUNvbG9yJHtlZShuKX1gXSwgdFtsXSwgdFtgJHtsfSR7ZWUobil9YF1dO1xuICB9XG59KShxZSgoe1xuICB0aGVtZTogZVxufSkgPT4ge1xuICBjb25zdCB0ID0gZS5wYWxldHRlLm1vZGUgPT09IFwibGlnaHRcIiA/IGUucGFsZXR0ZS5ncmV5WzcwMF0gOiBlLnBhbGV0dGUuZ3JleVszMDBdO1xuICByZXR1cm4ge1xuICAgIG1heFdpZHRoOiBcIjEwMCVcIixcbiAgICBmb250RmFtaWx5OiBlLnR5cG9ncmFwaHkuZm9udEZhbWlseSxcbiAgICBmb250U2l6ZTogZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTMpLFxuICAgIGRpc3BsYXk6IFwiaW5saW5lLWZsZXhcIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgIGhlaWdodDogMzIsXG4gICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS50ZXh0LnByaW1hcnksXG4gICAgYmFja2dyb3VuZENvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkLFxuICAgIGJvcmRlclJhZGl1czogMzIgLyAyLFxuICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gICAgdHJhbnNpdGlvbjogZS50cmFuc2l0aW9ucy5jcmVhdGUoW1wiYmFja2dyb3VuZC1jb2xvclwiLCBcImJveC1zaGFkb3dcIl0pLFxuICAgIC8vIHJlc2V0IGN1cnNvciBleHBsaWNpdGx5IGluIGNhc2UgQnV0dG9uQmFzZSBpcyB1c2VkXG4gICAgY3Vyc29yOiBcInVuc2V0XCIsXG4gICAgLy8gV2UgZGlzYWJsZSB0aGUgZm9jdXMgcmluZyBmb3IgbW91c2UsIHRvdWNoIGFuZCBrZXlib2FyZCB1c2Vycy5cbiAgICBvdXRsaW5lOiAwLFxuICAgIHRleHREZWNvcmF0aW9uOiBcIm5vbmVcIixcbiAgICBib3JkZXI6IDAsXG4gICAgLy8gUmVtb3ZlIGBidXR0b25gIGJvcmRlclxuICAgIHBhZGRpbmc6IDAsXG4gICAgLy8gUmVtb3ZlIGBidXR0b25gIHBhZGRpbmdcbiAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgW2AmLiR7aWUuZGlzYWJsZWR9YF06IHtcbiAgICAgIG9wYWNpdHk6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRPcGFjaXR5LFxuICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICB9LFxuICAgIFtgJiAuJHtpZS5hdmF0YXJ9YF06IHtcbiAgICAgIG1hcmdpbkxlZnQ6IDUsXG4gICAgICBtYXJnaW5SaWdodDogLTYsXG4gICAgICB3aWR0aDogMjQsXG4gICAgICBoZWlnaHQ6IDI0LFxuICAgICAgY29sb3I6IGUudmFycyA/IGUudmFycy5wYWxldHRlLkNoaXAuZGVmYXVsdEF2YXRhckNvbG9yIDogdCxcbiAgICAgIGZvbnRTaXplOiBlLnR5cG9ncmFwaHkucHhUb1JlbSgxMilcbiAgICB9LFxuICAgIFtgJiAuJHtpZS5hdmF0YXJDb2xvclByaW1hcnl9YF06IHtcbiAgICAgIGNvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGUucHJpbWFyeS5jb250cmFzdFRleHQsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5wcmltYXJ5LmRhcmtcbiAgICB9LFxuICAgIFtgJiAuJHtpZS5hdmF0YXJDb2xvclNlY29uZGFyeX1gXToge1xuICAgICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5zZWNvbmRhcnkuY29udHJhc3RUZXh0LFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGUuc2Vjb25kYXJ5LmRhcmtcbiAgICB9LFxuICAgIFtgJiAuJHtpZS5hdmF0YXJTbWFsbH1gXToge1xuICAgICAgbWFyZ2luTGVmdDogNCxcbiAgICAgIG1hcmdpblJpZ2h0OiAtNCxcbiAgICAgIHdpZHRoOiAxOCxcbiAgICAgIGhlaWdodDogMTgsXG4gICAgICBmb250U2l6ZTogZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTApXG4gICAgfSxcbiAgICBbYCYgLiR7aWUuaWNvbn1gXToge1xuICAgICAgbWFyZ2luTGVmdDogNSxcbiAgICAgIG1hcmdpblJpZ2h0OiAtNlxuICAgIH0sXG4gICAgW2AmIC4ke2llLmRlbGV0ZUljb259YF06IHtcbiAgICAgIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICBjb2xvcjogZS52YXJzID8gYHJnYmEoJHtlLnZhcnMucGFsZXR0ZS50ZXh0LnByaW1hcnlDaGFubmVsfSAvIDAuMjYpYCA6IERlKGUucGFsZXR0ZS50ZXh0LnByaW1hcnksIDAuMjYpLFxuICAgICAgZm9udFNpemU6IDIyLFxuICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgIG1hcmdpbjogXCIwIDVweCAwIC02cHhcIixcbiAgICAgIFwiJjpob3ZlclwiOiB7XG4gICAgICAgIGNvbG9yOiBlLnZhcnMgPyBgcmdiYSgke2UudmFycy5wYWxldHRlLnRleHQucHJpbWFyeUNoYW5uZWx9IC8gMC40KWAgOiBEZShlLnBhbGV0dGUudGV4dC5wcmltYXJ5LCAwLjQpXG4gICAgICB9XG4gICAgfSxcbiAgICB2YXJpYW50czogW3tcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHNpemU6IFwic21hbGxcIlxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGhlaWdodDogMjQsXG4gICAgICAgIFtgJiAuJHtpZS5pY29ufWBdOiB7XG4gICAgICAgICAgZm9udFNpemU6IDE4LFxuICAgICAgICAgIG1hcmdpbkxlZnQ6IDQsXG4gICAgICAgICAgbWFyZ2luUmlnaHQ6IC00XG4gICAgICAgIH0sXG4gICAgICAgIFtgJiAuJHtpZS5kZWxldGVJY29ufWBdOiB7XG4gICAgICAgICAgZm9udFNpemU6IDE2LFxuICAgICAgICAgIG1hcmdpblJpZ2h0OiA0LFxuICAgICAgICAgIG1hcmdpbkxlZnQ6IC00XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAuLi5PYmplY3QuZW50cmllcyhlLnBhbGV0dGUpLmZpbHRlcihQdChbXCJjb250cmFzdFRleHRcIl0pKS5tYXAoKFtyXSkgPT4gKHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiByXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGVbcl0ubWFpbixcbiAgICAgICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZVtyXS5jb250cmFzdFRleHQsXG4gICAgICAgIFtgJiAuJHtpZS5kZWxldGVJY29ufWBdOiB7XG4gICAgICAgICAgY29sb3I6IGUudmFycyA/IGByZ2JhKCR7ZS52YXJzLnBhbGV0dGVbcl0uY29udHJhc3RUZXh0Q2hhbm5lbH0gLyAwLjcpYCA6IERlKGUucGFsZXR0ZVtyXS5jb250cmFzdFRleHQsIDAuNyksXG4gICAgICAgICAgXCImOmhvdmVyLCAmOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlW3JdLmNvbnRyYXN0VGV4dFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKSwge1xuICAgICAgcHJvcHM6IChyKSA9PiByLmljb25Db2xvciA9PT0gci5jb2xvcixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIFtgJiAuJHtpZS5pY29ufWBdOiB7XG4gICAgICAgICAgY29sb3I6IGUudmFycyA/IGUudmFycy5wYWxldHRlLkNoaXAuZGVmYXVsdEljb25Db2xvciA6IHRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHByb3BzOiAocikgPT4gci5pY29uQ29sb3IgPT09IHIuY29sb3IgJiYgci5jb2xvciAhPT0gXCJkZWZhdWx0XCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICBbYCYgLiR7aWUuaWNvbn1gXToge1xuICAgICAgICAgIGNvbG9yOiBcImluaGVyaXRcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgb25EZWxldGU6ICEwXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgW2AmLiR7aWUuZm9jdXNWaXNpYmxlfWBdOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLnZhcnMgPyBgcmdiYSgke2UudmFycy5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZENoYW5uZWx9IC8gY2FsYygke2UudmFycy5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHl9ICsgJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uZm9jdXNPcGFjaXR5fSkpYCA6IERlKGUucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWQsIGUucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRPcGFjaXR5ICsgZS5wYWxldHRlLmFjdGlvbi5mb2N1c09wYWNpdHkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAuLi5PYmplY3QuZW50cmllcyhlLnBhbGV0dGUpLmZpbHRlcihQdChbXCJkYXJrXCJdKSkubWFwKChbcl0pID0+ICh7XG4gICAgICBwcm9wczoge1xuICAgICAgICBjb2xvcjogcixcbiAgICAgICAgb25EZWxldGU6ICEwXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgW2AmLiR7aWUuZm9jdXNWaXNpYmxlfWBdOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogKGUudmFycyB8fCBlKS5wYWxldHRlW3JdLmRhcmtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKSwge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xpY2thYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICAgICAgICBXZWJraXRUYXBIaWdobGlnaHRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICBcIiY6aG92ZXJcIjoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS52YXJzID8gYHJnYmEoJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRDaGFubmVsfSAvIGNhbGMoJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRPcGFjaXR5fSArICR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eX0pKWAgOiBEZShlLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkLCBlLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkT3BhY2l0eSArIGUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KVxuICAgICAgICB9LFxuICAgICAgICBbYCYuJHtpZS5mb2N1c1Zpc2libGV9YF06IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUudmFycyA/IGByZ2JhKCR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkQ2hhbm5lbH0gLyBjYWxjKCR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkT3BhY2l0eX0gKyAke2UudmFycy5wYWxldHRlLmFjdGlvbi5mb2N1c09wYWNpdHl9KSlgIDogRGUoZS5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZCwgZS5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHkgKyBlLnBhbGV0dGUuYWN0aW9uLmZvY3VzT3BhY2l0eSlcbiAgICAgICAgfSxcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgYm94U2hhZG93OiAoZS52YXJzIHx8IGUpLnNoYWRvd3NbMV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIC4uLk9iamVjdC5lbnRyaWVzKGUucGFsZXR0ZSkuZmlsdGVyKFB0KFtcImRhcmtcIl0pKS5tYXAoKFtyXSkgPT4gKHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiByLFxuICAgICAgICBjbGlja2FibGU6ICEwXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgW2AmOmhvdmVyLCAmLiR7aWUuZm9jdXNWaXNpYmxlfWBdOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGVbcl0uZGFya1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpLCB7XG4gICAgICBwcm9wczoge1xuICAgICAgICB2YXJpYW50OiBcIm91dGxpbmVkXCJcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgYm9yZGVyOiBlLnZhcnMgPyBgMXB4IHNvbGlkICR7ZS52YXJzLnBhbGV0dGUuQ2hpcC5kZWZhdWx0Qm9yZGVyfWAgOiBgMXB4IHNvbGlkICR7ZS5wYWxldHRlLm1vZGUgPT09IFwibGlnaHRcIiA/IGUucGFsZXR0ZS5ncmV5WzQwMF0gOiBlLnBhbGV0dGUuZ3JleVs3MDBdfWAsXG4gICAgICAgIFtgJi4ke2llLmNsaWNrYWJsZX06aG92ZXJgXToge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLmFjdGlvbi5ob3ZlclxuICAgICAgICB9LFxuICAgICAgICBbYCYuJHtpZS5mb2N1c1Zpc2libGV9YF06IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5hY3Rpb24uZm9jdXNcbiAgICAgICAgfSxcbiAgICAgICAgW2AmIC4ke2llLmF2YXRhcn1gXToge1xuICAgICAgICAgIG1hcmdpbkxlZnQ6IDRcbiAgICAgICAgfSxcbiAgICAgICAgW2AmIC4ke2llLmF2YXRhclNtYWxsfWBdOiB7XG4gICAgICAgICAgbWFyZ2luTGVmdDogMlxuICAgICAgICB9LFxuICAgICAgICBbYCYgLiR7aWUuaWNvbn1gXToge1xuICAgICAgICAgIG1hcmdpbkxlZnQ6IDRcbiAgICAgICAgfSxcbiAgICAgICAgW2AmIC4ke2llLmljb25TbWFsbH1gXToge1xuICAgICAgICAgIG1hcmdpbkxlZnQ6IDJcbiAgICAgICAgfSxcbiAgICAgICAgW2AmIC4ke2llLmRlbGV0ZUljb259YF06IHtcbiAgICAgICAgICBtYXJnaW5SaWdodDogNVxuICAgICAgICB9LFxuICAgICAgICBbYCYgLiR7aWUuZGVsZXRlSWNvblNtYWxsfWBdOiB7XG4gICAgICAgICAgbWFyZ2luUmlnaHQ6IDNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIC4uLk9iamVjdC5lbnRyaWVzKGUucGFsZXR0ZSkuZmlsdGVyKFB0KCkpLm1hcCgoW3JdKSA9PiAoe1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdmFyaWFudDogXCJvdXRsaW5lZFwiLFxuICAgICAgICBjb2xvcjogclxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGVbcl0ubWFpbixcbiAgICAgICAgYm9yZGVyOiBgMXB4IHNvbGlkICR7ZS52YXJzID8gYHJnYmEoJHtlLnZhcnMucGFsZXR0ZVtyXS5tYWluQ2hhbm5lbH0gLyAwLjcpYCA6IERlKGUucGFsZXR0ZVtyXS5tYWluLCAwLjcpfWAsXG4gICAgICAgIFtgJi4ke2llLmNsaWNrYWJsZX06aG92ZXJgXToge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS52YXJzID8gYHJnYmEoJHtlLnZhcnMucGFsZXR0ZVtyXS5tYWluQ2hhbm5lbH0gLyAke2UudmFycy5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHl9KWAgOiBEZShlLnBhbGV0dGVbcl0ubWFpbiwgZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpXG4gICAgICAgIH0sXG4gICAgICAgIFtgJi4ke2llLmZvY3VzVmlzaWJsZX1gXToge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS52YXJzID8gYHJnYmEoJHtlLnZhcnMucGFsZXR0ZVtyXS5tYWluQ2hhbm5lbH0gLyAke2UudmFycy5wYWxldHRlLmFjdGlvbi5mb2N1c09wYWNpdHl9KWAgOiBEZShlLnBhbGV0dGVbcl0ubWFpbiwgZS5wYWxldHRlLmFjdGlvbi5mb2N1c09wYWNpdHkpXG4gICAgICAgIH0sXG4gICAgICAgIFtgJiAuJHtpZS5kZWxldGVJY29ufWBdOiB7XG4gICAgICAgICAgY29sb3I6IGUudmFycyA/IGByZ2JhKCR7ZS52YXJzLnBhbGV0dGVbcl0ubWFpbkNoYW5uZWx9IC8gMC43KWAgOiBEZShlLnBhbGV0dGVbcl0ubWFpbiwgMC43KSxcbiAgICAgICAgICBcIiY6aG92ZXIsICY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGNvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGVbcl0ubWFpblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKV1cbiAgfTtcbn0pKSwgb20gPSBsZShcInNwYW5cIiwge1xuICBuYW1lOiBcIk11aUNoaXBcIixcbiAgc2xvdDogXCJMYWJlbFwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lclN0YXRlOiByXG4gICAgfSA9IGUsIHtcbiAgICAgIHNpemU6IG5cbiAgICB9ID0gcjtcbiAgICByZXR1cm4gW3QubGFiZWwsIHRbYGxhYmVsJHtlZShuKX1gXV07XG4gIH1cbn0pKHtcbiAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiLFxuICBwYWRkaW5nTGVmdDogMTIsXG4gIHBhZGRpbmdSaWdodDogMTIsXG4gIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiB7XG4gICAgICB2YXJpYW50OiBcIm91dGxpbmVkXCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBwYWRkaW5nTGVmdDogMTEsXG4gICAgICBwYWRkaW5nUmlnaHQ6IDExXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHNpemU6IFwic21hbGxcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmdMZWZ0OiA4LFxuICAgICAgcGFkZGluZ1JpZ2h0OiA4XG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHNpemU6IFwic21hbGxcIixcbiAgICAgIHZhcmlhbnQ6IFwib3V0bGluZWRcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmdMZWZ0OiA3LFxuICAgICAgcGFkZGluZ1JpZ2h0OiA3XG4gICAgfVxuICB9XVxufSk7XG5mdW5jdGlvbiBiYShlKSB7XG4gIHJldHVybiBlLmtleSA9PT0gXCJCYWNrc3BhY2VcIiB8fCBlLmtleSA9PT0gXCJEZWxldGVcIjtcbn1cbmNvbnN0IElzID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IG4gPSBIZSh7XG4gICAgcHJvcHM6IHQsXG4gICAgbmFtZTogXCJNdWlDaGlwXCJcbiAgfSksIHtcbiAgICBhdmF0YXI6IG8sXG4gICAgY2xhc3NOYW1lOiBpLFxuICAgIGNsaWNrYWJsZTogcyxcbiAgICBjb2xvcjogYyA9IFwiZGVmYXVsdFwiLFxuICAgIGNvbXBvbmVudDogbCxcbiAgICBkZWxldGVJY29uOiB1LFxuICAgIGRpc2FibGVkOiBwID0gITEsXG4gICAgaWNvbjogbSxcbiAgICBsYWJlbDogZyxcbiAgICBvbkNsaWNrOiB4LFxuICAgIG9uRGVsZXRlOiB5LFxuICAgIG9uS2V5RG93bjogZixcbiAgICBvbktleVVwOiBTLFxuICAgIHNpemU6IEUgPSBcIm1lZGl1bVwiLFxuICAgIHZhcmlhbnQ6IFAgPSBcImZpbGxlZFwiLFxuICAgIHRhYkluZGV4OiBULFxuICAgIHNraXBGb2N1c1doZW5EaXNhYmxlZDogYiA9ICExLFxuICAgIC8vIFRPRE8gdjY6IFJlbmFtZSB0byBgZm9jdXNhYmxlV2hlbkRpc2FibGVkYC5cbiAgICAuLi5oXG4gIH0gPSBuLCB3ID0gQy51c2VSZWYobnVsbCksIGsgPSBhdCh3LCByKSwgTCA9IChGKSA9PiB7XG4gICAgRi5zdG9wUHJvcGFnYXRpb24oKSwgeSAmJiB5KEYpO1xuICB9LCBCID0gKEYpID0+IHtcbiAgICBGLmN1cnJlbnRUYXJnZXQgPT09IEYudGFyZ2V0ICYmIGJhKEYpICYmIEYucHJldmVudERlZmF1bHQoKSwgZiAmJiBmKEYpO1xuICB9LCBkID0gKEYpID0+IHtcbiAgICBGLmN1cnJlbnRUYXJnZXQgPT09IEYudGFyZ2V0ICYmIHkgJiYgYmEoRikgJiYgeShGKSwgUyAmJiBTKEYpO1xuICB9LCBBID0gcyAhPT0gITEgJiYgeCA/ICEwIDogcywgRCA9IEEgfHwgeSA/ICRyIDogbCB8fCBcImRpdlwiLCBqID0ge1xuICAgIC4uLm4sXG4gICAgY29tcG9uZW50OiBELFxuICAgIGRpc2FibGVkOiBwLFxuICAgIHNpemU6IEUsXG4gICAgY29sb3I6IGMsXG4gICAgaWNvbkNvbG9yOiAvKiBAX19QVVJFX18gKi8gQy5pc1ZhbGlkRWxlbWVudChtKSAmJiBtLnByb3BzLmNvbG9yIHx8IGMsXG4gICAgb25EZWxldGU6ICEheSxcbiAgICBjbGlja2FibGU6IEEsXG4gICAgdmFyaWFudDogUFxuICB9LCBXID0gcm0oaiksIHogPSBEID09PSAkciA/IHtcbiAgICBjb21wb25lbnQ6IGwgfHwgXCJkaXZcIixcbiAgICBmb2N1c1Zpc2libGVDbGFzc05hbWU6IFcuZm9jdXNWaXNpYmxlLFxuICAgIC4uLnkgJiYge1xuICAgICAgZGlzYWJsZVJpcHBsZTogITBcbiAgICB9XG4gIH0gOiB7fTtcbiAgbGV0IFUgPSBudWxsO1xuICB5ICYmIChVID0gdSAmJiAvKiBAX19QVVJFX18gKi8gQy5pc1ZhbGlkRWxlbWVudCh1KSA/IC8qIEBfX1BVUkVfXyAqLyBDLmNsb25lRWxlbWVudCh1LCB7XG4gICAgY2xhc3NOYW1lOiBzZSh1LnByb3BzLmNsYXNzTmFtZSwgVy5kZWxldGVJY29uKSxcbiAgICBvbkNsaWNrOiBMXG4gIH0pIDogLyogQF9fUFVSRV9fICovIE4uanN4KGVtLCB7XG4gICAgY2xhc3NOYW1lOiBzZShXLmRlbGV0ZUljb24pLFxuICAgIG9uQ2xpY2s6IExcbiAgfSkpO1xuICBsZXQgViA9IG51bGw7XG4gIG8gJiYgLyogQF9fUFVSRV9fICovIEMuaXNWYWxpZEVsZW1lbnQobykgJiYgKFYgPSAvKiBAX19QVVJFX18gKi8gQy5jbG9uZUVsZW1lbnQobywge1xuICAgIGNsYXNzTmFtZTogc2UoVy5hdmF0YXIsIG8ucHJvcHMuY2xhc3NOYW1lKVxuICB9KSk7XG4gIGxldCB0ZSA9IG51bGw7XG4gIHJldHVybiBtICYmIC8qIEBfX1BVUkVfXyAqLyBDLmlzVmFsaWRFbGVtZW50KG0pICYmICh0ZSA9IC8qIEBfX1BVUkVfXyAqLyBDLmNsb25lRWxlbWVudChtLCB7XG4gICAgY2xhc3NOYW1lOiBzZShXLmljb24sIG0ucHJvcHMuY2xhc3NOYW1lKVxuICB9KSksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBWICYmIHRlICYmIGNvbnNvbGUuZXJyb3IoXCJNVUk6IFRoZSBDaGlwIGNvbXBvbmVudCBjYW4gbm90IGhhbmRsZSB0aGUgYXZhdGFyIGFuZCB0aGUgaWNvbiBwcm9wIGF0IHRoZSBzYW1lIHRpbWUuIFBpY2sgb25lLlwiKSwgLyogQF9fUFVSRV9fICovIE4uanN4cyhubSwge1xuICAgIGFzOiBELFxuICAgIGNsYXNzTmFtZTogc2UoVy5yb290LCBpKSxcbiAgICBkaXNhYmxlZDogQSAmJiBwID8gITAgOiB2b2lkIDAsXG4gICAgb25DbGljazogeCxcbiAgICBvbktleURvd246IEIsXG4gICAgb25LZXlVcDogZCxcbiAgICByZWY6IGssXG4gICAgdGFiSW5kZXg6IGIgJiYgcCA/IC0xIDogVCxcbiAgICBvd25lclN0YXRlOiBqLFxuICAgIC4uLnosXG4gICAgLi4uaCxcbiAgICBjaGlsZHJlbjogW1YgfHwgdGUsIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChvbSwge1xuICAgICAgY2xhc3NOYW1lOiBzZShXLmxhYmVsKSxcbiAgICAgIG93bmVyU3RhdGU6IGosXG4gICAgICBjaGlsZHJlbjogZ1xuICAgIH0pLCBVXVxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChJcy5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCICAgIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiAgICAg4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogVGhlIEF2YXRhciBlbGVtZW50IHRvIGRpc3BsYXkuXG4gICAqL1xuICBhdmF0YXI6IGEuZWxlbWVudCxcbiAgLyoqXG4gICAqIFRoaXMgcHJvcCBpc24ndCBzdXBwb3J0ZWQuXG4gICAqIFVzZSB0aGUgYGNvbXBvbmVudGAgcHJvcCBpZiB5b3UgbmVlZCB0byBjaGFuZ2UgdGhlIGNoaWxkcmVuIHN0cnVjdHVyZS5cbiAgICovXG4gIGNoaWxkcmVuOiBCdSxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNoaXAgd2lsbCBhcHBlYXIgY2xpY2thYmxlLCBhbmQgd2lsbCByYWlzZSB3aGVuIHByZXNzZWQsXG4gICAqIGV2ZW4gaWYgdGhlIG9uQ2xpY2sgcHJvcCBpcyBub3QgZGVmaW5lZC5cbiAgICogSWYgYGZhbHNlYCwgdGhlIGNoaXAgd2lsbCBub3QgYXBwZWFyIGNsaWNrYWJsZSwgZXZlbiBpZiBvbkNsaWNrIHByb3AgaXMgZGVmaW5lZC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsXG4gICAqIGFsb25nIHdpdGggdGhlIGNvbXBvbmVudCBwcm9wIHRvIGluZGljYXRlIGFuIGFuY2hvciBDaGlwIGlzIGNsaWNrYWJsZS5cbiAgICogTm90ZTogdGhpcyBjb250cm9scyB0aGUgVUkgYW5kIGRvZXMgbm90IGFmZmVjdCB0aGUgb25DbGljayBldmVudC5cbiAgICovXG4gIGNsaWNrYWJsZTogYS5ib29sLFxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIEl0IHN1cHBvcnRzIGJvdGggZGVmYXVsdCBhbmQgY3VzdG9tIHRoZW1lIGNvbG9ycywgd2hpY2ggY2FuIGJlIGFkZGVkIGFzIHNob3duIGluIHRoZVxuICAgKiBbcGFsZXR0ZSBjdXN0b21pemF0aW9uIGd1aWRlXShodHRwczovL211aS5jb20vbWF0ZXJpYWwtdWkvY3VzdG9taXphdGlvbi9wYWxldHRlLyNjdXN0b20tY29sb3JzKS5cbiAgICogQGRlZmF1bHQgJ2RlZmF1bHQnXG4gICAqL1xuICBjb2xvcjogYS5vbmVPZlR5cGUoW2Eub25lT2YoW1wiZGVmYXVsdFwiLCBcInByaW1hcnlcIiwgXCJzZWNvbmRhcnlcIiwgXCJlcnJvclwiLCBcImluZm9cIiwgXCJzdWNjZXNzXCIsIFwid2FybmluZ1wiXSksIGEuc3RyaW5nXSksXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IGEuZWxlbWVudFR5cGUsXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBkZWxldGUgaWNvbiBlbGVtZW50LiBTaG93biBvbmx5IGlmIGBvbkRlbGV0ZWAgaXMgc2V0LlxuICAgKi9cbiAgZGVsZXRlSWNvbjogYS5lbGVtZW50LFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IGlzIGRpc2FibGVkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZWQ6IGEuYm9vbCxcbiAgLyoqXG4gICAqIEljb24gZWxlbWVudC5cbiAgICovXG4gIGljb246IGEuZWxlbWVudCxcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBsYWJlbDogYS5ub2RlLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25DbGljazogYS5mdW5jLFxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgZGVsZXRlIGljb24gaXMgY2xpY2tlZC5cbiAgICogSWYgc2V0LCB0aGUgZGVsZXRlIGljb24gd2lsbCBiZSBzaG93bi5cbiAgICovXG4gIG9uRGVsZXRlOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbktleURvd246IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uS2V5VXA6IGEuZnVuYyxcbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIEBkZWZhdWx0ICdtZWRpdW0nXG4gICAqL1xuICBzaXplOiBhLm9uZU9mVHlwZShbYS5vbmVPZihbXCJtZWRpdW1cIiwgXCJzbWFsbFwiXSksIGEuc3RyaW5nXSksXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGFsbG93cyB0aGUgZGlzYWJsZWQgY2hpcCB0byBlc2NhcGUgZm9jdXMuXG4gICAqIElmIGBmYWxzZWAsIGFsbG93cyB0aGUgZGlzYWJsZWQgY2hpcCB0byByZWNlaXZlIGZvY3VzLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc2tpcEZvY3VzV2hlbkRpc2FibGVkOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHByb3AgdGhhdCBhbGxvd3MgZGVmaW5pbmcgc3lzdGVtIG92ZXJyaWRlcyBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHN4OiBhLm9uZU9mVHlwZShbYS5hcnJheU9mKGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0LCBhLmJvb2xdKSksIGEuZnVuYywgYS5vYmplY3RdKSxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHRhYkluZGV4OiBhLm51bWJlcixcbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICogQGRlZmF1bHQgJ2ZpbGxlZCdcbiAgICovXG4gIHZhcmlhbnQ6IGEub25lT2ZUeXBlKFthLm9uZU9mKFtcImZpbGxlZFwiLCBcIm91dGxpbmVkXCJdKSwgYS5zdHJpbmddKVxufSk7XG5jb25zdCBpbSA9IHNyKC8qIEBfX1BVUkVfXyAqLyBOLmpzeChcInBhdGhcIiwge1xuICBkOiBcIk0xMiAxMmMyLjIxIDAgNC0xLjc5IDQtNHMtMS43OS00LTQtNC00IDEuNzktNCA0IDEuNzkgNCA0IDR6bTAgMmMtMi42NyAwLTggMS4zNC04IDR2MmgxNnYtMmMwLTIuNjYtNS4zMy00LTgtNHpcIlxufSksIFwiUGVyc29uXCIpO1xuZnVuY3Rpb24gYW0oZSkge1xuICByZXR1cm4gVmUoXCJNdWlBdmF0YXJcIiwgZSk7XG59XG5GZShcIk11aUF2YXRhclwiLCBbXCJyb290XCIsIFwiY29sb3JEZWZhdWx0XCIsIFwiY2lyY3VsYXJcIiwgXCJyb3VuZGVkXCIsIFwic3F1YXJlXCIsIFwiaW1nXCIsIFwiZmFsbGJhY2tcIl0pO1xuY29uc3Qgc20gPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xhc3NlczogdCxcbiAgICB2YXJpYW50OiByLFxuICAgIGNvbG9yRGVmYXVsdDogblxuICB9ID0gZTtcbiAgcmV0dXJuIEdlKHtcbiAgICByb290OiBbXCJyb290XCIsIHIsIG4gJiYgXCJjb2xvckRlZmF1bHRcIl0sXG4gICAgaW1nOiBbXCJpbWdcIl0sXG4gICAgZmFsbGJhY2s6IFtcImZhbGxiYWNrXCJdXG4gIH0sIGFtLCB0KTtcbn0sIGNtID0gbGUoXCJkaXZcIiwge1xuICBuYW1lOiBcIk11aUF2YXRhclwiLFxuICBzbG90OiBcIlJvb3RcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJTdGF0ZTogclxuICAgIH0gPSBlO1xuICAgIHJldHVybiBbdC5yb290LCB0W3IudmFyaWFudF0sIHIuY29sb3JEZWZhdWx0ICYmIHQuY29sb3JEZWZhdWx0XTtcbiAgfVxufSkocWUoKHtcbiAgdGhlbWU6IGVcbn0pID0+ICh7XG4gIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gIGRpc3BsYXk6IFwiZmxleFwiLFxuICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgZmxleFNocmluazogMCxcbiAgd2lkdGg6IDQwLFxuICBoZWlnaHQ6IDQwLFxuICBmb250RmFtaWx5OiBlLnR5cG9ncmFwaHkuZm9udEZhbWlseSxcbiAgZm9udFNpemU6IGUudHlwb2dyYXBoeS5weFRvUmVtKDIwKSxcbiAgbGluZUhlaWdodDogMSxcbiAgYm9yZGVyUmFkaXVzOiBcIjUwJVwiLFxuICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgdXNlclNlbGVjdDogXCJub25lXCIsXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiB7XG4gICAgICB2YXJpYW50OiBcInJvdW5kZWRcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGJvcmRlclJhZGl1czogKGUudmFycyB8fCBlKS5zaGFwZS5ib3JkZXJSYWRpdXNcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgdmFyaWFudDogXCJzcXVhcmVcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGJvcmRlclJhZGl1czogMFxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiB7XG4gICAgICBjb2xvckRlZmF1bHQ6ICEwXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5iYWNrZ3JvdW5kLmRlZmF1bHQsXG4gICAgICAuLi5lLnZhcnMgPyB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogZS52YXJzLnBhbGV0dGUuQXZhdGFyLmRlZmF1bHRCZ1xuICAgICAgfSA6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLnBhbGV0dGUuZ3JleVs0MDBdLFxuICAgICAgICAuLi5lLmFwcGx5U3R5bGVzKFwiZGFya1wiLCB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLnBhbGV0dGUuZ3JleVs2MDBdXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XVxufSkpKSwgbG0gPSBsZShcImltZ1wiLCB7XG4gIG5hbWU6IFwiTXVpQXZhdGFyXCIsXG4gIHNsb3Q6IFwiSW1nXCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4gdC5pbWdcbn0pKHtcbiAgd2lkdGg6IFwiMTAwJVwiLFxuICBoZWlnaHQ6IFwiMTAwJVwiLFxuICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gIC8vIEhhbmRsZSBub24tc3F1YXJlIGltYWdlLlxuICBvYmplY3RGaXQ6IFwiY292ZXJcIixcbiAgLy8gSGlkZSBhbHQgdGV4dC5cbiAgY29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgLy8gSGlkZSB0aGUgaW1hZ2UgYnJva2VuIGljb24sIG9ubHkgd29ya3Mgb24gQ2hyb21lLlxuICB0ZXh0SW5kZW50OiAxZTRcbn0pLCB1bSA9IGxlKGltLCB7XG4gIG5hbWU6IFwiTXVpQXZhdGFyXCIsXG4gIHNsb3Q6IFwiRmFsbGJhY2tcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB0LmZhbGxiYWNrXG59KSh7XG4gIHdpZHRoOiBcIjc1JVwiLFxuICBoZWlnaHQ6IFwiNzUlXCJcbn0pO1xuZnVuY3Rpb24gZm0oe1xuICBjcm9zc09yaWdpbjogZSxcbiAgcmVmZXJyZXJQb2xpY3k6IHQsXG4gIHNyYzogcixcbiAgc3JjU2V0OiBuXG59KSB7XG4gIGNvbnN0IFtvLCBpXSA9IEMudXNlU3RhdGUoITEpO1xuICByZXR1cm4gQy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghciAmJiAhbilcbiAgICAgIHJldHVybjtcbiAgICBpKCExKTtcbiAgICBsZXQgcyA9ICEwO1xuICAgIGNvbnN0IGMgPSBuZXcgSW1hZ2UoKTtcbiAgICByZXR1cm4gYy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBzICYmIGkoXCJsb2FkZWRcIik7XG4gICAgfSwgYy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgcyAmJiBpKFwiZXJyb3JcIik7XG4gICAgfSwgYy5jcm9zc09yaWdpbiA9IGUsIGMucmVmZXJyZXJQb2xpY3kgPSB0LCBjLnNyYyA9IHIsIG4gJiYgKGMuc3Jjc2V0ID0gbiksICgpID0+IHtcbiAgICAgIHMgPSAhMTtcbiAgICB9O1xuICB9LCBbZSwgdCwgciwgbl0pLCBvO1xufVxuY29uc3QgX3MgPSAvKiBAX19QVVJFX18gKi8gQy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsIHIpIHtcbiAgY29uc3QgbiA9IEhlKHtcbiAgICBwcm9wczogdCxcbiAgICBuYW1lOiBcIk11aUF2YXRhclwiXG4gIH0pLCB7XG4gICAgYWx0OiBvLFxuICAgIGNoaWxkcmVuOiBpLFxuICAgIGNsYXNzTmFtZTogcyxcbiAgICBjb21wb25lbnQ6IGMgPSBcImRpdlwiLFxuICAgIHNsb3RzOiBsID0ge30sXG4gICAgc2xvdFByb3BzOiB1ID0ge30sXG4gICAgaW1nUHJvcHM6IHAsXG4gICAgc2l6ZXM6IG0sXG4gICAgc3JjOiBnLFxuICAgIHNyY1NldDogeCxcbiAgICB2YXJpYW50OiB5ID0gXCJjaXJjdWxhclwiLFxuICAgIC4uLmZcbiAgfSA9IG47XG4gIGxldCBTID0gbnVsbDtcbiAgY29uc3QgRSA9IHtcbiAgICAuLi5uLFxuICAgIGNvbXBvbmVudDogYyxcbiAgICB2YXJpYW50OiB5XG4gIH0sIFAgPSBmbSh7XG4gICAgLi4ucCxcbiAgICAuLi50eXBlb2YgdS5pbWcgPT0gXCJmdW5jdGlvblwiID8gdS5pbWcoRSkgOiB1LmltZyxcbiAgICBzcmM6IGcsXG4gICAgc3JjU2V0OiB4XG4gIH0pLCBUID0gZyB8fCB4LCBiID0gVCAmJiBQICE9PSBcImVycm9yXCI7XG4gIEUuY29sb3JEZWZhdWx0ID0gIWIsIGRlbGV0ZSBFLm93bmVyU3RhdGU7XG4gIGNvbnN0IGggPSBzbShFKSwgW3csIGtdID0gQnQoXCJpbWdcIiwge1xuICAgIGNsYXNzTmFtZTogaC5pbWcsXG4gICAgZWxlbWVudFR5cGU6IGxtLFxuICAgIGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6IHtcbiAgICAgIHNsb3RzOiBsLFxuICAgICAgc2xvdFByb3BzOiB7XG4gICAgICAgIGltZzoge1xuICAgICAgICAgIC4uLnAsXG4gICAgICAgICAgLi4udS5pbWdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWRkaXRpb25hbFByb3BzOiB7XG4gICAgICBhbHQ6IG8sXG4gICAgICBzcmM6IGcsXG4gICAgICBzcmNTZXQ6IHgsXG4gICAgICBzaXplczogbVxuICAgIH0sXG4gICAgb3duZXJTdGF0ZTogRVxuICB9KTtcbiAgcmV0dXJuIGIgPyBTID0gLyogQF9fUFVSRV9fICovIE4uanN4KHcsIHtcbiAgICAuLi5rXG4gIH0pIDogaSB8fCBpID09PSAwID8gUyA9IGkgOiBUICYmIG8gPyBTID0gb1swXSA6IFMgPSAvKiBAX19QVVJFX18gKi8gTi5qc3godW0sIHtcbiAgICBvd25lclN0YXRlOiBFLFxuICAgIGNsYXNzTmFtZTogaC5mYWxsYmFja1xuICB9KSwgLyogQF9fUFVSRV9fICovIE4uanN4KGNtLCB7XG4gICAgYXM6IGMsXG4gICAgY2xhc3NOYW1lOiBzZShoLnJvb3QsIHMpLFxuICAgIHJlZjogcixcbiAgICAuLi5mLFxuICAgIG93bmVyU3RhdGU6IEUsXG4gICAgY2hpbGRyZW46IFNcbiAgfSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoX3MucHJvcFR5cGVzID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiAgICBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4gICAgIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICAqIFVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgc3JjYCBvciBgc3JjU2V0YCB0b1xuICAgKiBwcm92aWRlIGFuIGFsdCBhdHRyaWJ1dGUgZm9yIHRoZSByZW5kZXJlZCBgaW1nYCBlbGVtZW50LlxuICAgKi9cbiAgYWx0OiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVuZGVyIGljb24gb3IgdGV4dCBlbGVtZW50cyBpbnNpZGUgdGhlIEF2YXRhciBpZiBgc3JjYCBpcyBub3Qgc2V0LlxuICAgKiBUaGlzIGNhbiBiZSBhbiBlbGVtZW50LCBvciBqdXN0IGEgc3RyaW5nLlxuICAgKi9cbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogYS5lbGVtZW50VHlwZSxcbiAgLyoqXG4gICAqIFtBdHRyaWJ1dGVzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHJpYnV0ZXMpIGFwcGxpZWQgdG8gdGhlIGBpbWdgIGVsZW1lbnQgaWYgdGhlIGNvbXBvbmVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYW4gaW1hZ2UuXG4gICAqIEl0IGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3IgdGhlIGxvYWRpbmcgZXJyb3IgZXZlbnQuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgc2xvdFByb3BzLmltZ2AgaW5zdGVhZC4gVGhpcyBwcm9wIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4gU2VlIFtNaWdyYXRpbmcgZnJvbSBkZXByZWNhdGVkIEFQSXNdKC9tYXRlcmlhbC11aS9taWdyYXRpb24vbWlncmF0aW5nLWZyb20tZGVwcmVjYXRlZC1hcGlzLykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGltZ1Byb3BzOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIFRoZSBgc2l6ZXNgIGF0dHJpYnV0ZSBmb3IgdGhlIGBpbWdgIGVsZW1lbnQuXG4gICAqL1xuICBzaXplczogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBUaGUgcHJvcHMgdXNlZCBmb3IgZWFjaCBzbG90IGluc2lkZS5cbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIHNsb3RQcm9wczogYS5zaGFwZSh7XG4gICAgaW1nOiBhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdF0pXG4gIH0pLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudHMgdXNlZCBmb3IgZWFjaCBzbG90IGluc2lkZS5cbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIHNsb3RzOiBhLnNoYXBlKHtcbiAgICBpbWc6IGEuZWxlbWVudFR5cGVcbiAgfSksXG4gIC8qKlxuICAgKiBUaGUgYHNyY2AgYXR0cmlidXRlIGZvciB0aGUgYGltZ2AgZWxlbWVudC5cbiAgICovXG4gIHNyYzogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBUaGUgYHNyY1NldGAgYXR0cmlidXRlIGZvciB0aGUgYGltZ2AgZWxlbWVudC5cbiAgICogVXNlIHRoaXMgYXR0cmlidXRlIGZvciByZXNwb25zaXZlIGltYWdlIGRpc3BsYXkuXG4gICAqL1xuICBzcmNTZXQ6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSksXG4gIC8qKlxuICAgKiBUaGUgc2hhcGUgb2YgdGhlIGF2YXRhci5cbiAgICogQGRlZmF1bHQgJ2NpcmN1bGFyJ1xuICAgKi9cbiAgdmFyaWFudDogYS5vbmVPZlR5cGUoW2Eub25lT2YoW1wiY2lyY3VsYXJcIiwgXCJyb3VuZGVkXCIsIFwic3F1YXJlXCJdKSwgYS5zdHJpbmddKVxufSk7XG5jb25zdCBkbSA9IEZlKFwiTXVpQm94XCIsIFtcInJvb3RcIl0pLCBwbSA9IEZuKCksIGR0ID0gYnUoe1xuICB0aGVtZUlkOiB3dCxcbiAgZGVmYXVsdFRoZW1lOiBwbSxcbiAgZGVmYXVsdENsYXNzTmFtZTogZG0ucm9vdCxcbiAgZ2VuZXJhdGVDbGFzc05hbWU6IFdhLmdlbmVyYXRlXG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoZHQucHJvcFR5cGVzID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiAgICBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4gICAgIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNoaWxkcmVuOiBhLm5vZGUsXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IGEuZWxlbWVudFR5cGUsXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHByb3AgdGhhdCBhbGxvd3MgZGVmaW5pbmcgc3lzdGVtIG92ZXJyaWRlcyBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHN4OiBhLm9uZU9mVHlwZShbYS5hcnJheU9mKGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0LCBhLmJvb2xdKSksIGEuZnVuYywgYS5vYmplY3RdKVxufSk7XG5mdW5jdGlvbiB4byhlKSB7XG4gIHJldHVybiBgc2NhbGUoJHtlfSwgJHtlICoqIDJ9KWA7XG59XG5jb25zdCBtbSA9IHtcbiAgZW50ZXJpbmc6IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHRyYW5zZm9ybTogeG8oMSlcbiAgfSxcbiAgZW50ZXJlZDoge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgdHJhbnNmb3JtOiBcIm5vbmVcIlxuICB9XG59LCBubyA9IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSooc2FmYXJpfG1vYmlsZSkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC8ob3MgfHZlcnNpb25cXC8pMTUoLnxfKTQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLCBPbiA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCB7XG4gICAgYWRkRW5kTGlzdGVuZXI6IG4sXG4gICAgYXBwZWFyOiBvID0gITAsXG4gICAgY2hpbGRyZW46IGksXG4gICAgZWFzaW5nOiBzLFxuICAgIGluOiBjLFxuICAgIG9uRW50ZXI6IGwsXG4gICAgb25FbnRlcmVkOiB1LFxuICAgIG9uRW50ZXJpbmc6IHAsXG4gICAgb25FeGl0OiBtLFxuICAgIG9uRXhpdGVkOiBnLFxuICAgIG9uRXhpdGluZzogeCxcbiAgICBzdHlsZTogeSxcbiAgICB0aW1lb3V0OiBmID0gXCJhdXRvXCIsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3Byb3AtdHlwZXNcbiAgICBUcmFuc2l0aW9uQ29tcG9uZW50OiBTID0gRXQsXG4gICAgLi4uRVxuICB9ID0gdCwgUCA9IER0KCksIFQgPSBDLnVzZVJlZigpLCBiID0gTHIoKSwgaCA9IEMudXNlUmVmKG51bGwpLCB3ID0gYXQoaCwgQm8oaSksIHIpLCBrID0gKHopID0+IChVKSA9PiB7XG4gICAgaWYgKHopIHtcbiAgICAgIGNvbnN0IFYgPSBoLmN1cnJlbnQ7XG4gICAgICBVID09PSB2b2lkIDAgPyB6KFYpIDogeihWLCBVKTtcbiAgICB9XG4gIH0sIEwgPSBrKHApLCBCID0gaygoeiwgVSkgPT4ge1xuICAgIHRkKHopO1xuICAgIGNvbnN0IHtcbiAgICAgIGR1cmF0aW9uOiBWLFxuICAgICAgZGVsYXk6IHRlLFxuICAgICAgZWFzaW5nOiBGXG4gICAgfSA9IHZuKHtcbiAgICAgIHN0eWxlOiB5LFxuICAgICAgdGltZW91dDogZixcbiAgICAgIGVhc2luZzogc1xuICAgIH0sIHtcbiAgICAgIG1vZGU6IFwiZW50ZXJcIlxuICAgIH0pO1xuICAgIGxldCBSO1xuICAgIGYgPT09IFwiYXV0b1wiID8gKFIgPSBiLnRyYW5zaXRpb25zLmdldEF1dG9IZWlnaHREdXJhdGlvbih6LmNsaWVudEhlaWdodCksIFQuY3VycmVudCA9IFIpIDogUiA9IFYsIHouc3R5bGUudHJhbnNpdGlvbiA9IFtiLnRyYW5zaXRpb25zLmNyZWF0ZShcIm9wYWNpdHlcIiwge1xuICAgICAgZHVyYXRpb246IFIsXG4gICAgICBkZWxheTogdGVcbiAgICB9KSwgYi50cmFuc2l0aW9ucy5jcmVhdGUoXCJ0cmFuc2Zvcm1cIiwge1xuICAgICAgZHVyYXRpb246IG5vID8gUiA6IFIgKiAwLjY2NixcbiAgICAgIGRlbGF5OiB0ZSxcbiAgICAgIGVhc2luZzogRlxuICAgIH0pXS5qb2luKFwiLFwiKSwgbCAmJiBsKHosIFUpO1xuICB9KSwgZCA9IGsodSksIEEgPSBrKHgpLCBEID0gaygoeikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGR1cmF0aW9uOiBVLFxuICAgICAgZGVsYXk6IFYsXG4gICAgICBlYXNpbmc6IHRlXG4gICAgfSA9IHZuKHtcbiAgICAgIHN0eWxlOiB5LFxuICAgICAgdGltZW91dDogZixcbiAgICAgIGVhc2luZzogc1xuICAgIH0sIHtcbiAgICAgIG1vZGU6IFwiZXhpdFwiXG4gICAgfSk7XG4gICAgbGV0IEY7XG4gICAgZiA9PT0gXCJhdXRvXCIgPyAoRiA9IGIudHJhbnNpdGlvbnMuZ2V0QXV0b0hlaWdodER1cmF0aW9uKHouY2xpZW50SGVpZ2h0KSwgVC5jdXJyZW50ID0gRikgOiBGID0gVSwgei5zdHlsZS50cmFuc2l0aW9uID0gW2IudHJhbnNpdGlvbnMuY3JlYXRlKFwib3BhY2l0eVwiLCB7XG4gICAgICBkdXJhdGlvbjogRixcbiAgICAgIGRlbGF5OiBWXG4gICAgfSksIGIudHJhbnNpdGlvbnMuY3JlYXRlKFwidHJhbnNmb3JtXCIsIHtcbiAgICAgIGR1cmF0aW9uOiBubyA/IEYgOiBGICogMC42NjYsXG4gICAgICBkZWxheTogbm8gPyBWIDogViB8fCBGICogMC4zMzMsXG4gICAgICBlYXNpbmc6IHRlXG4gICAgfSldLmpvaW4oXCIsXCIpLCB6LnN0eWxlLm9wYWNpdHkgPSAwLCB6LnN0eWxlLnRyYW5zZm9ybSA9IHhvKDAuNzUpLCBtICYmIG0oeik7XG4gIH0pLCBqID0gayhnKSwgVyA9ICh6KSA9PiB7XG4gICAgZiA9PT0gXCJhdXRvXCIgJiYgUC5zdGFydChULmN1cnJlbnQgfHwgMCwgeiksIG4gJiYgbihoLmN1cnJlbnQsIHopO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KFMsIHtcbiAgICBhcHBlYXI6IG8sXG4gICAgaW46IGMsXG4gICAgbm9kZVJlZjogaCxcbiAgICBvbkVudGVyOiBCLFxuICAgIG9uRW50ZXJlZDogZCxcbiAgICBvbkVudGVyaW5nOiBMLFxuICAgIG9uRXhpdDogRCxcbiAgICBvbkV4aXRlZDogaixcbiAgICBvbkV4aXRpbmc6IEEsXG4gICAgYWRkRW5kTGlzdGVuZXI6IFcsXG4gICAgdGltZW91dDogZiA9PT0gXCJhdXRvXCIgPyBudWxsIDogZixcbiAgICAuLi5FLFxuICAgIGNoaWxkcmVuOiAoeiwge1xuICAgICAgb3duZXJTdGF0ZTogVSxcbiAgICAgIC4uLlZcbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi8gQy5jbG9uZUVsZW1lbnQoaSwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgdHJhbnNmb3JtOiB4bygwLjc1KSxcbiAgICAgICAgdmlzaWJpbGl0eTogeiA9PT0gXCJleGl0ZWRcIiAmJiAhYyA/IFwiaGlkZGVuXCIgOiB2b2lkIDAsXG4gICAgICAgIC4uLm1tW3pdLFxuICAgICAgICAuLi55LFxuICAgICAgICAuLi5pLnByb3BzLnN0eWxlXG4gICAgICB9LFxuICAgICAgcmVmOiB3LFxuICAgICAgLi4uVlxuICAgIH0pXG4gIH0pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKE9uLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgICAgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBBZGQgYSBjdXN0b20gdHJhbnNpdGlvbiBlbmQgdHJpZ2dlci4gQ2FsbGVkIHdpdGggdGhlIHRyYW5zaXRpb25pbmcgRE9NXG4gICAqIG5vZGUgYW5kIGEgZG9uZSBjYWxsYmFjay4gQWxsb3dzIGZvciBtb3JlIGZpbmUgZ3JhaW5lZCB0cmFuc2l0aW9uIGVuZFxuICAgKiBsb2dpYy4gTm90ZTogVGltZW91dHMgYXJlIHN0aWxsIHVzZWQgYXMgYSBmYWxsYmFjayBpZiBwcm92aWRlZC5cbiAgICovXG4gIGFkZEVuZExpc3RlbmVyOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBQZXJmb3JtIHRoZSBlbnRlciB0cmFuc2l0aW9uIHdoZW4gaXQgZmlyc3QgbW91bnRzIGlmIGBpbmAgaXMgYWxzbyBgdHJ1ZWAuXG4gICAqIFNldCB0aGlzIHRvIGBmYWxzZWAgdG8gZGlzYWJsZSB0aGlzIGJlaGF2aW9yLlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBhcHBlYXI6IGEuYm9vbCxcbiAgLyoqXG4gICAqIEEgc2luZ2xlIGNoaWxkIGNvbnRlbnQgZWxlbWVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBqby5pc1JlcXVpcmVkLFxuICAvKipcbiAgICogVGhlIHRyYW5zaXRpb24gdGltaW5nIGZ1bmN0aW9uLlxuICAgKiBZb3UgbWF5IHNwZWNpZnkgYSBzaW5nbGUgZWFzaW5nIG9yIGEgb2JqZWN0IGNvbnRhaW5pbmcgZW50ZXIgYW5kIGV4aXQgdmFsdWVzLlxuICAgKi9cbiAgZWFzaW5nOiBhLm9uZU9mVHlwZShbYS5zaGFwZSh7XG4gICAgZW50ZXI6IGEuc3RyaW5nLFxuICAgIGV4aXQ6IGEuc3RyaW5nXG4gIH0pLCBhLnN0cmluZ10pLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IHdpbGwgdHJhbnNpdGlvbiBpbi5cbiAgICovXG4gIGluOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkVudGVyOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkVudGVyZWQ6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRW50ZXJpbmc6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRXhpdDogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FeGl0ZWQ6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRXhpdGluZzogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3R5bGU6IGEub2JqZWN0LFxuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIGZvciB0aGUgdHJhbnNpdGlvbiwgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBZb3UgbWF5IHNwZWNpZnkgYSBzaW5nbGUgdGltZW91dCBmb3IgYWxsIHRyYW5zaXRpb25zLCBvciBpbmRpdmlkdWFsbHkgd2l0aCBhbiBvYmplY3QuXG4gICAqXG4gICAqIFNldCB0byAnYXV0bycgdG8gYXV0b21hdGljYWxseSBjYWxjdWxhdGUgdHJhbnNpdGlvbiB0aW1lIGJhc2VkIG9uIGhlaWdodC5cbiAgICogQGRlZmF1bHQgJ2F1dG8nXG4gICAqL1xuICB0aW1lb3V0OiBhLm9uZU9mVHlwZShbYS5vbmVPZihbXCJhdXRvXCJdKSwgYS5udW1iZXIsIGEuc2hhcGUoe1xuICAgIGFwcGVhcjogYS5udW1iZXIsXG4gICAgZW50ZXI6IGEubnVtYmVyLFxuICAgIGV4aXQ6IGEubnVtYmVyXG4gIH0pXSlcbn0pO1xuT24gJiYgKE9uLm11aVN1cHBvcnRBdXRvID0gITApO1xuY29uc3Qgb3IgPSAvKiBAX19QVVJFX18gKi8gQy5jcmVhdGVDb250ZXh0KHt9KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAob3IuZGlzcGxheU5hbWUgPSBcIkxpc3RDb250ZXh0XCIpO1xuZnVuY3Rpb24gaG0oZSkge1xuICByZXR1cm4gVmUoXCJNdWlMaXN0XCIsIGUpO1xufVxuRmUoXCJNdWlMaXN0XCIsIFtcInJvb3RcIiwgXCJwYWRkaW5nXCIsIFwiZGVuc2VcIiwgXCJzdWJoZWFkZXJcIl0pO1xuY29uc3QgZ20gPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xhc3NlczogdCxcbiAgICBkaXNhYmxlUGFkZGluZzogcixcbiAgICBkZW5zZTogbixcbiAgICBzdWJoZWFkZXI6IG9cbiAgfSA9IGU7XG4gIHJldHVybiBHZSh7XG4gICAgcm9vdDogW1wicm9vdFwiLCAhciAmJiBcInBhZGRpbmdcIiwgbiAmJiBcImRlbnNlXCIsIG8gJiYgXCJzdWJoZWFkZXJcIl1cbiAgfSwgaG0sIHQpO1xufSwgeW0gPSBsZShcInVsXCIsIHtcbiAgbmFtZTogXCJNdWlMaXN0XCIsXG4gIHNsb3Q6IFwiUm9vdFwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lclN0YXRlOiByXG4gICAgfSA9IGU7XG4gICAgcmV0dXJuIFt0LnJvb3QsICFyLmRpc2FibGVQYWRkaW5nICYmIHQucGFkZGluZywgci5kZW5zZSAmJiB0LmRlbnNlLCByLnN1YmhlYWRlciAmJiB0LnN1YmhlYWRlcl07XG4gIH1cbn0pKHtcbiAgbGlzdFN0eWxlOiBcIm5vbmVcIixcbiAgbWFyZ2luOiAwLFxuICBwYWRkaW5nOiAwLFxuICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICB2YXJpYW50czogW3tcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IGVcbiAgICB9KSA9PiAhZS5kaXNhYmxlUGFkZGluZyxcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZ1RvcDogOCxcbiAgICAgIHBhZGRpbmdCb3R0b206IDhcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IGVcbiAgICB9KSA9PiBlLnN1YmhlYWRlcixcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZ1RvcDogMFxuICAgIH1cbiAgfV1cbn0pLCB0aSA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCBuID0gSGUoe1xuICAgIHByb3BzOiB0LFxuICAgIG5hbWU6IFwiTXVpTGlzdFwiXG4gIH0pLCB7XG4gICAgY2hpbGRyZW46IG8sXG4gICAgY2xhc3NOYW1lOiBpLFxuICAgIGNvbXBvbmVudDogcyA9IFwidWxcIixcbiAgICBkZW5zZTogYyA9ICExLFxuICAgIGRpc2FibGVQYWRkaW5nOiBsID0gITEsXG4gICAgc3ViaGVhZGVyOiB1LFxuICAgIC4uLnBcbiAgfSA9IG4sIG0gPSBDLnVzZU1lbW8oKCkgPT4gKHtcbiAgICBkZW5zZTogY1xuICB9KSwgW2NdKSwgZyA9IHtcbiAgICAuLi5uLFxuICAgIGNvbXBvbmVudDogcyxcbiAgICBkZW5zZTogYyxcbiAgICBkaXNhYmxlUGFkZGluZzogbFxuICB9LCB4ID0gZ20oZyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3gob3IuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbSxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4cyh5bSwge1xuICAgICAgYXM6IHMsXG4gICAgICBjbGFzc05hbWU6IHNlKHgucm9vdCwgaSksXG4gICAgICByZWY6IHIsXG4gICAgICBvd25lclN0YXRlOiBnLFxuICAgICAgLi4ucCxcbiAgICAgIGNoaWxkcmVuOiBbdSwgb11cbiAgICB9KVxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICh0aS5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCICAgIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiAgICAg4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBhLm5vZGUsXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjbGFzc2VzOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IGEuZWxlbWVudFR5cGUsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGNvbXBhY3QgdmVydGljYWwgcGFkZGluZyBkZXNpZ25lZCBmb3Iga2V5Ym9hcmQgYW5kIG1vdXNlIGlucHV0IGlzIHVzZWQgZm9yXG4gICAqIHRoZSBsaXN0IGFuZCBsaXN0IGl0ZW1zLlxuICAgKiBUaGUgcHJvcCBpcyBhdmFpbGFibGUgdG8gZGVzY2VuZGFudCBjb21wb25lbnRzIGFzIHRoZSBgZGVuc2VgIGNvbnRleHQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkZW5zZTogYS5ib29sLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB2ZXJ0aWNhbCBwYWRkaW5nIGlzIHJlbW92ZWQgZnJvbSB0aGUgbGlzdC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVQYWRkaW5nOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgc3ViaGVhZGVyLCBub3JtYWxseSBgTGlzdFN1YmhlYWRlcmAuXG4gICAqL1xuICBzdWJoZWFkZXI6IGEubm9kZSxcbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gcHJvcCB0aGF0IGFsbG93cyBkZWZpbmluZyBzeXN0ZW0gb3ZlcnJpZGVzIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgc3g6IGEub25lT2ZUeXBlKFthLmFycmF5T2YoYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3QsIGEuYm9vbF0pKSwgYS5mdW5jLCBhLm9iamVjdF0pXG59KTtcbmZ1bmN0aW9uIGJtKGUpIHtcbiAgcmV0dXJuIFZlKFwiTXVpTGlzdEl0ZW1CdXR0b25cIiwgZSk7XG59XG5jb25zdCBtciA9IEZlKFwiTXVpTGlzdEl0ZW1CdXR0b25cIiwgW1wicm9vdFwiLCBcImZvY3VzVmlzaWJsZVwiLCBcImRlbnNlXCIsIFwiYWxpZ25JdGVtc0ZsZXhTdGFydFwiLCBcImRpc2FibGVkXCIsIFwiZGl2aWRlclwiLCBcImd1dHRlcnNcIiwgXCJzZWxlY3RlZFwiXSksIHZtID0gKGUsIHQpID0+IHtcbiAgY29uc3Qge1xuICAgIG93bmVyU3RhdGU6IHJcbiAgfSA9IGU7XG4gIHJldHVybiBbdC5yb290LCByLmRlbnNlICYmIHQuZGVuc2UsIHIuYWxpZ25JdGVtcyA9PT0gXCJmbGV4LXN0YXJ0XCIgJiYgdC5hbGlnbkl0ZW1zRmxleFN0YXJ0LCByLmRpdmlkZXIgJiYgdC5kaXZpZGVyLCAhci5kaXNhYmxlR3V0dGVycyAmJiB0Lmd1dHRlcnNdO1xufSwgeG0gPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgYWxpZ25JdGVtczogdCxcbiAgICBjbGFzc2VzOiByLFxuICAgIGRlbnNlOiBuLFxuICAgIGRpc2FibGVkOiBvLFxuICAgIGRpc2FibGVHdXR0ZXJzOiBpLFxuICAgIGRpdmlkZXI6IHMsXG4gICAgc2VsZWN0ZWQ6IGNcbiAgfSA9IGUsIHUgPSBHZSh7XG4gICAgcm9vdDogW1wicm9vdFwiLCBuICYmIFwiZGVuc2VcIiwgIWkgJiYgXCJndXR0ZXJzXCIsIHMgJiYgXCJkaXZpZGVyXCIsIG8gJiYgXCJkaXNhYmxlZFwiLCB0ID09PSBcImZsZXgtc3RhcnRcIiAmJiBcImFsaWduSXRlbXNGbGV4U3RhcnRcIiwgYyAmJiBcInNlbGVjdGVkXCJdXG4gIH0sIGJtLCByKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5yLFxuICAgIC4uLnVcbiAgfTtcbn0sIFNtID0gbGUoJHIsIHtcbiAgc2hvdWxkRm9yd2FyZFByb3A6IChlKSA9PiB5cyhlKSB8fCBlID09PSBcImNsYXNzZXNcIixcbiAgbmFtZTogXCJNdWlMaXN0SXRlbUJ1dHRvblwiLFxuICBzbG90OiBcIlJvb3RcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IHZtXG59KShxZSgoe1xuICB0aGVtZTogZVxufSkgPT4gKHtcbiAgZGlzcGxheTogXCJmbGV4XCIsXG4gIGZsZXhHcm93OiAxLFxuICBqdXN0aWZ5Q29udGVudDogXCJmbGV4LXN0YXJ0XCIsXG4gIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gIHRleHREZWNvcmF0aW9uOiBcIm5vbmVcIixcbiAgbWluV2lkdGg6IDAsXG4gIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gIHRleHRBbGlnbjogXCJsZWZ0XCIsXG4gIHBhZGRpbmdUb3A6IDgsXG4gIHBhZGRpbmdCb3R0b206IDgsXG4gIHRyYW5zaXRpb246IGUudHJhbnNpdGlvbnMuY3JlYXRlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB7XG4gICAgZHVyYXRpb246IGUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlc3RcbiAgfSksXG4gIFwiJjpob3ZlclwiOiB7XG4gICAgdGV4dERlY29yYXRpb246IFwibm9uZVwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLmFjdGlvbi5ob3ZlcixcbiAgICAvLyBSZXNldCBvbiB0b3VjaCBkZXZpY2VzLCBpdCBkb2Vzbid0IGFkZCBzcGVjaWZpY2l0eVxuICAgIFwiQG1lZGlhIChob3Zlcjogbm9uZSlcIjoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICB9XG4gIH0sXG4gIFtgJi4ke21yLnNlbGVjdGVkfWBdOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBlLnZhcnMgPyBgcmdiYSgke2UudmFycy5wYWxldHRlLnByaW1hcnkubWFpbkNoYW5uZWx9IC8gJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRPcGFjaXR5fSlgIDogRGUoZS5wYWxldHRlLnByaW1hcnkubWFpbiwgZS5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHkpLFxuICAgIFtgJi4ke21yLmZvY3VzVmlzaWJsZX1gXToge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBlLnZhcnMgPyBgcmdiYSgke2UudmFycy5wYWxldHRlLnByaW1hcnkubWFpbkNoYW5uZWx9IC8gY2FsYygke2UudmFycy5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHl9ICsgJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uZm9jdXNPcGFjaXR5fSkpYCA6IERlKGUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sIGUucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRPcGFjaXR5ICsgZS5wYWxldHRlLmFjdGlvbi5mb2N1c09wYWNpdHkpXG4gICAgfVxuICB9LFxuICBbYCYuJHttci5zZWxlY3RlZH06aG92ZXJgXToge1xuICAgIGJhY2tncm91bmRDb2xvcjogZS52YXJzID8gYHJnYmEoJHtlLnZhcnMucGFsZXR0ZS5wcmltYXJ5Lm1haW5DaGFubmVsfSAvIGNhbGMoJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRPcGFjaXR5fSArICR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eX0pKWAgOiBEZShlLnBhbGV0dGUucHJpbWFyeS5tYWluLCBlLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkT3BhY2l0eSArIGUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KSxcbiAgICAvLyBSZXNldCBvbiB0b3VjaCBkZXZpY2VzLCBpdCBkb2Vzbid0IGFkZCBzcGVjaWZpY2l0eVxuICAgIFwiQG1lZGlhIChob3Zlcjogbm9uZSlcIjoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBlLnZhcnMgPyBgcmdiYSgke2UudmFycy5wYWxldHRlLnByaW1hcnkubWFpbkNoYW5uZWx9IC8gJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRPcGFjaXR5fSlgIDogRGUoZS5wYWxldHRlLnByaW1hcnkubWFpbiwgZS5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHkpXG4gICAgfVxuICB9LFxuICBbYCYuJHttci5mb2N1c1Zpc2libGV9YF06IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5hY3Rpb24uZm9jdXNcbiAgfSxcbiAgW2AmLiR7bXIuZGlzYWJsZWR9YF06IHtcbiAgICBvcGFjaXR5OiAoZS52YXJzIHx8IGUpLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkT3BhY2l0eVxuICB9LFxuICB2YXJpYW50czogW3tcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiB0LmRpdmlkZXIsXG4gICAgc3R5bGU6IHtcbiAgICAgIGJvcmRlckJvdHRvbTogYDFweCBzb2xpZCAkeyhlLnZhcnMgfHwgZSkucGFsZXR0ZS5kaXZpZGVyfWAsXG4gICAgICBiYWNrZ3JvdW5kQ2xpcDogXCJwYWRkaW5nLWJveFwiXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGFsaWduSXRlbXM6IFwiZmxleC1zdGFydFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0XCJcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiAhdC5kaXNhYmxlR3V0dGVycyxcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZ0xlZnQ6IDE2LFxuICAgICAgcGFkZGluZ1JpZ2h0OiAxNlxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+IHQuZGVuc2UsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmdUb3A6IDQsXG4gICAgICBwYWRkaW5nQm90dG9tOiA0XG4gICAgfVxuICB9XVxufSkpKSwgcmkgPSAvKiBAX19QVVJFX18gKi8gQy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsIHIpIHtcbiAgY29uc3QgbiA9IEhlKHtcbiAgICBwcm9wczogdCxcbiAgICBuYW1lOiBcIk11aUxpc3RJdGVtQnV0dG9uXCJcbiAgfSksIHtcbiAgICBhbGlnbkl0ZW1zOiBvID0gXCJjZW50ZXJcIixcbiAgICBhdXRvRm9jdXM6IGkgPSAhMSxcbiAgICBjb21wb25lbnQ6IHMgPSBcImRpdlwiLFxuICAgIGNoaWxkcmVuOiBjLFxuICAgIGRlbnNlOiBsID0gITEsXG4gICAgZGlzYWJsZUd1dHRlcnM6IHUgPSAhMSxcbiAgICBkaXZpZGVyOiBwID0gITEsXG4gICAgZm9jdXNWaXNpYmxlQ2xhc3NOYW1lOiBtLFxuICAgIHNlbGVjdGVkOiBnID0gITEsXG4gICAgY2xhc3NOYW1lOiB4LFxuICAgIC4uLnlcbiAgfSA9IG4sIGYgPSBDLnVzZUNvbnRleHQob3IpLCBTID0gQy51c2VNZW1vKCgpID0+ICh7XG4gICAgZGVuc2U6IGwgfHwgZi5kZW5zZSB8fCAhMSxcbiAgICBhbGlnbkl0ZW1zOiBvLFxuICAgIGRpc2FibGVHdXR0ZXJzOiB1XG4gIH0pLCBbbywgZi5kZW5zZSwgbCwgdV0pLCBFID0gQy51c2VSZWYobnVsbCk7XG4gIEZ0KCgpID0+IHtcbiAgICBpICYmIChFLmN1cnJlbnQgPyBFLmN1cnJlbnQuZm9jdXMoKSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFwiTVVJOiBVbmFibGUgdG8gc2V0IGZvY3VzIHRvIGEgTGlzdEl0ZW1CdXR0b24gd2hvc2UgY29tcG9uZW50IGhhcyBub3QgYmVlbiByZW5kZXJlZC5cIikpO1xuICB9LCBbaV0pO1xuICBjb25zdCBQID0ge1xuICAgIC4uLm4sXG4gICAgYWxpZ25JdGVtczogbyxcbiAgICBkZW5zZTogUy5kZW5zZSxcbiAgICBkaXNhYmxlR3V0dGVyczogdSxcbiAgICBkaXZpZGVyOiBwLFxuICAgIHNlbGVjdGVkOiBnXG4gIH0sIFQgPSB4bShQKSwgYiA9IGF0KEUsIHIpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KG9yLlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChTbSwge1xuICAgICAgcmVmOiBiLFxuICAgICAgaHJlZjogeS5ocmVmIHx8IHkudG8sXG4gICAgICBjb21wb25lbnQ6ICh5LmhyZWYgfHwgeS50bykgJiYgcyA9PT0gXCJkaXZcIiA/IFwiYnV0dG9uXCIgOiBzLFxuICAgICAgZm9jdXNWaXNpYmxlQ2xhc3NOYW1lOiBzZShULmZvY3VzVmlzaWJsZSwgbSksXG4gICAgICBvd25lclN0YXRlOiBQLFxuICAgICAgY2xhc3NOYW1lOiBzZShULnJvb3QsIHgpLFxuICAgICAgLi4ueSxcbiAgICAgIGNsYXNzZXM6IFQsXG4gICAgICBjaGlsZHJlbjogY1xuICAgIH0pXG4gIH0pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHJpLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgICAgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBgYWxpZ24taXRlbXNgIHN0eWxlIHByb3BlcnR5LlxuICAgKiBAZGVmYXVsdCAnY2VudGVyJ1xuICAgKi9cbiAgYWxpZ25JdGVtczogYS5vbmVPZihbXCJjZW50ZXJcIiwgXCJmbGV4LXN0YXJ0XCJdKSxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxpc3QgaXRlbSBpcyBmb2N1c2VkIGR1cmluZyB0aGUgZmlyc3QgbW91bnQuXG4gICAqIEZvY3VzIHdpbGwgYWxzbyBiZSB0cmlnZ2VyZWQgaWYgdGhlIHZhbHVlIGNoYW5nZXMgZnJvbSBmYWxzZSB0byB0cnVlLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYXV0b0ZvY3VzOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50IGlmIGEgYExpc3RJdGVtU2Vjb25kYXJ5QWN0aW9uYCBpcyB1c2VkIGl0IG11c3RcbiAgICogYmUgdGhlIGxhc3QgY2hpbGQuXG4gICAqL1xuICBjaGlsZHJlbjogYS5ub2RlLFxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgY29tcG9uZW50OiBhLmVsZW1lbnRUeXBlLFxuICAvKipcbiAgICogSWYgYHRydWVgLCBjb21wYWN0IHZlcnRpY2FsIHBhZGRpbmcgZGVzaWduZWQgZm9yIGtleWJvYXJkIGFuZCBtb3VzZSBpbnB1dCBpcyB1c2VkLlxuICAgKiBUaGUgcHJvcCBkZWZhdWx0cyB0byB0aGUgdmFsdWUgaW5oZXJpdGVkIGZyb20gdGhlIHBhcmVudCBMaXN0IGNvbXBvbmVudC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRlbnNlOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgaXMgZGlzYWJsZWQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlZDogYS5ib29sLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGVmdCBhbmQgcmlnaHQgcGFkZGluZyBpcyByZW1vdmVkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZUd1dHRlcnM6IGEuYm9vbCxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYSAxcHggbGlnaHQgYm9yZGVyIGlzIGFkZGVkIHRvIHRoZSBib3R0b20gb2YgdGhlIGxpc3QgaXRlbS5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpdmlkZXI6IGEuYm9vbCxcbiAgLyoqXG4gICAqIFRoaXMgcHJvcCBjYW4gaGVscCBpZGVudGlmeSB3aGljaCBlbGVtZW50IGhhcyBrZXlib2FyZCBmb2N1cy5cbiAgICogVGhlIGNsYXNzIG5hbWUgd2lsbCBiZSBhcHBsaWVkIHdoZW4gdGhlIGVsZW1lbnQgZ2FpbnMgdGhlIGZvY3VzIHRocm91Z2gga2V5Ym9hcmQgaW50ZXJhY3Rpb24uXG4gICAqIEl0J3MgYSBwb2x5ZmlsbCBmb3IgdGhlIFtDU1MgOmZvY3VzLXZpc2libGUgc2VsZWN0b3JdKGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9zZWxlY3RvcnMtNC8jdGhlLWZvY3VzLXZpc2libGUtcHNldWRvKS5cbiAgICogVGhlIHJhdGlvbmFsZSBmb3IgdXNpbmcgdGhpcyBmZWF0dXJlIFtpcyBleHBsYWluZWQgaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvZm9jdXMtdmlzaWJsZS9ibG9iL0hFQUQvZXhwbGFpbmVyLm1kKS5cbiAgICogQSBbcG9seWZpbGwgY2FuIGJlIHVzZWRdKGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2ZvY3VzLXZpc2libGUpIHRvIGFwcGx5IGEgYGZvY3VzLXZpc2libGVgIGNsYXNzIHRvIG90aGVyIGNvbXBvbmVudHNcbiAgICogaWYgbmVlZGVkLlxuICAgKi9cbiAgZm9jdXNWaXNpYmxlQ2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGhyZWY6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVXNlIHRvIGFwcGx5IHNlbGVjdGVkIHN0eWxpbmcuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzZWxlY3RlZDogYS5ib29sLFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSlcbn0pO1xuZnVuY3Rpb24gRW0oZSkge1xuICByZXR1cm4gVmUoXCJNdWlMaXN0SXRlbUljb25cIiwgZSk7XG59XG5GZShcIk11aUxpc3RJdGVtSWNvblwiLCBbXCJyb290XCIsIFwiYWxpZ25JdGVtc0ZsZXhTdGFydFwiXSk7XG5jb25zdCBDbSA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBhbGlnbkl0ZW1zOiB0LFxuICAgIGNsYXNzZXM6IHJcbiAgfSA9IGU7XG4gIHJldHVybiBHZSh7XG4gICAgcm9vdDogW1wicm9vdFwiLCB0ID09PSBcImZsZXgtc3RhcnRcIiAmJiBcImFsaWduSXRlbXNGbGV4U3RhcnRcIl1cbiAgfSwgRW0sIHIpO1xufSwgVG0gPSBsZShcImRpdlwiLCB7XG4gIG5hbWU6IFwiTXVpTGlzdEl0ZW1JY29uXCIsXG4gIHNsb3Q6IFwiUm9vdFwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lclN0YXRlOiByXG4gICAgfSA9IGU7XG4gICAgcmV0dXJuIFt0LnJvb3QsIHIuYWxpZ25JdGVtcyA9PT0gXCJmbGV4LXN0YXJ0XCIgJiYgdC5hbGlnbkl0ZW1zRmxleFN0YXJ0XTtcbiAgfVxufSkocWUoKHtcbiAgdGhlbWU6IGVcbn0pID0+ICh7XG4gIG1pbldpZHRoOiA1NixcbiAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5hY3Rpb24uYWN0aXZlLFxuICBmbGV4U2hyaW5rOiAwLFxuICBkaXNwbGF5OiBcImlubGluZS1mbGV4XCIsXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiB7XG4gICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnRcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIG1hcmdpblRvcDogOFxuICAgIH1cbiAgfV1cbn0pKSksIG5pID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IG4gPSBIZSh7XG4gICAgcHJvcHM6IHQsXG4gICAgbmFtZTogXCJNdWlMaXN0SXRlbUljb25cIlxuICB9KSwge1xuICAgIGNsYXNzTmFtZTogbyxcbiAgICAuLi5pXG4gIH0gPSBuLCBzID0gQy51c2VDb250ZXh0KG9yKSwgYyA9IHtcbiAgICAuLi5uLFxuICAgIGFsaWduSXRlbXM6IHMuYWxpZ25JdGVtc1xuICB9LCBsID0gQ20oYyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goVG0sIHtcbiAgICBjbGFzc05hbWU6IHNlKGwucm9vdCwgbyksXG4gICAgb3duZXJTdGF0ZTogYyxcbiAgICByZWY6IHIsXG4gICAgLi4uaVxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChuaS5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCICAgIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiAgICAg4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudCwgbm9ybWFsbHkgYEljb25gLCBgU3ZnSWNvbmAsXG4gICAqIG9yIGEgYEBtdWkvaWNvbnMtbWF0ZXJpYWxgIFNWRyBpY29uIGVsZW1lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogYS5ub2RlLFxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSlcbn0pO1xuZnVuY3Rpb24gd20oZSkge1xuICByZXR1cm4gVmUoXCJNdWlMaXN0SXRlbVRleHRcIiwgZSk7XG59XG5jb25zdCBlbiA9IEZlKFwiTXVpTGlzdEl0ZW1UZXh0XCIsIFtcInJvb3RcIiwgXCJtdWx0aWxpbmVcIiwgXCJkZW5zZVwiLCBcImluc2V0XCIsIFwicHJpbWFyeVwiLCBcInNlY29uZGFyeVwiXSksIE9tID0gKGUpID0+IHtcbiAgY29uc3Qge1xuICAgIGNsYXNzZXM6IHQsXG4gICAgaW5zZXQ6IHIsXG4gICAgcHJpbWFyeTogbixcbiAgICBzZWNvbmRhcnk6IG8sXG4gICAgZGVuc2U6IGlcbiAgfSA9IGU7XG4gIHJldHVybiBHZSh7XG4gICAgcm9vdDogW1wicm9vdFwiLCByICYmIFwiaW5zZXRcIiwgaSAmJiBcImRlbnNlXCIsIG4gJiYgbyAmJiBcIm11bHRpbGluZVwiXSxcbiAgICBwcmltYXJ5OiBbXCJwcmltYXJ5XCJdLFxuICAgIHNlY29uZGFyeTogW1wic2Vjb25kYXJ5XCJdXG4gIH0sIHdtLCB0KTtcbn0sIFJtID0gbGUoXCJkaXZcIiwge1xuICBuYW1lOiBcIk11aUxpc3RJdGVtVGV4dFwiLFxuICBzbG90OiBcIlJvb3RcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJTdGF0ZTogclxuICAgIH0gPSBlO1xuICAgIHJldHVybiBbe1xuICAgICAgW2AmIC4ke2VuLnByaW1hcnl9YF06IHQucHJpbWFyeVxuICAgIH0sIHtcbiAgICAgIFtgJiAuJHtlbi5zZWNvbmRhcnl9YF06IHQuc2Vjb25kYXJ5XG4gICAgfSwgdC5yb290LCByLmluc2V0ICYmIHQuaW5zZXQsIHIucHJpbWFyeSAmJiByLnNlY29uZGFyeSAmJiB0Lm11bHRpbGluZSwgci5kZW5zZSAmJiB0LmRlbnNlXTtcbiAgfVxufSkoe1xuICBmbGV4OiBcIjEgMSBhdXRvXCIsXG4gIG1pbldpZHRoOiAwLFxuICBtYXJnaW5Ub3A6IDQsXG4gIG1hcmdpbkJvdHRvbTogNCxcbiAgW2AuJHtzYS5yb290fTp3aGVyZSgmIC4ke2VuLnByaW1hcnl9KWBdOiB7XG4gICAgZGlzcGxheTogXCJibG9ja1wiXG4gIH0sXG4gIFtgLiR7c2Eucm9vdH06d2hlcmUoJiAuJHtlbi5zZWNvbmRhcnl9KWBdOiB7XG4gICAgZGlzcGxheTogXCJibG9ja1wiXG4gIH0sXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogZVxuICAgIH0pID0+IGUucHJpbWFyeSAmJiBlLnNlY29uZGFyeSxcbiAgICBzdHlsZToge1xuICAgICAgbWFyZ2luVG9wOiA2LFxuICAgICAgbWFyZ2luQm90dG9tOiA2XG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiBlXG4gICAgfSkgPT4gZS5pbnNldCxcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZ0xlZnQ6IDU2XG4gICAgfVxuICB9XVxufSksIG9pID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IG4gPSBIZSh7XG4gICAgcHJvcHM6IHQsXG4gICAgbmFtZTogXCJNdWlMaXN0SXRlbVRleHRcIlxuICB9KSwge1xuICAgIGNoaWxkcmVuOiBvLFxuICAgIGNsYXNzTmFtZTogaSxcbiAgICBkaXNhYmxlVHlwb2dyYXBoeTogcyA9ICExLFxuICAgIGluc2V0OiBjID0gITEsXG4gICAgcHJpbWFyeTogbCxcbiAgICBwcmltYXJ5VHlwb2dyYXBoeVByb3BzOiB1LFxuICAgIHNlY29uZGFyeTogcCxcbiAgICBzZWNvbmRhcnlUeXBvZ3JhcGh5UHJvcHM6IG0sXG4gICAgc2xvdHM6IGcgPSB7fSxcbiAgICBzbG90UHJvcHM6IHggPSB7fSxcbiAgICAuLi55XG4gIH0gPSBuLCB7XG4gICAgZGVuc2U6IGZcbiAgfSA9IEMudXNlQ29udGV4dChvcik7XG4gIGxldCBTID0gbCA/PyBvLCBFID0gcDtcbiAgY29uc3QgUCA9IHtcbiAgICAuLi5uLFxuICAgIGRpc2FibGVUeXBvZ3JhcGh5OiBzLFxuICAgIGluc2V0OiBjLFxuICAgIHByaW1hcnk6ICEhUyxcbiAgICBzZWNvbmRhcnk6ICEhRSxcbiAgICBkZW5zZTogZlxuICB9LCBUID0gT20oUCksIGIgPSB7XG4gICAgc2xvdHM6IGcsXG4gICAgc2xvdFByb3BzOiB7XG4gICAgICBwcmltYXJ5OiB1LFxuICAgICAgc2Vjb25kYXJ5OiBtLFxuICAgICAgLi4ueFxuICAgIH1cbiAgfSwgW2gsIHddID0gQnQoXCJwcmltYXJ5XCIsIHtcbiAgICBjbGFzc05hbWU6IFQucHJpbWFyeSxcbiAgICBlbGVtZW50VHlwZTogYnQsXG4gICAgZXh0ZXJuYWxGb3J3YXJkZWRQcm9wczogYixcbiAgICBvd25lclN0YXRlOiBQXG4gIH0pLCBbaywgTF0gPSBCdChcInNlY29uZGFyeVwiLCB7XG4gICAgY2xhc3NOYW1lOiBULnNlY29uZGFyeSxcbiAgICBlbGVtZW50VHlwZTogYnQsXG4gICAgZXh0ZXJuYWxGb3J3YXJkZWRQcm9wczogYixcbiAgICBvd25lclN0YXRlOiBQXG4gIH0pO1xuICByZXR1cm4gUyAhPSBudWxsICYmIFMudHlwZSAhPT0gYnQgJiYgIXMgJiYgKFMgPSAvKiBAX19QVVJFX18gKi8gTi5qc3goaCwge1xuICAgIHZhcmlhbnQ6IGYgPyBcImJvZHkyXCIgOiBcImJvZHkxXCIsXG4gICAgY29tcG9uZW50OiB3ICE9IG51bGwgJiYgdy52YXJpYW50ID8gdm9pZCAwIDogXCJzcGFuXCIsXG4gICAgLi4udyxcbiAgICBjaGlsZHJlbjogU1xuICB9KSksIEUgIT0gbnVsbCAmJiBFLnR5cGUgIT09IGJ0ICYmICFzICYmIChFID0gLyogQF9fUFVSRV9fICovIE4uanN4KGssIHtcbiAgICB2YXJpYW50OiBcImJvZHkyXCIsXG4gICAgY29sb3I6IFwidGV4dFNlY29uZGFyeVwiLFxuICAgIC4uLkwsXG4gICAgY2hpbGRyZW46IEVcbiAgfSkpLCAvKiBAX19QVVJFX18gKi8gTi5qc3hzKFJtLCB7XG4gICAgY2xhc3NOYW1lOiBzZShULnJvb3QsIGkpLFxuICAgIG93bmVyU3RhdGU6IFAsXG4gICAgcmVmOiByLFxuICAgIC4uLnksXG4gICAgY2hpbGRyZW46IFtTLCBFXVxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChvaS5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCICAgIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiAgICAg4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogQWxpYXMgZm9yIHRoZSBgcHJpbWFyeWAgcHJvcC5cbiAgICovXG4gIGNoaWxkcmVuOiBhLm5vZGUsXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjbGFzc2VzOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjaGlsZHJlbiB3b24ndCBiZSB3cmFwcGVkIGJ5IGEgVHlwb2dyYXBoeSBjb21wb25lbnQuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byByZW5kZXIgYW4gYWx0ZXJuYXRpdmUgVHlwb2dyYXBoeSB2YXJpYW50IGJ5IHdyYXBwaW5nXG4gICAqIHRoZSBgY2hpbGRyZW5gIChvciBgcHJpbWFyeWApIHRleHQsIGFuZCBvcHRpb25hbCBgc2Vjb25kYXJ5YCB0ZXh0XG4gICAqIHdpdGggdGhlIFR5cG9ncmFwaHkgY29tcG9uZW50LlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZVR5cG9ncmFwaHk6IGEuYm9vbCxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNoaWxkcmVuIGFyZSBpbmRlbnRlZC5cbiAgICogVGhpcyBzaG91bGQgYmUgdXNlZCBpZiB0aGVyZSBpcyBubyBsZWZ0IGF2YXRhciBvciBsZWZ0IGljb24uXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpbnNldDogYS5ib29sLFxuICAvKipcbiAgICogVGhlIG1haW4gY29udGVudCBlbGVtZW50LlxuICAgKi9cbiAgcHJpbWFyeTogYS5ub2RlLFxuICAvKipcbiAgICogVGhlc2UgcHJvcHMgd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGhlIHByaW1hcnkgdHlwb2dyYXBoeSBjb21wb25lbnRcbiAgICogKGFzIGxvbmcgYXMgZGlzYWJsZVR5cG9ncmFwaHkgaXMgbm90IGB0cnVlYCkuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgc2xvdFByb3BzLnByaW1hcnlgIGluc3RlYWQuIFRoaXMgcHJvcCB3aWxsIGJlIHJlbW92ZWQgaW4gdjcuIFNlZSBbTWlncmF0aW5nIGZyb20gZGVwcmVjYXRlZCBBUElzXSgvbWF0ZXJpYWwtdWkvbWlncmF0aW9uL21pZ3JhdGluZy1mcm9tLWRlcHJlY2F0ZWQtYXBpcy8pIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBwcmltYXJ5VHlwb2dyYXBoeVByb3BzOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIFRoZSBzZWNvbmRhcnkgY29udGVudCBlbGVtZW50LlxuICAgKi9cbiAgc2Vjb25kYXJ5OiBhLm5vZGUsXG4gIC8qKlxuICAgKiBUaGVzZSBwcm9wcyB3aWxsIGJlIGZvcndhcmRlZCB0byB0aGUgc2Vjb25kYXJ5IHR5cG9ncmFwaHkgY29tcG9uZW50XG4gICAqIChhcyBsb25nIGFzIGRpc2FibGVUeXBvZ3JhcGh5IGlzIG5vdCBgdHJ1ZWApLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHNsb3RQcm9wcy5zZWNvbmRhcnlgIGluc3RlYWQuIFRoaXMgcHJvcCB3aWxsIGJlIHJlbW92ZWQgaW4gdjcuIFNlZSBbTWlncmF0aW5nIGZyb20gZGVwcmVjYXRlZCBBUElzXSgvbWF0ZXJpYWwtdWkvbWlncmF0aW9uL21pZ3JhdGluZy1mcm9tLWRlcHJlY2F0ZWQtYXBpcy8pIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBzZWNvbmRhcnlUeXBvZ3JhcGh5UHJvcHM6IGEub2JqZWN0LFxuICAvKipcbiAgICogVGhlIHByb3BzIHVzZWQgZm9yIGVhY2ggc2xvdCBpbnNpZGUuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBzbG90UHJvcHM6IGEuc2hhcGUoe1xuICAgIHByaW1hcnk6IGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0XSksXG4gICAgc2Vjb25kYXJ5OiBhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdF0pXG4gIH0pLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudHMgdXNlZCBmb3IgZWFjaCBzbG90IGluc2lkZS5cbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIHNsb3RzOiBhLnNoYXBlKHtcbiAgICBwcmltYXJ5OiBhLmVsZW1lbnRUeXBlLFxuICAgIHNlY29uZGFyeTogYS5lbGVtZW50VHlwZVxuICB9KSxcbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gcHJvcCB0aGF0IGFsbG93cyBkZWZpbmluZyBzeXN0ZW0gb3ZlcnJpZGVzIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgc3g6IGEub25lT2ZUeXBlKFthLmFycmF5T2YoYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3QsIGEuYm9vbF0pKSwgYS5mdW5jLCBhLm9iamVjdF0pXG59KTtcbmZ1bmN0aW9uICRtKGUpIHtcbiAgcmV0dXJuIFZlKFwiTXVpVG9vbHRpcFwiLCBlKTtcbn1cbmNvbnN0IE5lID0gRmUoXCJNdWlUb29sdGlwXCIsIFtcInBvcHBlclwiLCBcInBvcHBlckludGVyYWN0aXZlXCIsIFwicG9wcGVyQXJyb3dcIiwgXCJwb3BwZXJDbG9zZVwiLCBcInRvb2x0aXBcIiwgXCJ0b29sdGlwQXJyb3dcIiwgXCJ0b3VjaFwiLCBcInRvb2x0aXBQbGFjZW1lbnRMZWZ0XCIsIFwidG9vbHRpcFBsYWNlbWVudFJpZ2h0XCIsIFwidG9vbHRpcFBsYWNlbWVudFRvcFwiLCBcInRvb2x0aXBQbGFjZW1lbnRCb3R0b21cIiwgXCJhcnJvd1wiXSk7XG5mdW5jdGlvbiBQbShlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGUgKiAxZTUpIC8gMWU1O1xufVxuY29uc3Qga20gPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xhc3NlczogdCxcbiAgICBkaXNhYmxlSW50ZXJhY3RpdmU6IHIsXG4gICAgYXJyb3c6IG4sXG4gICAgdG91Y2g6IG8sXG4gICAgcGxhY2VtZW50OiBpXG4gIH0gPSBlLCBzID0ge1xuICAgIHBvcHBlcjogW1wicG9wcGVyXCIsICFyICYmIFwicG9wcGVySW50ZXJhY3RpdmVcIiwgbiAmJiBcInBvcHBlckFycm93XCJdLFxuICAgIHRvb2x0aXA6IFtcInRvb2x0aXBcIiwgbiAmJiBcInRvb2x0aXBBcnJvd1wiLCBvICYmIFwidG91Y2hcIiwgYHRvb2x0aXBQbGFjZW1lbnQke2VlKGkuc3BsaXQoXCItXCIpWzBdKX1gXSxcbiAgICBhcnJvdzogW1wiYXJyb3dcIl1cbiAgfTtcbiAgcmV0dXJuIEdlKHMsICRtLCB0KTtcbn0sIEFtID0gbGUoZWksIHtcbiAgbmFtZTogXCJNdWlUb29sdGlwXCIsXG4gIHNsb3Q6IFwiUG9wcGVyXCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyU3RhdGU6IHJcbiAgICB9ID0gZTtcbiAgICByZXR1cm4gW3QucG9wcGVyLCAhci5kaXNhYmxlSW50ZXJhY3RpdmUgJiYgdC5wb3BwZXJJbnRlcmFjdGl2ZSwgci5hcnJvdyAmJiB0LnBvcHBlckFycm93LCAhci5vcGVuICYmIHQucG9wcGVyQ2xvc2VdO1xuICB9XG59KShxZSgoe1xuICB0aGVtZTogZVxufSkgPT4gKHtcbiAgekluZGV4OiAoZS52YXJzIHx8IGUpLnpJbmRleC50b29sdGlwLFxuICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiB0XG4gICAgfSkgPT4gIXQuZGlzYWJsZUludGVyYWN0aXZlLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIlxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3BlbjogdFxuICAgIH0pID0+ICF0LFxuICAgIHN0eWxlOiB7XG4gICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+IHQuYXJyb3csXG4gICAgc3R5bGU6IHtcbiAgICAgIFtgJltkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwiYm90dG9tXCJdIC4ke05lLmFycm93fWBdOiB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbWFyZ2luVG9wOiBcIi0wLjcxZW1cIixcbiAgICAgICAgXCImOjpiZWZvcmVcIjoge1xuICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogXCIwIDEwMCVcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2AmW2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJ0b3BcIl0gLiR7TmUuYXJyb3d9YF06IHtcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IFwiLTAuNzFlbVwiLFxuICAgICAgICBcIiY6OmJlZm9yZVwiOiB7XG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIjEwMCUgMFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbYCZbZGF0YS1wb3BwZXItcGxhY2VtZW50Kj1cInJpZ2h0XCJdIC4ke05lLmFycm93fWBdOiB7XG4gICAgICAgIGhlaWdodDogXCIxZW1cIixcbiAgICAgICAgd2lkdGg6IFwiMC43MWVtXCIsXG4gICAgICAgIFwiJjo6YmVmb3JlXCI6IHtcbiAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiMTAwJSAxMDAlXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtgJltkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwibGVmdFwiXSAuJHtOZS5hcnJvd31gXToge1xuICAgICAgICBoZWlnaHQ6IFwiMWVtXCIsXG4gICAgICAgIHdpZHRoOiBcIjAuNzFlbVwiLFxuICAgICAgICBcIiY6OmJlZm9yZVwiOiB7XG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIjAgMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiB0LmFycm93ICYmICF0LmlzUnRsLFxuICAgIHN0eWxlOiB7XG4gICAgICBbYCZbZGF0YS1wb3BwZXItcGxhY2VtZW50Kj1cInJpZ2h0XCJdIC4ke05lLmFycm93fWBdOiB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiLTAuNzFlbVwiXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiB0XG4gICAgfSkgPT4gdC5hcnJvdyAmJiAhIXQuaXNSdGwsXG4gICAgc3R5bGU6IHtcbiAgICAgIFtgJltkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwicmlnaHRcIl0gLiR7TmUuYXJyb3d9YF06IHtcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIG1hcmdpblJpZ2h0OiBcIi0wLjcxZW1cIlxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+IHQuYXJyb3cgJiYgIXQuaXNSdGwsXG4gICAgc3R5bGU6IHtcbiAgICAgIFtgJltkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwibGVmdFwiXSAuJHtOZS5hcnJvd31gXToge1xuICAgICAgICByaWdodDogMCxcbiAgICAgICAgbWFyZ2luUmlnaHQ6IFwiLTAuNzFlbVwiXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiB0XG4gICAgfSkgPT4gdC5hcnJvdyAmJiAhIXQuaXNSdGwsXG4gICAgc3R5bGU6IHtcbiAgICAgIFtgJltkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwibGVmdFwiXSAuJHtOZS5hcnJvd31gXToge1xuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0wLjcxZW1cIlxuICAgICAgfVxuICAgIH1cbiAgfV1cbn0pKSksIE5tID0gbGUoXCJkaXZcIiwge1xuICBuYW1lOiBcIk11aVRvb2x0aXBcIixcbiAgc2xvdDogXCJUb29sdGlwXCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyU3RhdGU6IHJcbiAgICB9ID0gZTtcbiAgICByZXR1cm4gW3QudG9vbHRpcCwgci50b3VjaCAmJiB0LnRvdWNoLCByLmFycm93ICYmIHQudG9vbHRpcEFycm93LCB0W2B0b29sdGlwUGxhY2VtZW50JHtlZShyLnBsYWNlbWVudC5zcGxpdChcIi1cIilbMF0pfWBdXTtcbiAgfVxufSkocWUoKHtcbiAgdGhlbWU6IGVcbn0pID0+ICh7XG4gIGJhY2tncm91bmRDb2xvcjogZS52YXJzID8gZS52YXJzLnBhbGV0dGUuVG9vbHRpcC5iZyA6IERlKGUucGFsZXR0ZS5ncmV5WzcwMF0sIDAuOTIpLFxuICBib3JkZXJSYWRpdXM6IChlLnZhcnMgfHwgZSkuc2hhcGUuYm9yZGVyUmFkaXVzLFxuICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLmNvbW1vbi53aGl0ZSxcbiAgZm9udEZhbWlseTogZS50eXBvZ3JhcGh5LmZvbnRGYW1pbHksXG4gIHBhZGRpbmc6IFwiNHB4IDhweFwiLFxuICBmb250U2l6ZTogZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTEpLFxuICBtYXhXaWR0aDogMzAwLFxuICBtYXJnaW46IDIsXG4gIHdvcmRXcmFwOiBcImJyZWFrLXdvcmRcIixcbiAgZm9udFdlaWdodDogZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW0sXG4gIFtgLiR7TmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwibGVmdFwiXSAmYF06IHtcbiAgICB0cmFuc2Zvcm1PcmlnaW46IFwicmlnaHQgY2VudGVyXCJcbiAgfSxcbiAgW2AuJHtOZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJyaWdodFwiXSAmYF06IHtcbiAgICB0cmFuc2Zvcm1PcmlnaW46IFwibGVmdCBjZW50ZXJcIlxuICB9LFxuICBbYC4ke05lLnBvcHBlcn1bZGF0YS1wb3BwZXItcGxhY2VtZW50Kj1cInRvcFwiXSAmYF06IHtcbiAgICB0cmFuc2Zvcm1PcmlnaW46IFwiY2VudGVyIGJvdHRvbVwiLFxuICAgIG1hcmdpbkJvdHRvbTogXCIxNHB4XCJcbiAgfSxcbiAgW2AuJHtOZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJib3R0b21cIl0gJmBdOiB7XG4gICAgdHJhbnNmb3JtT3JpZ2luOiBcImNlbnRlciB0b3BcIixcbiAgICBtYXJnaW5Ub3A6IFwiMTRweFwiXG4gIH0sXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+IHQuYXJyb3csXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICBtYXJnaW46IDBcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiB0LnRvdWNoLFxuICAgIHN0eWxlOiB7XG4gICAgICBwYWRkaW5nOiBcIjhweCAxNnB4XCIsXG4gICAgICBmb250U2l6ZTogZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTQpLFxuICAgICAgbGluZUhlaWdodDogYCR7UG0oMTYgLyAxNCl9ZW1gLFxuICAgICAgZm9udFdlaWdodDogZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRSZWd1bGFyXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiB0XG4gICAgfSkgPT4gIXQuaXNSdGwsXG4gICAgc3R5bGU6IHtcbiAgICAgIFtgLiR7TmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwibGVmdFwiXSAmYF06IHtcbiAgICAgICAgbWFyZ2luUmlnaHQ6IFwiMTRweFwiXG4gICAgICB9LFxuICAgICAgW2AuJHtOZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJyaWdodFwiXSAmYF06IHtcbiAgICAgICAgbWFyZ2luTGVmdDogXCIxNHB4XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiAhdC5pc1J0bCAmJiB0LnRvdWNoLFxuICAgIHN0eWxlOiB7XG4gICAgICBbYC4ke05lLnBvcHBlcn1bZGF0YS1wb3BwZXItcGxhY2VtZW50Kj1cImxlZnRcIl0gJmBdOiB7XG4gICAgICAgIG1hcmdpblJpZ2h0OiBcIjI0cHhcIlxuICAgICAgfSxcbiAgICAgIFtgLiR7TmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwicmlnaHRcIl0gJmBdOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiMjRweFwiXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiB0XG4gICAgfSkgPT4gISF0LmlzUnRsLFxuICAgIHN0eWxlOiB7XG4gICAgICBbYC4ke05lLnBvcHBlcn1bZGF0YS1wb3BwZXItcGxhY2VtZW50Kj1cImxlZnRcIl0gJmBdOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiMTRweFwiXG4gICAgICB9LFxuICAgICAgW2AuJHtOZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJyaWdodFwiXSAmYF06IHtcbiAgICAgICAgbWFyZ2luUmlnaHQ6IFwiMTRweFwiXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiB0XG4gICAgfSkgPT4gISF0LmlzUnRsICYmIHQudG91Y2gsXG4gICAgc3R5bGU6IHtcbiAgICAgIFtgLiR7TmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwibGVmdFwiXSAmYF06IHtcbiAgICAgICAgbWFyZ2luTGVmdDogXCIyNHB4XCJcbiAgICAgIH0sXG4gICAgICBbYC4ke05lLnBvcHBlcn1bZGF0YS1wb3BwZXItcGxhY2VtZW50Kj1cInJpZ2h0XCJdICZgXToge1xuICAgICAgICBtYXJnaW5SaWdodDogXCIyNHB4XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiB0LnRvdWNoLFxuICAgIHN0eWxlOiB7XG4gICAgICBbYC4ke05lLnBvcHBlcn1bZGF0YS1wb3BwZXItcGxhY2VtZW50Kj1cInRvcFwiXSAmYF06IHtcbiAgICAgICAgbWFyZ2luQm90dG9tOiBcIjI0cHhcIlxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+IHQudG91Y2gsXG4gICAgc3R5bGU6IHtcbiAgICAgIFtgLiR7TmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwiYm90dG9tXCJdICZgXToge1xuICAgICAgICBtYXJnaW5Ub3A6IFwiMjRweFwiXG4gICAgICB9XG4gICAgfVxuICB9XVxufSkpKSwgTW0gPSBsZShcInNwYW5cIiwge1xuICBuYW1lOiBcIk11aVRvb2x0aXBcIixcbiAgc2xvdDogXCJBcnJvd1wiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHQuYXJyb3dcbn0pKHFlKCh7XG4gIHRoZW1lOiBlXG59KSA9PiAoe1xuICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgd2lkdGg6IFwiMWVtXCIsXG4gIGhlaWdodDogXCIwLjcxZW1cIixcbiAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgY29sb3I6IGUudmFycyA/IGUudmFycy5wYWxldHRlLlRvb2x0aXAuYmcgOiBEZShlLnBhbGV0dGUuZ3JleVs3MDBdLCAwLjkpLFxuICBcIiY6OmJlZm9yZVwiOiB7XG4gICAgY29udGVudDogJ1wiXCInLFxuICAgIG1hcmdpbjogXCJhdXRvXCIsXG4gICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogXCJjdXJyZW50Q29sb3JcIixcbiAgICB0cmFuc2Zvcm06IFwicm90YXRlKDQ1ZGVnKVwiXG4gIH1cbn0pKSk7XG5sZXQgdG4gPSAhMTtcbmNvbnN0IHZhID0gbmV3IFZuKCk7XG5sZXQgaHIgPSB7XG4gIHg6IDAsXG4gIHk6IDBcbn07XG5mdW5jdGlvbiBybihlLCB0KSB7XG4gIHJldHVybiAociwgLi4ubikgPT4ge1xuICAgIHQgJiYgdChyLCAuLi5uKSwgZShyLCAuLi5uKTtcbiAgfTtcbn1cbmNvbnN0IGpzID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IG4gPSBIZSh7XG4gICAgcHJvcHM6IHQsXG4gICAgbmFtZTogXCJNdWlUb29sdGlwXCJcbiAgfSksIHtcbiAgICBhcnJvdzogbyA9ICExLFxuICAgIGNoaWxkcmVuOiBpLFxuICAgIGNsYXNzZXM6IHMsXG4gICAgY29tcG9uZW50czogYyA9IHt9LFxuICAgIGNvbXBvbmVudHNQcm9wczogbCA9IHt9LFxuICAgIGRlc2NyaWJlQ2hpbGQ6IHUgPSAhMSxcbiAgICBkaXNhYmxlRm9jdXNMaXN0ZW5lcjogcCA9ICExLFxuICAgIGRpc2FibGVIb3Zlckxpc3RlbmVyOiBtID0gITEsXG4gICAgZGlzYWJsZUludGVyYWN0aXZlOiBnID0gITEsXG4gICAgZGlzYWJsZVRvdWNoTGlzdGVuZXI6IHggPSAhMSxcbiAgICBlbnRlckRlbGF5OiB5ID0gMTAwLFxuICAgIGVudGVyTmV4dERlbGF5OiBmID0gMCxcbiAgICBlbnRlclRvdWNoRGVsYXk6IFMgPSA3MDAsXG4gICAgZm9sbG93Q3Vyc29yOiBFID0gITEsXG4gICAgaWQ6IFAsXG4gICAgbGVhdmVEZWxheTogVCA9IDAsXG4gICAgbGVhdmVUb3VjaERlbGF5OiBiID0gMTUwMCxcbiAgICBvbkNsb3NlOiBoLFxuICAgIG9uT3BlbjogdyxcbiAgICBvcGVuOiBrLFxuICAgIHBsYWNlbWVudDogTCA9IFwiYm90dG9tXCIsXG4gICAgUG9wcGVyQ29tcG9uZW50OiBCLFxuICAgIFBvcHBlclByb3BzOiBkID0ge30sXG4gICAgc2xvdFByb3BzOiBBID0ge30sXG4gICAgc2xvdHM6IEQgPSB7fSxcbiAgICB0aXRsZTogaixcbiAgICBUcmFuc2l0aW9uQ29tcG9uZW50OiBXLFxuICAgIFRyYW5zaXRpb25Qcm9wczogeixcbiAgICAuLi5VXG4gIH0gPSBuLCBWID0gLyogQF9fUFVSRV9fICovIEMuaXNWYWxpZEVsZW1lbnQoaSkgPyBpIDogLyogQF9fUFVSRV9fICovIE4uanN4KFwic3BhblwiLCB7XG4gICAgY2hpbGRyZW46IGlcbiAgfSksIHRlID0gTHIoKSwgRiA9IGlzKCksIFtSLCBJXSA9IEMudXNlU3RhdGUoKSwgW0osIFFdID0gQy51c2VTdGF0ZShudWxsKSwgSCA9IEMudXNlUmVmKCExKSwgWCA9IGcgfHwgRSwgXyA9IER0KCksIHEgPSBEdCgpLCBHID0gRHQoKSwgcmUgPSBEdCgpLCBbWiwgYWVdID0gVnUoe1xuICAgIGNvbnRyb2xsZWQ6IGssXG4gICAgZGVmYXVsdDogITEsXG4gICAgbmFtZTogXCJUb29sdGlwXCIsXG4gICAgc3RhdGU6IFwib3BlblwiXG4gIH0pO1xuICBsZXQgTyA9IFo7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50OiBuZVxuICAgIH0gPSBDLnVzZVJlZihrICE9PSB2b2lkIDApO1xuICAgIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIFIgJiYgUi5kaXNhYmxlZCAmJiAhbmUgJiYgaiAhPT0gXCJcIiAmJiBSLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIiAmJiBjb25zb2xlLndhcm4oW1wiTVVJOiBZb3UgYXJlIHByb3ZpZGluZyBhIGRpc2FibGVkIGBidXR0b25gIGNoaWxkIHRvIHRoZSBUb29sdGlwIGNvbXBvbmVudC5cIiwgXCJBIGRpc2FibGVkIGVsZW1lbnQgZG9lcyBub3QgZmlyZSBldmVudHMuXCIsIFwiVG9vbHRpcCBuZWVkcyB0byBsaXN0ZW4gdG8gdGhlIGNoaWxkIGVsZW1lbnQncyBldmVudHMgdG8gZGlzcGxheSB0aGUgdGl0bGUuXCIsIFwiXCIsIFwiQWRkIGEgc2ltcGxlIHdyYXBwZXIgZWxlbWVudCwgc3VjaCBhcyBhIGBzcGFuYC5cIl0uam9pbihgXG5gKSk7XG4gICAgfSwgW2osIFIsIG5lXSk7XG4gIH1cbiAgY29uc3QgeWUgPSBRYShQKSwgRWUgPSBDLnVzZVJlZigpLCBNZSA9IFF0KCgpID0+IHtcbiAgICBFZS5jdXJyZW50ICE9PSB2b2lkIDAgJiYgKGRvY3VtZW50LmJvZHkuc3R5bGUuV2Via2l0VXNlclNlbGVjdCA9IEVlLmN1cnJlbnQsIEVlLmN1cnJlbnQgPSB2b2lkIDApLCByZS5jbGVhcigpO1xuICB9KTtcbiAgQy51c2VFZmZlY3QoKCkgPT4gTWUsIFtNZV0pO1xuICBjb25zdCBRZSA9IChuZSkgPT4ge1xuICAgIHZhLmNsZWFyKCksIHRuID0gITAsIGFlKCEwKSwgdyAmJiAhTyAmJiB3KG5lKTtcbiAgfSwgdmUgPSBRdChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlYWN0LlN5bnRoZXRpY0V2ZW50IHwgRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgKG5lKSA9PiB7XG4gICAgICB2YS5zdGFydCg4MDAgKyBULCAoKSA9PiB7XG4gICAgICAgIHRuID0gITE7XG4gICAgICB9KSwgYWUoITEpLCBoICYmIE8gJiYgaChuZSksIF8uc3RhcnQodGUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlc3QsICgpID0+IHtcbiAgICAgICAgSC5jdXJyZW50ID0gITE7XG4gICAgICB9KTtcbiAgICB9XG4gICksIFBlID0gKG5lKSA9PiB7XG4gICAgSC5jdXJyZW50ICYmIG5lLnR5cGUgIT09IFwidG91Y2hzdGFydFwiIHx8IChSICYmIFIucmVtb3ZlQXR0cmlidXRlKFwidGl0bGVcIiksIHEuY2xlYXIoKSwgRy5jbGVhcigpLCB5IHx8IHRuICYmIGYgPyBxLnN0YXJ0KHRuID8gZiA6IHksICgpID0+IHtcbiAgICAgIFFlKG5lKTtcbiAgICB9KSA6IFFlKG5lKSk7XG4gIH0sIHplID0gKG5lKSA9PiB7XG4gICAgcS5jbGVhcigpLCBHLnN0YXJ0KFQsICgpID0+IHtcbiAgICAgIHZlKG5lKTtcbiAgICB9KTtcbiAgfSwgWywgTGVdID0gQy51c2VTdGF0ZSghMSksIHYgPSAobmUpID0+IHtcbiAgICBobihuZS50YXJnZXQpIHx8IChMZSghMSksIHplKG5lKSk7XG4gIH0sIE0gPSAobmUpID0+IHtcbiAgICBSIHx8IEkobmUuY3VycmVudFRhcmdldCksIGhuKG5lLnRhcmdldCkgJiYgKExlKCEwKSwgUGUobmUpKTtcbiAgfSwgWSA9IChuZSkgPT4ge1xuICAgIEguY3VycmVudCA9ICEwO1xuICAgIGNvbnN0IGZ0ID0gVi5wcm9wcztcbiAgICBmdC5vblRvdWNoU3RhcnQgJiYgZnQub25Ub3VjaFN0YXJ0KG5lKTtcbiAgfSwgb2UgPSAobmUpID0+IHtcbiAgICBZKG5lKSwgRy5jbGVhcigpLCBfLmNsZWFyKCksIE1lKCksIEVlLmN1cnJlbnQgPSBkb2N1bWVudC5ib2R5LnN0eWxlLldlYmtpdFVzZXJTZWxlY3QsIGRvY3VtZW50LmJvZHkuc3R5bGUuV2Via2l0VXNlclNlbGVjdCA9IFwibm9uZVwiLCByZS5zdGFydChTLCAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLldlYmtpdFVzZXJTZWxlY3QgPSBFZS5jdXJyZW50LCBQZShuZSk7XG4gICAgfSk7XG4gIH0sIFJlID0gKG5lKSA9PiB7XG4gICAgVi5wcm9wcy5vblRvdWNoRW5kICYmIFYucHJvcHMub25Ub3VjaEVuZChuZSksIE1lKCksIEcuc3RhcnQoYiwgKCkgPT4ge1xuICAgICAgdmUobmUpO1xuICAgIH0pO1xuICB9O1xuICBDLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFPKVxuICAgICAgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIG5lKGZ0KSB7XG4gICAgICBmdC5rZXkgPT09IFwiRXNjYXBlXCIgJiYgdmUoZnQpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgbmUpLCAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBuZSk7XG4gICAgfTtcbiAgfSwgW3ZlLCBPXSk7XG4gIGNvbnN0IHVlID0gYXQoQm8oViksIEksIHIpO1xuICAhaiAmJiBqICE9PSAwICYmIChPID0gITEpO1xuICBjb25zdCBLID0gQy51c2VSZWYoKSwgYmUgPSAobmUpID0+IHtcbiAgICBjb25zdCBmdCA9IFYucHJvcHM7XG4gICAgZnQub25Nb3VzZU1vdmUgJiYgZnQub25Nb3VzZU1vdmUobmUpLCBociA9IHtcbiAgICAgIHg6IG5lLmNsaWVudFgsXG4gICAgICB5OiBuZS5jbGllbnRZXG4gICAgfSwgSy5jdXJyZW50ICYmIEsuY3VycmVudC51cGRhdGUoKTtcbiAgfSwgd2UgPSB7fSwgT2UgPSB0eXBlb2YgaiA9PSBcInN0cmluZ1wiO1xuICB1ID8gKHdlLnRpdGxlID0gIU8gJiYgT2UgJiYgIW0gPyBqIDogbnVsbCwgd2VbXCJhcmlhLWRlc2NyaWJlZGJ5XCJdID0gTyA/IHllIDogbnVsbCkgOiAod2VbXCJhcmlhLWxhYmVsXCJdID0gT2UgPyBqIDogbnVsbCwgd2VbXCJhcmlhLWxhYmVsbGVkYnlcIl0gPSBPICYmICFPZSA/IHllIDogbnVsbCk7XG4gIGNvbnN0IGNlID0ge1xuICAgIC4uLndlLFxuICAgIC4uLlUsXG4gICAgLi4uVi5wcm9wcyxcbiAgICBjbGFzc05hbWU6IHNlKFUuY2xhc3NOYW1lLCBWLnByb3BzLmNsYXNzTmFtZSksXG4gICAgb25Ub3VjaFN0YXJ0OiBZLFxuICAgIHJlZjogdWUsXG4gICAgLi4uRSA/IHtcbiAgICAgIG9uTW91c2VNb3ZlOiBiZVxuICAgIH0gOiB7fVxuICB9O1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGNlW1wiZGF0YS1tdWktaW50ZXJuYWwtY2xvbmUtZWxlbWVudFwiXSA9ICEwLCBDLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgUiAmJiAhUi5nZXRBdHRyaWJ1dGUoXCJkYXRhLW11aS1pbnRlcm5hbC1jbG9uZS1lbGVtZW50XCIpICYmIGNvbnNvbGUuZXJyb3IoW1wiTVVJOiBUaGUgYGNoaWxkcmVuYCBjb21wb25lbnQgb2YgdGhlIFRvb2x0aXAgaXMgbm90IGZvcndhcmRpbmcgaXRzIHByb3BzIGNvcnJlY3RseS5cIiwgXCJQbGVhc2UgbWFrZSBzdXJlIHRoYXQgcHJvcHMgYXJlIHNwcmVhZCBvbiB0aGUgc2FtZSBlbGVtZW50IHRoYXQgdGhlIHJlZiBpcyBhcHBsaWVkIHRvLlwiXS5qb2luKGBcbmApKTtcbiAgfSwgW1JdKSk7XG4gIGNvbnN0IEllID0ge307XG4gIHggfHwgKGNlLm9uVG91Y2hTdGFydCA9IG9lLCBjZS5vblRvdWNoRW5kID0gUmUpLCBtIHx8IChjZS5vbk1vdXNlT3ZlciA9IHJuKFBlLCBjZS5vbk1vdXNlT3ZlciksIGNlLm9uTW91c2VMZWF2ZSA9IHJuKHplLCBjZS5vbk1vdXNlTGVhdmUpLCBYIHx8IChJZS5vbk1vdXNlT3ZlciA9IFBlLCBJZS5vbk1vdXNlTGVhdmUgPSB6ZSkpLCBwIHx8IChjZS5vbkZvY3VzID0gcm4oTSwgY2Uub25Gb2N1cyksIGNlLm9uQmx1ciA9IHJuKHYsIGNlLm9uQmx1ciksIFggfHwgKEllLm9uRm9jdXMgPSBNLCBJZS5vbkJsdXIgPSB2KSksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBWLnByb3BzLnRpdGxlICYmIGNvbnNvbGUuZXJyb3IoW1wiTVVJOiBZb3UgaGF2ZSBwcm92aWRlZCBhIGB0aXRsZWAgcHJvcCB0byB0aGUgY2hpbGQgb2YgPFRvb2x0aXAgLz4uXCIsIGBSZW1vdmUgdGhpcyB0aXRsZSBwcm9wIFxcYCR7Vi5wcm9wcy50aXRsZX1cXGAgb3IgdGhlIFRvb2x0aXAgY29tcG9uZW50LmBdLmpvaW4oYFxuYCkpO1xuICBjb25zdCBXZSA9IHtcbiAgICAuLi5uLFxuICAgIGlzUnRsOiBGLFxuICAgIGFycm93OiBvLFxuICAgIGRpc2FibGVJbnRlcmFjdGl2ZTogWCxcbiAgICBwbGFjZW1lbnQ6IEwsXG4gICAgUG9wcGVyQ29tcG9uZW50UHJvcDogQixcbiAgICB0b3VjaDogSC5jdXJyZW50XG4gIH0sIFVlID0gdHlwZW9mIEEucG9wcGVyID09IFwiZnVuY3Rpb25cIiA/IEEucG9wcGVyKFdlKSA6IEEucG9wcGVyLCB1dCA9IEMudXNlTWVtbygoKSA9PiB7XG4gICAgdmFyIGZ0LCBpaTtcbiAgICBsZXQgbmUgPSBbe1xuICAgICAgbmFtZTogXCJhcnJvd1wiLFxuICAgICAgZW5hYmxlZDogISFKLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBlbGVtZW50OiBKLFxuICAgICAgICBwYWRkaW5nOiA0XG4gICAgICB9XG4gICAgfV07XG4gICAgcmV0dXJuIChmdCA9IGQucG9wcGVyT3B0aW9ucykgIT0gbnVsbCAmJiBmdC5tb2RpZmllcnMgJiYgKG5lID0gbmUuY29uY2F0KGQucG9wcGVyT3B0aW9ucy5tb2RpZmllcnMpKSwgKGlpID0gVWUgPT0gbnVsbCA/IHZvaWQgMCA6IFVlLnBvcHBlck9wdGlvbnMpICE9IG51bGwgJiYgaWkubW9kaWZpZXJzICYmIChuZSA9IG5lLmNvbmNhdChVZS5wb3BwZXJPcHRpb25zLm1vZGlmaWVycykpLCB7XG4gICAgICAuLi5kLnBvcHBlck9wdGlvbnMsXG4gICAgICAuLi5VZSA9PSBudWxsID8gdm9pZCAwIDogVWUucG9wcGVyT3B0aW9ucyxcbiAgICAgIG1vZGlmaWVyczogbmVcbiAgICB9O1xuICB9LCBbSiwgZC5wb3BwZXJPcHRpb25zLCBVZSA9PSBudWxsID8gdm9pZCAwIDogVWUucG9wcGVyT3B0aW9uc10pLCBVbiA9IGttKFdlKSwgQnMgPSB0eXBlb2YgQS50cmFuc2l0aW9uID09IFwiZnVuY3Rpb25cIiA/IEEudHJhbnNpdGlvbihXZSkgOiBBLnRyYW5zaXRpb24sIHpyID0ge1xuICAgIHNsb3RzOiB7XG4gICAgICBwb3BwZXI6IGMuUG9wcGVyLFxuICAgICAgdHJhbnNpdGlvbjogYy5UcmFuc2l0aW9uID8/IFcsXG4gICAgICB0b29sdGlwOiBjLlRvb2x0aXAsXG4gICAgICBhcnJvdzogYy5BcnJvdyxcbiAgICAgIC4uLkRcbiAgICB9LFxuICAgIHNsb3RQcm9wczoge1xuICAgICAgYXJyb3c6IEEuYXJyb3cgPz8gbC5hcnJvdyxcbiAgICAgIHBvcHBlcjoge1xuICAgICAgICAuLi5kLFxuICAgICAgICAuLi5VZSA/PyBsLnBvcHBlclxuICAgICAgfSxcbiAgICAgIC8vIHJlc29sdmVkUG9wcGVyUHJvcHMgY2FuIGJlIHNwcmVhZCBiZWNhdXNlIGl0J3MgYWxyZWFkeSBhbiBvYmplY3RcbiAgICAgIHRvb2x0aXA6IEEudG9vbHRpcCA/PyBsLnRvb2x0aXAsXG4gICAgICB0cmFuc2l0aW9uOiB7XG4gICAgICAgIC4uLnosXG4gICAgICAgIC4uLkJzID8/IGwudHJhbnNpdGlvblxuICAgICAgfVxuICAgIH1cbiAgfSwgW1ZzLCBGc10gPSBCdChcInBvcHBlclwiLCB7XG4gICAgZWxlbWVudFR5cGU6IEFtLFxuICAgIGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6IHpyLFxuICAgIG93bmVyU3RhdGU6IFdlLFxuICAgIGNsYXNzTmFtZTogc2UoVW4ucG9wcGVyLCBkID09IG51bGwgPyB2b2lkIDAgOiBkLmNsYXNzTmFtZSlcbiAgfSksIFt6cywgV3NdID0gQnQoXCJ0cmFuc2l0aW9uXCIsIHtcbiAgICBlbGVtZW50VHlwZTogT24sXG4gICAgZXh0ZXJuYWxGb3J3YXJkZWRQcm9wczogenIsXG4gICAgb3duZXJTdGF0ZTogV2VcbiAgfSksIFtVcywgWXNdID0gQnQoXCJ0b29sdGlwXCIsIHtcbiAgICBlbGVtZW50VHlwZTogTm0sXG4gICAgY2xhc3NOYW1lOiBVbi50b29sdGlwLFxuICAgIGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6IHpyLFxuICAgIG93bmVyU3RhdGU6IFdlXG4gIH0pLCBbSHMsIHFzXSA9IEJ0KFwiYXJyb3dcIiwge1xuICAgIGVsZW1lbnRUeXBlOiBNbSxcbiAgICBjbGFzc05hbWU6IFVuLmFycm93LFxuICAgIGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6IHpyLFxuICAgIG93bmVyU3RhdGU6IFdlLFxuICAgIHJlZjogUVxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeHMoQy5GcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIEMuY2xvbmVFbGVtZW50KFYsIGNlKSwgLyogQF9fUFVSRV9fICovIE4uanN4KFZzLCB7XG4gICAgICBhczogQiA/PyBlaSxcbiAgICAgIHBsYWNlbWVudDogTCxcbiAgICAgIGFuY2hvckVsOiBFID8ge1xuICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6ICgpID0+ICh7XG4gICAgICAgICAgdG9wOiBoci55LFxuICAgICAgICAgIGxlZnQ6IGhyLngsXG4gICAgICAgICAgcmlnaHQ6IGhyLngsXG4gICAgICAgICAgYm90dG9tOiBoci55LFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9KVxuICAgICAgfSA6IFIsXG4gICAgICBwb3BwZXJSZWY6IEssXG4gICAgICBvcGVuOiBSID8gTyA6ICExLFxuICAgICAgaWQ6IHllLFxuICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAuLi5JZSxcbiAgICAgIC4uLkZzLFxuICAgICAgcG9wcGVyT3B0aW9uczogdXQsXG4gICAgICBjaGlsZHJlbjogKHtcbiAgICAgICAgVHJhbnNpdGlvblByb3BzOiBuZVxuICAgICAgfSkgPT4gLyogQF9fUFVSRV9fICovIE4uanN4KHpzLCB7XG4gICAgICAgIHRpbWVvdXQ6IHRlLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXIsXG4gICAgICAgIC4uLm5lLFxuICAgICAgICAuLi5XcyxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeHMoVXMsIHtcbiAgICAgICAgICAuLi5ZcyxcbiAgICAgICAgICBjaGlsZHJlbjogW2osIG8gPyAvKiBAX19QVVJFX18gKi8gTi5qc3goSHMsIHtcbiAgICAgICAgICAgIC4uLnFzXG4gICAgICAgICAgfSkgOiBudWxsXVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KV1cbiAgfSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoanMucHJvcFR5cGVzID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiAgICBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4gICAgIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYWRkcyBhbiBhcnJvdyB0byB0aGUgdG9vbHRpcC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFycm93OiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUb29sdGlwIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IGpvLmlzUmVxdWlyZWQsXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjbGFzc2VzOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgdGhlIGBzbG90c2AgcHJvcCBpbnN0ZWFkLiBUaGlzIHByb3Agd2lsbCBiZSByZW1vdmVkIGluIHY3LiBTZWUgW01pZ3JhdGluZyBmcm9tIGRlcHJlY2F0ZWQgQVBJc10oaHR0cHM6Ly9tdWkuY29tL21hdGVyaWFsLXVpL21pZ3JhdGlvbi9taWdyYXRpbmctZnJvbS1kZXByZWNhdGVkLWFwaXMvKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgY29tcG9uZW50czogYS5zaGFwZSh7XG4gICAgQXJyb3c6IGEuZWxlbWVudFR5cGUsXG4gICAgUG9wcGVyOiBhLmVsZW1lbnRUeXBlLFxuICAgIFRvb2x0aXA6IGEuZWxlbWVudFR5cGUsXG4gICAgVHJhbnNpdGlvbjogYS5lbGVtZW50VHlwZVxuICB9KSxcbiAgLyoqXG4gICAqIFRoZSBleHRyYSBwcm9wcyBmb3IgdGhlIHNsb3QgY29tcG9uZW50cy5cbiAgICogWW91IGNhbiBvdmVycmlkZSB0aGUgZXhpc3RpbmcgcHJvcHMgb3IgYWRkIG5ldyBvbmVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgdGhlIGBzbG90UHJvcHNgIHByb3AgaW5zdGVhZC4gVGhpcyBwcm9wIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4gU2VlIFtNaWdyYXRpbmcgZnJvbSBkZXByZWNhdGVkIEFQSXNdKGh0dHBzOi8vbXVpLmNvbS9tYXRlcmlhbC11aS9taWdyYXRpb24vbWlncmF0aW5nLWZyb20tZGVwcmVjYXRlZC1hcGlzLykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIGNvbXBvbmVudHNQcm9wczogYS5zaGFwZSh7XG4gICAgYXJyb3c6IGEub2JqZWN0LFxuICAgIHBvcHBlcjogYS5vYmplY3QsXG4gICAgdG9vbHRpcDogYS5vYmplY3QsXG4gICAgdHJhbnNpdGlvbjogYS5vYmplY3RcbiAgfSksXG4gIC8qKlxuICAgKiBTZXQgdG8gYHRydWVgIGlmIHRoZSBgdGl0bGVgIGFjdHMgYXMgYW4gYWNjZXNzaWJsZSBkZXNjcmlwdGlvbi5cbiAgICogQnkgZGVmYXVsdCB0aGUgYHRpdGxlYCBhY3RzIGFzIGFuIGFjY2Vzc2libGUgbGFiZWwgZm9yIHRoZSBjaGlsZC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRlc2NyaWJlQ2hpbGQ6IGEuYm9vbCxcbiAgLyoqXG4gICAqIERvIG5vdCByZXNwb25kIHRvIGZvY3VzLXZpc2libGUgZXZlbnRzLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZUZvY3VzTGlzdGVuZXI6IGEuYm9vbCxcbiAgLyoqXG4gICAqIERvIG5vdCByZXNwb25kIHRvIGhvdmVyIGV2ZW50cy5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVIb3Zlckxpc3RlbmVyOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBNYWtlcyBhIHRvb2x0aXAgbm90IGludGVyYWN0aXZlLCBpLmUuIGl0IHdpbGwgY2xvc2Ugd2hlbiB0aGUgdXNlclxuICAgKiBob3ZlcnMgb3ZlciB0aGUgdG9vbHRpcCBiZWZvcmUgdGhlIGBsZWF2ZURlbGF5YCBpcyBleHBpcmVkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZUludGVyYWN0aXZlOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBEbyBub3QgcmVzcG9uZCB0byBsb25nIHByZXNzIHRvdWNoIGV2ZW50cy5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVUb3VjaExpc3RlbmVyOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBzaG93aW5nIHRoZSB0b29sdGlwLlxuICAgKiBUaGlzIHByb3Agd29uJ3QgaW1wYWN0IHRoZSBlbnRlciB0b3VjaCBkZWxheSAoYGVudGVyVG91Y2hEZWxheWApLlxuICAgKiBAZGVmYXVsdCAxMDBcbiAgICovXG4gIGVudGVyRGVsYXk6IGEubnVtYmVyLFxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgc2hvd2luZyB0aGUgdG9vbHRpcCB3aGVuIG9uZSB3YXMgYWxyZWFkeSByZWNlbnRseSBvcGVuZWQuXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGVudGVyTmV4dERlbGF5OiBhLm51bWJlcixcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGEgdXNlciBtdXN0IHRvdWNoIHRoZSBlbGVtZW50IGJlZm9yZSBzaG93aW5nIHRoZSB0b29sdGlwLlxuICAgKiBAZGVmYXVsdCA3MDBcbiAgICovXG4gIGVudGVyVG91Y2hEZWxheTogYS5udW1iZXIsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB0b29sdGlwIGZvbGxvdyB0aGUgY3Vyc29yIG92ZXIgdGhlIHdyYXBwZWQgZWxlbWVudC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGZvbGxvd0N1cnNvcjogYS5ib29sLFxuICAvKipcbiAgICogVGhpcyBwcm9wIGlzIHVzZWQgdG8gaGVscCBpbXBsZW1lbnQgdGhlIGFjY2Vzc2liaWxpdHkgbG9naWMuXG4gICAqIElmIHlvdSBkb24ndCBwcm92aWRlIHRoaXMgcHJvcC4gSXQgZmFsbHMgYmFjayB0byBhIHJhbmRvbWx5IGdlbmVyYXRlZCBpZC5cbiAgICovXG4gIGlkOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGhpZGluZyB0aGUgdG9vbHRpcC5cbiAgICogVGhpcyBwcm9wIHdvbid0IGltcGFjdCB0aGUgbGVhdmUgdG91Y2ggZGVsYXkgKGBsZWF2ZVRvdWNoRGVsYXlgKS5cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgbGVhdmVEZWxheTogYS5udW1iZXIsXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhZnRlciB0aGUgdXNlciBzdG9wcyB0b3VjaGluZyBhbiBlbGVtZW50IGJlZm9yZSBoaWRpbmcgdGhlIHRvb2x0aXAuXG4gICAqIEBkZWZhdWx0IDE1MDBcbiAgICovXG4gIGxlYXZlVG91Y2hEZWxheTogYS5udW1iZXIsXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgcmVxdWVzdHMgdG8gYmUgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0LlN5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICovXG4gIG9uQ2xvc2U6IGEuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCByZXF1ZXN0cyB0byBiZSBvcGVuLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0LlN5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICovXG4gIG9uT3BlbjogYS5mdW5jLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IGlzIHNob3duLlxuICAgKi9cbiAgb3BlbjogYS5ib29sLFxuICAvKipcbiAgICogVG9vbHRpcCBwbGFjZW1lbnQuXG4gICAqIEBkZWZhdWx0ICdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6IGEub25lT2YoW1wiYm90dG9tLWVuZFwiLCBcImJvdHRvbS1zdGFydFwiLCBcImJvdHRvbVwiLCBcImxlZnQtZW5kXCIsIFwibGVmdC1zdGFydFwiLCBcImxlZnRcIiwgXCJyaWdodC1lbmRcIiwgXCJyaWdodC1zdGFydFwiLCBcInJpZ2h0XCIsIFwidG9wLWVuZFwiLCBcInRvcC1zdGFydFwiLCBcInRvcFwiXSksXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSBwb3BwZXIuXG4gICAqIEBkZXByZWNhdGVkIHVzZSB0aGUgYHNsb3RzLnBvcHBlcmAgcHJvcCBpbnN0ZWFkLiBUaGlzIHByb3Agd2lsbCBiZSByZW1vdmVkIGluIHY3LiBTZWUgW01pZ3JhdGluZyBmcm9tIGRlcHJlY2F0ZWQgQVBJc10oaHR0cHM6Ly9tdWkuY29tL21hdGVyaWFsLXVpL21pZ3JhdGlvbi9taWdyYXRpbmctZnJvbS1kZXByZWNhdGVkLWFwaXMvKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgUG9wcGVyQ29tcG9uZW50OiBhLmVsZW1lbnRUeXBlLFxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgW2BQb3BwZXJgXShodHRwczovL211aS5jb20vbWF0ZXJpYWwtdWkvYXBpL3BvcHBlci8pIGVsZW1lbnQuXG4gICAqIEBkZXByZWNhdGVkIHVzZSB0aGUgYHNsb3RQcm9wcy5wb3BwZXJgIHByb3AgaW5zdGVhZC4gVGhpcyBwcm9wIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4gU2VlIFtNaWdyYXRpbmcgZnJvbSBkZXByZWNhdGVkIEFQSXNdKGh0dHBzOi8vbXVpLmNvbS9tYXRlcmlhbC11aS9taWdyYXRpb24vbWlncmF0aW5nLWZyb20tZGVwcmVjYXRlZC1hcGlzLykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIFBvcHBlclByb3BzOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIFRoZSBwcm9wcyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgc2xvdFByb3BzOiBhLnNoYXBlKHtcbiAgICBhcnJvdzogYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3RdKSxcbiAgICBwb3BwZXI6IGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0XSksXG4gICAgdG9vbHRpcDogYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3RdKSxcbiAgICB0cmFuc2l0aW9uOiBhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdF0pXG4gIH0pLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudHMgdXNlZCBmb3IgZWFjaCBzbG90IGluc2lkZS5cbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIHNsb3RzOiBhLnNoYXBlKHtcbiAgICBhcnJvdzogYS5lbGVtZW50VHlwZSxcbiAgICBwb3BwZXI6IGEuZWxlbWVudFR5cGUsXG4gICAgdG9vbHRpcDogYS5lbGVtZW50VHlwZSxcbiAgICB0cmFuc2l0aW9uOiBhLmVsZW1lbnRUeXBlXG4gIH0pLFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSksXG4gIC8qKlxuICAgKiBUb29sdGlwIHRpdGxlLiBaZXJvLWxlbmd0aCB0aXRsZXMgc3RyaW5nLCB1bmRlZmluZWQsIG51bGwgYW5kIGZhbHNlIGFyZSBuZXZlciBkaXNwbGF5ZWQuXG4gICAqL1xuICB0aXRsZTogYS5ub2RlLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgdHJhbnNpdGlvbi5cbiAgICogW0ZvbGxvdyB0aGlzIGd1aWRlXShodHRwczovL211aS5jb20vbWF0ZXJpYWwtdWkvdHJhbnNpdGlvbnMvI3RyYW5zaXRpb25jb21wb25lbnQtcHJvcCkgdG8gbGVhcm4gbW9yZSBhYm91dCB0aGUgcmVxdWlyZW1lbnRzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICogQGRlcHJlY2F0ZWQgdXNlIHRoZSBgc2xvdHMudHJhbnNpdGlvbmAgcHJvcCBpbnN0ZWFkLiBUaGlzIHByb3Agd2lsbCBiZSByZW1vdmVkIGluIHY3LiBTZWUgW01pZ3JhdGluZyBmcm9tIGRlcHJlY2F0ZWQgQVBJc10oaHR0cHM6Ly9tdWkuY29tL21hdGVyaWFsLXVpL21pZ3JhdGlvbi9taWdyYXRpbmctZnJvbS1kZXByZWNhdGVkLWFwaXMvKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgVHJhbnNpdGlvbkNvbXBvbmVudDogYS5lbGVtZW50VHlwZSxcbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIHRyYW5zaXRpb24gZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgdGhlIGVsZW1lbnQgaXMgYmFzZWQgb24gdGhpcyBbYFRyYW5zaXRpb25gXShodHRwczovL3JlYWN0Y29tbXVuaXR5Lm9yZy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL3RyYW5zaXRpb24vKSBjb21wb25lbnQuXG4gICAqIEBkZXByZWNhdGVkIHVzZSB0aGUgYHNsb3RQcm9wcy50cmFuc2l0aW9uYCBwcm9wIGluc3RlYWQuIFRoaXMgcHJvcCB3aWxsIGJlIHJlbW92ZWQgaW4gdjcuIFNlZSBbTWlncmF0aW5nIGZyb20gZGVwcmVjYXRlZCBBUElzXShodHRwczovL211aS5jb20vbWF0ZXJpYWwtdWkvbWlncmF0aW9uL21pZ3JhdGluZy1mcm9tLWRlcHJlY2F0ZWQtYXBpcy8pIGZvciBtb3JlIGRldGFpbHMuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBUcmFuc2l0aW9uUHJvcHM6IGEub2JqZWN0XG59KTtcbmNvbnN0IEltID0gc3IoLyogQF9fUFVSRV9fICovIE4uanN4KFwicGF0aFwiLCB7XG4gIGQ6IFwiTTEyIDJDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJtMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDhtMC0xMi41Yy0yLjQ5IDAtNC41IDIuMDEtNC41IDQuNXMyLjAxIDQuNSA0LjUgNC41IDQuNS0yLjAxIDQuNS00LjUtMi4wMS00LjUtNC41LTQuNW0wIDUuNWMtLjU1IDAtMS0uNDUtMS0xcy40NS0xIDEtMSAxIC40NSAxIDEtLjQ1IDEtMSAxXCJcbn0pLCBcIkFsYnVtT3V0bGluZWRcIiksIF9tID0gKHtcbiAgdXNlck5hbWU6IGUgPSBcIlwiLFxuICBkZXNpZ25hdGlvbjogdCA9IFwiXCIsXG4gIHVzZXJpbWc6IHIgPSBcIlwiLFxuICBpc0NvbGxhcHNlOiBuID0gITEsXG4gIG9uTG9nb3V0OiBvXG59KSA9PiB7XG4gIGNvbnN0IGkgPSBMcigpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KGR0LCB7IGNoaWxkcmVuOiBuID8gXCJcIiA6IC8qIEBfX1BVUkVfXyAqLyBOLmpzeHMoXG4gICAgZHQsXG4gICAge1xuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgZ2FwOiAyLFxuICAgICAgc3g6IHtcbiAgICAgICAgbTogMyxcbiAgICAgICAgcDogMixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjhweFwiLFxuICAgICAgICBiZ2NvbG9yOiBpLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4gKyAyMFxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChfcywgeyBhbHQ6IFwiUmVteSBTaGFycFwiLCBzcmM6IHIgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBOLmpzeHMoZHQsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gTi5qc3goYnQsIHsgdmFyaWFudDogXCJoNlwiLCBjaGlsZHJlbjogZSB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gTi5qc3goYnQsIHsgdmFyaWFudDogXCJjYXB0aW9uXCIsIGNoaWxkcmVuOiB0IH0pXG4gICAgICAgIF0gfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChkdCwgeyBzeDogeyBtbDogXCJhdXRvXCIgfSwgb25DbGljazogbywgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChqcywgeyB0aXRsZTogXCJMb2dvdXRcIiwgcGxhY2VtZW50OiBcInRvcFwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KENzLCB7IGNvbG9yOiBcInByaW1hcnlcIiwgXCJhcmlhLWxhYmVsXCI6IFwibG9nb3V0XCIsIHNpemU6IFwic21hbGxcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChJbSwge30pIH0pIH0pIH0pXG4gICAgICBdXG4gICAgfVxuICApIH0pO1xufSwgRnIgPSBDLmNyZWF0ZUNvbnRleHQoe1xuICB3aWR0aDogXCIyNzBweFwiLFxuICBjb2xsYXBzZXdpZHRoOiBcIjgwcHhcIixcbiAgdGV4dENvbG9yOiBcIiM4RDkzOURcIixcbiAgaXNDb2xsYXBzZTogITEsXG4gIHRoZW1lQ29sb3I6IFwiIzVkODdmZlwiXG59KTtcbmxldCBqbSA9ICgpID0+IHtcbiAgYWxlcnQoXCJMb2dvdXQgU3VjY2Vzc2Z1bGx5XCIpO1xufTtcbmNvbnN0IFVtID0gKHtcbiAgY2hpbGRyZW46IGUsXG4gIHdpZHRoOiB0ID0gXCIyNjBweFwiLFxuICBjb2xsYXBzZXdpZHRoOiByID0gXCI4MHB4XCIsXG4gIHRleHRDb2xvcjogbiA9IFwiIzJiMmIyYlwiLFxuICBpc0NvbGxhcHNlOiBvID0gITEsXG4gIHRoZW1lQ29sb3I6IGkgPSBcIiM1ZDg3ZmZcIixcbiAgdGhlbWVTZWNvbmRhcnlDb2xvcjogcyA9IFwiIzQ5YmVmZlwiLFxuICBtb2RlOiBjID0gXCJsaWdodFwiLFxuICBkaXJlY3Rpb246IGwgPSBcImx0clwiLFxuICB1c2VyTmFtZTogdSA9IFwiTWF0aGV3XCIsXG4gIGRlc2lnbmF0aW9uOiBwID0gXCJEZXNpZ25lclwiLFxuICBzaG93UHJvZmlsZTogbSA9ICEwLFxuICB1c2VyaW1nOiBnID0gXCJodHRwczovL2Jvb3RzdHJhcGRlbW9zLmFkbWlubWFydC5jb20vbW9kZXJuaXplL2Rpc3QvYXNzZXRzL2ltYWdlcy9wcm9maWxlL3VzZXItMS5qcGdcIixcbiAgb25Mb2dvdXQ6IHggPSBqbVxufSkgPT4ge1xuICBjb25zdCBbeSwgZl0gPSBDLnVzZVN0YXRlKCExKSwgUyA9IG8gJiYgIXkgPyByIDogdCwgRSA9IEZuKHtcbiAgICBkaXJlY3Rpb246IGwsXG4gICAgcGFsZXR0ZToge1xuICAgICAgbW9kZTogYyxcbiAgICAgIHByaW1hcnk6IHtcbiAgICAgICAgbWFpbjogaVxuICAgICAgfSxcbiAgICAgIHNlY29uZGFyeToge1xuICAgICAgICBtYWluOiBzLFxuICAgICAgICBjb250cmFzdFRleHQ6IFwiI2ZmZlwiXG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGMgPT09IFwiZGFya1wiICYmIChuID0gXCJyZ2JhKDI1NSwyNTUsMjU1LCAwLjkpXCIpLCAvKiBAX19QVVJFX18gKi8gTi5qc3goemYsIHsgdGhlbWU6IEUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goXG4gICAgZHQsXG4gICAge1xuICAgICAgZGlyOiBsLFxuICAgICAgc3g6IHtcbiAgICAgICAgd2lkdGg6IFMsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGZvbnRGYW1pbHk6IFwiaW5oZXJpdFwiLFxuICAgICAgICBjb2xvcjogblxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3hzKGR0LCB7IHN4OiB7IHdpZHRoOiBTIH0sIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChcbiAgICAgICAgICBGci5Qcm92aWRlcixcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YWx1ZTogeyB0ZXh0Q29sb3I6IG4sIGlzQ29sbGFwc2U6IG8sIHdpZHRoOiB0LCBjb2xsYXBzZXdpZHRoOiByLCB0aGVtZUNvbG9yOiBpIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogZVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgbSA/IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChcbiAgICAgICAgICBfbSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB1c2VyTmFtZTogdSxcbiAgICAgICAgICAgIGRlc2lnbmF0aW9uOiBwLFxuICAgICAgICAgICAgdXNlcmltZzogZyxcbiAgICAgICAgICAgIGlzQ29sbGFwc2U6IG8sXG4gICAgICAgICAgICBvbkxvZ291dDogeFxuICAgICAgICAgIH1cbiAgICAgICAgKSA6IG51bGxcbiAgICAgIF0gfSlcbiAgICB9XG4gICkgfSk7XG59LCBZbSA9ICh7IGNoaWxkcmVuOiBlLCBzdWJIZWFkaW5nOiB0ID0gXCJtZW51XCIgfSkgPT4ge1xuICBjb25zdCByID0gQy51c2VDb250ZXh0KEZyKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChkdCwgeyBzeDogeyBweDogci5pc0NvbGxhcHNlID8gMiA6IDMsIHB0OiAyIH0sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goXG4gICAgdGksXG4gICAge1xuICAgICAgY29tcG9uZW50OiBcIm5hdlwiLFxuICAgICAgc3ViaGVhZGVyOiAvKiBAX19QVVJFX18gKi8gTi5qc3goXG4gICAgICAgIHduLFxuICAgICAgICB7XG4gICAgICAgICAgY29tcG9uZW50OiBcImRpdlwiLFxuICAgICAgICAgIHN4OiB7XG4gICAgICAgICAgICBwYWRkaW5nWTogXCIzcHhcIixcbiAgICAgICAgICAgIGNvbG9yOiByLnRleHRDb2xvcixcbiAgICAgICAgICAgIHBhZGRpbmdYOiBcIjBweFwiLFxuICAgICAgICAgICAgbGluZUhlaWdodDogXCIyMHB4XCIsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICAgICAgICAgIGZvbnRTaXplOiBcIjEycHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRyZW46IHIuaXNDb2xsYXBzZSA/IFwiLi4uXCIgOiB0XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBjaGlsZHJlbjogZVxuICAgIH1cbiAgKSB9KTtcbn0sIERtID0gc3IoLyogQF9fUFVSRV9fICovIE4uanN4KFwicGF0aFwiLCB7XG4gIGQ6IFwibTEyIDgtNiA2IDEuNDEgMS40MUwxMiAxMC44M2w0LjU5IDQuNThMMTggMTR6XCJcbn0pLCBcIkV4cGFuZExlc3NcIiksIExtID0gc3IoLyogQF9fUFVSRV9fICovIE4uanN4KFwicGF0aFwiLCB7XG4gIGQ6IFwiTTE2LjU5IDguNTkgMTIgMTMuMTcgNy40MSA4LjU5IDYgMTBsNiA2IDYtNnpcIlxufSksIFwiRXhwYW5kTW9yZVwiKSwgRHMgPSBzcigvKiBAX19QVVJFX18gKi8gTi5qc3goXCJwYXRoXCIsIHtcbiAgZDogXCJNMTIgMkM2LjQ3IDIgMiA2LjQ3IDIgMTJzNC40NyAxMCAxMCAxMCAxMC00LjQ3IDEwLTEwUzE3LjUzIDIgMTIgMm0wIDE4Yy00LjQyIDAtOC0zLjU4LTgtOHMzLjU4LTggOC04IDggMy41OCA4IDgtMy41OCA4LTggOFwiXG59KSwgXCJDaXJjbGVPdXRsaW5lZFwiKSwgSG0gPSAoe1xuICBjaGlsZHJlbjogZSxcbiAgdGl0bGU6IHQgPSBcIlwiLFxuICBpY29uOiByLFxuICBib3JkZXJSYWRpdXM6IG4gPSBcIjhweFwiLFxuICB0ZXh0Rm9udFNpemU6IG8gPSBcIjE0cHhcIixcbiAgZGlzYWJsZWQ6IGkgPSAhMVxufSkgPT4ge1xuICBjb25zdCBzID0gQy51c2VDb250ZXh0KEZyKSwgW2MsIGxdID0gQy51c2VTdGF0ZSghMSksIHUgPSAoKSA9PiB7XG4gICAgbCghYyk7XG4gIH0sIHAgPSBsZShyaSkoKCkgPT4gKHtcbiAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICAgIG1hcmdpbkJvdHRvbTogXCIycHhcIixcbiAgICBwYWRkaW5nOiBcIjEwcHggMTJweFwiLFxuICAgIGJvcmRlclJhZGl1czogbixcbiAgICBjb2xvcjogYyA/IFwiI2ZmZlwiIDogcy50ZXh0Q29sb3IsXG4gICAgY3Vyc29yOiBpID8gXCJkZWZhdWx0XCIgOiBcInBvaW50ZXJcIixcbiAgICBvcGFjaXR5OiBpID8gXCIwLjZcIiA6IFwiMVwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogYyA/IHMudGhlbWVDb2xvciA6IFwiXCIsXG4gICAgXCIuTXVpTGlzdEl0ZW1JY29uLXJvb3RcIjoge1xuICAgICAgY29sb3I6IGMgPyBcIiNmZmZcIiA6IHMudGV4dENvbG9yXG4gICAgfSxcbiAgICBcIiY6aG92ZXJcIjoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBjID8gcy50aGVtZUNvbG9yIDogcy50aGVtZUNvbG9yICsgMjAsXG4gICAgICBjb2xvcjogYyA/IFwiI2ZmZlwiIDogcy50aGVtZUNvbG9yLFxuICAgICAgXCIuTXVpTGlzdEl0ZW1JY29uLXJvb3RcIjoge1xuICAgICAgICBjb2xvcjogYyA/IFwiI2ZmZlwiIDogcy50aGVtZUNvbG9yXG4gICAgICB9XG4gICAgfVxuICB9KSksIG0gPSBsZShuaSkoKCkgPT4gKHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBnYXA6IFwiMTBweFwiLFxuICAgIG1hcmdpbkJvdHRvbTogXCIwcHhcIixcbiAgICBwYWRkaW5nOiBcIjBweFwiLFxuICAgIG1pbldpZHRoOiBcIjMwcHhcIixcbiAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgIGNvbG9yOiBcImluaGVyaXRcIlxuICB9KSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3hzKGR0LCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIE4uanN4cyhwLCB7IG9uQ2xpY2s6IHUsIHN4OiB7IGRpc3BsYXk6IFwiZmxleFwiLCBnYXA6IFwiMTVweFwiIH0sIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gTi5qc3gobSwgeyBzdHlsZTogeyBtaW5XaWR0aDogXCIwcHhcIiB9LCBjaGlsZHJlbjogciB8fCAvKiBAX19QVVJFX18gKi8gTi5qc3goRHMsIHt9KSB9KSxcbiAgICAgICFzLmlzQ29sbGFwc2UgJiYgLyogQF9fUFVSRV9fICovIE4uanN4cyhOLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChvaSwgeyBzeDogeyBteTogMCB9LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KGJ0LCB7IGZvbnRTaXplOiBvLCBzeDogeyBsaW5lSGVpZ2h0OiBcIjFcIiB9LCB2YXJpYW50OiBcImNhcHRpb25cIiwgY2hpbGRyZW46IHQgfSkgfSksXG4gICAgICAgIGMgPyAvKiBAX19QVVJFX18gKi8gTi5qc3goRG0sIHt9KSA6IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChMbSwge30pXG4gICAgICBdIH0pXG4gICAgXSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gTi5qc3goeG4sIHsgaW46IGMsIHRpbWVvdXQ6IFwiYXV0b1wiLCB1bm1vdW50T25FeGl0OiAhMCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeCh0aSwgeyBjb21wb25lbnQ6IFwiZGl2XCIsIGRpc2FibGVQYWRkaW5nOiAhMCwgY2hpbGRyZW46IGUgfSkgfSlcbiAgXSB9KTtcbn0sIExzID0gKHtcbiAgY29tcG9uZW50OiBlID0gXCJhXCIsXG4gIGNoaWxkcmVuOiB0LFxuICAuLi5yXG59KSA9PiAvKiBAX19QVVJFX18gKi8gTi5qc3goZSwgeyAuLi5yLCBzdHlsZTogeyB0ZXh0RGVjb3JhdGlvbjogXCJub25lXCIgfSwgY2hpbGRyZW46IHQgfSksIHFtID0gKHtcbiAgY2hpbGRyZW46IGUsXG4gIGljb246IHQsXG4gIGNvbXBvbmVudDogcixcbiAgYmFkZ2U6IG4gPSAhMSxcbiAgbGluazogbyA9IFwiL1wiLFxuICBiYWRnZUNvbG9yOiBpID0gXCJzZWNvbmRhcnlcIixcbiAgYmFkZ2VDb250ZW50OiBzID0gXCI2XCIsXG4gIGJhZGdlVGV4dENvbG9yOiBjID0gXCIjZmZmXCIsXG4gIHRleHRGb250U2l6ZTogbCA9IFwiMTRweFwiLFxuICBib3JkZXJSYWRpdXM6IHUgPSBcIjhweFwiLFxuICBkaXNhYmxlZDogcCA9ICExLFxuICBiYWRnZVR5cGU6IG0gPSBcImZpbGxlZFwiLFxuICB0YXJnZXQ6IGcgPSBcIlwiLFxuICBpc1NlbGVjdGVkOiB4ID0gITFcbn0pID0+IHtcbiAgY29uc3QgeSA9IEMudXNlQ29udGV4dChGciksIGYgPSBMcigpLCBTID0gbGUocmkpKCgpID0+ICh7XG4gICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICBtYXJnaW5Cb3R0b206IFwiMnB4XCIsXG4gICAgcGFkZGluZzogXCIxMHB4IDEycHhcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgdGV4dEFsaWduOiBmLmRpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgIGJvcmRlclJhZGl1czogdSxcbiAgICBjb2xvcjogeS50ZXh0Q29sb3IsXG4gICAgY3Vyc29yOiBwID8gXCJkZWZhdWx0XCIgOiBcInBvaW50ZXJcIixcbiAgICBvcGFjaXR5OiBwID8gXCIwLjZcIiA6IFwiMVwiLFxuICAgIFwiLk11aUxpc3RJdGVtSWNvbi1yb290XCI6IHtcbiAgICAgIGNvbG9yOiB5LnRleHRDb2xvclxuICAgIH0sXG4gICAgXCImOmhvdmVyXCI6IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogcCA/IFwiI2ZmZlwiIDogeS50aGVtZUNvbG9yICsgMjAsXG4gICAgICBjb2xvcjogeS50aGVtZUNvbG9yLFxuICAgICAgXCIuTXVpTGlzdEl0ZW1JY29uLXJvb3RcIjoge1xuICAgICAgICBjb2xvcjogeS50aGVtZUNvbG9yXG4gICAgICB9XG4gICAgfSxcbiAgICBcIiYuTXVpLXNlbGVjdGVkXCI6IHtcbiAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHkudGhlbWVDb2xvcixcbiAgICAgIFwiJjpob3ZlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogeS50aGVtZUNvbG9yLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgICB9LFxuICAgICAgXCIuTXVpTGlzdEl0ZW1JY29uLXJvb3RcIjoge1xuICAgICAgICBjb2xvcjogXCIjZmZmXCJcbiAgICAgIH1cbiAgICB9XG4gIH0pKSwgRSA9IGxlKG5pKSgoKSA9PiAoe1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgZ2FwOiBcIjEwcHhcIixcbiAgICBtYXJnaW5Cb3R0b206IFwiMHB4XCIsXG4gICAgcGFkZGluZzogXCIwcHhcIixcbiAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgIGNvbG9yOiBcImluaGVyaXRcIlxuICB9KSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goZHQsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChMcywgeyBjb21wb25lbnQ6IHIsIGhyZWY6IG8sIHRvOiBvLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4cyhcbiAgICBTLFxuICAgIHtcbiAgICAgIHN4OiB7IGRpc3BsYXk6IFwiZmxleFwiLCBnYXA6IFwiMTVweFwiIH0sXG4gICAgICB0YXJnZXQ6IGcsXG4gICAgICBzZWxlY3RlZDogISF4LFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIE4uanN4KFxuICAgICAgICAgIEUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3g6IHtcbiAgICAgICAgICAgICAgbWluV2lkdGg6IFwiMHB4XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogdCB8fCAvKiBAX19QVVJFX18gKi8gTi5qc3goRHMsIHt9KVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeS5pc0NvbGxhcHNlID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBOLmpzeHMoTi5GcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChvaSwgeyBzeDogeyBteTogMCB9LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KFxuICAgICAgICAgICAgYnQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvbnRTaXplOiBsLFxuICAgICAgICAgICAgICBzeDogeyBsaW5lSGVpZ2h0OiBcIjFcIiB9LFxuICAgICAgICAgICAgICB2YXJpYW50OiBcImNhcHRpb25cIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApIH0pLFxuICAgICAgICAgIG4gJiYgLyogQF9fUFVSRV9fICovIE4uanN4KFxuICAgICAgICAgICAgSXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxhYmVsOiBzLFxuICAgICAgICAgICAgICBjb2xvcjogaSxcbiAgICAgICAgICAgICAgdmFyaWFudDogbSxcbiAgICAgICAgICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgICAgICAgICBzeDogeyBjb2xvcjogYyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICBdIH0pXG4gICAgICBdXG4gICAgfVxuICApIH0pIH0pO1xufSwgR20gPSAoe1xuICBjaGlsZHJlbjogZSxcbiAgaW1nOiB0ID0gXCJodHRwczovL2FkbWlubWFydC5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMjQvMDMvbG9nby1hZG1pbi1tYXJ0LW5ld3MucG5nXCIsXG4gIGhyZWY6IHIgPSBcIi9cIixcbiAgY29tcG9uZW50OiBuXG59KSA9PiB7XG4gIGNvbnN0IG8gPSBDLnVzZUNvbnRleHQoRnIpLCBpID0gbGUoXCJzcGFuXCIpKCgpID0+ICh7XG4gICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICBvdmVyZmxvdzogby5pc0NvbGxhcHNlID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiLFxuICAgIFdlYmtpdExpbmVDbGFtcDogXCIxXCIsXG4gICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgIHBhZGRpbmc6IFwiMTVweCAyMnB4XCIsXG4gICAgdGV4dE92ZXJmbG93OiBcImVsbGlwc2lzXCJcbiAgfSkpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KExzLCB7IGhyZWY6IHIsIGNvbXBvbmVudDogbiwgdG86IHIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goaSwgeyBjaGlsZHJlbjogdCA9PT0gXCJcIiA/IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChidCwgeyB2YXJpYW50OiBcImJvZHkxXCIsIGNoaWxkcmVuOiBlIH0pIDogLyogQF9fUFVSRV9fICovIE4uanN4KFxuICAgIGR0LFxuICAgIHtcbiAgICAgIGNvbXBvbmVudDogXCJpbWdcIixcbiAgICAgIHN4OiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiXG4gICAgICB9LFxuICAgICAgc3JjOiB0XG4gICAgfVxuICApIH0pIH0pO1xufTtcbmV4cG9ydCB7XG4gIEdtIGFzIExvZ28sXG4gIFltIGFzIE1lbnUsXG4gIHFtIGFzIE1lbnVJdGVtLFxuICBVbSBhcyBTaWRlYmFyLFxuICBIbSBhcyBTdWJtZW51XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-mui-sidebar/dist/index.es.js\n");

/***/ })

};
;