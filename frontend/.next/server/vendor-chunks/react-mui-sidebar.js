"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-mui-sidebar";
exports.ids = ["vendor-chunks/react-mui-sidebar"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-mui-sidebar/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-mui-sidebar/dist/index.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logo: () => (/* binding */ Gm),\n/* harmony export */   Menu: () => (/* binding */ Ym),\n/* harmony export */   MenuItem: () => (/* binding */ qm),\n/* harmony export */   Sidebar: () => (/* binding */ Um),\n/* harmony export */   Submenu: () => (/* binding */ Hm)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar Gs = Object.defineProperty;\nvar Ks = (e, t, r) => t in e ? Gs(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;\nvar cr = (e, t, r) => Ks(e, typeof t != \"symbol\" ? t + \"\" : t, r);\n\n\n\n\nfunction ec(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nvar Ur = { exports: {} }, lr = {};\n/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar ai;\nfunction tc() {\n  if (ai) return lr;\n  ai = 1;\n  var e = Symbol.for(\"react.transitional.element\"), t = Symbol.for(\"react.fragment\");\n  function r(n, o, i) {\n    var s = null;\n    if (i !== void 0 && (s = \"\" + i), o.key !== void 0 && (s = \"\" + o.key), \"key\" in o) {\n      i = {};\n      for (var c in o)\n        c !== \"key\" && (i[c] = o[c]);\n    } else i = o;\n    return o = i.ref, {\n      $$typeof: e,\n      type: n,\n      key: s,\n      ref: o !== void 0 ? o : null,\n      props: i\n    };\n  }\n  return lr.Fragment = t, lr.jsx = r, lr.jsxs = r, lr;\n}\nvar ur = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar si;\nfunction rc() {\n  return si || (si = 1,  true && function() {\n    function e(v) {\n      if (v == null) return null;\n      if (typeof v == \"function\")\n        return v.$$typeof === te ? null : v.displayName || v.name || null;\n      if (typeof v == \"string\") return v;\n      switch (v) {\n        case w:\n          return \"Fragment\";\n        case h:\n          return \"Portal\";\n        case L:\n          return \"Profiler\";\n        case k:\n          return \"StrictMode\";\n        case D:\n          return \"Suspense\";\n        case j:\n          return \"SuspenseList\";\n      }\n      if (typeof v == \"object\")\n        switch (typeof v.tag == \"number\" && console.error(\n          \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n        ), v.$$typeof) {\n          case d:\n            return (v.displayName || \"Context\") + \".Provider\";\n          case B:\n            return (v._context.displayName || \"Context\") + \".Consumer\";\n          case A:\n            var M = v.render;\n            return v = v.displayName, v || (v = M.displayName || M.name || \"\", v = v !== \"\" ? \"ForwardRef(\" + v + \")\" : \"ForwardRef\"), v;\n          case W:\n            return M = v.displayName || null, M !== null ? M : e(v.type) || \"Memo\";\n          case z:\n            M = v._payload, v = v._init;\n            try {\n              return e(v(M));\n            } catch {\n            }\n        }\n      return null;\n    }\n    function t(v) {\n      return \"\" + v;\n    }\n    function r(v) {\n      try {\n        t(v);\n        var M = !1;\n      } catch {\n        M = !0;\n      }\n      if (M) {\n        M = console;\n        var Y = M.error, oe = typeof Symbol == \"function\" && Symbol.toStringTag && v[Symbol.toStringTag] || v.constructor.name || \"Object\";\n        return Y.call(\n          M,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          oe\n        ), t(v);\n      }\n    }\n    function n() {\n    }\n    function o() {\n      if (H === 0) {\n        X = console.log, _ = console.info, q = console.warn, G = console.error, re = console.group, Z = console.groupCollapsed, ae = console.groupEnd;\n        var v = {\n          configurable: !0,\n          enumerable: !0,\n          value: n,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: v,\n          log: v,\n          warn: v,\n          error: v,\n          group: v,\n          groupCollapsed: v,\n          groupEnd: v\n        });\n      }\n      H++;\n    }\n    function i() {\n      if (H--, H === 0) {\n        var v = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: I({}, v, { value: X }),\n          info: I({}, v, { value: _ }),\n          warn: I({}, v, { value: q }),\n          error: I({}, v, { value: G }),\n          group: I({}, v, { value: re }),\n          groupCollapsed: I({}, v, { value: Z }),\n          groupEnd: I({}, v, { value: ae })\n        });\n      }\n      0 > H && console.error(\n        \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n      );\n    }\n    function s(v) {\n      if (O === void 0)\n        try {\n          throw Error();\n        } catch (Y) {\n          var M = Y.stack.trim().match(/\\n( *(at )?)/);\n          O = M && M[1] || \"\", ye = -1 < Y.stack.indexOf(`\n    at`) ? \" (<anonymous>)\" : -1 < Y.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n        }\n      return `\n` + O + v + ye;\n    }\n    function c(v, M) {\n      if (!v || Ee) return \"\";\n      var Y = Me.get(v);\n      if (Y !== void 0) return Y;\n      Ee = !0, Y = Error.prepareStackTrace, Error.prepareStackTrace = void 0;\n      var oe = null;\n      oe = F.H, F.H = null, o();\n      try {\n        var Re = {\n          DetermineComponentFrameRoot: function() {\n            try {\n              if (M) {\n                var We = function() {\n                  throw Error();\n                };\n                if (Object.defineProperty(We.prototype, \"props\", {\n                  set: function() {\n                    throw Error();\n                  }\n                }), typeof Reflect == \"object\" && Reflect.construct) {\n                  try {\n                    Reflect.construct(We, []);\n                  } catch (ut) {\n                    var Ue = ut;\n                  }\n                  Reflect.construct(v, [], We);\n                } else {\n                  try {\n                    We.call();\n                  } catch (ut) {\n                    Ue = ut;\n                  }\n                  v.call(We.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (ut) {\n                  Ue = ut;\n                }\n                (We = v()) && typeof We.catch == \"function\" && We.catch(function() {\n                });\n              }\n            } catch (ut) {\n              if (ut && Ue && typeof ut.stack == \"string\")\n                return [ut.stack, Ue.stack];\n            }\n            return [null, null];\n          }\n        };\n        Re.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n        var ue = Object.getOwnPropertyDescriptor(\n          Re.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        ue && ue.configurable && Object.defineProperty(\n          Re.DetermineComponentFrameRoot,\n          \"name\",\n          { value: \"DetermineComponentFrameRoot\" }\n        );\n        var K = Re.DetermineComponentFrameRoot(), be = K[0], we = K[1];\n        if (be && we) {\n          var Oe = be.split(`\n`), ce = we.split(`\n`);\n          for (K = ue = 0; ue < Oe.length && !Oe[ue].includes(\n            \"DetermineComponentFrameRoot\"\n          ); )\n            ue++;\n          for (; K < ce.length && !ce[K].includes(\n            \"DetermineComponentFrameRoot\"\n          ); )\n            K++;\n          if (ue === Oe.length || K === ce.length)\n            for (ue = Oe.length - 1, K = ce.length - 1; 1 <= ue && 0 <= K && Oe[ue] !== ce[K]; )\n              K--;\n          for (; 1 <= ue && 0 <= K; ue--, K--)\n            if (Oe[ue] !== ce[K]) {\n              if (ue !== 1 || K !== 1)\n                do\n                  if (ue--, K--, 0 > K || Oe[ue] !== ce[K]) {\n                    var Ie = `\n` + Oe[ue].replace(\n                      \" at new \",\n                      \" at \"\n                    );\n                    return v.displayName && Ie.includes(\"<anonymous>\") && (Ie = Ie.replace(\"<anonymous>\", v.displayName)), typeof v == \"function\" && Me.set(v, Ie), Ie;\n                  }\n                while (1 <= ue && 0 <= K);\n              break;\n            }\n        }\n      } finally {\n        Ee = !1, F.H = oe, i(), Error.prepareStackTrace = Y;\n      }\n      return Oe = (Oe = v ? v.displayName || v.name : \"\") ? s(Oe) : \"\", typeof v == \"function\" && Me.set(v, Oe), Oe;\n    }\n    function l(v) {\n      if (v == null) return \"\";\n      if (typeof v == \"function\") {\n        var M = v.prototype;\n        return c(\n          v,\n          !(!M || !M.isReactComponent)\n        );\n      }\n      if (typeof v == \"string\") return s(v);\n      switch (v) {\n        case D:\n          return s(\"Suspense\");\n        case j:\n          return s(\"SuspenseList\");\n      }\n      if (typeof v == \"object\")\n        switch (v.$$typeof) {\n          case A:\n            return v = c(v.render, !1), v;\n          case W:\n            return l(v.type);\n          case z:\n            M = v._payload, v = v._init;\n            try {\n              return l(v(M));\n            } catch {\n            }\n        }\n      return \"\";\n    }\n    function u() {\n      var v = F.A;\n      return v === null ? null : v.getOwner();\n    }\n    function p(v) {\n      if (R.call(v, \"key\")) {\n        var M = Object.getOwnPropertyDescriptor(v, \"key\").get;\n        if (M && M.isReactWarning) return !1;\n      }\n      return v.key !== void 0;\n    }\n    function m(v, M) {\n      function Y() {\n        ve || (ve = !0, console.error(\n          \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n          M\n        ));\n      }\n      Y.isReactWarning = !0, Object.defineProperty(v, \"key\", {\n        get: Y,\n        configurable: !0\n      });\n    }\n    function g() {\n      var v = e(this.type);\n      return Pe[v] || (Pe[v] = !0, console.error(\n        \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n      )), v = this.props.ref, v !== void 0 ? v : null;\n    }\n    function x(v, M, Y, oe, Re, ue) {\n      return Y = ue.ref, v = {\n        $$typeof: b,\n        type: v,\n        key: M,\n        props: ue,\n        _owner: Re\n      }, (Y !== void 0 ? Y : null) !== null ? Object.defineProperty(v, \"ref\", {\n        enumerable: !1,\n        get: g\n      }) : Object.defineProperty(v, \"ref\", { enumerable: !1, value: null }), v._store = {}, Object.defineProperty(v._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      }), Object.defineProperty(v, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      }), Object.freeze && (Object.freeze(v.props), Object.freeze(v)), v;\n    }\n    function y(v, M, Y, oe, Re, ue) {\n      if (typeof v == \"string\" || typeof v == \"function\" || v === w || v === L || v === k || v === D || v === j || v === U || typeof v == \"object\" && v !== null && (v.$$typeof === z || v.$$typeof === W || v.$$typeof === d || v.$$typeof === B || v.$$typeof === A || v.$$typeof === J || v.getModuleId !== void 0)) {\n        var K = M.children;\n        if (K !== void 0)\n          if (oe)\n            if (Q(K)) {\n              for (oe = 0; oe < K.length; oe++)\n                f(K[oe], v);\n              Object.freeze && Object.freeze(K);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else f(K, v);\n      } else\n        K = \"\", (v === void 0 || typeof v == \"object\" && v !== null && Object.keys(v).length === 0) && (K += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\"), v === null ? oe = \"null\" : Q(v) ? oe = \"array\" : v !== void 0 && v.$$typeof === b ? (oe = \"<\" + (e(v.type) || \"Unknown\") + \" />\", K = \" Did you accidentally export a JSX literal instead of a component?\") : oe = typeof v, console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          oe,\n          K\n        );\n      if (R.call(M, \"key\")) {\n        K = e(v);\n        var be = Object.keys(M).filter(function(Oe) {\n          return Oe !== \"key\";\n        });\n        oe = 0 < be.length ? \"{key: someKey, \" + be.join(\": ..., \") + \": ...}\" : \"{key: someKey}\", ze[K + oe] || (be = 0 < be.length ? \"{\" + be.join(\": ..., \") + \": ...}\" : \"{}\", console.error(\n          `A props object containing a \"key\" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />`,\n          oe,\n          K,\n          be,\n          K\n        ), ze[K + oe] = !0);\n      }\n      if (K = null, Y !== void 0 && (r(Y), K = \"\" + Y), p(M) && (r(M.key), K = \"\" + M.key), \"key\" in M) {\n        Y = {};\n        for (var we in M)\n          we !== \"key\" && (Y[we] = M[we]);\n      } else Y = M;\n      return K && m(\n        Y,\n        typeof v == \"function\" ? v.displayName || v.name || \"Unknown\" : v\n      ), x(v, K, ue, Re, u(), Y);\n    }\n    function f(v, M) {\n      if (typeof v == \"object\" && v && v.$$typeof !== Qe) {\n        if (Q(v))\n          for (var Y = 0; Y < v.length; Y++) {\n            var oe = v[Y];\n            S(oe) && E(oe, M);\n          }\n        else if (S(v))\n          v._store && (v._store.validated = 1);\n        else if (v === null || typeof v != \"object\" ? Y = null : (Y = V && v[V] || v[\"@@iterator\"], Y = typeof Y == \"function\" ? Y : null), typeof Y == \"function\" && Y !== v.entries && (Y = Y.call(v), Y !== v))\n          for (; !(v = Y.next()).done; )\n            S(v.value) && E(v.value, M);\n      }\n    }\n    function S(v) {\n      return typeof v == \"object\" && v !== null && v.$$typeof === b;\n    }\n    function E(v, M) {\n      if (v._store && !v._store.validated && v.key == null && (v._store.validated = 1, M = P(M), !Le[M])) {\n        Le[M] = !0;\n        var Y = \"\";\n        v && v._owner != null && v._owner !== u() && (Y = null, typeof v._owner.tag == \"number\" ? Y = e(v._owner.type) : typeof v._owner.name == \"string\" && (Y = v._owner.name), Y = \" It was passed a child from \" + Y + \".\");\n        var oe = F.getCurrentStack;\n        F.getCurrentStack = function() {\n          var Re = l(v.type);\n          return oe && (Re += oe() || \"\"), Re;\n        }, console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          M,\n          Y\n        ), F.getCurrentStack = oe;\n      }\n    }\n    function P(v) {\n      var M = \"\", Y = u();\n      return Y && (Y = e(Y.type)) && (M = `\n\nCheck the render method of \\`` + Y + \"`.\"), M || (v = e(v)) && (M = `\n\nCheck the top-level render call using <` + v + \">.\"), M;\n    }\n    var T = react__WEBPACK_IMPORTED_MODULE_0__, b = Symbol.for(\"react.transitional.element\"), h = Symbol.for(\"react.portal\"), w = Symbol.for(\"react.fragment\"), k = Symbol.for(\"react.strict_mode\"), L = Symbol.for(\"react.profiler\"), B = Symbol.for(\"react.consumer\"), d = Symbol.for(\"react.context\"), A = Symbol.for(\"react.forward_ref\"), D = Symbol.for(\"react.suspense\"), j = Symbol.for(\"react.suspense_list\"), W = Symbol.for(\"react.memo\"), z = Symbol.for(\"react.lazy\"), U = Symbol.for(\"react.offscreen\"), V = Symbol.iterator, te = Symbol.for(\"react.client.reference\"), F = T.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, R = Object.prototype.hasOwnProperty, I = Object.assign, J = Symbol.for(\"react.client.reference\"), Q = Array.isArray, H = 0, X, _, q, G, re, Z, ae;\n    n.__reactDisabledLog = !0;\n    var O, ye, Ee = !1, Me = new (typeof WeakMap == \"function\" ? WeakMap : Map)(), Qe = Symbol.for(\"react.client.reference\"), ve, Pe = {}, ze = {}, Le = {};\n    ur.Fragment = w, ur.jsx = function(v, M, Y, oe, Re) {\n      return y(v, M, Y, !1, oe, Re);\n    }, ur.jsxs = function(v, M, Y, oe, Re) {\n      return y(v, M, Y, !0, oe, Re);\n    };\n  }()), ur;\n}\nvar ci;\nfunction nc() {\n  return ci || (ci = 1,  false ? 0 : Ur.exports = rc()), Ur.exports;\n}\nvar N = nc();\nconst Er = {\n  black: \"#000\",\n  white: \"#fff\"\n}, Wt = {\n  50: \"#ffebee\",\n  100: \"#ffcdd2\",\n  200: \"#ef9a9a\",\n  300: \"#e57373\",\n  400: \"#ef5350\",\n  500: \"#f44336\",\n  600: \"#e53935\",\n  700: \"#d32f2f\",\n  800: \"#c62828\",\n  900: \"#b71c1c\",\n  A100: \"#ff8a80\",\n  A200: \"#ff5252\",\n  A400: \"#ff1744\",\n  A700: \"#d50000\"\n}, Ut = {\n  50: \"#f3e5f5\",\n  100: \"#e1bee7\",\n  200: \"#ce93d8\",\n  300: \"#ba68c8\",\n  400: \"#ab47bc\",\n  500: \"#9c27b0\",\n  600: \"#8e24aa\",\n  700: \"#7b1fa2\",\n  800: \"#6a1b9a\",\n  900: \"#4a148c\",\n  A100: \"#ea80fc\",\n  A200: \"#e040fb\",\n  A400: \"#d500f9\",\n  A700: \"#aa00ff\"\n}, Yt = {\n  50: \"#e3f2fd\",\n  100: \"#bbdefb\",\n  200: \"#90caf9\",\n  300: \"#64b5f6\",\n  400: \"#42a5f5\",\n  500: \"#2196f3\",\n  600: \"#1e88e5\",\n  700: \"#1976d2\",\n  800: \"#1565c0\",\n  900: \"#0d47a1\",\n  A100: \"#82b1ff\",\n  A200: \"#448aff\",\n  A400: \"#2979ff\",\n  A700: \"#2962ff\"\n}, Ht = {\n  50: \"#e1f5fe\",\n  100: \"#b3e5fc\",\n  200: \"#81d4fa\",\n  300: \"#4fc3f7\",\n  400: \"#29b6f6\",\n  500: \"#03a9f4\",\n  600: \"#039be5\",\n  700: \"#0288d1\",\n  800: \"#0277bd\",\n  900: \"#01579b\",\n  A100: \"#80d8ff\",\n  A200: \"#40c4ff\",\n  A400: \"#00b0ff\",\n  A700: \"#0091ea\"\n}, qt = {\n  50: \"#e8f5e9\",\n  100: \"#c8e6c9\",\n  200: \"#a5d6a7\",\n  300: \"#81c784\",\n  400: \"#66bb6a\",\n  500: \"#4caf50\",\n  600: \"#43a047\",\n  700: \"#388e3c\",\n  800: \"#2e7d32\",\n  900: \"#1b5e20\",\n  A100: \"#b9f6ca\",\n  A200: \"#69f0ae\",\n  A400: \"#00e676\",\n  A700: \"#00c853\"\n}, fr = {\n  50: \"#fff3e0\",\n  100: \"#ffe0b2\",\n  200: \"#ffcc80\",\n  300: \"#ffb74d\",\n  400: \"#ffa726\",\n  500: \"#ff9800\",\n  600: \"#fb8c00\",\n  700: \"#f57c00\",\n  800: \"#ef6c00\",\n  900: \"#e65100\",\n  A100: \"#ffd180\",\n  A200: \"#ffab40\",\n  A400: \"#ff9100\",\n  A700: \"#ff6d00\"\n}, oc = {\n  50: \"#fafafa\",\n  100: \"#f5f5f5\",\n  200: \"#eeeeee\",\n  300: \"#e0e0e0\",\n  400: \"#bdbdbd\",\n  500: \"#9e9e9e\",\n  600: \"#757575\",\n  700: \"#616161\",\n  800: \"#424242\",\n  900: \"#212121\",\n  A100: \"#f5f5f5\",\n  A200: \"#eeeeee\",\n  A400: \"#bdbdbd\",\n  A700: \"#616161\"\n};\nfunction kt(e, ...t) {\n  const r = new URL(`https://mui.com/production-error/?code=${e}`);\n  return t.forEach((n) => r.searchParams.append(\"args[]\", n)), `Minified MUI error #${e}; visit ${r} for the full message.`;\n}\nconst wt = \"$$material\";\nfunction fn() {\n  return fn = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var r = arguments[t];\n      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);\n    }\n    return e;\n  }, fn.apply(null, arguments);\n}\nfunction ic(e) {\n  if (e.sheet)\n    return e.sheet;\n  for (var t = 0; t < document.styleSheets.length; t++)\n    if (document.styleSheets[t].ownerNode === e)\n      return document.styleSheets[t];\n}\nfunction ac(e) {\n  var t = document.createElement(\"style\");\n  return t.setAttribute(\"data-emotion\", e.key), e.nonce !== void 0 && t.setAttribute(\"nonce\", e.nonce), t.appendChild(document.createTextNode(\"\")), t.setAttribute(\"data-s\", \"\"), t;\n}\nvar sc = /* @__PURE__ */ function() {\n  function e(r) {\n    var n = this;\n    this._insertTag = function(o) {\n      var i;\n      n.tags.length === 0 ? n.insertionPoint ? i = n.insertionPoint.nextSibling : n.prepend ? i = n.container.firstChild : i = n.before : i = n.tags[n.tags.length - 1].nextSibling, n.container.insertBefore(o, i), n.tags.push(o);\n    }, this.isSpeedy = r.speedy === void 0 ? !0 : r.speedy, this.tags = [], this.ctr = 0, this.nonce = r.nonce, this.key = r.key, this.container = r.container, this.prepend = r.prepend, this.insertionPoint = r.insertionPoint, this.before = null;\n  }\n  var t = e.prototype;\n  return t.hydrate = function(n) {\n    n.forEach(this._insertTag);\n  }, t.insert = function(n) {\n    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(ac(this));\n    var o = this.tags[this.tags.length - 1];\n    if (this.isSpeedy) {\n      var i = ic(o);\n      try {\n        i.insertRule(n, i.cssRules.length);\n      } catch {\n      }\n    } else\n      o.appendChild(document.createTextNode(n));\n    this.ctr++;\n  }, t.flush = function() {\n    this.tags.forEach(function(n) {\n      var o;\n      return (o = n.parentNode) == null ? void 0 : o.removeChild(n);\n    }), this.tags = [], this.ctr = 0;\n  }, e;\n}(), Ye = \"-ms-\", dn = \"-moz-\", fe = \"-webkit-\", xa = \"comm\", So = \"rule\", Eo = \"decl\", cc = \"@import\", Sa = \"@keyframes\", lc = \"@layer\", uc = Math.abs, Rn = String.fromCharCode, fc = Object.assign;\nfunction dc(e, t) {\n  return Be(e, 0) ^ 45 ? (((t << 2 ^ Be(e, 0)) << 2 ^ Be(e, 1)) << 2 ^ Be(e, 2)) << 2 ^ Be(e, 3) : 0;\n}\nfunction Ea(e) {\n  return e.trim();\n}\nfunction pc(e, t) {\n  return (e = t.exec(e)) ? e[0] : e;\n}\nfunction de(e, t, r) {\n  return e.replace(t, r);\n}\nfunction oo(e, t) {\n  return e.indexOf(t);\n}\nfunction Be(e, t) {\n  return e.charCodeAt(t) | 0;\n}\nfunction Cr(e, t, r) {\n  return e.slice(t, r);\n}\nfunction mt(e) {\n  return e.length;\n}\nfunction Co(e) {\n  return e.length;\n}\nfunction Yr(e, t) {\n  return t.push(e), e;\n}\nfunction mc(e, t) {\n  return e.map(t).join(\"\");\n}\nvar $n = 1, Zt = 1, Ca = 0, Je = 0, je = 0, ir = \"\";\nfunction Pn(e, t, r, n, o, i, s) {\n  return { value: e, root: t, parent: r, type: n, props: o, children: i, line: $n, column: Zt, length: s, return: \"\" };\n}\nfunction dr(e, t) {\n  return fc(Pn(\"\", null, null, \"\", null, null, 0), e, { length: -e.length }, t);\n}\nfunction hc() {\n  return je;\n}\nfunction gc() {\n  return je = Je > 0 ? Be(ir, --Je) : 0, Zt--, je === 10 && (Zt = 1, $n--), je;\n}\nfunction et() {\n  return je = Je < Ca ? Be(ir, Je++) : 0, Zt++, je === 10 && (Zt = 1, $n++), je;\n}\nfunction vt() {\n  return Be(ir, Je);\n}\nfunction an() {\n  return Je;\n}\nfunction Ar(e, t) {\n  return Cr(ir, e, t);\n}\nfunction Tr(e) {\n  switch (e) {\n    // \\0 \\t \\n \\r \\s whitespace token\n    case 0:\n    case 9:\n    case 10:\n    case 13:\n    case 32:\n      return 5;\n    // ! + , / > @ ~ isolate token\n    case 33:\n    case 43:\n    case 44:\n    case 47:\n    case 62:\n    case 64:\n    case 126:\n    // ; { } breakpoint token\n    case 59:\n    case 123:\n    case 125:\n      return 4;\n    // : accompanied token\n    case 58:\n      return 3;\n    // \" ' ( [ opening delimit token\n    case 34:\n    case 39:\n    case 40:\n    case 91:\n      return 2;\n    // ) ] closing delimit token\n    case 41:\n    case 93:\n      return 1;\n  }\n  return 0;\n}\nfunction Ta(e) {\n  return $n = Zt = 1, Ca = mt(ir = e), Je = 0, [];\n}\nfunction wa(e) {\n  return ir = \"\", e;\n}\nfunction sn(e) {\n  return Ea(Ar(Je - 1, io(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));\n}\nfunction yc(e) {\n  for (; (je = vt()) && je < 33; )\n    et();\n  return Tr(e) > 2 || Tr(je) > 3 ? \"\" : \" \";\n}\nfunction bc(e, t) {\n  for (; --t && et() && !(je < 48 || je > 102 || je > 57 && je < 65 || je > 70 && je < 97); )\n    ;\n  return Ar(e, an() + (t < 6 && vt() == 32 && et() == 32));\n}\nfunction io(e) {\n  for (; et(); )\n    switch (je) {\n      // ] ) \" '\n      case e:\n        return Je;\n      // \" '\n      case 34:\n      case 39:\n        e !== 34 && e !== 39 && io(je);\n        break;\n      // (\n      case 40:\n        e === 41 && io(e);\n        break;\n      // \\\n      case 92:\n        et();\n        break;\n    }\n  return Je;\n}\nfunction vc(e, t) {\n  for (; et() && e + je !== 57; )\n    if (e + je === 84 && vt() === 47)\n      break;\n  return \"/*\" + Ar(t, Je - 1) + \"*\" + Rn(e === 47 ? e : et());\n}\nfunction xc(e) {\n  for (; !Tr(vt()); )\n    et();\n  return Ar(e, Je);\n}\nfunction Sc(e) {\n  return wa(cn(\"\", null, null, null, [\"\"], e = Ta(e), 0, [0], e));\n}\nfunction cn(e, t, r, n, o, i, s, c, l) {\n  for (var u = 0, p = 0, m = s, g = 0, x = 0, y = 0, f = 1, S = 1, E = 1, P = 0, T = \"\", b = o, h = i, w = n, k = T; S; )\n    switch (y = P, P = et()) {\n      // (\n      case 40:\n        if (y != 108 && Be(k, m - 1) == 58) {\n          oo(k += de(sn(P), \"&\", \"&\\f\"), \"&\\f\") != -1 && (E = -1);\n          break;\n        }\n      // \" ' [\n      case 34:\n      case 39:\n      case 91:\n        k += sn(P);\n        break;\n      // \\t \\n \\r \\s\n      case 9:\n      case 10:\n      case 13:\n      case 32:\n        k += yc(y);\n        break;\n      // \\\n      case 92:\n        k += bc(an() - 1, 7);\n        continue;\n      // /\n      case 47:\n        switch (vt()) {\n          case 42:\n          case 47:\n            Yr(Ec(vc(et(), an()), t, r), l);\n            break;\n          default:\n            k += \"/\";\n        }\n        break;\n      // {\n      case 123 * f:\n        c[u++] = mt(k) * E;\n      // } ; \\0\n      case 125 * f:\n      case 59:\n      case 0:\n        switch (P) {\n          // \\0 }\n          case 0:\n          case 125:\n            S = 0;\n          // ;\n          case 59 + p:\n            E == -1 && (k = de(k, /\\f/g, \"\")), x > 0 && mt(k) - m && Yr(x > 32 ? ui(k + \";\", n, r, m - 1) : ui(de(k, \" \", \"\") + \";\", n, r, m - 2), l);\n            break;\n          // @ ;\n          case 59:\n            k += \";\";\n          // { rule/at-rule\n          default:\n            if (Yr(w = li(k, t, r, u, p, o, c, T, b = [], h = [], m), i), P === 123)\n              if (p === 0)\n                cn(k, t, w, w, b, i, m, c, h);\n              else\n                switch (g === 99 && Be(k, 3) === 110 ? 100 : g) {\n                  // d l m s\n                  case 100:\n                  case 108:\n                  case 109:\n                  case 115:\n                    cn(e, w, w, n && Yr(li(e, w, w, 0, 0, o, c, T, o, b = [], m), h), o, h, m, c, n ? b : h);\n                    break;\n                  default:\n                    cn(k, w, w, w, [\"\"], h, 0, c, h);\n                }\n        }\n        u = p = x = 0, f = E = 1, T = k = \"\", m = s;\n        break;\n      // :\n      case 58:\n        m = 1 + mt(k), x = y;\n      default:\n        if (f < 1) {\n          if (P == 123)\n            --f;\n          else if (P == 125 && f++ == 0 && gc() == 125)\n            continue;\n        }\n        switch (k += Rn(P), P * f) {\n          // &\n          case 38:\n            E = p > 0 ? 1 : (k += \"\\f\", -1);\n            break;\n          // ,\n          case 44:\n            c[u++] = (mt(k) - 1) * E, E = 1;\n            break;\n          // @\n          case 64:\n            vt() === 45 && (k += sn(et())), g = vt(), p = m = mt(T = k += xc(an())), P++;\n            break;\n          // -\n          case 45:\n            y === 45 && mt(k) == 2 && (f = 0);\n        }\n    }\n  return i;\n}\nfunction li(e, t, r, n, o, i, s, c, l, u, p) {\n  for (var m = o - 1, g = o === 0 ? i : [\"\"], x = Co(g), y = 0, f = 0, S = 0; y < n; ++y)\n    for (var E = 0, P = Cr(e, m + 1, m = uc(f = s[y])), T = e; E < x; ++E)\n      (T = Ea(f > 0 ? g[E] + \" \" + P : de(P, /&\\f/g, g[E]))) && (l[S++] = T);\n  return Pn(e, t, r, o === 0 ? So : c, l, u, p);\n}\nfunction Ec(e, t, r) {\n  return Pn(e, t, r, xa, Rn(hc()), Cr(e, 2, -2), 0);\n}\nfunction ui(e, t, r, n) {\n  return Pn(e, t, r, Eo, Cr(e, 0, n), Cr(e, n + 1, -1), n);\n}\nfunction Xt(e, t) {\n  for (var r = \"\", n = Co(e), o = 0; o < n; o++)\n    r += t(e[o], o, e, t) || \"\";\n  return r;\n}\nfunction Cc(e, t, r, n) {\n  switch (e.type) {\n    case lc:\n      if (e.children.length) break;\n    case cc:\n    case Eo:\n      return e.return = e.return || e.value;\n    case xa:\n      return \"\";\n    case Sa:\n      return e.return = e.value + \"{\" + Xt(e.children, n) + \"}\";\n    case So:\n      e.value = e.props.join(\",\");\n  }\n  return mt(r = Xt(e.children, n)) ? e.return = e.value + \"{\" + r + \"}\" : \"\";\n}\nfunction Tc(e) {\n  var t = Co(e);\n  return function(r, n, o, i) {\n    for (var s = \"\", c = 0; c < t; c++)\n      s += e[c](r, n, o, i) || \"\";\n    return s;\n  };\n}\nfunction wc(e) {\n  return function(t) {\n    t.root || (t = t.return) && e(t);\n  };\n}\nfunction Oa(e) {\n  var t = /* @__PURE__ */ Object.create(null);\n  return function(r) {\n    return t[r] === void 0 && (t[r] = e(r)), t[r];\n  };\n}\nvar Oc = function(t, r, n) {\n  for (var o = 0, i = 0; o = i, i = vt(), o === 38 && i === 12 && (r[n] = 1), !Tr(i); )\n    et();\n  return Ar(t, Je);\n}, Rc = function(t, r) {\n  var n = -1, o = 44;\n  do\n    switch (Tr(o)) {\n      case 0:\n        o === 38 && vt() === 12 && (r[n] = 1), t[n] += Oc(Je - 1, r, n);\n        break;\n      case 2:\n        t[n] += sn(o);\n        break;\n      case 4:\n        if (o === 44) {\n          t[++n] = vt() === 58 ? \"&\\f\" : \"\", r[n] = t[n].length;\n          break;\n        }\n      // fallthrough\n      default:\n        t[n] += Rn(o);\n    }\n  while (o = et());\n  return t;\n}, $c = function(t, r) {\n  return wa(Rc(Ta(t), r));\n}, fi = /* @__PURE__ */ new WeakMap(), Pc = function(t) {\n  if (!(t.type !== \"rule\" || !t.parent || // positive .length indicates that this rule contains pseudo\n  // negative .length indicates that this rule has been already prefixed\n  t.length < 1)) {\n    for (var r = t.value, n = t.parent, o = t.column === n.column && t.line === n.line; n.type !== \"rule\"; )\n      if (n = n.parent, !n) return;\n    if (!(t.props.length === 1 && r.charCodeAt(0) !== 58 && !fi.get(n)) && !o) {\n      fi.set(t, !0);\n      for (var i = [], s = $c(r, i), c = n.props, l = 0, u = 0; l < s.length; l++)\n        for (var p = 0; p < c.length; p++, u++)\n          t.props[u] = i[l] ? s[l].replace(/&\\f/g, c[p]) : c[p] + \" \" + s[l];\n    }\n  }\n}, kc = function(t) {\n  if (t.type === \"decl\") {\n    var r = t.value;\n    // charcode for l\n    r.charCodeAt(0) === 108 && // charcode for b\n    r.charCodeAt(2) === 98 && (t.return = \"\", t.value = \"\");\n  }\n};\nfunction Ra(e, t) {\n  switch (dc(e, t)) {\n    // color-adjust\n    case 5103:\n      return fe + \"print-\" + e + e;\n    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)\n    case 5737:\n    case 4201:\n    case 3177:\n    case 3433:\n    case 1641:\n    case 4457:\n    case 2921:\n    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break\n    case 5572:\n    case 6356:\n    case 5844:\n    case 3191:\n    case 6645:\n    case 3005:\n    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,\n    case 6391:\n    case 5879:\n    case 5623:\n    case 6135:\n    case 4599:\n    case 4855:\n    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)\n    case 4215:\n    case 6389:\n    case 5109:\n    case 5365:\n    case 5621:\n    case 3829:\n      return fe + e + e;\n    // appearance, user-select, transform, hyphens, text-size-adjust\n    case 5349:\n    case 4246:\n    case 4810:\n    case 6968:\n    case 2756:\n      return fe + e + dn + e + Ye + e + e;\n    // flex, flex-direction\n    case 6828:\n    case 4268:\n      return fe + e + Ye + e + e;\n    // order\n    case 6165:\n      return fe + e + Ye + \"flex-\" + e + e;\n    // align-items\n    case 5187:\n      return fe + e + de(e, /(\\w+).+(:[^]+)/, fe + \"box-$1$2\" + Ye + \"flex-$1$2\") + e;\n    // align-self\n    case 5443:\n      return fe + e + Ye + \"flex-item-\" + de(e, /flex-|-self/, \"\") + e;\n    // align-content\n    case 4675:\n      return fe + e + Ye + \"flex-line-pack\" + de(e, /align-content|flex-|-self/, \"\") + e;\n    // flex-shrink\n    case 5548:\n      return fe + e + Ye + de(e, \"shrink\", \"negative\") + e;\n    // flex-basis\n    case 5292:\n      return fe + e + Ye + de(e, \"basis\", \"preferred-size\") + e;\n    // flex-grow\n    case 6060:\n      return fe + \"box-\" + de(e, \"-grow\", \"\") + fe + e + Ye + de(e, \"grow\", \"positive\") + e;\n    // transition\n    case 4554:\n      return fe + de(e, /([^-])(transform)/g, \"$1\" + fe + \"$2\") + e;\n    // cursor\n    case 6187:\n      return de(de(de(e, /(zoom-|grab)/, fe + \"$1\"), /(image-set)/, fe + \"$1\"), e, \"\") + e;\n    // background, background-image\n    case 5495:\n    case 3959:\n      return de(e, /(image-set\\([^]*)/, fe + \"$1$`$1\");\n    // justify-content\n    case 4968:\n      return de(de(e, /(.+:)(flex-)?(.*)/, fe + \"box-pack:$3\" + Ye + \"flex-pack:$3\"), /s.+-b[^;]+/, \"justify\") + fe + e + e;\n    // (margin|padding)-inline-(start|end)\n    case 4095:\n    case 3583:\n    case 4068:\n    case 2532:\n      return de(e, /(.+)-inline(.+)/, fe + \"$1$2\") + e;\n    // (min|max)?(width|height|inline-size|block-size)\n    case 8116:\n    case 7059:\n    case 5753:\n    case 5535:\n    case 5445:\n    case 5701:\n    case 4933:\n    case 4677:\n    case 5533:\n    case 5789:\n    case 5021:\n    case 4765:\n      if (mt(e) - 1 - t > 6) switch (Be(e, t + 1)) {\n        // (m)ax-content, (m)in-content\n        case 109:\n          if (Be(e, t + 4) !== 45) break;\n        // (f)ill-available, (f)it-content\n        case 102:\n          return de(e, /(.+:)(.+)-([^]+)/, \"$1\" + fe + \"$2-$3$1\" + dn + (Be(e, t + 3) == 108 ? \"$3\" : \"$2-$3\")) + e;\n        // (s)tretch\n        case 115:\n          return ~oo(e, \"stretch\") ? Ra(de(e, \"stretch\", \"fill-available\"), t) + e : e;\n      }\n      break;\n    // position: sticky\n    case 4949:\n      if (Be(e, t + 1) !== 115) break;\n    // display: (flex|inline-flex)\n    case 6444:\n      switch (Be(e, mt(e) - 3 - (~oo(e, \"!important\") && 10))) {\n        // stic(k)y\n        case 107:\n          return de(e, \":\", \":\" + fe) + e;\n        // (inline-)?fl(e)x\n        case 101:\n          return de(e, /(.+:)([^;!]+)(;|!.+)?/, \"$1\" + fe + (Be(e, 14) === 45 ? \"inline-\" : \"\") + \"box$3$1\" + fe + \"$2$3$1\" + Ye + \"$2box$3\") + e;\n      }\n      break;\n    // writing-mode\n    case 5936:\n      switch (Be(e, t + 11)) {\n        // vertical-l(r)\n        case 114:\n          return fe + e + Ye + de(e, /[svh]\\w+-[tblr]{2}/, \"tb\") + e;\n        // vertical-r(l)\n        case 108:\n          return fe + e + Ye + de(e, /[svh]\\w+-[tblr]{2}/, \"tb-rl\") + e;\n        // horizontal(-)tb\n        case 45:\n          return fe + e + Ye + de(e, /[svh]\\w+-[tblr]{2}/, \"lr\") + e;\n      }\n      return fe + e + Ye + e + e;\n  }\n  return e;\n}\nvar Ac = function(t, r, n, o) {\n  if (t.length > -1 && !t.return) switch (t.type) {\n    case Eo:\n      t.return = Ra(t.value, t.length);\n      break;\n    case Sa:\n      return Xt([dr(t, {\n        value: de(t.value, \"@\", \"@\" + fe)\n      })], o);\n    case So:\n      if (t.length) return mc(t.props, function(i) {\n        switch (pc(i, /(::plac\\w+|:read-\\w+)/)) {\n          // :read-(only|write)\n          case \":read-only\":\n          case \":read-write\":\n            return Xt([dr(t, {\n              props: [de(i, /:(read-\\w+)/, \":\" + dn + \"$1\")]\n            })], o);\n          // :placeholder\n          case \"::placeholder\":\n            return Xt([dr(t, {\n              props: [de(i, /:(plac\\w+)/, \":\" + fe + \"input-$1\")]\n            }), dr(t, {\n              props: [de(i, /:(plac\\w+)/, \":\" + dn + \"$1\")]\n            }), dr(t, {\n              props: [de(i, /:(plac\\w+)/, Ye + \"input-$1\")]\n            })], o);\n        }\n        return \"\";\n      });\n  }\n}, Nc = [Ac], Mc = function(t) {\n  var r = t.key;\n  if (r === \"css\") {\n    var n = document.querySelectorAll(\"style[data-emotion]:not([data-s])\");\n    Array.prototype.forEach.call(n, function(f) {\n      var S = f.getAttribute(\"data-emotion\");\n      S.indexOf(\" \") !== -1 && (document.head.appendChild(f), f.setAttribute(\"data-s\", \"\"));\n    });\n  }\n  var o = t.stylisPlugins || Nc, i = {}, s, c = [];\n  s = t.container || document.head, Array.prototype.forEach.call(\n    // this means we will ignore elements which don't have a space in them which\n    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements\n    document.querySelectorAll('style[data-emotion^=\"' + r + ' \"]'),\n    function(f) {\n      for (var S = f.getAttribute(\"data-emotion\").split(\" \"), E = 1; E < S.length; E++)\n        i[S[E]] = !0;\n      c.push(f);\n    }\n  );\n  var l, u = [Pc, kc];\n  {\n    var p, m = [Cc, wc(function(f) {\n      p.insert(f);\n    })], g = Tc(u.concat(o, m)), x = function(S) {\n      return Xt(Sc(S), g);\n    };\n    l = function(S, E, P, T) {\n      p = P, x(S ? S + \"{\" + E.styles + \"}\" : E.styles), T && (y.inserted[E.name] = !0);\n    };\n  }\n  var y = {\n    key: r,\n    sheet: new sc({\n      key: r,\n      container: s,\n      nonce: t.nonce,\n      speedy: t.speedy,\n      prepend: t.prepend,\n      insertionPoint: t.insertionPoint\n    }),\n    nonce: t.nonce,\n    inserted: i,\n    registered: {},\n    insert: l\n  };\n  return y.sheet.hydrate(c), y;\n}, Hr = { exports: {} }, pe = {};\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar di;\nfunction Ic() {\n  if (di) return pe;\n  di = 1;\n  var e = typeof Symbol == \"function\" && Symbol.for, t = e ? Symbol.for(\"react.element\") : 60103, r = e ? Symbol.for(\"react.portal\") : 60106, n = e ? Symbol.for(\"react.fragment\") : 60107, o = e ? Symbol.for(\"react.strict_mode\") : 60108, i = e ? Symbol.for(\"react.profiler\") : 60114, s = e ? Symbol.for(\"react.provider\") : 60109, c = e ? Symbol.for(\"react.context\") : 60110, l = e ? Symbol.for(\"react.async_mode\") : 60111, u = e ? Symbol.for(\"react.concurrent_mode\") : 60111, p = e ? Symbol.for(\"react.forward_ref\") : 60112, m = e ? Symbol.for(\"react.suspense\") : 60113, g = e ? Symbol.for(\"react.suspense_list\") : 60120, x = e ? Symbol.for(\"react.memo\") : 60115, y = e ? Symbol.for(\"react.lazy\") : 60116, f = e ? Symbol.for(\"react.block\") : 60121, S = e ? Symbol.for(\"react.fundamental\") : 60117, E = e ? Symbol.for(\"react.responder\") : 60118, P = e ? Symbol.for(\"react.scope\") : 60119;\n  function T(h) {\n    if (typeof h == \"object\" && h !== null) {\n      var w = h.$$typeof;\n      switch (w) {\n        case t:\n          switch (h = h.type, h) {\n            case l:\n            case u:\n            case n:\n            case i:\n            case o:\n            case m:\n              return h;\n            default:\n              switch (h = h && h.$$typeof, h) {\n                case c:\n                case p:\n                case y:\n                case x:\n                case s:\n                  return h;\n                default:\n                  return w;\n              }\n          }\n        case r:\n          return w;\n      }\n    }\n  }\n  function b(h) {\n    return T(h) === u;\n  }\n  return pe.AsyncMode = l, pe.ConcurrentMode = u, pe.ContextConsumer = c, pe.ContextProvider = s, pe.Element = t, pe.ForwardRef = p, pe.Fragment = n, pe.Lazy = y, pe.Memo = x, pe.Portal = r, pe.Profiler = i, pe.StrictMode = o, pe.Suspense = m, pe.isAsyncMode = function(h) {\n    return b(h) || T(h) === l;\n  }, pe.isConcurrentMode = b, pe.isContextConsumer = function(h) {\n    return T(h) === c;\n  }, pe.isContextProvider = function(h) {\n    return T(h) === s;\n  }, pe.isElement = function(h) {\n    return typeof h == \"object\" && h !== null && h.$$typeof === t;\n  }, pe.isForwardRef = function(h) {\n    return T(h) === p;\n  }, pe.isFragment = function(h) {\n    return T(h) === n;\n  }, pe.isLazy = function(h) {\n    return T(h) === y;\n  }, pe.isMemo = function(h) {\n    return T(h) === x;\n  }, pe.isPortal = function(h) {\n    return T(h) === r;\n  }, pe.isProfiler = function(h) {\n    return T(h) === i;\n  }, pe.isStrictMode = function(h) {\n    return T(h) === o;\n  }, pe.isSuspense = function(h) {\n    return T(h) === m;\n  }, pe.isValidElementType = function(h) {\n    return typeof h == \"string\" || typeof h == \"function\" || h === n || h === u || h === i || h === o || h === m || h === g || typeof h == \"object\" && h !== null && (h.$$typeof === y || h.$$typeof === x || h.$$typeof === s || h.$$typeof === c || h.$$typeof === p || h.$$typeof === S || h.$$typeof === E || h.$$typeof === P || h.$$typeof === f);\n  }, pe.typeOf = T, pe;\n}\nvar me = {};\n/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar pi;\nfunction _c() {\n  return pi || (pi = 1,  true && function() {\n    var e = typeof Symbol == \"function\" && Symbol.for, t = e ? Symbol.for(\"react.element\") : 60103, r = e ? Symbol.for(\"react.portal\") : 60106, n = e ? Symbol.for(\"react.fragment\") : 60107, o = e ? Symbol.for(\"react.strict_mode\") : 60108, i = e ? Symbol.for(\"react.profiler\") : 60114, s = e ? Symbol.for(\"react.provider\") : 60109, c = e ? Symbol.for(\"react.context\") : 60110, l = e ? Symbol.for(\"react.async_mode\") : 60111, u = e ? Symbol.for(\"react.concurrent_mode\") : 60111, p = e ? Symbol.for(\"react.forward_ref\") : 60112, m = e ? Symbol.for(\"react.suspense\") : 60113, g = e ? Symbol.for(\"react.suspense_list\") : 60120, x = e ? Symbol.for(\"react.memo\") : 60115, y = e ? Symbol.for(\"react.lazy\") : 60116, f = e ? Symbol.for(\"react.block\") : 60121, S = e ? Symbol.for(\"react.fundamental\") : 60117, E = e ? Symbol.for(\"react.responder\") : 60118, P = e ? Symbol.for(\"react.scope\") : 60119;\n    function T(O) {\n      return typeof O == \"string\" || typeof O == \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n      O === n || O === u || O === i || O === o || O === m || O === g || typeof O == \"object\" && O !== null && (O.$$typeof === y || O.$$typeof === x || O.$$typeof === s || O.$$typeof === c || O.$$typeof === p || O.$$typeof === S || O.$$typeof === E || O.$$typeof === P || O.$$typeof === f);\n    }\n    function b(O) {\n      if (typeof O == \"object\" && O !== null) {\n        var ye = O.$$typeof;\n        switch (ye) {\n          case t:\n            var Ee = O.type;\n            switch (Ee) {\n              case l:\n              case u:\n              case n:\n              case i:\n              case o:\n              case m:\n                return Ee;\n              default:\n                var Me = Ee && Ee.$$typeof;\n                switch (Me) {\n                  case c:\n                  case p:\n                  case y:\n                  case x:\n                  case s:\n                    return Me;\n                  default:\n                    return ye;\n                }\n            }\n          case r:\n            return ye;\n        }\n      }\n    }\n    var h = l, w = u, k = c, L = s, B = t, d = p, A = n, D = y, j = x, W = r, z = i, U = o, V = m, te = !1;\n    function F(O) {\n      return te || (te = !0, console.warn(\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\")), R(O) || b(O) === l;\n    }\n    function R(O) {\n      return b(O) === u;\n    }\n    function I(O) {\n      return b(O) === c;\n    }\n    function J(O) {\n      return b(O) === s;\n    }\n    function Q(O) {\n      return typeof O == \"object\" && O !== null && O.$$typeof === t;\n    }\n    function H(O) {\n      return b(O) === p;\n    }\n    function X(O) {\n      return b(O) === n;\n    }\n    function _(O) {\n      return b(O) === y;\n    }\n    function q(O) {\n      return b(O) === x;\n    }\n    function G(O) {\n      return b(O) === r;\n    }\n    function re(O) {\n      return b(O) === i;\n    }\n    function Z(O) {\n      return b(O) === o;\n    }\n    function ae(O) {\n      return b(O) === m;\n    }\n    me.AsyncMode = h, me.ConcurrentMode = w, me.ContextConsumer = k, me.ContextProvider = L, me.Element = B, me.ForwardRef = d, me.Fragment = A, me.Lazy = D, me.Memo = j, me.Portal = W, me.Profiler = z, me.StrictMode = U, me.Suspense = V, me.isAsyncMode = F, me.isConcurrentMode = R, me.isContextConsumer = I, me.isContextProvider = J, me.isElement = Q, me.isForwardRef = H, me.isFragment = X, me.isLazy = _, me.isMemo = q, me.isPortal = G, me.isProfiler = re, me.isStrictMode = Z, me.isSuspense = ae, me.isValidElementType = T, me.typeOf = b;\n  }()), me;\n}\nvar mi;\nfunction jc() {\n  return mi || (mi = 1,  false ? 0 : Hr.exports = _c()), Hr.exports;\n}\nvar Yn, hi;\nfunction Dc() {\n  if (hi) return Yn;\n  hi = 1;\n  var e = jc(), t = {\n    childContextTypes: !0,\n    contextType: !0,\n    contextTypes: !0,\n    defaultProps: !0,\n    displayName: !0,\n    getDefaultProps: !0,\n    getDerivedStateFromError: !0,\n    getDerivedStateFromProps: !0,\n    mixins: !0,\n    propTypes: !0,\n    type: !0\n  }, r = {\n    name: !0,\n    length: !0,\n    prototype: !0,\n    caller: !0,\n    callee: !0,\n    arguments: !0,\n    arity: !0\n  }, n = {\n    $$typeof: !0,\n    render: !0,\n    defaultProps: !0,\n    displayName: !0,\n    propTypes: !0\n  }, o = {\n    $$typeof: !0,\n    compare: !0,\n    defaultProps: !0,\n    displayName: !0,\n    propTypes: !0,\n    type: !0\n  }, i = {};\n  i[e.ForwardRef] = n, i[e.Memo] = o;\n  function s(y) {\n    return e.isMemo(y) ? o : i[y.$$typeof] || t;\n  }\n  var c = Object.defineProperty, l = Object.getOwnPropertyNames, u = Object.getOwnPropertySymbols, p = Object.getOwnPropertyDescriptor, m = Object.getPrototypeOf, g = Object.prototype;\n  function x(y, f, S) {\n    if (typeof f != \"string\") {\n      if (g) {\n        var E = m(f);\n        E && E !== g && x(y, E, S);\n      }\n      var P = l(f);\n      u && (P = P.concat(u(f)));\n      for (var T = s(y), b = s(f), h = 0; h < P.length; ++h) {\n        var w = P[h];\n        if (!r[w] && !(S && S[w]) && !(b && b[w]) && !(T && T[w])) {\n          var k = p(f, w);\n          try {\n            c(y, w, k);\n          } catch {\n          }\n        }\n      }\n    }\n    return y;\n  }\n  return Yn = x, Yn;\n}\nDc();\nvar Lc = !0;\nfunction $a(e, t, r) {\n  var n = \"\";\n  return r.split(\" \").forEach(function(o) {\n    e[o] !== void 0 ? t.push(e[o] + \";\") : o && (n += o + \" \");\n  }), n;\n}\nvar To = function(t, r, n) {\n  var o = t.key + \"-\" + r.name;\n  // we only need to add the styles to the registered cache if the\n  // class name could be used further down\n  // the tree but if it's a string tag, we know it won't\n  // so we don't have to add it to registered cache.\n  // this improves memory usage since we can avoid storing the whole style string\n  (n === !1 || // we need to always store it if we're in compat mode and\n  // in node since emotion-server relies on whether a style is in\n  // the registered cache to know whether a style is global or not\n  // also, note that this check will be dead code eliminated in the browser\n  Lc === !1) && t.registered[o] === void 0 && (t.registered[o] = r.styles);\n}, wo = function(t, r, n) {\n  To(t, r, n);\n  var o = t.key + \"-\" + r.name;\n  if (t.inserted[r.name] === void 0) {\n    var i = r;\n    do\n      t.insert(r === i ? \".\" + o : \"\", i, t.sheet, !0), i = i.next;\n    while (i !== void 0);\n  }\n};\nfunction Bc(e) {\n  for (var t = 0, r, n = 0, o = e.length; o >= 4; ++n, o -= 4)\n    r = e.charCodeAt(n) & 255 | (e.charCodeAt(++n) & 255) << 8 | (e.charCodeAt(++n) & 255) << 16 | (e.charCodeAt(++n) & 255) << 24, r = /* Math.imul(k, m): */\n    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= /* k >>> r: */\n    r >>> 24, t = /* Math.imul(k, m): */\n    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */\n    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);\n  switch (o) {\n    case 3:\n      t ^= (e.charCodeAt(n + 2) & 255) << 16;\n    case 2:\n      t ^= (e.charCodeAt(n + 1) & 255) << 8;\n    case 1:\n      t ^= e.charCodeAt(n) & 255, t = /* Math.imul(h, m): */\n      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);\n  }\n  return t ^= t >>> 13, t = /* Math.imul(h, m): */\n  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);\n}\nvar Vc = {\n  animationIterationCount: 1,\n  aspectRatio: 1,\n  borderImageOutset: 1,\n  borderImageSlice: 1,\n  borderImageWidth: 1,\n  boxFlex: 1,\n  boxFlexGroup: 1,\n  boxOrdinalGroup: 1,\n  columnCount: 1,\n  columns: 1,\n  flex: 1,\n  flexGrow: 1,\n  flexPositive: 1,\n  flexShrink: 1,\n  flexNegative: 1,\n  flexOrder: 1,\n  gridRow: 1,\n  gridRowEnd: 1,\n  gridRowSpan: 1,\n  gridRowStart: 1,\n  gridColumn: 1,\n  gridColumnEnd: 1,\n  gridColumnSpan: 1,\n  gridColumnStart: 1,\n  msGridRow: 1,\n  msGridRowSpan: 1,\n  msGridColumn: 1,\n  msGridColumnSpan: 1,\n  fontWeight: 1,\n  lineHeight: 1,\n  opacity: 1,\n  order: 1,\n  orphans: 1,\n  scale: 1,\n  tabSize: 1,\n  widows: 1,\n  zIndex: 1,\n  zoom: 1,\n  WebkitLineClamp: 1,\n  // SVG-related properties\n  fillOpacity: 1,\n  floodOpacity: 1,\n  stopOpacity: 1,\n  strokeDasharray: 1,\n  strokeDashoffset: 1,\n  strokeMiterlimit: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1\n}, Fc = /[A-Z]|^ms/g, zc = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Pa = function(t) {\n  return t.charCodeAt(1) === 45;\n}, gi = function(t) {\n  return t != null && typeof t != \"boolean\";\n}, Hn = /* @__PURE__ */ Oa(function(e) {\n  return Pa(e) ? e : e.replace(Fc, \"-$&\").toLowerCase();\n}), yi = function(t, r) {\n  switch (t) {\n    case \"animation\":\n    case \"animationName\":\n      if (typeof r == \"string\")\n        return r.replace(zc, function(n, o, i) {\n          return ht = {\n            name: o,\n            styles: i,\n            next: ht\n          }, o;\n        });\n  }\n  return Vc[t] !== 1 && !Pa(t) && typeof r == \"number\" && r !== 0 ? r + \"px\" : r;\n};\nfunction wr(e, t, r) {\n  if (r == null)\n    return \"\";\n  var n = r;\n  if (n.__emotion_styles !== void 0)\n    return n;\n  switch (typeof r) {\n    case \"boolean\":\n      return \"\";\n    case \"object\": {\n      var o = r;\n      if (o.anim === 1)\n        return ht = {\n          name: o.name,\n          styles: o.styles,\n          next: ht\n        }, o.name;\n      var i = r;\n      if (i.styles !== void 0) {\n        var s = i.next;\n        if (s !== void 0)\n          for (; s !== void 0; )\n            ht = {\n              name: s.name,\n              styles: s.styles,\n              next: ht\n            }, s = s.next;\n        var c = i.styles + \";\";\n        return c;\n      }\n      return Wc(e, t, r);\n    }\n    case \"function\": {\n      if (e !== void 0) {\n        var l = ht, u = r(e);\n        return ht = l, wr(e, t, u);\n      }\n      break;\n    }\n  }\n  var p = r;\n  if (t == null)\n    return p;\n  var m = t[p];\n  return m !== void 0 ? m : p;\n}\nfunction Wc(e, t, r) {\n  var n = \"\";\n  if (Array.isArray(r))\n    for (var o = 0; o < r.length; o++)\n      n += wr(e, t, r[o]) + \";\";\n  else\n    for (var i in r) {\n      var s = r[i];\n      if (typeof s != \"object\") {\n        var c = s;\n        t != null && t[c] !== void 0 ? n += i + \"{\" + t[c] + \"}\" : gi(c) && (n += Hn(i) + \":\" + yi(i, c) + \";\");\n      } else if (Array.isArray(s) && typeof s[0] == \"string\" && (t == null || t[s[0]] === void 0))\n        for (var l = 0; l < s.length; l++)\n          gi(s[l]) && (n += Hn(i) + \":\" + yi(i, s[l]) + \";\");\n      else {\n        var u = wr(e, t, s);\n        switch (i) {\n          case \"animation\":\n          case \"animationName\": {\n            n += Hn(i) + \":\" + u + \";\";\n            break;\n          }\n          default:\n            n += i + \"{\" + u + \"}\";\n        }\n      }\n    }\n  return n;\n}\nvar bi = /label:\\s*([^\\s;{]+)\\s*(;|$)/g, ht;\nfunction Nr(e, t, r) {\n  if (e.length === 1 && typeof e[0] == \"object\" && e[0] !== null && e[0].styles !== void 0)\n    return e[0];\n  var n = !0, o = \"\";\n  ht = void 0;\n  var i = e[0];\n  if (i == null || i.raw === void 0)\n    n = !1, o += wr(r, t, i);\n  else {\n    var s = i;\n    o += s[0];\n  }\n  for (var c = 1; c < e.length; c++)\n    if (o += wr(r, t, e[c]), n) {\n      var l = i;\n      o += l[c];\n    }\n  bi.lastIndex = 0;\n  for (var u = \"\", p; (p = bi.exec(o)) !== null; )\n    u += \"-\" + p[1];\n  var m = Bc(o) + u;\n  return {\n    name: m,\n    styles: o,\n    next: ht\n  };\n}\nvar Uc = function(t) {\n  return t();\n}, ka = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ? react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect : !1, Aa = ka || Uc, vi = ka || react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect, Na = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(\n  // we're doing this to avoid preconstruct's dead code elimination in this one case\n  // because this module is primarily intended for the browser and node\n  // but it's also required in react native and similar environments sometimes\n  // and we could have a special build just for that\n  // but this is much easier and the native packages\n  // might use a different theme context in the future anyway\n  typeof HTMLElement < \"u\" ? /* @__PURE__ */ Mc({\n    key: \"css\"\n  }) : null\n);\nNa.Provider;\nvar Oo = function(t) {\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(r, n) {\n    var o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Na);\n    return t(r, o, n);\n  });\n}, Mr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext({}), Ro = {}.hasOwnProperty, ao = \"__EMOTION_TYPE_PLEASE_DO_NOT_USE__\", Yc = function(t, r) {\n  var n = {};\n  for (var o in r)\n    Ro.call(r, o) && (n[o] = r[o]);\n  return n[ao] = t, n;\n}, Hc = function(t) {\n  var r = t.cache, n = t.serialized, o = t.isStringTag;\n  return To(r, n, o), Aa(function() {\n    return wo(r, n, o);\n  }), null;\n}, qc = /* @__PURE__ */ Oo(function(e, t, r) {\n  var n = e.css;\n  typeof n == \"string\" && t.registered[n] !== void 0 && (n = t.registered[n]);\n  var o = e[ao], i = [n], s = \"\";\n  typeof e.className == \"string\" ? s = $a(t.registered, i, e.className) : e.className != null && (s = e.className + \" \");\n  var c = Nr(i, void 0, react__WEBPACK_IMPORTED_MODULE_0__.useContext(Mr));\n  s += t.key + \"-\" + c.name;\n  var l = {};\n  for (var u in e)\n    Ro.call(e, u) && u !== \"css\" && u !== ao && (l[u] = e[u]);\n  return l.className = s, r && (l.ref = r), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Hc, {\n    cache: t,\n    serialized: c,\n    isStringTag: typeof o == \"string\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(o, l));\n}), Gc = qc, Kc = function(t, r) {\n  var n = arguments;\n  if (r == null || !Ro.call(r, \"css\"))\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(void 0, n);\n  var o = n.length, i = new Array(o);\n  i[0] = Gc, i[1] = Yc(t, r);\n  for (var s = 2; s < o; s++)\n    i[s] = n[s];\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(null, i);\n};\n(function(e) {\n  var t;\n  t || (t = e.JSX || (e.JSX = {}));\n})(Kc);\nvar Xc = /* @__PURE__ */ Oo(function(e, t) {\n  var r = e.styles, n = Nr([r], void 0, react__WEBPACK_IMPORTED_MODULE_0__.useContext(Mr)), o = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  return vi(function() {\n    var i = t.key + \"-global\", s = new t.sheet.constructor({\n      key: i,\n      nonce: t.sheet.nonce,\n      container: t.sheet.container,\n      speedy: t.sheet.isSpeedy\n    }), c = !1, l = document.querySelector('style[data-emotion=\"' + i + \" \" + n.name + '\"]');\n    return t.sheet.tags.length && (s.before = t.sheet.tags[0]), l !== null && (c = !0, l.setAttribute(\"data-emotion\", i), s.hydrate([l])), o.current = [s, c], function() {\n      s.flush();\n    };\n  }, [t]), vi(function() {\n    var i = o.current, s = i[0], c = i[1];\n    if (c) {\n      i[1] = !1;\n      return;\n    }\n    if (n.next !== void 0 && wo(t, n.next, !0), s.tags.length) {\n      var l = s.tags[s.tags.length - 1].nextElementSibling;\n      s.before = l, s.flush();\n    }\n    t.insert(\"\", n, s, !1);\n  }, [t, n.name]), null;\n});\nfunction $o() {\n  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)\n    t[r] = arguments[r];\n  return Nr(t);\n}\nfunction Ir() {\n  var e = $o.apply(void 0, arguments), t = \"animation-\" + e.name;\n  return {\n    name: t,\n    styles: \"@keyframes \" + t + \"{\" + e.styles + \"}\",\n    anim: 1,\n    toString: function() {\n      return \"_EMO_\" + this.name + \"_\" + this.styles + \"_EMO_\";\n    }\n  };\n}\nvar Jc = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, Qc = /* @__PURE__ */ Oa(\n  function(e) {\n    return Jc.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;\n  }\n  /* Z+1 */\n), Zc = Qc, el = function(t) {\n  return t !== \"theme\";\n}, xi = function(t) {\n  return typeof t == \"string\" && // 96 is one less than the char code\n  // for \"a\" so this is checking that\n  // it's a lowercase character\n  t.charCodeAt(0) > 96 ? Zc : el;\n}, Si = function(t, r, n) {\n  var o;\n  if (r) {\n    var i = r.shouldForwardProp;\n    o = t.__emotion_forwardProp && i ? function(s) {\n      return t.__emotion_forwardProp(s) && i(s);\n    } : i;\n  }\n  return typeof o != \"function\" && n && (o = t.__emotion_forwardProp), o;\n}, tl = function(t) {\n  var r = t.cache, n = t.serialized, o = t.isStringTag;\n  return To(r, n, o), Aa(function() {\n    return wo(r, n, o);\n  }), null;\n}, rl = function e(t, r) {\n  var n = t.__emotion_real === t, o = n && t.__emotion_base || t, i, s;\n  r !== void 0 && (i = r.label, s = r.target);\n  var c = Si(t, r, n), l = c || xi(o), u = !l(\"as\");\n  return function() {\n    var p = arguments, m = n && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];\n    if (i !== void 0 && m.push(\"label:\" + i + \";\"), p[0] == null || p[0].raw === void 0)\n      m.push.apply(m, p);\n    else {\n      var g = p[0];\n      m.push(g[0]);\n      for (var x = p.length, y = 1; y < x; y++)\n        m.push(p[y], g[y]);\n    }\n    var f = Oo(function(S, E, P) {\n      var T = u && S.as || o, b = \"\", h = [], w = S;\n      if (S.theme == null) {\n        w = {};\n        for (var k in S)\n          w[k] = S[k];\n        w.theme = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Mr);\n      }\n      typeof S.className == \"string\" ? b = $a(E.registered, h, S.className) : S.className != null && (b = S.className + \" \");\n      var L = Nr(m.concat(h), E.registered, w);\n      b += E.key + \"-\" + L.name, s !== void 0 && (b += \" \" + s);\n      var B = u && c === void 0 ? xi(T) : l, d = {};\n      for (var A in S)\n        u && A === \"as\" || B(A) && (d[A] = S[A]);\n      return d.className = b, P && (d.ref = P), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(tl, {\n        cache: E,\n        serialized: L,\n        isStringTag: typeof T == \"string\"\n      }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(T, d));\n    });\n    return f.displayName = i !== void 0 ? i : \"Styled(\" + (typeof o == \"string\" ? o : o.displayName || o.name || \"Component\") + \")\", f.defaultProps = t.defaultProps, f.__emotion_real = f, f.__emotion_base = o, f.__emotion_styles = m, f.__emotion_forwardProp = c, Object.defineProperty(f, \"toString\", {\n      value: function() {\n        return \".\" + s;\n      }\n    }), f.withComponent = function(S, E) {\n      var P = e(S, fn({}, r, E, {\n        shouldForwardProp: Si(f, E, !0)\n      }));\n      return P.apply(void 0, m);\n    }, f;\n  };\n}, nl = [\n  \"a\",\n  \"abbr\",\n  \"address\",\n  \"area\",\n  \"article\",\n  \"aside\",\n  \"audio\",\n  \"b\",\n  \"base\",\n  \"bdi\",\n  \"bdo\",\n  \"big\",\n  \"blockquote\",\n  \"body\",\n  \"br\",\n  \"button\",\n  \"canvas\",\n  \"caption\",\n  \"cite\",\n  \"code\",\n  \"col\",\n  \"colgroup\",\n  \"data\",\n  \"datalist\",\n  \"dd\",\n  \"del\",\n  \"details\",\n  \"dfn\",\n  \"dialog\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"em\",\n  \"embed\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"footer\",\n  \"form\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"head\",\n  \"header\",\n  \"hgroup\",\n  \"hr\",\n  \"html\",\n  \"i\",\n  \"iframe\",\n  \"img\",\n  \"input\",\n  \"ins\",\n  \"kbd\",\n  \"keygen\",\n  \"label\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"map\",\n  \"mark\",\n  \"marquee\",\n  \"menu\",\n  \"menuitem\",\n  \"meta\",\n  \"meter\",\n  \"nav\",\n  \"noscript\",\n  \"object\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"p\",\n  \"param\",\n  \"picture\",\n  \"pre\",\n  \"progress\",\n  \"q\",\n  \"rp\",\n  \"rt\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"script\",\n  \"section\",\n  \"select\",\n  \"small\",\n  \"source\",\n  \"span\",\n  \"strong\",\n  \"style\",\n  \"sub\",\n  \"summary\",\n  \"sup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"textarea\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"time\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"u\",\n  \"ul\",\n  \"var\",\n  \"video\",\n  \"wbr\",\n  // SVG\n  \"circle\",\n  \"clipPath\",\n  \"defs\",\n  \"ellipse\",\n  \"foreignObject\",\n  \"g\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"mask\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"stop\",\n  \"svg\",\n  \"text\",\n  \"tspan\"\n], so = rl.bind(null);\nnl.forEach(function(e) {\n  so[e] = so(e);\n});\nvar qr = { exports: {} }, Gr = { exports: {} }, he = {};\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Ei;\nfunction ol() {\n  if (Ei) return he;\n  Ei = 1;\n  var e = typeof Symbol == \"function\" && Symbol.for, t = e ? Symbol.for(\"react.element\") : 60103, r = e ? Symbol.for(\"react.portal\") : 60106, n = e ? Symbol.for(\"react.fragment\") : 60107, o = e ? Symbol.for(\"react.strict_mode\") : 60108, i = e ? Symbol.for(\"react.profiler\") : 60114, s = e ? Symbol.for(\"react.provider\") : 60109, c = e ? Symbol.for(\"react.context\") : 60110, l = e ? Symbol.for(\"react.async_mode\") : 60111, u = e ? Symbol.for(\"react.concurrent_mode\") : 60111, p = e ? Symbol.for(\"react.forward_ref\") : 60112, m = e ? Symbol.for(\"react.suspense\") : 60113, g = e ? Symbol.for(\"react.suspense_list\") : 60120, x = e ? Symbol.for(\"react.memo\") : 60115, y = e ? Symbol.for(\"react.lazy\") : 60116, f = e ? Symbol.for(\"react.block\") : 60121, S = e ? Symbol.for(\"react.fundamental\") : 60117, E = e ? Symbol.for(\"react.responder\") : 60118, P = e ? Symbol.for(\"react.scope\") : 60119;\n  function T(h) {\n    if (typeof h == \"object\" && h !== null) {\n      var w = h.$$typeof;\n      switch (w) {\n        case t:\n          switch (h = h.type, h) {\n            case l:\n            case u:\n            case n:\n            case i:\n            case o:\n            case m:\n              return h;\n            default:\n              switch (h = h && h.$$typeof, h) {\n                case c:\n                case p:\n                case y:\n                case x:\n                case s:\n                  return h;\n                default:\n                  return w;\n              }\n          }\n        case r:\n          return w;\n      }\n    }\n  }\n  function b(h) {\n    return T(h) === u;\n  }\n  return he.AsyncMode = l, he.ConcurrentMode = u, he.ContextConsumer = c, he.ContextProvider = s, he.Element = t, he.ForwardRef = p, he.Fragment = n, he.Lazy = y, he.Memo = x, he.Portal = r, he.Profiler = i, he.StrictMode = o, he.Suspense = m, he.isAsyncMode = function(h) {\n    return b(h) || T(h) === l;\n  }, he.isConcurrentMode = b, he.isContextConsumer = function(h) {\n    return T(h) === c;\n  }, he.isContextProvider = function(h) {\n    return T(h) === s;\n  }, he.isElement = function(h) {\n    return typeof h == \"object\" && h !== null && h.$$typeof === t;\n  }, he.isForwardRef = function(h) {\n    return T(h) === p;\n  }, he.isFragment = function(h) {\n    return T(h) === n;\n  }, he.isLazy = function(h) {\n    return T(h) === y;\n  }, he.isMemo = function(h) {\n    return T(h) === x;\n  }, he.isPortal = function(h) {\n    return T(h) === r;\n  }, he.isProfiler = function(h) {\n    return T(h) === i;\n  }, he.isStrictMode = function(h) {\n    return T(h) === o;\n  }, he.isSuspense = function(h) {\n    return T(h) === m;\n  }, he.isValidElementType = function(h) {\n    return typeof h == \"string\" || typeof h == \"function\" || h === n || h === u || h === i || h === o || h === m || h === g || typeof h == \"object\" && h !== null && (h.$$typeof === y || h.$$typeof === x || h.$$typeof === s || h.$$typeof === c || h.$$typeof === p || h.$$typeof === S || h.$$typeof === E || h.$$typeof === P || h.$$typeof === f);\n  }, he.typeOf = T, he;\n}\nvar ge = {};\n/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Ci;\nfunction il() {\n  return Ci || (Ci = 1,  true && function() {\n    var e = typeof Symbol == \"function\" && Symbol.for, t = e ? Symbol.for(\"react.element\") : 60103, r = e ? Symbol.for(\"react.portal\") : 60106, n = e ? Symbol.for(\"react.fragment\") : 60107, o = e ? Symbol.for(\"react.strict_mode\") : 60108, i = e ? Symbol.for(\"react.profiler\") : 60114, s = e ? Symbol.for(\"react.provider\") : 60109, c = e ? Symbol.for(\"react.context\") : 60110, l = e ? Symbol.for(\"react.async_mode\") : 60111, u = e ? Symbol.for(\"react.concurrent_mode\") : 60111, p = e ? Symbol.for(\"react.forward_ref\") : 60112, m = e ? Symbol.for(\"react.suspense\") : 60113, g = e ? Symbol.for(\"react.suspense_list\") : 60120, x = e ? Symbol.for(\"react.memo\") : 60115, y = e ? Symbol.for(\"react.lazy\") : 60116, f = e ? Symbol.for(\"react.block\") : 60121, S = e ? Symbol.for(\"react.fundamental\") : 60117, E = e ? Symbol.for(\"react.responder\") : 60118, P = e ? Symbol.for(\"react.scope\") : 60119;\n    function T(O) {\n      return typeof O == \"string\" || typeof O == \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n      O === n || O === u || O === i || O === o || O === m || O === g || typeof O == \"object\" && O !== null && (O.$$typeof === y || O.$$typeof === x || O.$$typeof === s || O.$$typeof === c || O.$$typeof === p || O.$$typeof === S || O.$$typeof === E || O.$$typeof === P || O.$$typeof === f);\n    }\n    function b(O) {\n      if (typeof O == \"object\" && O !== null) {\n        var ye = O.$$typeof;\n        switch (ye) {\n          case t:\n            var Ee = O.type;\n            switch (Ee) {\n              case l:\n              case u:\n              case n:\n              case i:\n              case o:\n              case m:\n                return Ee;\n              default:\n                var Me = Ee && Ee.$$typeof;\n                switch (Me) {\n                  case c:\n                  case p:\n                  case y:\n                  case x:\n                  case s:\n                    return Me;\n                  default:\n                    return ye;\n                }\n            }\n          case r:\n            return ye;\n        }\n      }\n    }\n    var h = l, w = u, k = c, L = s, B = t, d = p, A = n, D = y, j = x, W = r, z = i, U = o, V = m, te = !1;\n    function F(O) {\n      return te || (te = !0, console.warn(\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\")), R(O) || b(O) === l;\n    }\n    function R(O) {\n      return b(O) === u;\n    }\n    function I(O) {\n      return b(O) === c;\n    }\n    function J(O) {\n      return b(O) === s;\n    }\n    function Q(O) {\n      return typeof O == \"object\" && O !== null && O.$$typeof === t;\n    }\n    function H(O) {\n      return b(O) === p;\n    }\n    function X(O) {\n      return b(O) === n;\n    }\n    function _(O) {\n      return b(O) === y;\n    }\n    function q(O) {\n      return b(O) === x;\n    }\n    function G(O) {\n      return b(O) === r;\n    }\n    function re(O) {\n      return b(O) === i;\n    }\n    function Z(O) {\n      return b(O) === o;\n    }\n    function ae(O) {\n      return b(O) === m;\n    }\n    ge.AsyncMode = h, ge.ConcurrentMode = w, ge.ContextConsumer = k, ge.ContextProvider = L, ge.Element = B, ge.ForwardRef = d, ge.Fragment = A, ge.Lazy = D, ge.Memo = j, ge.Portal = W, ge.Profiler = z, ge.StrictMode = U, ge.Suspense = V, ge.isAsyncMode = F, ge.isConcurrentMode = R, ge.isContextConsumer = I, ge.isContextProvider = J, ge.isElement = Q, ge.isForwardRef = H, ge.isFragment = X, ge.isLazy = _, ge.isMemo = q, ge.isPortal = G, ge.isProfiler = re, ge.isStrictMode = Z, ge.isSuspense = ae, ge.isValidElementType = T, ge.typeOf = b;\n  }()), ge;\n}\nvar Ti;\nfunction Ma() {\n  return Ti || (Ti = 1,  false ? 0 : Gr.exports = il()), Gr.exports;\n}\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar qn, wi;\nfunction al() {\n  if (wi) return qn;\n  wi = 1;\n  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable;\n  function n(i) {\n    if (i == null)\n      throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n    return Object(i);\n  }\n  function o() {\n    try {\n      if (!Object.assign)\n        return !1;\n      var i = new String(\"abc\");\n      if (i[5] = \"de\", Object.getOwnPropertyNames(i)[0] === \"5\")\n        return !1;\n      for (var s = {}, c = 0; c < 10; c++)\n        s[\"_\" + String.fromCharCode(c)] = c;\n      var l = Object.getOwnPropertyNames(s).map(function(p) {\n        return s[p];\n      });\n      if (l.join(\"\") !== \"0123456789\")\n        return !1;\n      var u = {};\n      return \"abcdefghijklmnopqrst\".split(\"\").forEach(function(p) {\n        u[p] = p;\n      }), Object.keys(Object.assign({}, u)).join(\"\") === \"abcdefghijklmnopqrst\";\n    } catch {\n      return !1;\n    }\n  }\n  return qn = o() ? Object.assign : function(i, s) {\n    for (var c, l = n(i), u, p = 1; p < arguments.length; p++) {\n      c = Object(arguments[p]);\n      for (var m in c)\n        t.call(c, m) && (l[m] = c[m]);\n      if (e) {\n        u = e(c);\n        for (var g = 0; g < u.length; g++)\n          r.call(c, u[g]) && (l[u[g]] = c[u[g]]);\n      }\n    }\n    return l;\n  }, qn;\n}\nvar Gn, Oi;\nfunction Po() {\n  if (Oi) return Gn;\n  Oi = 1;\n  var e = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n  return Gn = e, Gn;\n}\nvar Kn, Ri;\nfunction Ia() {\n  return Ri || (Ri = 1, Kn = Function.call.bind(Object.prototype.hasOwnProperty)), Kn;\n}\nvar Xn, $i;\nfunction sl() {\n  if ($i) return Xn;\n  $i = 1;\n  var e = function() {\n  };\n  if (true) {\n    var t = /* @__PURE__ */ Po(), r = {}, n = /* @__PURE__ */ Ia();\n    e = function(i) {\n      var s = \"Warning: \" + i;\n      typeof console < \"u\" && console.error(s);\n      try {\n        throw new Error(s);\n      } catch {\n      }\n    };\n  }\n  function o(i, s, c, l, u) {\n    if (true) {\n      for (var p in i)\n        if (n(i, p)) {\n          var m;\n          try {\n            if (typeof i[p] != \"function\") {\n              var g = Error(\n                (l || \"React class\") + \": \" + c + \" type `\" + p + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof i[p] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\"\n              );\n              throw g.name = \"Invariant Violation\", g;\n            }\n            m = i[p](s, p, l, c, null, t);\n          } catch (y) {\n            m = y;\n          }\n          if (m && !(m instanceof Error) && e(\n            (l || \"React class\") + \": type specification of \" + c + \" `\" + p + \"` is invalid; the type checker function must return `null` or an `Error` but returned a \" + typeof m + \". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\"\n          ), m instanceof Error && !(m.message in r)) {\n            r[m.message] = !0;\n            var x = u ? u() : \"\";\n            e(\n              \"Failed \" + c + \" type: \" + m.message + (x ?? \"\")\n            );\n          }\n        }\n    }\n  }\n  return o.resetWarningCache = function() {\n     true && (r = {});\n  }, Xn = o, Xn;\n}\nvar Jn, Pi;\nfunction cl() {\n  if (Pi) return Jn;\n  Pi = 1;\n  var e = Ma(), t = al(), r = /* @__PURE__ */ Po(), n = /* @__PURE__ */ Ia(), o = /* @__PURE__ */ sl(), i = function() {\n  };\n   true && (i = function(c) {\n    var l = \"Warning: \" + c;\n    typeof console < \"u\" && console.error(l);\n    try {\n      throw new Error(l);\n    } catch {\n    }\n  });\n  function s() {\n    return null;\n  }\n  return Jn = function(c, l) {\n    var u = typeof Symbol == \"function\" && Symbol.iterator, p = \"@@iterator\";\n    function m(R) {\n      var I = R && (u && R[u] || R[p]);\n      if (typeof I == \"function\")\n        return I;\n    }\n    var g = \"<<anonymous>>\", x = {\n      array: E(\"array\"),\n      bigint: E(\"bigint\"),\n      bool: E(\"boolean\"),\n      func: E(\"function\"),\n      number: E(\"number\"),\n      object: E(\"object\"),\n      string: E(\"string\"),\n      symbol: E(\"symbol\"),\n      any: P(),\n      arrayOf: T,\n      element: b(),\n      elementType: h(),\n      instanceOf: w,\n      node: d(),\n      objectOf: L,\n      oneOf: k,\n      oneOfType: B,\n      shape: D,\n      exact: j\n    };\n    function y(R, I) {\n      return R === I ? R !== 0 || 1 / R === 1 / I : R !== R && I !== I;\n    }\n    function f(R, I) {\n      this.message = R, this.data = I && typeof I == \"object\" ? I : {}, this.stack = \"\";\n    }\n    f.prototype = Error.prototype;\n    function S(R) {\n      if (true)\n        var I = {}, J = 0;\n      function Q(X, _, q, G, re, Z, ae) {\n        if (G = G || g, Z = Z || q, ae !== r) {\n          if (l) {\n            var O = new Error(\n              \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types\"\n            );\n            throw O.name = \"Invariant Violation\", O;\n          } else if ( true && typeof console < \"u\") {\n            var ye = G + \":\" + q;\n            !I[ye] && // Avoid spamming the console because they are often not actionable except for lib authors\n            J < 3 && (i(\n              \"You are manually calling a React.PropTypes validation function for the `\" + Z + \"` prop on `\" + G + \"`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\"\n            ), I[ye] = !0, J++);\n          }\n        }\n        return _[q] == null ? X ? _[q] === null ? new f(\"The \" + re + \" `\" + Z + \"` is marked as required \" + (\"in `\" + G + \"`, but its value is `null`.\")) : new f(\"The \" + re + \" `\" + Z + \"` is marked as required in \" + (\"`\" + G + \"`, but its value is `undefined`.\")) : null : R(_, q, G, re, Z);\n      }\n      var H = Q.bind(null, !1);\n      return H.isRequired = Q.bind(null, !0), H;\n    }\n    function E(R) {\n      function I(J, Q, H, X, _, q) {\n        var G = J[Q], re = U(G);\n        if (re !== R) {\n          var Z = V(G);\n          return new f(\n            \"Invalid \" + X + \" `\" + _ + \"` of type \" + (\"`\" + Z + \"` supplied to `\" + H + \"`, expected \") + (\"`\" + R + \"`.\"),\n            { expectedType: R }\n          );\n        }\n        return null;\n      }\n      return S(I);\n    }\n    function P() {\n      return S(s);\n    }\n    function T(R) {\n      function I(J, Q, H, X, _) {\n        if (typeof R != \"function\")\n          return new f(\"Property `\" + _ + \"` of component `\" + H + \"` has invalid PropType notation inside arrayOf.\");\n        var q = J[Q];\n        if (!Array.isArray(q)) {\n          var G = U(q);\n          return new f(\"Invalid \" + X + \" `\" + _ + \"` of type \" + (\"`\" + G + \"` supplied to `\" + H + \"`, expected an array.\"));\n        }\n        for (var re = 0; re < q.length; re++) {\n          var Z = R(q, re, H, X, _ + \"[\" + re + \"]\", r);\n          if (Z instanceof Error)\n            return Z;\n        }\n        return null;\n      }\n      return S(I);\n    }\n    function b() {\n      function R(I, J, Q, H, X) {\n        var _ = I[J];\n        if (!c(_)) {\n          var q = U(_);\n          return new f(\"Invalid \" + H + \" `\" + X + \"` of type \" + (\"`\" + q + \"` supplied to `\" + Q + \"`, expected a single ReactElement.\"));\n        }\n        return null;\n      }\n      return S(R);\n    }\n    function h() {\n      function R(I, J, Q, H, X) {\n        var _ = I[J];\n        if (!e.isValidElementType(_)) {\n          var q = U(_);\n          return new f(\"Invalid \" + H + \" `\" + X + \"` of type \" + (\"`\" + q + \"` supplied to `\" + Q + \"`, expected a single ReactElement type.\"));\n        }\n        return null;\n      }\n      return S(R);\n    }\n    function w(R) {\n      function I(J, Q, H, X, _) {\n        if (!(J[Q] instanceof R)) {\n          var q = R.name || g, G = F(J[Q]);\n          return new f(\"Invalid \" + X + \" `\" + _ + \"` of type \" + (\"`\" + G + \"` supplied to `\" + H + \"`, expected \") + (\"instance of `\" + q + \"`.\"));\n        }\n        return null;\n      }\n      return S(I);\n    }\n    function k(R) {\n      if (!Array.isArray(R))\n        return  true && (arguments.length > 1 ? i(\n          \"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\"\n        ) : i(\"Invalid argument supplied to oneOf, expected an array.\")), s;\n      function I(J, Q, H, X, _) {\n        for (var q = J[Q], G = 0; G < R.length; G++)\n          if (y(q, R[G]))\n            return null;\n        var re = JSON.stringify(R, function(ae, O) {\n          var ye = V(O);\n          return ye === \"symbol\" ? String(O) : O;\n        });\n        return new f(\"Invalid \" + X + \" `\" + _ + \"` of value `\" + String(q) + \"` \" + (\"supplied to `\" + H + \"`, expected one of \" + re + \".\"));\n      }\n      return S(I);\n    }\n    function L(R) {\n      function I(J, Q, H, X, _) {\n        if (typeof R != \"function\")\n          return new f(\"Property `\" + _ + \"` of component `\" + H + \"` has invalid PropType notation inside objectOf.\");\n        var q = J[Q], G = U(q);\n        if (G !== \"object\")\n          return new f(\"Invalid \" + X + \" `\" + _ + \"` of type \" + (\"`\" + G + \"` supplied to `\" + H + \"`, expected an object.\"));\n        for (var re in q)\n          if (n(q, re)) {\n            var Z = R(q, re, H, X, _ + \".\" + re, r);\n            if (Z instanceof Error)\n              return Z;\n          }\n        return null;\n      }\n      return S(I);\n    }\n    function B(R) {\n      if (!Array.isArray(R))\n        return  true && i(\"Invalid argument supplied to oneOfType, expected an instance of array.\"), s;\n      for (var I = 0; I < R.length; I++) {\n        var J = R[I];\n        if (typeof J != \"function\")\n          return i(\n            \"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \" + te(J) + \" at index \" + I + \".\"\n          ), s;\n      }\n      function Q(H, X, _, q, G) {\n        for (var re = [], Z = 0; Z < R.length; Z++) {\n          var ae = R[Z], O = ae(H, X, _, q, G, r);\n          if (O == null)\n            return null;\n          O.data && n(O.data, \"expectedType\") && re.push(O.data.expectedType);\n        }\n        var ye = re.length > 0 ? \", expected one of type [\" + re.join(\", \") + \"]\" : \"\";\n        return new f(\"Invalid \" + q + \" `\" + G + \"` supplied to \" + (\"`\" + _ + \"`\" + ye + \".\"));\n      }\n      return S(Q);\n    }\n    function d() {\n      function R(I, J, Q, H, X) {\n        return W(I[J]) ? null : new f(\"Invalid \" + H + \" `\" + X + \"` supplied to \" + (\"`\" + Q + \"`, expected a ReactNode.\"));\n      }\n      return S(R);\n    }\n    function A(R, I, J, Q, H) {\n      return new f(\n        (R || \"React class\") + \": \" + I + \" type `\" + J + \".\" + Q + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + H + \"`.\"\n      );\n    }\n    function D(R) {\n      function I(J, Q, H, X, _) {\n        var q = J[Q], G = U(q);\n        if (G !== \"object\")\n          return new f(\"Invalid \" + X + \" `\" + _ + \"` of type `\" + G + \"` \" + (\"supplied to `\" + H + \"`, expected `object`.\"));\n        for (var re in R) {\n          var Z = R[re];\n          if (typeof Z != \"function\")\n            return A(H, X, _, re, V(Z));\n          var ae = Z(q, re, H, X, _ + \".\" + re, r);\n          if (ae)\n            return ae;\n        }\n        return null;\n      }\n      return S(I);\n    }\n    function j(R) {\n      function I(J, Q, H, X, _) {\n        var q = J[Q], G = U(q);\n        if (G !== \"object\")\n          return new f(\"Invalid \" + X + \" `\" + _ + \"` of type `\" + G + \"` \" + (\"supplied to `\" + H + \"`, expected `object`.\"));\n        var re = t({}, J[Q], R);\n        for (var Z in re) {\n          var ae = R[Z];\n          if (n(R, Z) && typeof ae != \"function\")\n            return A(H, X, _, Z, V(ae));\n          if (!ae)\n            return new f(\n              \"Invalid \" + X + \" `\" + _ + \"` key `\" + Z + \"` supplied to `\" + H + \"`.\\nBad object: \" + JSON.stringify(J[Q], null, \"  \") + `\nValid keys: ` + JSON.stringify(Object.keys(R), null, \"  \")\n            );\n          var O = ae(q, Z, H, X, _ + \".\" + Z, r);\n          if (O)\n            return O;\n        }\n        return null;\n      }\n      return S(I);\n    }\n    function W(R) {\n      switch (typeof R) {\n        case \"number\":\n        case \"string\":\n        case \"undefined\":\n          return !0;\n        case \"boolean\":\n          return !R;\n        case \"object\":\n          if (Array.isArray(R))\n            return R.every(W);\n          if (R === null || c(R))\n            return !0;\n          var I = m(R);\n          if (I) {\n            var J = I.call(R), Q;\n            if (I !== R.entries) {\n              for (; !(Q = J.next()).done; )\n                if (!W(Q.value))\n                  return !1;\n            } else\n              for (; !(Q = J.next()).done; ) {\n                var H = Q.value;\n                if (H && !W(H[1]))\n                  return !1;\n              }\n          } else\n            return !1;\n          return !0;\n        default:\n          return !1;\n      }\n    }\n    function z(R, I) {\n      return R === \"symbol\" ? !0 : I ? I[\"@@toStringTag\"] === \"Symbol\" || typeof Symbol == \"function\" && I instanceof Symbol : !1;\n    }\n    function U(R) {\n      var I = typeof R;\n      return Array.isArray(R) ? \"array\" : R instanceof RegExp ? \"object\" : z(I, R) ? \"symbol\" : I;\n    }\n    function V(R) {\n      if (typeof R > \"u\" || R === null)\n        return \"\" + R;\n      var I = U(R);\n      if (I === \"object\") {\n        if (R instanceof Date)\n          return \"date\";\n        if (R instanceof RegExp)\n          return \"regexp\";\n      }\n      return I;\n    }\n    function te(R) {\n      var I = V(R);\n      switch (I) {\n        case \"array\":\n        case \"object\":\n          return \"an \" + I;\n        case \"boolean\":\n        case \"date\":\n        case \"regexp\":\n          return \"a \" + I;\n        default:\n          return I;\n      }\n    }\n    function F(R) {\n      return !R.constructor || !R.constructor.name ? g : R.constructor.name;\n    }\n    return x.checkPropTypes = o, x.resetWarningCache = o.resetWarningCache, x.PropTypes = x, x;\n  }, Jn;\n}\nvar Qn, ki;\nfunction ll() {\n  if (ki) return Qn;\n  ki = 1;\n  var e = /* @__PURE__ */ Po();\n  function t() {\n  }\n  function r() {\n  }\n  return r.resetWarningCache = t, Qn = function() {\n    function n(s, c, l, u, p, m) {\n      if (m !== e) {\n        var g = new Error(\n          \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\"\n        );\n        throw g.name = \"Invariant Violation\", g;\n      }\n    }\n    n.isRequired = n;\n    function o() {\n      return n;\n    }\n    var i = {\n      array: n,\n      bigint: n,\n      bool: n,\n      func: n,\n      number: n,\n      object: n,\n      string: n,\n      symbol: n,\n      any: n,\n      arrayOf: o,\n      element: n,\n      elementType: n,\n      instanceOf: o,\n      node: n,\n      objectOf: o,\n      oneOf: o,\n      oneOfType: o,\n      shape: o,\n      exact: o,\n      checkPropTypes: r,\n      resetWarningCache: t\n    };\n    return i.PropTypes = i, i;\n  }, Qn;\n}\nvar Ai;\nfunction ul() {\n  if (Ai) return qr.exports;\n  if (Ai = 1, \"development\" !== \"production\") {\n    var e = Ma(), t = !0;\n    qr.exports = /* @__PURE__ */ cl()(e.isElement, t);\n  } else\n    qr.exports = /* @__PURE__ */ ll()();\n  return qr.exports;\n}\nvar fl = /* @__PURE__ */ ul();\nconst a = /* @__PURE__ */ ec(fl);\nfunction dl(e) {\n  return e == null || Object.keys(e).length === 0;\n}\nfunction _a(e) {\n  const {\n    styles: t,\n    defaultTheme: r = {}\n  } = e, n = typeof t == \"function\" ? (o) => t(dl(o) ? r : o) : t;\n  return /* @__PURE__ */ N.jsx(Xc, {\n    styles: n\n  });\n}\n true && (_a.propTypes = {\n  defaultTheme: a.object,\n  styles: a.oneOfType([a.array, a.string, a.object, a.func])\n});\n/**\n * @mui/styled-engine v6.4.0\n *\n * @license MIT\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nfunction ja(e, t) {\n  const r = so(e, t);\n  return  true ? (...n) => {\n    const o = typeof e == \"string\" ? `\"${e}\"` : \"component\";\n    return n.length === 0 ? console.error([`MUI: Seems like you called \\`styled(${o})()\\` without a \\`style\\` argument.`, 'You must provide a `styles` argument: `styled(\"div\")(styleYouForgotToPass)`.'].join(`\n`)) : n.some((i) => i === void 0) && console.error(`MUI: the styled(${o})(...args) API requires all its args to be defined.`), r(...n);\n  } : 0;\n}\nfunction pl(e, t) {\n  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));\n}\nconst Ni = [];\nfunction Mi(e) {\n  return Ni[0] = e, Nr(Ni);\n}\nvar Kr = { exports: {} }, xe = {};\n/**\n * @license React\n * react-is.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Ii;\nfunction ml() {\n  if (Ii) return xe;\n  Ii = 1;\n  var e = Symbol.for(\"react.transitional.element\"), t = Symbol.for(\"react.portal\"), r = Symbol.for(\"react.fragment\"), n = Symbol.for(\"react.strict_mode\"), o = Symbol.for(\"react.profiler\"), i = Symbol.for(\"react.consumer\"), s = Symbol.for(\"react.context\"), c = Symbol.for(\"react.forward_ref\"), l = Symbol.for(\"react.suspense\"), u = Symbol.for(\"react.suspense_list\"), p = Symbol.for(\"react.memo\"), m = Symbol.for(\"react.lazy\"), g = Symbol.for(\"react.offscreen\"), x = Symbol.for(\"react.client.reference\");\n  function y(f) {\n    if (typeof f == \"object\" && f !== null) {\n      var S = f.$$typeof;\n      switch (S) {\n        case e:\n          switch (f = f.type, f) {\n            case r:\n            case o:\n            case n:\n            case l:\n            case u:\n              return f;\n            default:\n              switch (f = f && f.$$typeof, f) {\n                case s:\n                case c:\n                case m:\n                case p:\n                  return f;\n                case i:\n                  return f;\n                default:\n                  return S;\n              }\n          }\n        case t:\n          return S;\n      }\n    }\n  }\n  return xe.ContextConsumer = i, xe.ContextProvider = s, xe.Element = e, xe.ForwardRef = c, xe.Fragment = r, xe.Lazy = m, xe.Memo = p, xe.Portal = t, xe.Profiler = o, xe.StrictMode = n, xe.Suspense = l, xe.SuspenseList = u, xe.isContextConsumer = function(f) {\n    return y(f) === i;\n  }, xe.isContextProvider = function(f) {\n    return y(f) === s;\n  }, xe.isElement = function(f) {\n    return typeof f == \"object\" && f !== null && f.$$typeof === e;\n  }, xe.isForwardRef = function(f) {\n    return y(f) === c;\n  }, xe.isFragment = function(f) {\n    return y(f) === r;\n  }, xe.isLazy = function(f) {\n    return y(f) === m;\n  }, xe.isMemo = function(f) {\n    return y(f) === p;\n  }, xe.isPortal = function(f) {\n    return y(f) === t;\n  }, xe.isProfiler = function(f) {\n    return y(f) === o;\n  }, xe.isStrictMode = function(f) {\n    return y(f) === n;\n  }, xe.isSuspense = function(f) {\n    return y(f) === l;\n  }, xe.isSuspenseList = function(f) {\n    return y(f) === u;\n  }, xe.isValidElementType = function(f) {\n    return typeof f == \"string\" || typeof f == \"function\" || f === r || f === o || f === n || f === l || f === u || f === g || typeof f == \"object\" && f !== null && (f.$$typeof === m || f.$$typeof === p || f.$$typeof === s || f.$$typeof === i || f.$$typeof === c || f.$$typeof === x || f.getModuleId !== void 0);\n  }, xe.typeOf = y, xe;\n}\nvar Se = {};\n/**\n * @license React\n * react-is.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar _i;\nfunction hl() {\n  return _i || (_i = 1,  true && function() {\n    function e(f) {\n      if (typeof f == \"object\" && f !== null) {\n        var S = f.$$typeof;\n        switch (S) {\n          case t:\n            switch (f = f.type, f) {\n              case n:\n              case i:\n              case o:\n              case u:\n              case p:\n                return f;\n              default:\n                switch (f = f && f.$$typeof, f) {\n                  case c:\n                  case l:\n                  case g:\n                  case m:\n                    return f;\n                  case s:\n                    return f;\n                  default:\n                    return S;\n                }\n            }\n          case r:\n            return S;\n        }\n      }\n    }\n    var t = Symbol.for(\"react.transitional.element\"), r = Symbol.for(\"react.portal\"), n = Symbol.for(\"react.fragment\"), o = Symbol.for(\"react.strict_mode\"), i = Symbol.for(\"react.profiler\"), s = Symbol.for(\"react.consumer\"), c = Symbol.for(\"react.context\"), l = Symbol.for(\"react.forward_ref\"), u = Symbol.for(\"react.suspense\"), p = Symbol.for(\"react.suspense_list\"), m = Symbol.for(\"react.memo\"), g = Symbol.for(\"react.lazy\"), x = Symbol.for(\"react.offscreen\"), y = Symbol.for(\"react.client.reference\");\n    Se.ContextConsumer = s, Se.ContextProvider = c, Se.Element = t, Se.ForwardRef = l, Se.Fragment = n, Se.Lazy = g, Se.Memo = m, Se.Portal = r, Se.Profiler = i, Se.StrictMode = o, Se.Suspense = u, Se.SuspenseList = p, Se.isContextConsumer = function(f) {\n      return e(f) === s;\n    }, Se.isContextProvider = function(f) {\n      return e(f) === c;\n    }, Se.isElement = function(f) {\n      return typeof f == \"object\" && f !== null && f.$$typeof === t;\n    }, Se.isForwardRef = function(f) {\n      return e(f) === l;\n    }, Se.isFragment = function(f) {\n      return e(f) === n;\n    }, Se.isLazy = function(f) {\n      return e(f) === g;\n    }, Se.isMemo = function(f) {\n      return e(f) === m;\n    }, Se.isPortal = function(f) {\n      return e(f) === r;\n    }, Se.isProfiler = function(f) {\n      return e(f) === i;\n    }, Se.isStrictMode = function(f) {\n      return e(f) === o;\n    }, Se.isSuspense = function(f) {\n      return e(f) === u;\n    }, Se.isSuspenseList = function(f) {\n      return e(f) === p;\n    }, Se.isValidElementType = function(f) {\n      return typeof f == \"string\" || typeof f == \"function\" || f === n || f === i || f === o || f === u || f === p || f === x || typeof f == \"object\" && f !== null && (f.$$typeof === g || f.$$typeof === m || f.$$typeof === c || f.$$typeof === s || f.$$typeof === l || f.$$typeof === y || f.getModuleId !== void 0);\n    }, Se.typeOf = e;\n  }()), Se;\n}\nvar ji;\nfunction gl() {\n  return ji || (ji = 1,  false ? 0 : Kr.exports = /* @__PURE__ */ hl()), Kr.exports;\n}\nvar pn = /* @__PURE__ */ gl();\nfunction gt(e) {\n  if (typeof e != \"object\" || e === null)\n    return !1;\n  const t = Object.getPrototypeOf(e);\n  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);\n}\nfunction Da(e) {\n  if (/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(e) || pn.isValidElementType(e) || !gt(e))\n    return e;\n  const t = {};\n  return Object.keys(e).forEach((r) => {\n    t[r] = Da(e[r]);\n  }), t;\n}\nfunction tt(e, t, r = {\n  clone: !0\n}) {\n  const n = r.clone ? {\n    ...e\n  } : e;\n  return gt(e) && gt(t) && Object.keys(t).forEach((o) => {\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(t[o]) || pn.isValidElementType(t[o]) ? n[o] = t[o] : gt(t[o]) && // Avoid prototype pollution\n    Object.prototype.hasOwnProperty.call(e, o) && gt(e[o]) ? n[o] = tt(e[o], t[o], r) : r.clone ? n[o] = gt(t[o]) ? Da(t[o]) : t[o] : n[o] = t[o];\n  }), n;\n}\nconst yl = (e) => {\n  const t = Object.keys(e).map((r) => ({\n    key: r,\n    val: e[r]\n  })) || [];\n  return t.sort((r, n) => r.val - n.val), t.reduce((r, n) => ({\n    ...r,\n    [n.key]: n.val\n  }), {});\n};\nfunction bl(e) {\n  const {\n    // The breakpoint **start** at this value.\n    // For instance with the first breakpoint xs: [xs, sm).\n    values: t = {\n      xs: 0,\n      // phone\n      sm: 600,\n      // tablet\n      md: 900,\n      // small laptop\n      lg: 1200,\n      // desktop\n      xl: 1536\n      // large screen\n    },\n    unit: r = \"px\",\n    step: n = 5,\n    ...o\n  } = e, i = yl(t), s = Object.keys(i);\n  function c(g) {\n    return `@media (min-width:${typeof t[g] == \"number\" ? t[g] : g}${r})`;\n  }\n  function l(g) {\n    return `@media (max-width:${(typeof t[g] == \"number\" ? t[g] : g) - n / 100}${r})`;\n  }\n  function u(g, x) {\n    const y = s.indexOf(x);\n    return `@media (min-width:${typeof t[g] == \"number\" ? t[g] : g}${r}) and (max-width:${(y !== -1 && typeof t[s[y]] == \"number\" ? t[s[y]] : x) - n / 100}${r})`;\n  }\n  function p(g) {\n    return s.indexOf(g) + 1 < s.length ? u(g, s[s.indexOf(g) + 1]) : c(g);\n  }\n  function m(g) {\n    const x = s.indexOf(g);\n    return x === 0 ? c(s[1]) : x === s.length - 1 ? l(s[x]) : u(g, s[s.indexOf(g) + 1]).replace(\"@media\", \"@media not all and\");\n  }\n  return {\n    keys: s,\n    values: i,\n    up: c,\n    down: l,\n    between: u,\n    only: p,\n    not: m,\n    unit: r,\n    ...o\n  };\n}\nfunction vl(e, t) {\n  if (!e.containerQueries)\n    return t;\n  const r = Object.keys(t).filter((n) => n.startsWith(\"@container\")).sort((n, o) => {\n    var s, c;\n    const i = /min-width:\\s*([0-9.]+)/;\n    return +(((s = n.match(i)) == null ? void 0 : s[1]) || 0) - +(((c = o.match(i)) == null ? void 0 : c[1]) || 0);\n  });\n  return r.length ? r.reduce((n, o) => {\n    const i = t[o];\n    return delete n[o], n[o] = i, n;\n  }, {\n    ...t\n  }) : t;\n}\nfunction xl(e, t) {\n  return t === \"@\" || t.startsWith(\"@\") && (e.some((r) => t.startsWith(`@${r}`)) || !!t.match(/^@\\d/));\n}\nfunction Sl(e, t) {\n  const r = t.match(/^@([^/]+)?\\/?(.+)?$/);\n  if (!r) {\n    if (true)\n      throw new Error( true ? `MUI: The provided shorthand ${`(${t})`} is invalid. The format should be \\`@<breakpoint | number>\\` or \\`@<breakpoint | number>/<container>\\`.\nFor example, \\`@sm\\` or \\`@600\\` or \\`@40rem/sidebar\\`.` : 0);\n    return null;\n  }\n  const [, n, o] = r, i = Number.isNaN(+n) ? n || 0 : +n;\n  return e.containerQueries(o).up(i);\n}\nfunction El(e) {\n  const t = (i, s) => i.replace(\"@media\", s ? `@container ${s}` : \"@container\");\n  function r(i, s) {\n    i.up = (...c) => t(e.breakpoints.up(...c), s), i.down = (...c) => t(e.breakpoints.down(...c), s), i.between = (...c) => t(e.breakpoints.between(...c), s), i.only = (...c) => t(e.breakpoints.only(...c), s), i.not = (...c) => {\n      const l = t(e.breakpoints.not(...c), s);\n      return l.includes(\"not all and\") ? l.replace(\"not all and \", \"\").replace(\"min-width:\", \"width<\").replace(\"max-width:\", \"width>\").replace(\"and\", \"or\") : l;\n    };\n  }\n  const n = {}, o = (i) => (r(n, i), n);\n  return r(o), {\n    ...e,\n    containerQueries: o\n  };\n}\nconst Cl = {\n  borderRadius: 4\n}, Mt =  true ? a.oneOfType([a.number, a.string, a.object, a.array]) : 0;\nfunction vr(e, t) {\n  return t ? tt(e, t, {\n    clone: !1\n    // No need to clone deep, it's way faster.\n  }) : e;\n}\nconst kn = {\n  xs: 0,\n  // phone\n  sm: 600,\n  // tablet\n  md: 900,\n  // small laptop\n  lg: 1200,\n  // desktop\n  xl: 1536\n  // large screen\n}, Di = {\n  // Sorted ASC by size. That's important.\n  // It can't be configured as it's used statically for propTypes.\n  keys: [\"xs\", \"sm\", \"md\", \"lg\", \"xl\"],\n  up: (e) => `@media (min-width:${kn[e]}px)`\n}, Tl = {\n  containerQueries: (e) => ({\n    up: (t) => {\n      let r = typeof t == \"number\" ? t : kn[t] || t;\n      return typeof r == \"number\" && (r = `${r}px`), e ? `@container ${e} (min-width:${r})` : `@container (min-width:${r})`;\n    }\n  })\n};\nfunction Ot(e, t, r) {\n  const n = e.theme || {};\n  if (Array.isArray(t)) {\n    const i = n.breakpoints || Di;\n    return t.reduce((s, c, l) => (s[i.up(i.keys[l])] = r(t[l]), s), {});\n  }\n  if (typeof t == \"object\") {\n    const i = n.breakpoints || Di;\n    return Object.keys(t).reduce((s, c) => {\n      if (xl(i.keys, c)) {\n        const l = Sl(n.containerQueries ? n : Tl, c);\n        l && (s[l] = r(t[c], c));\n      } else if (Object.keys(i.values || kn).includes(c)) {\n        const l = i.up(c);\n        s[l] = r(t[c], c);\n      } else {\n        const l = c;\n        s[l] = t[l];\n      }\n      return s;\n    }, {});\n  }\n  return r(t);\n}\nfunction wl(e = {}) {\n  var r;\n  return ((r = e.keys) == null ? void 0 : r.reduce((n, o) => {\n    const i = e.up(o);\n    return n[i] = {}, n;\n  }, {})) || {};\n}\nfunction Ol(e, t) {\n  return e.reduce((r, n) => {\n    const o = r[n];\n    return (!o || Object.keys(o).length === 0) && delete r[n], r;\n  }, t);\n}\nfunction ee(e) {\n  if (typeof e != \"string\")\n    throw new Error( true ? \"MUI: `capitalize(string)` expects a string argument.\" : 0);\n  return e.charAt(0).toUpperCase() + e.slice(1);\n}\nfunction An(e, t, r = !0) {\n  if (!t || typeof t != \"string\")\n    return null;\n  if (e && e.vars && r) {\n    const n = `vars.${t}`.split(\".\").reduce((o, i) => o && o[i] ? o[i] : null, e);\n    if (n != null)\n      return n;\n  }\n  return t.split(\".\").reduce((n, o) => n && n[o] != null ? n[o] : null, e);\n}\nfunction mn(e, t, r, n = r) {\n  let o;\n  return typeof e == \"function\" ? o = e(r) : Array.isArray(e) ? o = e[r] || n : o = An(e, r) || n, t && (o = t(o, n, e)), o;\n}\nfunction _e(e) {\n  const {\n    prop: t,\n    cssProperty: r = e.prop,\n    themeKey: n,\n    transform: o\n  } = e, i = (s) => {\n    if (s[t] == null)\n      return null;\n    const c = s[t], l = s.theme, u = An(l, n) || {};\n    return Ot(s, c, (m) => {\n      let g = mn(u, o, m);\n      return m === g && typeof m == \"string\" && (g = mn(u, o, `${t}${m === \"default\" ? \"\" : ee(m)}`, m)), r === !1 ? g : {\n        [r]: g\n      };\n    });\n  };\n  return i.propTypes =  true ? {\n    [t]: Mt\n  } : 0, i.filterProps = [t], i;\n}\nfunction Rl(e) {\n  const t = {};\n  return (r) => (t[r] === void 0 && (t[r] = e(r)), t[r]);\n}\nconst $l = {\n  m: \"margin\",\n  p: \"padding\"\n}, Pl = {\n  t: \"Top\",\n  r: \"Right\",\n  b: \"Bottom\",\n  l: \"Left\",\n  x: [\"Left\", \"Right\"],\n  y: [\"Top\", \"Bottom\"]\n}, Li = {\n  marginX: \"mx\",\n  marginY: \"my\",\n  paddingX: \"px\",\n  paddingY: \"py\"\n}, kl = Rl((e) => {\n  if (e.length > 2)\n    if (Li[e])\n      e = Li[e];\n    else\n      return [e];\n  const [t, r] = e.split(\"\"), n = $l[t], o = Pl[r] || \"\";\n  return Array.isArray(o) ? o.map((i) => n + i) : [n + o];\n}), Nn = [\"m\", \"mt\", \"mr\", \"mb\", \"ml\", \"mx\", \"my\", \"margin\", \"marginTop\", \"marginRight\", \"marginBottom\", \"marginLeft\", \"marginX\", \"marginY\", \"marginInline\", \"marginInlineStart\", \"marginInlineEnd\", \"marginBlock\", \"marginBlockStart\", \"marginBlockEnd\"], Mn = [\"p\", \"pt\", \"pr\", \"pb\", \"pl\", \"px\", \"py\", \"padding\", \"paddingTop\", \"paddingRight\", \"paddingBottom\", \"paddingLeft\", \"paddingX\", \"paddingY\", \"paddingInline\", \"paddingInlineStart\", \"paddingInlineEnd\", \"paddingBlock\", \"paddingBlockStart\", \"paddingBlockEnd\"], Al = [...Nn, ...Mn];\nfunction _r(e, t, r, n) {\n  const o = An(e, t, !0) ?? r;\n  return typeof o == \"number\" || typeof o == \"string\" ? (i) => typeof i == \"string\" ? i : ( true && typeof i != \"number\" && console.error(`MUI: Expected ${n} argument to be a number or a string, got ${i}.`), typeof o == \"string\" ? `calc(${i} * ${o})` : o * i) : Array.isArray(o) ? (i) => {\n    if (typeof i == \"string\")\n      return i;\n    const s = Math.abs(i);\n     true && (Number.isInteger(s) ? s > o.length - 1 && console.error([`MUI: The value provided (${s}) overflows.`, `The supported values are: ${JSON.stringify(o)}.`, `${s} > ${o.length - 1}, you need to add the missing values.`].join(`\n`)) : console.error([`MUI: The \\`theme.${t}\\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \\`theme.${t}\\` as a number.`].join(`\n`)));\n    const c = o[s];\n    return i >= 0 ? c : typeof c == \"number\" ? -c : `-${c}`;\n  } : typeof o == \"function\" ? o : ( true && console.error([`MUI: The \\`theme.${t}\\` value (${o}) is invalid.`, \"It should be a number, an array or a function.\"].join(`\n`)), () => {\n  });\n}\nfunction ko(e) {\n  return _r(e, \"spacing\", 8, \"spacing\");\n}\nfunction jr(e, t) {\n  return typeof t == \"string\" || t == null ? t : e(t);\n}\nfunction Nl(e, t) {\n  return (r) => e.reduce((n, o) => (n[o] = jr(t, r), n), {});\n}\nfunction Ml(e, t, r, n) {\n  if (!t.includes(r))\n    return null;\n  const o = kl(r), i = Nl(o, n), s = e[r];\n  return Ot(e, s, i);\n}\nfunction La(e, t) {\n  const r = ko(e.theme);\n  return Object.keys(e).map((n) => Ml(e, t, n, r)).reduce(vr, {});\n}\nfunction ke(e) {\n  return La(e, Nn);\n}\nke.propTypes =  true ? Nn.reduce((e, t) => (e[t] = Mt, e), {}) : 0;\nke.filterProps = Nn;\nfunction Ae(e) {\n  return La(e, Mn);\n}\nAe.propTypes =  true ? Mn.reduce((e, t) => (e[t] = Mt, e), {}) : 0;\nAe.filterProps = Mn;\n true && Al.reduce((e, t) => (e[t] = Mt, e), {});\nfunction Ba(e = 8, t = ko({\n  spacing: e\n})) {\n  if (e.mui)\n    return e;\n  const r = (...n) => ( true && (n.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${n.length}`)), (n.length === 0 ? [1] : n).map((i) => {\n    const s = t(i);\n    return typeof s == \"number\" ? `${s}px` : s;\n  }).join(\" \"));\n  return r.mui = !0, r;\n}\nfunction In(...e) {\n  const t = e.reduce((n, o) => (o.filterProps.forEach((i) => {\n    n[i] = o;\n  }), n), {}), r = (n) => Object.keys(n).reduce((o, i) => t[i] ? vr(o, t[i](n)) : o, {});\n  return r.propTypes =  true ? e.reduce((n, o) => Object.assign(n, o.propTypes), {}) : 0, r.filterProps = e.reduce((n, o) => n.concat(o.filterProps), []), r;\n}\nfunction ot(e) {\n  return typeof e != \"number\" ? e : `${e}px solid`;\n}\nfunction lt(e, t) {\n  return _e({\n    prop: e,\n    themeKey: \"borders\",\n    transform: t\n  });\n}\nconst Il = lt(\"border\", ot), _l = lt(\"borderTop\", ot), jl = lt(\"borderRight\", ot), Dl = lt(\"borderBottom\", ot), Ll = lt(\"borderLeft\", ot), Bl = lt(\"borderColor\"), Vl = lt(\"borderTopColor\"), Fl = lt(\"borderRightColor\"), zl = lt(\"borderBottomColor\"), Wl = lt(\"borderLeftColor\"), Ul = lt(\"outline\", ot), Yl = lt(\"outlineColor\"), _n = (e) => {\n  if (e.borderRadius !== void 0 && e.borderRadius !== null) {\n    const t = _r(e.theme, \"shape.borderRadius\", 4, \"borderRadius\"), r = (n) => ({\n      borderRadius: jr(t, n)\n    });\n    return Ot(e, e.borderRadius, r);\n  }\n  return null;\n};\n_n.propTypes =  true ? {\n  borderRadius: Mt\n} : 0;\n_n.filterProps = [\"borderRadius\"];\nIn(Il, _l, jl, Dl, Ll, Bl, Vl, Fl, zl, Wl, _n, Ul, Yl);\nconst jn = (e) => {\n  if (e.gap !== void 0 && e.gap !== null) {\n    const t = _r(e.theme, \"spacing\", 8, \"gap\"), r = (n) => ({\n      gap: jr(t, n)\n    });\n    return Ot(e, e.gap, r);\n  }\n  return null;\n};\njn.propTypes =  true ? {\n  gap: Mt\n} : 0;\njn.filterProps = [\"gap\"];\nconst Dn = (e) => {\n  if (e.columnGap !== void 0 && e.columnGap !== null) {\n    const t = _r(e.theme, \"spacing\", 8, \"columnGap\"), r = (n) => ({\n      columnGap: jr(t, n)\n    });\n    return Ot(e, e.columnGap, r);\n  }\n  return null;\n};\nDn.propTypes =  true ? {\n  columnGap: Mt\n} : 0;\nDn.filterProps = [\"columnGap\"];\nconst Ln = (e) => {\n  if (e.rowGap !== void 0 && e.rowGap !== null) {\n    const t = _r(e.theme, \"spacing\", 8, \"rowGap\"), r = (n) => ({\n      rowGap: jr(t, n)\n    });\n    return Ot(e, e.rowGap, r);\n  }\n  return null;\n};\nLn.propTypes =  true ? {\n  rowGap: Mt\n} : 0;\nLn.filterProps = [\"rowGap\"];\nconst Hl = _e({\n  prop: \"gridColumn\"\n}), ql = _e({\n  prop: \"gridRow\"\n}), Gl = _e({\n  prop: \"gridAutoFlow\"\n}), Kl = _e({\n  prop: \"gridAutoColumns\"\n}), Xl = _e({\n  prop: \"gridAutoRows\"\n}), Jl = _e({\n  prop: \"gridTemplateColumns\"\n}), Ql = _e({\n  prop: \"gridTemplateRows\"\n}), Zl = _e({\n  prop: \"gridTemplateAreas\"\n}), eu = _e({\n  prop: \"gridArea\"\n});\nIn(jn, Dn, Ln, Hl, ql, Gl, Kl, Xl, Jl, Ql, Zl, eu);\nfunction Jt(e, t) {\n  return t === \"grey\" ? t : e;\n}\nconst tu = _e({\n  prop: \"color\",\n  themeKey: \"palette\",\n  transform: Jt\n}), ru = _e({\n  prop: \"bgcolor\",\n  cssProperty: \"backgroundColor\",\n  themeKey: \"palette\",\n  transform: Jt\n}), nu = _e({\n  prop: \"backgroundColor\",\n  themeKey: \"palette\",\n  transform: Jt\n});\nIn(tu, ru, nu);\nfunction Ze(e) {\n  return e <= 1 && e !== 0 ? `${e * 100}%` : e;\n}\nconst ou = _e({\n  prop: \"width\",\n  transform: Ze\n}), Ao = (e) => {\n  if (e.maxWidth !== void 0 && e.maxWidth !== null) {\n    const t = (r) => {\n      var o, i, s, c, l;\n      const n = ((s = (i = (o = e.theme) == null ? void 0 : o.breakpoints) == null ? void 0 : i.values) == null ? void 0 : s[r]) || kn[r];\n      return n ? ((l = (c = e.theme) == null ? void 0 : c.breakpoints) == null ? void 0 : l.unit) !== \"px\" ? {\n        maxWidth: `${n}${e.theme.breakpoints.unit}`\n      } : {\n        maxWidth: n\n      } : {\n        maxWidth: Ze(r)\n      };\n    };\n    return Ot(e, e.maxWidth, t);\n  }\n  return null;\n};\nAo.filterProps = [\"maxWidth\"];\nconst iu = _e({\n  prop: \"minWidth\",\n  transform: Ze\n}), au = _e({\n  prop: \"height\",\n  transform: Ze\n}), su = _e({\n  prop: \"maxHeight\",\n  transform: Ze\n}), cu = _e({\n  prop: \"minHeight\",\n  transform: Ze\n});\n_e({\n  prop: \"size\",\n  cssProperty: \"width\",\n  transform: Ze\n});\n_e({\n  prop: \"size\",\n  cssProperty: \"height\",\n  transform: Ze\n});\nconst lu = _e({\n  prop: \"boxSizing\"\n});\nIn(ou, Ao, iu, au, su, cu, lu);\nconst Dr = {\n  // borders\n  border: {\n    themeKey: \"borders\",\n    transform: ot\n  },\n  borderTop: {\n    themeKey: \"borders\",\n    transform: ot\n  },\n  borderRight: {\n    themeKey: \"borders\",\n    transform: ot\n  },\n  borderBottom: {\n    themeKey: \"borders\",\n    transform: ot\n  },\n  borderLeft: {\n    themeKey: \"borders\",\n    transform: ot\n  },\n  borderColor: {\n    themeKey: \"palette\"\n  },\n  borderTopColor: {\n    themeKey: \"palette\"\n  },\n  borderRightColor: {\n    themeKey: \"palette\"\n  },\n  borderBottomColor: {\n    themeKey: \"palette\"\n  },\n  borderLeftColor: {\n    themeKey: \"palette\"\n  },\n  outline: {\n    themeKey: \"borders\",\n    transform: ot\n  },\n  outlineColor: {\n    themeKey: \"palette\"\n  },\n  borderRadius: {\n    themeKey: \"shape.borderRadius\",\n    style: _n\n  },\n  // palette\n  color: {\n    themeKey: \"palette\",\n    transform: Jt\n  },\n  bgcolor: {\n    themeKey: \"palette\",\n    cssProperty: \"backgroundColor\",\n    transform: Jt\n  },\n  backgroundColor: {\n    themeKey: \"palette\",\n    transform: Jt\n  },\n  // spacing\n  p: {\n    style: Ae\n  },\n  pt: {\n    style: Ae\n  },\n  pr: {\n    style: Ae\n  },\n  pb: {\n    style: Ae\n  },\n  pl: {\n    style: Ae\n  },\n  px: {\n    style: Ae\n  },\n  py: {\n    style: Ae\n  },\n  padding: {\n    style: Ae\n  },\n  paddingTop: {\n    style: Ae\n  },\n  paddingRight: {\n    style: Ae\n  },\n  paddingBottom: {\n    style: Ae\n  },\n  paddingLeft: {\n    style: Ae\n  },\n  paddingX: {\n    style: Ae\n  },\n  paddingY: {\n    style: Ae\n  },\n  paddingInline: {\n    style: Ae\n  },\n  paddingInlineStart: {\n    style: Ae\n  },\n  paddingInlineEnd: {\n    style: Ae\n  },\n  paddingBlock: {\n    style: Ae\n  },\n  paddingBlockStart: {\n    style: Ae\n  },\n  paddingBlockEnd: {\n    style: Ae\n  },\n  m: {\n    style: ke\n  },\n  mt: {\n    style: ke\n  },\n  mr: {\n    style: ke\n  },\n  mb: {\n    style: ke\n  },\n  ml: {\n    style: ke\n  },\n  mx: {\n    style: ke\n  },\n  my: {\n    style: ke\n  },\n  margin: {\n    style: ke\n  },\n  marginTop: {\n    style: ke\n  },\n  marginRight: {\n    style: ke\n  },\n  marginBottom: {\n    style: ke\n  },\n  marginLeft: {\n    style: ke\n  },\n  marginX: {\n    style: ke\n  },\n  marginY: {\n    style: ke\n  },\n  marginInline: {\n    style: ke\n  },\n  marginInlineStart: {\n    style: ke\n  },\n  marginInlineEnd: {\n    style: ke\n  },\n  marginBlock: {\n    style: ke\n  },\n  marginBlockStart: {\n    style: ke\n  },\n  marginBlockEnd: {\n    style: ke\n  },\n  // display\n  displayPrint: {\n    cssProperty: !1,\n    transform: (e) => ({\n      \"@media print\": {\n        display: e\n      }\n    })\n  },\n  display: {},\n  overflow: {},\n  textOverflow: {},\n  visibility: {},\n  whiteSpace: {},\n  // flexbox\n  flexBasis: {},\n  flexDirection: {},\n  flexWrap: {},\n  justifyContent: {},\n  alignItems: {},\n  alignContent: {},\n  order: {},\n  flex: {},\n  flexGrow: {},\n  flexShrink: {},\n  alignSelf: {},\n  justifyItems: {},\n  justifySelf: {},\n  // grid\n  gap: {\n    style: jn\n  },\n  rowGap: {\n    style: Ln\n  },\n  columnGap: {\n    style: Dn\n  },\n  gridColumn: {},\n  gridRow: {},\n  gridAutoFlow: {},\n  gridAutoColumns: {},\n  gridAutoRows: {},\n  gridTemplateColumns: {},\n  gridTemplateRows: {},\n  gridTemplateAreas: {},\n  gridArea: {},\n  // positions\n  position: {},\n  zIndex: {\n    themeKey: \"zIndex\"\n  },\n  top: {},\n  right: {},\n  bottom: {},\n  left: {},\n  // shadows\n  boxShadow: {\n    themeKey: \"shadows\"\n  },\n  // sizing\n  width: {\n    transform: Ze\n  },\n  maxWidth: {\n    style: Ao\n  },\n  minWidth: {\n    transform: Ze\n  },\n  height: {\n    transform: Ze\n  },\n  maxHeight: {\n    transform: Ze\n  },\n  minHeight: {\n    transform: Ze\n  },\n  boxSizing: {},\n  // typography\n  font: {\n    themeKey: \"font\"\n  },\n  fontFamily: {\n    themeKey: \"typography\"\n  },\n  fontSize: {\n    themeKey: \"typography\"\n  },\n  fontStyle: {\n    themeKey: \"typography\"\n  },\n  fontWeight: {\n    themeKey: \"typography\"\n  },\n  letterSpacing: {},\n  textTransform: {},\n  lineHeight: {},\n  textAlign: {},\n  typography: {\n    cssProperty: !1,\n    themeKey: \"typography\"\n  }\n};\nfunction uu(...e) {\n  const t = e.reduce((n, o) => n.concat(Object.keys(o)), []), r = new Set(t);\n  return e.every((n) => r.size === Object.keys(n).length);\n}\nfunction fu(e, t) {\n  return typeof e == \"function\" ? e(t) : e;\n}\nfunction du() {\n  function e(r, n, o, i) {\n    const s = {\n      [r]: n,\n      theme: o\n    }, c = i[r];\n    if (!c)\n      return {\n        [r]: n\n      };\n    const {\n      cssProperty: l = r,\n      themeKey: u,\n      transform: p,\n      style: m\n    } = c;\n    if (n == null)\n      return null;\n    if (u === \"typography\" && n === \"inherit\")\n      return {\n        [r]: n\n      };\n    const g = An(o, u) || {};\n    return m ? m(s) : Ot(s, n, (y) => {\n      let f = mn(g, p, y);\n      return y === f && typeof y == \"string\" && (f = mn(g, p, `${r}${y === \"default\" ? \"\" : ee(y)}`, y)), l === !1 ? f : {\n        [l]: f\n      };\n    });\n  }\n  function t(r) {\n    const {\n      sx: n,\n      theme: o = {}\n    } = r || {};\n    if (!n)\n      return null;\n    const i = o.unstable_sxConfig ?? Dr;\n    function s(c) {\n      let l = c;\n      if (typeof c == \"function\")\n        l = c(o);\n      else if (typeof c != \"object\")\n        return c;\n      if (!l)\n        return null;\n      const u = wl(o.breakpoints), p = Object.keys(u);\n      let m = u;\n      return Object.keys(l).forEach((g) => {\n        const x = fu(l[g], o);\n        if (x != null)\n          if (typeof x == \"object\")\n            if (i[g])\n              m = vr(m, e(g, x, o, i));\n            else {\n              const y = Ot({\n                theme: o\n              }, x, (f) => ({\n                [g]: f\n              }));\n              uu(y, x) ? m[g] = t({\n                sx: x,\n                theme: o\n              }) : m = vr(m, y);\n            }\n          else\n            m = vr(m, e(g, x, o, i));\n      }), vl(o, Ol(p, m));\n    }\n    return Array.isArray(n) ? n.map(s) : s(n);\n  }\n  return t;\n}\nconst At = du();\nAt.filterProps = [\"sx\"];\nfunction pu(e, t) {\n  var n;\n  const r = this;\n  if (r.vars) {\n    if (!((n = r.colorSchemes) != null && n[e]) || typeof r.getColorSchemeSelector != \"function\")\n      return {};\n    let o = r.getColorSchemeSelector(e);\n    return o === \"&\" ? t : ((o.includes(\"data-\") || o.includes(\".\")) && (o = `*:where(${o.replace(/\\s*&$/, \"\")}) &`), {\n      [o]: t\n    });\n  }\n  return r.palette.mode === e ? t : {};\n}\nfunction No(e = {}, ...t) {\n  const {\n    breakpoints: r = {},\n    palette: n = {},\n    spacing: o,\n    shape: i = {},\n    ...s\n  } = e, c = bl(r), l = Ba(o);\n  let u = tt({\n    breakpoints: c,\n    direction: \"ltr\",\n    components: {},\n    // Inject component definitions.\n    palette: {\n      mode: \"light\",\n      ...n\n    },\n    spacing: l,\n    shape: {\n      ...Cl,\n      ...i\n    }\n  }, s);\n  return u = El(u), u.applyStyles = pu, u = t.reduce((p, m) => tt(p, m), u), u.unstable_sxConfig = {\n    ...Dr,\n    ...s == null ? void 0 : s.unstable_sxConfig\n  }, u.unstable_sx = function(m) {\n    return At({\n      sx: m,\n      theme: this\n    });\n  }, u;\n}\nfunction mu(e) {\n  return Object.keys(e).length === 0;\n}\nfunction Va(e = null) {\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Mr);\n  return !t || mu(t) ? e : t;\n}\nconst hu = No();\nfunction Fa(e = hu) {\n  return Va(e);\n}\nconst gu = (e) => {\n  var n;\n  const t = {\n    systemProps: {},\n    otherProps: {}\n  }, r = ((n = e == null ? void 0 : e.theme) == null ? void 0 : n.unstable_sxConfig) ?? Dr;\n  return Object.keys(e).forEach((o) => {\n    r[o] ? t.systemProps[o] = e[o] : t.otherProps[o] = e[o];\n  }), t;\n};\nfunction za(e) {\n  const {\n    sx: t,\n    ...r\n  } = e, {\n    systemProps: n,\n    otherProps: o\n  } = gu(r);\n  let i;\n  return Array.isArray(t) ? i = [n, ...t] : typeof t == \"function\" ? i = (...s) => {\n    const c = t(...s);\n    return gt(c) ? {\n      ...n,\n      ...c\n    } : n;\n  } : i = {\n    ...n,\n    ...t\n  }, {\n    ...o,\n    sx: i\n  };\n}\nconst Bi = (e) => e, yu = () => {\n  let e = Bi;\n  return {\n    configure(t) {\n      e = t;\n    },\n    generate(t) {\n      return e(t);\n    },\n    reset() {\n      e = Bi;\n    }\n  };\n}, Wa = yu();\nfunction Ua(e) {\n  var t, r, n = \"\";\n  if (typeof e == \"string\" || typeof e == \"number\") n += e;\n  else if (typeof e == \"object\") if (Array.isArray(e)) {\n    var o = e.length;\n    for (t = 0; t < o; t++) e[t] && (r = Ua(e[t])) && (n && (n += \" \"), n += r);\n  } else for (r in e) e[r] && (n && (n += \" \"), n += r);\n  return n;\n}\nfunction se() {\n  for (var e, t, r = 0, n = \"\", o = arguments.length; r < o; r++) (e = arguments[r]) && (t = Ua(e)) && (n && (n += \" \"), n += t);\n  return n;\n}\nfunction bu(e = {}) {\n  const {\n    themeId: t,\n    defaultTheme: r,\n    defaultClassName: n = \"MuiBox-root\",\n    generateClassName: o\n  } = e, i = ja(\"div\", {\n    shouldForwardProp: (c) => c !== \"theme\" && c !== \"sx\" && c !== \"as\"\n  })(At);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(l, u) {\n    const p = Fa(r), {\n      className: m,\n      component: g = \"div\",\n      ...x\n    } = za(l);\n    return /* @__PURE__ */ N.jsx(i, {\n      as: g,\n      ref: u,\n      className: se(m, o ? o(n) : n),\n      theme: t && p[t] || p,\n      ...x\n    });\n  });\n}\nconst vu = {\n  active: \"active\",\n  checked: \"checked\",\n  completed: \"completed\",\n  disabled: \"disabled\",\n  error: \"error\",\n  expanded: \"expanded\",\n  focused: \"focused\",\n  focusVisible: \"focusVisible\",\n  open: \"open\",\n  readOnly: \"readOnly\",\n  required: \"required\",\n  selected: \"selected\"\n};\nfunction Ve(e, t, r = \"Mui\") {\n  const n = vu[t];\n  return n ? `${r}-${n}` : `${Wa.generate(e)}-${t}`;\n}\nfunction Fe(e, t, r = \"Mui\") {\n  const n = {};\n  return t.forEach((o) => {\n    n[o] = Ve(e, o, r);\n  }), n;\n}\nfunction Ya(e, t = \"\") {\n  return e.displayName || e.name || t;\n}\nfunction Vi(e, t, r) {\n  const n = Ya(t);\n  return e.displayName || (n !== \"\" ? `${r}(${n})` : r);\n}\nfunction xu(e) {\n  if (e != null) {\n    if (typeof e == \"string\")\n      return e;\n    if (typeof e == \"function\")\n      return Ya(e, \"Component\");\n    if (typeof e == \"object\")\n      switch (e.$$typeof) {\n        case pn.ForwardRef:\n          return Vi(e, e.render, \"ForwardRef\");\n        case pn.Memo:\n          return Vi(e, e.type, \"memo\");\n        default:\n          return;\n      }\n  }\n}\nfunction Ha(e) {\n  const {\n    variants: t,\n    ...r\n  } = e, n = {\n    variants: t,\n    style: Mi(r),\n    isProcessed: !0\n  };\n  return n.style === r || t && t.forEach((o) => {\n    typeof o.style != \"function\" && (o.style = Mi(o.style));\n  }), n;\n}\nconst Su = No();\nfunction Zn(e) {\n  return e !== \"ownerState\" && e !== \"theme\" && e !== \"sx\" && e !== \"as\";\n}\nfunction Eu(e) {\n  return e ? (t, r) => r[e] : null;\n}\nfunction Cu(e, t, r) {\n  e.theme = Ru(e.theme) ? r : e.theme[t] || e.theme;\n}\nfunction ln(e, t) {\n  const r = typeof t == \"function\" ? t(e) : t;\n  if (Array.isArray(r))\n    return r.flatMap((n) => ln(e, n));\n  if (Array.isArray(r == null ? void 0 : r.variants)) {\n    let n;\n    if (r.isProcessed)\n      n = r.style;\n    else {\n      const {\n        variants: o,\n        ...i\n      } = r;\n      n = i;\n    }\n    return qa(e, r.variants, [n]);\n  }\n  return r != null && r.isProcessed ? r.style : r;\n}\nfunction qa(e, t, r = []) {\n  var o;\n  let n;\n  e: for (let i = 0; i < t.length; i += 1) {\n    const s = t[i];\n    if (typeof s.props == \"function\") {\n      if (n ?? (n = {\n        ...e,\n        ...e.ownerState,\n        ownerState: e.ownerState\n      }), !s.props(n))\n        continue;\n    } else\n      for (const c in s.props)\n        if (e[c] !== s.props[c] && ((o = e.ownerState) == null ? void 0 : o[c]) !== s.props[c])\n          continue e;\n    typeof s.style == \"function\" ? (n ?? (n = {\n      ...e,\n      ...e.ownerState,\n      ownerState: e.ownerState\n    }), r.push(s.style(n))) : r.push(s.style);\n  }\n  return r;\n}\nfunction Tu(e = {}) {\n  const {\n    themeId: t,\n    defaultTheme: r = Su,\n    rootShouldForwardProp: n = Zn,\n    slotShouldForwardProp: o = Zn\n  } = e;\n  function i(c) {\n    Cu(c, t, r);\n  }\n  return (c, l = {}) => {\n    pl(c, (h) => h.filter((w) => w !== At));\n    const {\n      name: u,\n      slot: p,\n      skipVariantsResolver: m,\n      skipSx: g,\n      // TODO v6: remove `lowercaseFirstLetter()` in the next major release\n      // For more details: https://github.com/mui/material-ui/pull/37908\n      overridesResolver: x = Eu(Ga(p)),\n      ...y\n    } = l, f = m !== void 0 ? m : (\n      // TODO v6: remove `Root` in the next major release\n      // For more details: https://github.com/mui/material-ui/pull/37908\n      p && p !== \"Root\" && p !== \"root\" || !1\n    ), S = g || !1;\n    let E = Zn;\n    p === \"Root\" || p === \"root\" ? E = n : p ? E = o : $u(c) && (E = void 0);\n    const P = ja(c, {\n      shouldForwardProp: E,\n      label: Ou(u, p),\n      ...y\n    }), T = (h) => {\n      if (typeof h == \"function\" && h.__emotion_real !== h)\n        return function(k) {\n          return ln(k, h);\n        };\n      if (gt(h)) {\n        const w = Ha(h);\n        return w.variants ? function(L) {\n          return ln(L, w);\n        } : w.style;\n      }\n      return h;\n    }, b = (...h) => {\n      const w = [], k = h.map(T), L = [];\n      if (w.push(i), u && x && L.push(function(D) {\n        var U, V;\n        const W = (V = (U = D.theme.components) == null ? void 0 : U[u]) == null ? void 0 : V.styleOverrides;\n        if (!W)\n          return null;\n        const z = {};\n        for (const te in W)\n          z[te] = ln(D, W[te]);\n        return x(D, z);\n      }), u && !f && L.push(function(D) {\n        var z, U;\n        const j = D.theme, W = (U = (z = j == null ? void 0 : j.components) == null ? void 0 : z[u]) == null ? void 0 : U.variants;\n        return W ? qa(D, W) : null;\n      }), S || L.push(At), Array.isArray(k[0])) {\n        const A = k.shift(), D = new Array(w.length).fill(\"\"), j = new Array(L.length).fill(\"\");\n        let W;\n        W = [...D, ...A, ...j], W.raw = [...D, ...A.raw, ...j], w.unshift(W);\n      }\n      const B = [...w, ...k, ...L], d = P(...B);\n      return c.muiName && (d.muiName = c.muiName),  true && (d.displayName = wu(u, p, c)), d;\n    };\n    return P.withConfig && (b.withConfig = P.withConfig), b;\n  };\n}\nfunction wu(e, t, r) {\n  return e ? `${e}${ee(t || \"\")}` : `Styled(${xu(r)})`;\n}\nfunction Ou(e, t) {\n  let r;\n  return  true && e && (r = `${e}-${Ga(t || \"Root\")}`), r;\n}\nfunction Ru(e) {\n  for (const t in e)\n    return !1;\n  return !0;\n}\nfunction $u(e) {\n  return typeof e == \"string\" && // 96 is one less than the char code\n  // for \"a\" so this is checking that\n  // it's a lowercase character\n  e.charCodeAt(0) > 96;\n}\nfunction Ga(e) {\n  return e && e.charAt(0).toLowerCase() + e.slice(1);\n}\nfunction co(e, t) {\n  const r = {\n    ...t\n  };\n  for (const n in e)\n    if (Object.prototype.hasOwnProperty.call(e, n)) {\n      const o = n;\n      if (o === \"components\" || o === \"slots\")\n        r[o] = {\n          ...e[o],\n          ...r[o]\n        };\n      else if (o === \"componentsProps\" || o === \"slotProps\") {\n        const i = e[o], s = t[o];\n        if (!s)\n          r[o] = i || {};\n        else if (!i)\n          r[o] = s;\n        else {\n          r[o] = {\n            ...s\n          };\n          for (const c in i)\n            if (Object.prototype.hasOwnProperty.call(i, c)) {\n              const l = c;\n              r[o][l] = co(i[l], s[l]);\n            }\n        }\n      } else r[o] === void 0 && (r[o] = e[o]);\n    }\n  return r;\n}\nconst Ft = typeof window < \"u\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction Pu(e, t = Number.MIN_SAFE_INTEGER, r = Number.MAX_SAFE_INTEGER) {\n  return Math.max(t, Math.min(e, r));\n}\nfunction Mo(e, t = 0, r = 1) {\n  return  true && (e < t || e > r) && console.error(`MUI: The value provided ${e} is out of range [${t}, ${r}].`), Pu(e, t, r);\n}\nfunction ku(e) {\n  e = e.slice(1);\n  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, \"g\");\n  let r = e.match(t);\n  return r && r[0].length === 1 && (r = r.map((n) => n + n)),  true && e.length !== e.trim().length && console.error(`MUI: The color: \"${e}\" is invalid. Make sure the color input doesn't contain leading/trailing space.`), r ? `rgb${r.length === 4 ? \"a\" : \"\"}(${r.map((n, o) => o < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3).join(\", \")})` : \"\";\n}\nfunction Nt(e) {\n  if (e.type)\n    return e;\n  if (e.charAt(0) === \"#\")\n    return Nt(ku(e));\n  const t = e.indexOf(\"(\"), r = e.substring(0, t);\n  if (![\"rgb\", \"rgba\", \"hsl\", \"hsla\", \"color\"].includes(r))\n    throw new Error( true ? `MUI: Unsupported \\`${e}\\` color.\nThe following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : 0);\n  let n = e.substring(t + 1, e.length - 1), o;\n  if (r === \"color\") {\n    if (n = n.split(\" \"), o = n.shift(), n.length === 4 && n[3].charAt(0) === \"/\" && (n[3] = n[3].slice(1)), ![\"srgb\", \"display-p3\", \"a98-rgb\", \"prophoto-rgb\", \"rec-2020\"].includes(o))\n      throw new Error( true ? `MUI: unsupported \\`${o}\\` color space.\nThe following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : 0);\n  } else\n    n = n.split(\",\");\n  return n = n.map((i) => parseFloat(i)), {\n    type: r,\n    values: n,\n    colorSpace: o\n  };\n}\nconst Au = (e) => {\n  const t = Nt(e);\n  return t.values.slice(0, 3).map((r, n) => t.type.includes(\"hsl\") && n !== 0 ? `${r}%` : r).join(\" \");\n}, gr = (e, t) => {\n  try {\n    return Au(e);\n  } catch {\n    return t && \"development\" !== \"production\" && console.warn(t), e;\n  }\n};\nfunction Bn(e) {\n  const {\n    type: t,\n    colorSpace: r\n  } = e;\n  let {\n    values: n\n  } = e;\n  return t.includes(\"rgb\") ? n = n.map((o, i) => i < 3 ? parseInt(o, 10) : o) : t.includes(\"hsl\") && (n[1] = `${n[1]}%`, n[2] = `${n[2]}%`), t.includes(\"color\") ? n = `${r} ${n.join(\" \")}` : n = `${n.join(\", \")}`, `${t}(${n})`;\n}\nfunction Ka(e) {\n  e = Nt(e);\n  const {\n    values: t\n  } = e, r = t[0], n = t[1] / 100, o = t[2] / 100, i = n * Math.min(o, 1 - o), s = (u, p = (u + r / 30) % 12) => o - i * Math.max(Math.min(p - 3, 9 - p, 1), -1);\n  let c = \"rgb\";\n  const l = [Math.round(s(0) * 255), Math.round(s(8) * 255), Math.round(s(4) * 255)];\n  return e.type === \"hsla\" && (c += \"a\", l.push(t[3])), Bn({\n    type: c,\n    values: l\n  });\n}\nfunction lo(e) {\n  e = Nt(e);\n  let t = e.type === \"hsl\" || e.type === \"hsla\" ? Nt(Ka(e)).values : e.values;\n  return t = t.map((r) => (e.type !== \"color\" && (r /= 255), r <= 0.03928 ? r / 12.92 : ((r + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));\n}\nfunction Fi(e, t) {\n  const r = lo(e), n = lo(t);\n  return (Math.max(r, n) + 0.05) / (Math.min(r, n) + 0.05);\n}\nfunction De(e, t) {\n  return e = Nt(e), t = Mo(t), (e.type === \"rgb\" || e.type === \"hsl\") && (e.type += \"a\"), e.type === \"color\" ? e.values[3] = `/${t}` : e.values[3] = t, Bn(e);\n}\nfunction Xr(e, t, r) {\n  try {\n    return De(e, t);\n  } catch {\n    return e;\n  }\n}\nfunction Io(e, t) {\n  if (e = Nt(e), t = Mo(t), e.type.includes(\"hsl\"))\n    e.values[2] *= 1 - t;\n  else if (e.type.includes(\"rgb\") || e.type.includes(\"color\"))\n    for (let r = 0; r < 3; r += 1)\n      e.values[r] *= 1 - t;\n  return Bn(e);\n}\nfunction Ce(e, t, r) {\n  try {\n    return Io(e, t);\n  } catch {\n    return e;\n  }\n}\nfunction _o(e, t) {\n  if (e = Nt(e), t = Mo(t), e.type.includes(\"hsl\"))\n    e.values[2] += (100 - e.values[2]) * t;\n  else if (e.type.includes(\"rgb\"))\n    for (let r = 0; r < 3; r += 1)\n      e.values[r] += (255 - e.values[r]) * t;\n  else if (e.type.includes(\"color\"))\n    for (let r = 0; r < 3; r += 1)\n      e.values[r] += (1 - e.values[r]) * t;\n  return Bn(e);\n}\nfunction Te(e, t, r) {\n  try {\n    return _o(e, t);\n  } catch {\n    return e;\n  }\n}\nfunction Nu(e, t = 0.15) {\n  return lo(e) > 0.5 ? Io(e, t) : _o(e, t);\n}\nfunction Jr(e, t, r) {\n  try {\n    return Nu(e, t);\n  } catch {\n    return e;\n  }\n}\nfunction ar(e, t) {\n  return  false ? 0 : function(...n) {\n    return e(...n) || t(...n);\n  };\n}\nfunction Mu(e) {\n  const {\n    prototype: t = {}\n  } = e;\n  return !!t.isReactComponent;\n}\nfunction Xa(e, t, r, n, o) {\n  const i = e[t], s = o || t;\n  if (i == null || // When server-side rendering React doesn't warn either.\n  // This is not an accurate check for SSR.\n  // This is only in place for Emotion compat.\n  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.\n  typeof window > \"u\")\n    return null;\n  let c;\n  const l = i.type;\n  return typeof l == \"function\" && !Mu(l) && (c = \"Did you accidentally use a plain function component for an element instead?\"), c !== void 0 ? new Error(`Invalid ${n} \\`${s}\\` supplied to \\`${r}\\`. Expected an element that can hold a ref. ${c} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;\n}\nconst jo = ar(a.element, Xa);\njo.isRequired = ar(a.element.isRequired, Xa);\nfunction Iu(e) {\n  const {\n    prototype: t = {}\n  } = e;\n  return !!t.isReactComponent;\n}\nfunction _u(e, t, r, n, o) {\n  const i = e[t], s = o || t;\n  if (i == null || // When server-side rendering React doesn't warn either.\n  // This is not an accurate check for SSR.\n  // This is only in place for emotion compat.\n  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.\n  typeof window > \"u\")\n    return null;\n  let c;\n  return typeof i == \"function\" && !Iu(i) && (c = \"Did you accidentally provide a plain function component instead?\"), c !== void 0 ? new Error(`Invalid ${n} \\`${s}\\` supplied to \\`${r}\\`. Expected an element type that can hold a ref. ${c} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;\n}\nconst Ja = ar(a.elementType, _u), ju = \"exact-prop: \";\nfunction Do(e) {\n  return  false ? 0 : {\n    ...e,\n    [ju]: (t) => {\n      const r = Object.keys(t).filter((n) => !e.hasOwnProperty(n));\n      return r.length > 0 ? new Error(`The following props are not supported: ${r.map((n) => `\\`${n}\\``).join(\", \")}. Please remove them.`) : null;\n    }\n  };\n}\nfunction Or(e, t, r, n, o) {\n  if (false)\n    {}\n  const i = e[t], s = o || t;\n  return i == null ? null : i && i.nodeType !== 1 ? new Error(`Invalid ${n} \\`${s}\\` supplied to \\`${r}\\`. Expected an HTMLElement.`) : null;\n}\nconst Lo = a.oneOfType([a.func, a.object]);\nfunction zi(e) {\n  return e && e.ownerDocument || document;\n}\nfunction uo(e, t) {\n  typeof e == \"function\" ? e(t) : e && (e.current = t);\n}\nlet Wi = 0;\nfunction Du(e) {\n  const [t, r] = react__WEBPACK_IMPORTED_MODULE_0__.useState(e), n = e || t;\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    t == null && (Wi += 1, r(`mui-${Wi}`));\n  }, [t]), n;\n}\nconst Lu = {\n  .../*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))\n}, Ui = Lu.useId;\nfunction Qa(e) {\n  if (Ui !== void 0) {\n    const t = Ui();\n    return e ?? t;\n  }\n  return Du(e);\n}\nfunction Bu(e, t, r, n, o) {\n  if (false)\n    {}\n  const i = o || t;\n  return typeof e[t] < \"u\" ? new Error(`The prop \\`${i}\\` is not supported. Please remove it.`) : null;\n}\nfunction Vu({\n  controlled: e,\n  default: t,\n  name: r,\n  state: n = \"value\"\n}) {\n  const {\n    current: o\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useRef(e !== void 0), [i, s] = react__WEBPACK_IMPORTED_MODULE_0__.useState(t), c = o ? e : i;\n  if (true) {\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      o !== (e !== void 0) && console.error([`MUI: A component is changing the ${o ? \"\" : \"un\"}controlled ${n} state of ${r} to be ${o ? \"un\" : \"\"}controlled.`, \"Elements should not switch from uncontrolled to controlled (or vice versa).\", `Decide between using a controlled or uncontrolled ${r} element for the lifetime of the component.`, \"The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.\", \"More info: https://fb.me/react-controlled-components\"].join(`\n`));\n    }, [n, r, e]);\n    const {\n      current: u\n    } = react__WEBPACK_IMPORTED_MODULE_0__.useRef(t);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      !o && !Object.is(u, t) && console.error([`MUI: A component is changing the default ${n} state of an uncontrolled ${r} after being initialized. To suppress this warning opt to use a controlled ${r}.`].join(`\n`));\n    }, [JSON.stringify(t)]);\n  }\n  const l = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((u) => {\n    o || s(u);\n  }, []);\n  return [c, l];\n}\nfunction Qt(e) {\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useRef(e);\n  return Ft(() => {\n    t.current = e;\n  }), react__WEBPACK_IMPORTED_MODULE_0__.useRef((...r) => (\n    // @ts-expect-error hide `this`\n    (0, t.current)(...r)\n  )).current;\n}\nfunction at(...e) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => e.every((t) => t == null) ? null : (t) => {\n    e.forEach((r) => {\n      uo(r, t);\n    });\n  }, e);\n}\nconst Yi = {};\nfunction Za(e, t) {\n  const r = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Yi);\n  return r.current === Yi && (r.current = e(t)), r;\n}\nconst Fu = [];\nfunction zu(e) {\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(e, Fu);\n}\nclass Vn {\n  constructor() {\n    cr(this, \"currentId\", null);\n    cr(this, \"clear\", () => {\n      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);\n    });\n    cr(this, \"disposeEffect\", () => this.clear);\n  }\n  static create() {\n    return new Vn();\n  }\n  /**\n   * Executes `fn` after `delay`, clearing any previously scheduled call.\n   */\n  start(t, r) {\n    this.clear(), this.currentId = setTimeout(() => {\n      this.currentId = null, r();\n    }, t);\n  }\n}\nfunction Dt() {\n  const e = Za(Vn.create).current;\n  return zu(e.disposeEffect), e;\n}\nfunction hn(e) {\n  try {\n    return e.matches(\":focus-visible\");\n  } catch {\n     true && !/jsdom/.test(window.navigator.userAgent) && console.warn([\"MUI: The `:focus-visible` pseudo class is not supported in this browser.\", \"Some components rely on this feature to work properly.\"].join(`\n`));\n  }\n  return !1;\n}\nfunction Ge(e, t, r = void 0) {\n  const n = {};\n  for (const o in e) {\n    const i = e[o];\n    let s = \"\", c = !0;\n    for (let l = 0; l < i.length; l += 1) {\n      const u = i[l];\n      u && (s += (c === !0 ? \"\" : \" \") + t(u), c = !1, r && r[u] && (s += \" \" + r[u]));\n    }\n    n[o] = s;\n  }\n  return n;\n}\nfunction Wu(e) {\n  return typeof e == \"string\";\n}\nfunction es(e, t, r) {\n  return e === void 0 || Wu(e) ? t : {\n    ...t,\n    ownerState: {\n      ...t.ownerState,\n      ...r\n    }\n  };\n}\nfunction Uu(e, t = []) {\n  if (e === void 0)\n    return {};\n  const r = {};\n  return Object.keys(e).filter((n) => n.match(/^on[A-Z]/) && typeof e[n] == \"function\" && !t.includes(n)).forEach((n) => {\n    r[n] = e[n];\n  }), r;\n}\nfunction Hi(e) {\n  if (e === void 0)\n    return {};\n  const t = {};\n  return Object.keys(e).filter((r) => !(r.match(/^on[A-Z]/) && typeof e[r] == \"function\")).forEach((r) => {\n    t[r] = e[r];\n  }), t;\n}\nfunction ts(e) {\n  const {\n    getSlotProps: t,\n    additionalProps: r,\n    externalSlotProps: n,\n    externalForwardedProps: o,\n    className: i\n  } = e;\n  if (!t) {\n    const x = se(r == null ? void 0 : r.className, i, o == null ? void 0 : o.className, n == null ? void 0 : n.className), y = {\n      ...r == null ? void 0 : r.style,\n      ...o == null ? void 0 : o.style,\n      ...n == null ? void 0 : n.style\n    }, f = {\n      ...r,\n      ...o,\n      ...n\n    };\n    return x.length > 0 && (f.className = x), Object.keys(y).length > 0 && (f.style = y), {\n      props: f,\n      internalRef: void 0\n    };\n  }\n  const s = Uu({\n    ...o,\n    ...n\n  }), c = Hi(n), l = Hi(o), u = t(s), p = se(u == null ? void 0 : u.className, r == null ? void 0 : r.className, i, o == null ? void 0 : o.className, n == null ? void 0 : n.className), m = {\n    ...u == null ? void 0 : u.style,\n    ...r == null ? void 0 : r.style,\n    ...o == null ? void 0 : o.style,\n    ...n == null ? void 0 : n.style\n  }, g = {\n    ...u,\n    ...r,\n    ...l,\n    ...c\n  };\n  return p.length > 0 && (g.className = p), Object.keys(m).length > 0 && (g.style = m), {\n    props: g,\n    internalRef: u.ref\n  };\n}\nfunction rs(e, t, r) {\n  return typeof e == \"function\" ? e(t, r) : e;\n}\nfunction Yu(e) {\n  var m;\n  const {\n    elementType: t,\n    externalSlotProps: r,\n    ownerState: n,\n    skipResolvingSlotProps: o = !1,\n    ...i\n  } = e, s = o ? {} : rs(r, n), {\n    props: c,\n    internalRef: l\n  } = ts({\n    ...i,\n    externalSlotProps: s\n  }), u = at(l, s == null ? void 0 : s.ref, (m = e.additionalProps) == null ? void 0 : m.ref);\n  return es(t, {\n    ...c,\n    ref: u\n  }, n);\n}\nfunction Bo(e) {\n  var t;\n  return parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version, 10) >= 19 ? ((t = e == null ? void 0 : e.props) == null ? void 0 : t.ref) || null : (e == null ? void 0 : e.ref) || null;\n}\nconst Vo = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n true && (Vo.displayName = \"ThemeContext\");\nfunction Fo() {\n  const e = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Vo);\n  return  true && react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(e), e;\n}\nconst Hu = typeof Symbol == \"function\" && Symbol.for, qu = Hu ? Symbol.for(\"mui.nested\") : \"__THEME_NESTED__\";\nfunction Gu(e, t) {\n  if (typeof t == \"function\") {\n    const r = t(e);\n    return  true && (r || console.error([\"MUI: You should return an object from your theme function, i.e.\", \"<ThemeProvider theme={() => ({})} />\"].join(`\n`))), r;\n  }\n  return {\n    ...e,\n    ...t\n  };\n}\nfunction gn(e) {\n  const {\n    children: t,\n    theme: r\n  } = e, n = Fo();\n   true && n === null && typeof r == \"function\" && console.error([\"MUI: You are providing a theme function prop to the ThemeProvider component:\", \"<ThemeProvider theme={outerTheme => outerTheme} />\", \"\", \"However, no outer theme is present.\", \"Make sure a theme is already injected higher in the React tree or provide a theme object.\"].join(`\n`));\n  const o = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const i = n === null ? {\n      ...r\n    } : Gu(n, r);\n    return i != null && (i[qu] = n !== null), i;\n  }, [r, n]);\n  return /* @__PURE__ */ N.jsx(Vo.Provider, {\n    value: o,\n    children: t\n  });\n}\n true && (gn.propTypes = {\n  /**\n   * Your component tree.\n   */\n  children: a.node,\n  /**\n   * A theme object. You can provide a function to extend the outer theme.\n   */\n  theme: a.oneOfType([a.object, a.func]).isRequired\n});\n true && (gn.propTypes = Do(gn.propTypes));\nconst ns = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext();\nfunction os({\n  value: e,\n  ...t\n}) {\n  return /* @__PURE__ */ N.jsx(ns.Provider, {\n    value: e ?? !0,\n    ...t\n  });\n}\n true && (os.propTypes = {\n  children: a.node,\n  value: a.bool\n});\nconst is = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(ns) ?? !1, as = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nfunction ss({\n  value: e,\n  children: t\n}) {\n  return /* @__PURE__ */ N.jsx(as.Provider, {\n    value: e,\n    children: t\n  });\n}\n true && (ss.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //  To update them, edit the TypeScript types and run `pnpm proptypes`. \n  // \n  /**\n   * @ignore\n   */\n  children: a.node,\n  /**\n   * @ignore\n   */\n  value: a.object\n});\nfunction Ku(e) {\n  const {\n    theme: t,\n    name: r,\n    props: n\n  } = e;\n  if (!t || !t.components || !t.components[r])\n    return n;\n  const o = t.components[r];\n  return o.defaultProps ? co(o.defaultProps, n) : !o.styleOverrides && !o.variants ? co(o, n) : n;\n}\nfunction Xu({\n  props: e,\n  name: t\n}) {\n  const r = react__WEBPACK_IMPORTED_MODULE_0__.useContext(as);\n  return Ku({\n    props: e,\n    name: t,\n    theme: {\n      components: r\n    }\n  });\n}\nconst qi = {};\nfunction Gi(e, t, r, n = !1) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const o = e && t[e] || t;\n    if (typeof r == \"function\") {\n      const i = r(o), s = e ? {\n        ...t,\n        [e]: i\n      } : i;\n      return n ? () => s : s;\n    }\n    return e ? {\n      ...t,\n      [e]: r\n    } : {\n      ...t,\n      ...r\n    };\n  }, [e, t, r, n]);\n}\nfunction Rr(e) {\n  const {\n    children: t,\n    theme: r,\n    themeId: n\n  } = e, o = Va(qi), i = Fo() || qi;\n   true && (o === null && typeof r == \"function\" || n && o && !o[n] && typeof r == \"function\") && console.error([\"MUI: You are providing a theme function prop to the ThemeProvider component:\", \"<ThemeProvider theme={outerTheme => outerTheme} />\", \"\", \"However, no outer theme is present.\", \"Make sure a theme is already injected higher in the React tree or provide a theme object.\"].join(`\n`));\n  const s = Gi(n, o, r), c = Gi(n, i, r, !0), l = (n ? s[n] : s).direction === \"rtl\";\n  return /* @__PURE__ */ N.jsx(gn, {\n    theme: c,\n    children: /* @__PURE__ */ N.jsx(Mr.Provider, {\n      value: s,\n      children: /* @__PURE__ */ N.jsx(os, {\n        value: l,\n        children: /* @__PURE__ */ N.jsx(ss, {\n          value: n ? s[n].components : s.components,\n          children: t\n        })\n      })\n    })\n  });\n}\n true && (Rr.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Your component tree.\n   */\n  children: a.node,\n  /**\n   * A theme object. You can provide a function to extend the outer theme.\n   */\n  theme: a.oneOfType([a.func, a.object]).isRequired,\n  /**\n   * The design system's unique id for getting the corresponded theme when there are multiple design systems.\n   */\n  themeId: a.string\n});\n true && (Rr.propTypes = Do(Rr.propTypes));\nconst Ki = {\n  theme: void 0\n};\nfunction Ju(e) {\n  let t, r;\n  return function(o) {\n    let i = t;\n    return (i === void 0 || o.theme !== r) && (Ki.theme = o.theme, i = Ha(e(Ki)), t = i, r = o.theme), i;\n  };\n}\nconst zo = \"mode\", Wo = \"color-scheme\", Qu = \"data-color-scheme\";\nfunction Zu(e) {\n  const {\n    defaultMode: t = \"system\",\n    defaultLightColorScheme: r = \"light\",\n    defaultDarkColorScheme: n = \"dark\",\n    modeStorageKey: o = zo,\n    colorSchemeStorageKey: i = Wo,\n    attribute: s = Qu,\n    colorSchemeNode: c = \"document.documentElement\",\n    nonce: l\n  } = e;\n  let u = \"\", p = s;\n  if (s === \"class\" && (p = \".%s\"), s === \"data\" && (p = \"[data-%s]\"), p.startsWith(\".\")) {\n    const g = p.substring(1);\n    u += `${c}.classList.remove('${g}'.replace('%s', light), '${g}'.replace('%s', dark));\n      ${c}.classList.add('${g}'.replace('%s', colorScheme));`;\n  }\n  const m = p.match(/\\[([^\\]]+)\\]/);\n  if (m) {\n    const [g, x] = m[1].split(\"=\");\n    x || (u += `${c}.removeAttribute('${g}'.replace('%s', light));\n      ${c}.removeAttribute('${g}'.replace('%s', dark));`), u += `\n      ${c}.setAttribute('${g}'.replace('%s', colorScheme), ${x ? `${x}.replace('%s', colorScheme)` : '\"\"'});`;\n  } else\n    u += `${c}.setAttribute('${p}', colorScheme);`;\n  return /* @__PURE__ */ N.jsx(\"script\", {\n    suppressHydrationWarning: !0,\n    nonce: typeof window > \"u\" ? l : \"\",\n    dangerouslySetInnerHTML: {\n      __html: `(function() {\ntry {\n  let colorScheme = '';\n  const mode = localStorage.getItem('${o}') || '${t}';\n  const dark = localStorage.getItem('${i}-dark') || '${n}';\n  const light = localStorage.getItem('${i}-light') || '${r}';\n  if (mode === 'system') {\n    // handle system mode\n    const mql = window.matchMedia('(prefers-color-scheme: dark)');\n    if (mql.matches) {\n      colorScheme = dark\n    } else {\n      colorScheme = light\n    }\n  }\n  if (mode === 'light') {\n    colorScheme = light;\n  }\n  if (mode === 'dark') {\n    colorScheme = dark;\n  }\n  if (colorScheme) {\n    ${u}\n  }\n} catch(e){}})();`\n    }\n  }, \"mui-color-scheme-init\");\n}\nfunction Xi(e) {\n  if (typeof window < \"u\" && typeof window.matchMedia == \"function\" && e === \"system\")\n    return window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n}\nfunction cs(e, t) {\n  if (e.mode === \"light\" || e.mode === \"system\" && e.systemMode === \"light\")\n    return t(\"light\");\n  if (e.mode === \"dark\" || e.mode === \"system\" && e.systemMode === \"dark\")\n    return t(\"dark\");\n}\nfunction ef(e) {\n  return cs(e, (t) => {\n    if (t === \"light\")\n      return e.lightColorScheme;\n    if (t === \"dark\")\n      return e.darkColorScheme;\n  });\n}\nfunction eo(e, t) {\n  if (typeof window > \"u\")\n    return;\n  let r;\n  try {\n    r = localStorage.getItem(e) || void 0, r || localStorage.setItem(e, t);\n  } catch {\n  }\n  return r || t;\n}\nfunction tf(e) {\n  const {\n    defaultMode: t = \"light\",\n    defaultLightColorScheme: r,\n    defaultDarkColorScheme: n,\n    supportedColorSchemes: o = [],\n    modeStorageKey: i = zo,\n    colorSchemeStorageKey: s = Wo,\n    storageWindow: c = typeof window > \"u\" ? void 0 : window,\n    noSsr: l = !1\n  } = e, u = o.join(\",\"), p = o.length > 1, [m, g] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {\n    const b = eo(i, t), h = eo(`${s}-light`, r), w = eo(`${s}-dark`, n);\n    return {\n      mode: b,\n      systemMode: Xi(b),\n      lightColorScheme: h,\n      darkColorScheme: w\n    };\n  }), [x, y] = react__WEBPACK_IMPORTED_MODULE_0__.useState(l || !p);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    y(!0);\n  }, []);\n  const f = ef(m), S = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((b) => {\n    g((h) => {\n      if (b === h.mode)\n        return h;\n      const w = b ?? t;\n      try {\n        localStorage.setItem(i, w);\n      } catch {\n      }\n      return {\n        ...h,\n        mode: w,\n        systemMode: Xi(w)\n      };\n    });\n  }, [i, t]), E = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((b) => {\n    b ? typeof b == \"string\" ? b && !u.includes(b) ? console.error(`\\`${b}\\` does not exist in \\`theme.colorSchemes\\`.`) : g((h) => {\n      const w = {\n        ...h\n      };\n      return cs(h, (k) => {\n        try {\n          localStorage.setItem(`${s}-${k}`, b);\n        } catch {\n        }\n        k === \"light\" && (w.lightColorScheme = b), k === \"dark\" && (w.darkColorScheme = b);\n      }), w;\n    }) : g((h) => {\n      const w = {\n        ...h\n      }, k = b.light === null ? r : b.light, L = b.dark === null ? n : b.dark;\n      if (k)\n        if (!u.includes(k))\n          console.error(`\\`${k}\\` does not exist in \\`theme.colorSchemes\\`.`);\n        else {\n          w.lightColorScheme = k;\n          try {\n            localStorage.setItem(`${s}-light`, k);\n          } catch {\n          }\n        }\n      if (L)\n        if (!u.includes(L))\n          console.error(`\\`${L}\\` does not exist in \\`theme.colorSchemes\\`.`);\n        else {\n          w.darkColorScheme = L;\n          try {\n            localStorage.setItem(`${s}-dark`, L);\n          } catch {\n          }\n        }\n      return w;\n    }) : g((h) => {\n      try {\n        localStorage.setItem(`${s}-light`, r), localStorage.setItem(`${s}-dark`, n);\n      } catch {\n      }\n      return {\n        ...h,\n        lightColorScheme: r,\n        darkColorScheme: n\n      };\n    });\n  }, [u, s, r, n]), P = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((b) => {\n    m.mode === \"system\" && g((h) => {\n      const w = b != null && b.matches ? \"dark\" : \"light\";\n      return h.systemMode === w ? h : {\n        ...h,\n        systemMode: w\n      };\n    });\n  }, [m.mode]), T = react__WEBPACK_IMPORTED_MODULE_0__.useRef(P);\n  return T.current = P, react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (typeof window.matchMedia != \"function\" || !p)\n      return;\n    const b = (...w) => T.current(...w), h = window.matchMedia(\"(prefers-color-scheme: dark)\");\n    return h.addListener(b), b(h), () => {\n      h.removeListener(b);\n    };\n  }, [p]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (c && p) {\n      const b = (h) => {\n        const w = h.newValue;\n        typeof h.key == \"string\" && h.key.startsWith(s) && (!w || u.match(w)) && (h.key.endsWith(\"light\") && E({\n          light: w\n        }), h.key.endsWith(\"dark\") && E({\n          dark: w\n        })), h.key === i && (!w || [\"light\", \"dark\", \"system\"].includes(w)) && S(w || t);\n      };\n      return c.addEventListener(\"storage\", b), () => {\n        c.removeEventListener(\"storage\", b);\n      };\n    }\n  }, [E, S, i, s, u, t, c, p]), {\n    ...m,\n    mode: x ? m.mode : void 0,\n    systemMode: x ? m.systemMode : void 0,\n    colorScheme: x ? f : void 0,\n    setMode: S,\n    setColorScheme: E\n  };\n}\nconst rf = \"*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\nfunction nf(e) {\n  const {\n    themeId: t,\n    /**\n     * This `theme` object needs to follow a certain structure to\n     * be used correctly by the finel `CssVarsProvider`. It should have a\n     * `colorSchemes` key with the light and dark (and any other) palette.\n     * It should also ideally have a vars object created using `prepareCssVars`.\n     */\n    theme: r = {},\n    modeStorageKey: n = zo,\n    colorSchemeStorageKey: o = Wo,\n    disableTransitionOnChange: i = !1,\n    defaultColorScheme: s,\n    resolveTheme: c\n  } = e, l = {\n    allColorSchemes: [],\n    colorScheme: void 0,\n    darkColorScheme: void 0,\n    lightColorScheme: void 0,\n    mode: void 0,\n    setColorScheme: () => {\n    },\n    setMode: () => {\n    },\n    systemMode: void 0\n  }, u = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\n   true && (u.displayName = \"ColorSchemeContext\");\n  const p = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(u) || l, m = {}, g = {};\n  function x(E) {\n    var Y, oe, Re, ue;\n    const {\n      children: P,\n      theme: T,\n      modeStorageKey: b = n,\n      colorSchemeStorageKey: h = o,\n      disableTransitionOnChange: w = i,\n      storageWindow: k = typeof window > \"u\" ? void 0 : window,\n      documentNode: L = typeof document > \"u\" ? void 0 : document,\n      colorSchemeNode: B = typeof document > \"u\" ? void 0 : document.documentElement,\n      disableNestedContext: d = !1,\n      disableStyleSheetGeneration: A = !1,\n      defaultMode: D = \"system\",\n      noSsr: j\n    } = E, W = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!1), z = Fo(), U = react__WEBPACK_IMPORTED_MODULE_0__.useContext(u), V = !!U && !d, te = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => T || (typeof r == \"function\" ? r() : r), [T]), F = te[t], R = F || te, {\n      colorSchemes: I = m,\n      components: J = g,\n      cssVarPrefix: Q\n    } = R, H = Object.keys(I).filter((K) => !!I[K]).join(\",\"), X = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => H.split(\",\"), [H]), _ = typeof s == \"string\" ? s : s.light, q = typeof s == \"string\" ? s : s.dark, G = I[_] && I[q] ? D : ((oe = (Y = I[R.defaultColorScheme]) == null ? void 0 : Y.palette) == null ? void 0 : oe.mode) || ((Re = R.palette) == null ? void 0 : Re.mode), {\n      mode: re,\n      setMode: Z,\n      systemMode: ae,\n      lightColorScheme: O,\n      darkColorScheme: ye,\n      colorScheme: Ee,\n      setColorScheme: Me\n    } = tf({\n      supportedColorSchemes: X,\n      defaultLightColorScheme: _,\n      defaultDarkColorScheme: q,\n      modeStorageKey: b,\n      colorSchemeStorageKey: h,\n      defaultMode: G,\n      storageWindow: k,\n      noSsr: j\n    });\n    let Qe = re, ve = Ee;\n    V && (Qe = U.mode, ve = U.colorScheme);\n    const Pe = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n      var Oe;\n      const K = ve || R.defaultColorScheme, be = ((Oe = R.generateThemeVars) == null ? void 0 : Oe.call(R)) || R.vars, we = {\n        ...R,\n        components: J,\n        colorSchemes: I,\n        cssVarPrefix: Q,\n        vars: be\n      };\n      if (typeof we.generateSpacing == \"function\" && (we.spacing = we.generateSpacing()), K) {\n        const ce = I[K];\n        ce && typeof ce == \"object\" && Object.keys(ce).forEach((Ie) => {\n          ce[Ie] && typeof ce[Ie] == \"object\" ? we[Ie] = {\n            ...we[Ie],\n            ...ce[Ie]\n          } : we[Ie] = ce[Ie];\n        });\n      }\n      return c ? c(we) : we;\n    }, [R, ve, J, I, Q]), ze = R.colorSchemeSelector;\n    Ft(() => {\n      if (ve && B && ze && ze !== \"media\") {\n        const K = ze;\n        let be = ze;\n        if (K === \"class\" && (be = \".%s\"), K === \"data\" && (be = \"[data-%s]\"), K != null && K.startsWith(\"data-\") && !K.includes(\"%s\") && (be = `[${K}=\"%s\"]`), be.startsWith(\".\"))\n          B.classList.remove(...X.map((we) => be.substring(1).replace(\"%s\", we))), B.classList.add(be.substring(1).replace(\"%s\", ve));\n        else {\n          const we = be.replace(\"%s\", ve).match(/\\[([^\\]]+)\\]/);\n          if (we) {\n            const [Oe, ce] = we[1].split(\"=\");\n            ce || X.forEach((Ie) => {\n              B.removeAttribute(Oe.replace(ve, Ie));\n            }), B.setAttribute(Oe, ce ? ce.replace(/\"|'/g, \"\") : \"\");\n          } else\n            B.setAttribute(be, ve);\n        }\n      }\n    }, [ve, ze, B, X]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      let K;\n      if (w && W.current && L) {\n        const be = L.createElement(\"style\");\n        be.appendChild(L.createTextNode(rf)), L.head.appendChild(be), window.getComputedStyle(L.body), K = setTimeout(() => {\n          L.head.removeChild(be);\n        }, 1);\n      }\n      return () => {\n        clearTimeout(K);\n      };\n    }, [ve, w, L]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => (W.current = !0, () => {\n      W.current = !1;\n    }), []);\n    const Le = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      allColorSchemes: X,\n      colorScheme: ve,\n      darkColorScheme: ye,\n      lightColorScheme: O,\n      mode: Qe,\n      setColorScheme: Me,\n      setMode:  false ? 0 : (K) => {\n        Pe.colorSchemeSelector === \"media\" && console.error([\"MUI: The `setMode` function has no effect if `colorSchemeSelector` is `media` (`media` is the default value).\", \"To toggle the mode manually, please configure `colorSchemeSelector` to use a class or data attribute.\", \"To learn more, visit https://mui.com/material-ui/customization/css-theme-variables/configuration/#toggling-dark-mode-manually\"].join(`\n`)), Z(K);\n      },\n      systemMode: ae\n    }), [X, ve, ye, O, Qe, Me, Z, ae, Pe.colorSchemeSelector]);\n    let v = !0;\n    (A || R.cssVariables === !1 || V && (z == null ? void 0 : z.cssVarPrefix) === Q) && (v = !1);\n    const M = /* @__PURE__ */ N.jsxs(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n      children: [/* @__PURE__ */ N.jsx(Rr, {\n        themeId: F ? t : void 0,\n        theme: Pe,\n        children: P\n      }), v && /* @__PURE__ */ N.jsx(_a, {\n        styles: ((ue = Pe.generateStyleSheets) == null ? void 0 : ue.call(Pe)) || []\n      })]\n    });\n    return V ? M : /* @__PURE__ */ N.jsx(u.Provider, {\n      value: Le,\n      children: M\n    });\n  }\n   true && (x.propTypes = {\n    /**\n     * The component tree.\n     */\n    children: a.node,\n    /**\n     * The node used to attach the color-scheme attribute\n     */\n    colorSchemeNode: a.any,\n    /**\n     * localStorage key used to store `colorScheme`\n     */\n    colorSchemeStorageKey: a.string,\n    /**\n     * The default mode when the storage is empty,\n     * require the theme to have `colorSchemes` with light and dark.\n     */\n    defaultMode: a.string,\n    /**\n     * If `true`, the provider creates its own context and generate stylesheet as if it is a root `CssVarsProvider`.\n     */\n    disableNestedContext: a.bool,\n    /**\n     * If `true`, the style sheet won't be generated.\n     *\n     * This is useful for controlling nested CssVarsProvider behavior.\n     */\n    disableStyleSheetGeneration: a.bool,\n    /**\n     * Disable CSS transitions when switching between modes or color schemes.\n     */\n    disableTransitionOnChange: a.bool,\n    /**\n     * The document to attach the attribute to.\n     */\n    documentNode: a.any,\n    /**\n     * The key in the local storage used to store current color scheme.\n     */\n    modeStorageKey: a.string,\n    /**\n     * If `true`, the mode will be the same value as the storage without an extra rerendering after the hydration.\n     * You should use this option in conjuction with `InitColorSchemeScript` component.\n     */\n    noSsr: a.bool,\n    /**\n     * The window that attaches the 'storage' event listener.\n     * @default window\n     */\n    storageWindow: a.any,\n    /**\n     * The calculated theme object that will be passed through context.\n     */\n    theme: a.object\n  });\n  const y = typeof s == \"string\" ? s : s.light, f = typeof s == \"string\" ? s : s.dark;\n  return {\n    CssVarsProvider: x,\n    useColorScheme: p,\n    getInitColorSchemeScript: (E) => Zu({\n      colorSchemeStorageKey: o,\n      defaultLightColorScheme: y,\n      defaultDarkColorScheme: f,\n      modeStorageKey: n,\n      ...E\n    })\n  };\n}\nfunction of(e = \"\") {\n  function t(...n) {\n    if (!n.length)\n      return \"\";\n    const o = n[0];\n    return typeof o == \"string\" && !o.match(/(#|\\(|\\)|(-?(\\d*\\.)?\\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\\d*\\.)?\\d+)$|(\\d+ \\d+ \\d+)/) ? `, var(--${e ? `${e}-` : \"\"}${o}${t(...n.slice(1))})` : `, ${o}`;\n  }\n  return (n, ...o) => `var(--${e ? `${e}-` : \"\"}${n}${t(...o)})`;\n}\nconst Ji = (e, t, r, n = []) => {\n  let o = e;\n  t.forEach((i, s) => {\n    s === t.length - 1 ? Array.isArray(o) ? o[Number(i)] = r : o && typeof o == \"object\" && (o[i] = r) : o && typeof o == \"object\" && (o[i] || (o[i] = n.includes(i) ? [] : {}), o = o[i]);\n  });\n}, af = (e, t, r) => {\n  function n(o, i = [], s = []) {\n    Object.entries(o).forEach(([c, l]) => {\n      (!r || !r([...i, c])) && l != null && (typeof l == \"object\" && Object.keys(l).length > 0 ? n(l, [...i, c], Array.isArray(l) ? [...s, c] : s) : t([...i, c], l, s));\n    });\n  }\n  n(e);\n}, sf = (e, t) => typeof t == \"number\" ? [\"lineHeight\", \"fontWeight\", \"opacity\", \"zIndex\"].some((n) => e.includes(n)) || e[e.length - 1].toLowerCase().includes(\"opacity\") ? t : `${t}px` : t;\nfunction to(e, t) {\n  const {\n    prefix: r,\n    shouldSkipGeneratingVar: n\n  } = t || {}, o = {}, i = {}, s = {};\n  return af(\n    e,\n    (c, l, u) => {\n      if ((typeof l == \"string\" || typeof l == \"number\") && (!n || !n(c, l))) {\n        const p = `--${r ? `${r}-` : \"\"}${c.join(\"-\")}`, m = sf(c, l);\n        Object.assign(o, {\n          [p]: m\n        }), Ji(i, c, `var(${p})`, u), Ji(s, c, `var(${p}, ${m})`, u);\n      }\n    },\n    (c) => c[0] === \"vars\"\n    // skip 'vars/*' paths\n  ), {\n    css: o,\n    vars: i,\n    varsWithDefaults: s\n  };\n}\nfunction cf(e, t = {}) {\n  const {\n    getSelector: r = S,\n    disableCssColorScheme: n,\n    colorSchemeSelector: o\n  } = t, {\n    colorSchemes: i = {},\n    components: s,\n    defaultColorScheme: c = \"light\",\n    ...l\n  } = e, {\n    vars: u,\n    css: p,\n    varsWithDefaults: m\n  } = to(l, t);\n  let g = m;\n  const x = {}, {\n    [c]: y,\n    ...f\n  } = i;\n  if (Object.entries(f || {}).forEach(([T, b]) => {\n    const {\n      vars: h,\n      css: w,\n      varsWithDefaults: k\n    } = to(b, t);\n    g = tt(g, k), x[T] = {\n      css: w,\n      vars: h\n    };\n  }), y) {\n    const {\n      css: T,\n      vars: b,\n      varsWithDefaults: h\n    } = to(y, t);\n    g = tt(g, h), x[c] = {\n      css: T,\n      vars: b\n    };\n  }\n  function S(T, b) {\n    var w, k;\n    let h = o;\n    if (o === \"class\" && (h = \".%s\"), o === \"data\" && (h = \"[data-%s]\"), o != null && o.startsWith(\"data-\") && !o.includes(\"%s\") && (h = `[${o}=\"%s\"]`), T) {\n      if (h === \"media\")\n        return e.defaultColorScheme === T ? \":root\" : {\n          [`@media (prefers-color-scheme: ${((k = (w = i[T]) == null ? void 0 : w.palette) == null ? void 0 : k.mode) || T})`]: {\n            \":root\": b\n          }\n        };\n      if (h)\n        return e.defaultColorScheme === T ? `:root, ${h.replace(\"%s\", String(T))}` : h.replace(\"%s\", String(T));\n    }\n    return \":root\";\n  }\n  return {\n    vars: g,\n    generateThemeVars: () => {\n      let T = {\n        ...u\n      };\n      return Object.entries(x).forEach(([, {\n        vars: b\n      }]) => {\n        T = tt(T, b);\n      }), T;\n    },\n    generateStyleSheets: () => {\n      var L, B;\n      const T = [], b = e.defaultColorScheme || \"light\";\n      function h(d, A) {\n        Object.keys(A).length && T.push(typeof d == \"string\" ? {\n          [d]: {\n            ...A\n          }\n        } : d);\n      }\n      h(r(void 0, {\n        ...p\n      }), p);\n      const {\n        [b]: w,\n        ...k\n      } = x;\n      if (w) {\n        const {\n          css: d\n        } = w, A = (B = (L = i[b]) == null ? void 0 : L.palette) == null ? void 0 : B.mode, D = !n && A ? {\n          colorScheme: A,\n          ...d\n        } : {\n          ...d\n        };\n        h(r(b, {\n          ...D\n        }), D);\n      }\n      return Object.entries(k).forEach(([d, {\n        css: A\n      }]) => {\n        var W, z;\n        const D = (z = (W = i[d]) == null ? void 0 : W.palette) == null ? void 0 : z.mode, j = !n && D ? {\n          colorScheme: D,\n          ...A\n        } : {\n          ...A\n        };\n        h(r(d, {\n          ...j\n        }), j);\n      }), T;\n    }\n  };\n}\nfunction lf(e) {\n  return function(r) {\n    return e === \"media\" ? ( true && r !== \"light\" && r !== \"dark\" && console.error(`MUI: @media (prefers-color-scheme) supports only 'light' or 'dark', but receive '${r}'.`), `@media (prefers-color-scheme: ${r})`) : e ? e.startsWith(\"data-\") && !e.includes(\"%s\") ? `[${e}=\"${r}\"] &` : e === \"class\" ? `.${r} &` : e === \"data\" ? `[data-${r}] &` : `${e.replace(\"%s\", r)} &` : \"&\";\n  };\n}\nfunction ls() {\n  return {\n    // The colors used to style the text.\n    text: {\n      // The most important text.\n      primary: \"rgba(0, 0, 0, 0.87)\",\n      // Secondary text.\n      secondary: \"rgba(0, 0, 0, 0.6)\",\n      // Disabled text have even lower visual prominence.\n      disabled: \"rgba(0, 0, 0, 0.38)\"\n    },\n    // The color used to divide different elements.\n    divider: \"rgba(0, 0, 0, 0.12)\",\n    // The background colors used to style the surfaces.\n    // Consistency between these values is important.\n    background: {\n      paper: Er.white,\n      default: Er.white\n    },\n    // The colors used to style the action elements.\n    action: {\n      // The color of an active action like an icon button.\n      active: \"rgba(0, 0, 0, 0.54)\",\n      // The color of an hovered action.\n      hover: \"rgba(0, 0, 0, 0.04)\",\n      hoverOpacity: 0.04,\n      // The color of a selected action.\n      selected: \"rgba(0, 0, 0, 0.08)\",\n      selectedOpacity: 0.08,\n      // The color of a disabled action.\n      disabled: \"rgba(0, 0, 0, 0.26)\",\n      // The background color of a disabled action.\n      disabledBackground: \"rgba(0, 0, 0, 0.12)\",\n      disabledOpacity: 0.38,\n      focus: \"rgba(0, 0, 0, 0.12)\",\n      focusOpacity: 0.12,\n      activatedOpacity: 0.12\n    }\n  };\n}\nconst uf = ls();\nfunction us() {\n  return {\n    text: {\n      primary: Er.white,\n      secondary: \"rgba(255, 255, 255, 0.7)\",\n      disabled: \"rgba(255, 255, 255, 0.5)\",\n      icon: \"rgba(255, 255, 255, 0.5)\"\n    },\n    divider: \"rgba(255, 255, 255, 0.12)\",\n    background: {\n      paper: \"#121212\",\n      default: \"#121212\"\n    },\n    action: {\n      active: Er.white,\n      hover: \"rgba(255, 255, 255, 0.08)\",\n      hoverOpacity: 0.08,\n      selected: \"rgba(255, 255, 255, 0.16)\",\n      selectedOpacity: 0.16,\n      disabled: \"rgba(255, 255, 255, 0.3)\",\n      disabledBackground: \"rgba(255, 255, 255, 0.12)\",\n      disabledOpacity: 0.38,\n      focus: \"rgba(255, 255, 255, 0.12)\",\n      focusOpacity: 0.12,\n      activatedOpacity: 0.24\n    }\n  };\n}\nconst Qi = us();\nfunction Zi(e, t, r, n) {\n  const o = n.light || n, i = n.dark || n * 1.5;\n  e[t] || (e.hasOwnProperty(r) ? e[t] = e[r] : t === \"light\" ? e.light = _o(e.main, o) : t === \"dark\" && (e.dark = Io(e.main, i)));\n}\nfunction ff(e = \"light\") {\n  return e === \"dark\" ? {\n    main: Yt[200],\n    light: Yt[50],\n    dark: Yt[400]\n  } : {\n    main: Yt[700],\n    light: Yt[400],\n    dark: Yt[800]\n  };\n}\nfunction df(e = \"light\") {\n  return e === \"dark\" ? {\n    main: Ut[200],\n    light: Ut[50],\n    dark: Ut[400]\n  } : {\n    main: Ut[500],\n    light: Ut[300],\n    dark: Ut[700]\n  };\n}\nfunction pf(e = \"light\") {\n  return e === \"dark\" ? {\n    main: Wt[500],\n    light: Wt[300],\n    dark: Wt[700]\n  } : {\n    main: Wt[700],\n    light: Wt[400],\n    dark: Wt[800]\n  };\n}\nfunction mf(e = \"light\") {\n  return e === \"dark\" ? {\n    main: Ht[400],\n    light: Ht[300],\n    dark: Ht[700]\n  } : {\n    main: Ht[700],\n    light: Ht[500],\n    dark: Ht[900]\n  };\n}\nfunction hf(e = \"light\") {\n  return e === \"dark\" ? {\n    main: qt[400],\n    light: qt[300],\n    dark: qt[700]\n  } : {\n    main: qt[800],\n    light: qt[500],\n    dark: qt[900]\n  };\n}\nfunction gf(e = \"light\") {\n  return e === \"dark\" ? {\n    main: fr[400],\n    light: fr[300],\n    dark: fr[700]\n  } : {\n    main: \"#ed6c02\",\n    // closest to orange[800] that pass 3:1.\n    light: fr[500],\n    dark: fr[900]\n  };\n}\nfunction Uo(e) {\n  const {\n    mode: t = \"light\",\n    contrastThreshold: r = 3,\n    tonalOffset: n = 0.2,\n    ...o\n  } = e, i = e.primary || ff(t), s = e.secondary || df(t), c = e.error || pf(t), l = e.info || mf(t), u = e.success || hf(t), p = e.warning || gf(t);\n  function m(f) {\n    const S = Fi(f, Qi.text.primary) >= r ? Qi.text.primary : uf.text.primary;\n    if (true) {\n      const E = Fi(f, S);\n      E < 3 && console.error([`MUI: The contrast ratio of ${E}:1 for ${S} on ${f}`, \"falls below the WCAG recommended absolute minimum contrast ratio of 3:1.\", \"https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast\"].join(`\n`));\n    }\n    return S;\n  }\n  const g = ({\n    color: f,\n    name: S,\n    mainShade: E = 500,\n    lightShade: P = 300,\n    darkShade: T = 700\n  }) => {\n    if (f = {\n      ...f\n    }, !f.main && f[E] && (f.main = f[E]), !f.hasOwnProperty(\"main\"))\n      throw new Error( true ? `MUI: The color${S ? ` (${S})` : \"\"} provided to augmentColor(color) is invalid.\nThe color object needs to have a \\`main\\` property or a \\`${E}\\` property.` : 0);\n    if (typeof f.main != \"string\")\n      throw new Error( true ? `MUI: The color${S ? ` (${S})` : \"\"} provided to augmentColor(color) is invalid.\n\\`color.main\\` should be a string, but \\`${JSON.stringify(f.main)}\\` was provided instead.\n\nDid you intend to use one of the following approaches?\n\nimport { green } from \"@mui/material/colors\";\n\nconst theme1 = createTheme({ palette: {\n  primary: green,\n} });\n\nconst theme2 = createTheme({ palette: {\n  primary: { main: green[500] },\n} });` : 0);\n    return Zi(f, \"light\", P, n), Zi(f, \"dark\", T, n), f.contrastText || (f.contrastText = m(f.main)), f;\n  };\n  let x;\n  return t === \"light\" ? x = ls() : t === \"dark\" && (x = us()),  true && (x || console.error(`MUI: The palette mode \\`${t}\\` is not supported.`)), tt({\n    // A collection of common colors.\n    common: {\n      ...Er\n    },\n    // prevent mutable object.\n    // The palette mode, can be light or dark.\n    mode: t,\n    // The colors used to represent primary interface elements for a user.\n    primary: g({\n      color: i,\n      name: \"primary\"\n    }),\n    // The colors used to represent secondary interface elements for a user.\n    secondary: g({\n      color: s,\n      name: \"secondary\",\n      mainShade: \"A400\",\n      lightShade: \"A200\",\n      darkShade: \"A700\"\n    }),\n    // The colors used to represent interface elements that the user should be made aware of.\n    error: g({\n      color: c,\n      name: \"error\"\n    }),\n    // The colors used to represent potentially dangerous actions or important messages.\n    warning: g({\n      color: p,\n      name: \"warning\"\n    }),\n    // The colors used to present information to the user that is neutral and not necessarily important.\n    info: g({\n      color: l,\n      name: \"info\"\n    }),\n    // The colors used to indicate the successful completion of an action that user triggered.\n    success: g({\n      color: u,\n      name: \"success\"\n    }),\n    // The grey colors.\n    grey: oc,\n    // Used by `getContrastText()` to maximize the contrast between\n    // the background and the text.\n    contrastThreshold: r,\n    // Takes a background color and returns the text color that maximizes the contrast.\n    getContrastText: m,\n    // Generate a rich color object.\n    augmentColor: g,\n    // Used by the functions below to shift a color's luminance by approximately\n    // two indexes within its tonal palette.\n    // E.g., shift from Red 500 to Red 300 or Red 700.\n    tonalOffset: n,\n    // The light and dark mode object.\n    ...x\n  }, o);\n}\nfunction yf(e) {\n  const t = {};\n  return Object.entries(e).forEach((n) => {\n    const [o, i] = n;\n    typeof i == \"object\" && (t[o] = `${i.fontStyle ? `${i.fontStyle} ` : \"\"}${i.fontVariant ? `${i.fontVariant} ` : \"\"}${i.fontWeight ? `${i.fontWeight} ` : \"\"}${i.fontStretch ? `${i.fontStretch} ` : \"\"}${i.fontSize || \"\"}${i.lineHeight ? `/${i.lineHeight} ` : \"\"}${i.fontFamily || \"\"}`);\n  }), t;\n}\nfunction bf(e, t) {\n  return {\n    toolbar: {\n      minHeight: 56,\n      [e.up(\"xs\")]: {\n        \"@media (orientation: landscape)\": {\n          minHeight: 48\n        }\n      },\n      [e.up(\"sm\")]: {\n        minHeight: 64\n      }\n    },\n    ...t\n  };\n}\nfunction vf(e) {\n  return Math.round(e * 1e5) / 1e5;\n}\nconst ea = {\n  textTransform: \"uppercase\"\n}, ta = '\"Roboto\", \"Helvetica\", \"Arial\", sans-serif';\nfunction fs(e, t) {\n  const {\n    fontFamily: r = ta,\n    // The default font size of the Material Specification.\n    fontSize: n = 14,\n    // px\n    fontWeightLight: o = 300,\n    fontWeightRegular: i = 400,\n    fontWeightMedium: s = 500,\n    fontWeightBold: c = 700,\n    // Tell MUI what's the font-size on the html element.\n    // 16px is the default font-size used by browsers.\n    htmlFontSize: l = 16,\n    // Apply the CSS properties to all the variants.\n    allVariants: u,\n    pxToRem: p,\n    ...m\n  } = typeof t == \"function\" ? t(e) : t;\n   true && (typeof n != \"number\" && console.error(\"MUI: `fontSize` is required to be a number.\"), typeof l != \"number\" && console.error(\"MUI: `htmlFontSize` is required to be a number.\"));\n  const g = n / 14, x = p || ((S) => `${S / l * g}rem`), y = (S, E, P, T, b) => ({\n    fontFamily: r,\n    fontWeight: S,\n    fontSize: x(E),\n    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/\n    lineHeight: P,\n    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing\n    // across font-families can cause issues with the kerning.\n    ...r === ta ? {\n      letterSpacing: `${vf(T / E)}em`\n    } : {},\n    ...b,\n    ...u\n  }), f = {\n    h1: y(o, 96, 1.167, -1.5),\n    h2: y(o, 60, 1.2, -0.5),\n    h3: y(i, 48, 1.167, 0),\n    h4: y(i, 34, 1.235, 0.25),\n    h5: y(i, 24, 1.334, 0),\n    h6: y(s, 20, 1.6, 0.15),\n    subtitle1: y(i, 16, 1.75, 0.15),\n    subtitle2: y(s, 14, 1.57, 0.1),\n    body1: y(i, 16, 1.5, 0.15),\n    body2: y(i, 14, 1.43, 0.15),\n    button: y(s, 14, 1.75, 0.4, ea),\n    caption: y(i, 12, 1.66, 0.4),\n    overline: y(i, 12, 2.66, 1, ea),\n    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.\n    inherit: {\n      fontFamily: \"inherit\",\n      fontWeight: \"inherit\",\n      fontSize: \"inherit\",\n      lineHeight: \"inherit\",\n      letterSpacing: \"inherit\"\n    }\n  };\n  return tt({\n    htmlFontSize: l,\n    pxToRem: x,\n    fontFamily: r,\n    fontSize: n,\n    fontWeightLight: o,\n    fontWeightRegular: i,\n    fontWeightMedium: s,\n    fontWeightBold: c,\n    ...f\n  }, m, {\n    clone: !1\n    // No need to clone deep\n  });\n}\nconst xf = 0.2, Sf = 0.14, Ef = 0.12;\nfunction $e(...e) {\n  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${xf})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${Sf})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${Ef})`].join(\",\");\n}\nconst Cf = [\"none\", $e(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), $e(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), $e(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), $e(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), $e(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), $e(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), $e(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), $e(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), $e(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), $e(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), $e(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), $e(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), $e(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), $e(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), $e(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), $e(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), $e(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), $e(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), $e(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), $e(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), $e(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), $e(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), $e(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), $e(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], Tf = {\n  // This is the most common easing curve.\n  easeInOut: \"cubic-bezier(0.4, 0, 0.2, 1)\",\n  // Objects enter the screen at full velocity from off-screen and\n  // slowly decelerate to a resting point.\n  easeOut: \"cubic-bezier(0.0, 0, 0.2, 1)\",\n  // Objects leave the screen at full velocity. They do not decelerate when off-screen.\n  easeIn: \"cubic-bezier(0.4, 0, 1, 1)\",\n  // The sharp curve is used by objects that may return to the screen at any time.\n  sharp: \"cubic-bezier(0.4, 0, 0.6, 1)\"\n}, ds = {\n  shortest: 150,\n  shorter: 200,\n  short: 250,\n  // most basic recommended timing\n  standard: 300,\n  // this is to be used in complex animations\n  complex: 375,\n  // recommended when something is entering screen\n  enteringScreen: 225,\n  // recommended when something is leaving screen\n  leavingScreen: 195\n};\nfunction ra(e) {\n  return `${Math.round(e)}ms`;\n}\nfunction wf(e) {\n  if (!e)\n    return 0;\n  const t = e / 36;\n  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);\n}\nfunction Of(e) {\n  const t = {\n    ...Tf,\n    ...e.easing\n  }, r = {\n    ...ds,\n    ...e.duration\n  };\n  return {\n    getAutoHeightDuration: wf,\n    create: (o = [\"all\"], i = {}) => {\n      const {\n        duration: s = r.standard,\n        easing: c = t.easeInOut,\n        delay: l = 0,\n        ...u\n      } = i;\n      if (true) {\n        const p = (g) => typeof g == \"string\", m = (g) => !Number.isNaN(parseFloat(g));\n        !p(o) && !Array.isArray(o) && console.error('MUI: Argument \"props\" must be a string or Array.'), !m(s) && !p(s) && console.error(`MUI: Argument \"duration\" must be a number or a string but found ${s}.`), p(c) || console.error('MUI: Argument \"easing\" must be a string.'), !m(l) && !p(l) && console.error('MUI: Argument \"delay\" must be a number or a string.'), typeof i != \"object\" && console.error([\"MUI: Secong argument of transition.create must be an object.\", \"Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`\"].join(`\n`)), Object.keys(u).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(u).join(\",\")}].`);\n      }\n      return (Array.isArray(o) ? o : [o]).map((p) => `${p} ${typeof s == \"string\" ? s : ra(s)} ${c} ${typeof l == \"string\" ? l : ra(l)}`).join(\",\");\n    },\n    ...e,\n    easing: t,\n    duration: r\n  };\n}\nconst Rf = {\n  mobileStepper: 1e3,\n  fab: 1050,\n  speedDial: 1050,\n  appBar: 1100,\n  drawer: 1200,\n  modal: 1300,\n  snackbar: 1400,\n  tooltip: 1500\n};\nfunction $f(e) {\n  return gt(e) || typeof e > \"u\" || typeof e == \"string\" || typeof e == \"boolean\" || typeof e == \"number\" || Array.isArray(e);\n}\nfunction ps(e = {}) {\n  const t = {\n    ...e\n  };\n  function r(n) {\n    const o = Object.entries(n);\n    for (let i = 0; i < o.length; i++) {\n      const [s, c] = o[i];\n      !$f(c) || s.startsWith(\"unstable_\") ? delete n[s] : gt(c) && (n[s] = {\n        ...c\n      }, r(n[s]));\n    }\n  }\n  return r(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';\n\nconst theme = ${JSON.stringify(t, null, 2)};\n\ntheme.breakpoints = createBreakpoints(theme.breakpoints || {});\ntheme.transitions = createTransitions(theme.transitions || {});\n\nexport default theme;`;\n}\nfunction fo(e = {}, ...t) {\n  const {\n    breakpoints: r,\n    mixins: n = {},\n    spacing: o,\n    palette: i = {},\n    transitions: s = {},\n    typography: c = {},\n    shape: l,\n    ...u\n  } = e;\n  if (e.vars)\n    throw new Error( true ? \"MUI: `vars` is a private field used for CSS variables support.\\nPlease use another name.\" : 0);\n  const p = Uo(i), m = No(e);\n  let g = tt(m, {\n    mixins: bf(m.breakpoints, n),\n    palette: p,\n    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.\n    shadows: Cf.slice(),\n    typography: fs(p, c),\n    transitions: Of(s),\n    zIndex: {\n      ...Rf\n    }\n  });\n  if (g = tt(g, u), g = t.reduce((x, y) => tt(x, y), g), \"development\" !== \"production\") {\n    const x = [\"active\", \"checked\", \"completed\", \"disabled\", \"error\", \"expanded\", \"focused\", \"focusVisible\", \"required\", \"selected\"], y = (f, S) => {\n      let E;\n      for (E in f) {\n        const P = f[E];\n        if (x.includes(E) && Object.keys(P).length > 0) {\n          if (true) {\n            const T = Ve(\"\", E);\n            console.error([`MUI: The \\`${S}\\` component increases the CSS specificity of the \\`${E}\\` internal state.`, \"You can not override it like this: \", JSON.stringify(f, null, 2), \"\", `Instead, you need to use the '&.${T}' syntax:`, JSON.stringify({\n              root: {\n                [`&.${T}`]: P\n              }\n            }, null, 2), \"\", \"https://mui.com/r/state-classes-guide\"].join(`\n`));\n          }\n          f[E] = {};\n        }\n      }\n    };\n    Object.keys(g.components).forEach((f) => {\n      const S = g.components[f].styleOverrides;\n      S && f.startsWith(\"Mui\") && y(S, f);\n    });\n  }\n  return g.unstable_sxConfig = {\n    ...Dr,\n    ...u == null ? void 0 : u.unstable_sxConfig\n  }, g.unstable_sx = function(y) {\n    return At({\n      sx: y,\n      theme: this\n    });\n  }, g.toRuntimeSource = ps, g;\n}\nfunction Pf(e) {\n  let t;\n  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;\n}\nconst kf = [...Array(25)].map((e, t) => {\n  if (t === 0)\n    return \"none\";\n  const r = Pf(t);\n  return `linear-gradient(rgba(255 255 255 / ${r}), rgba(255 255 255 / ${r}))`;\n});\nfunction ms(e) {\n  return {\n    inputPlaceholder: e === \"dark\" ? 0.5 : 0.42,\n    inputUnderline: e === \"dark\" ? 0.7 : 0.42,\n    switchTrackDisabled: e === \"dark\" ? 0.2 : 0.12,\n    switchTrack: e === \"dark\" ? 0.3 : 0.38\n  };\n}\nfunction hs(e) {\n  return e === \"dark\" ? kf : [];\n}\nfunction Af(e) {\n  const {\n    palette: t = {\n      mode: \"light\"\n    },\n    // need to cast to avoid module augmentation test\n    opacity: r,\n    overlays: n,\n    ...o\n  } = e, i = Uo(t);\n  return {\n    palette: i,\n    opacity: {\n      ...ms(i.mode),\n      ...r\n    },\n    overlays: n || hs(i.mode),\n    ...o\n  };\n}\nfunction Nf(e) {\n  var t;\n  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig\n  e[0] === \"palette\" && !!((t = e[1]) != null && t.match(/(mode|contrastThreshold|tonalOffset)/));\n}\nconst Mf = (e) => [...[...Array(25)].map((t, r) => `--${e ? `${e}-` : \"\"}overlays-${r}`), `--${e ? `${e}-` : \"\"}palette-AppBar-darkBg`, `--${e ? `${e}-` : \"\"}palette-AppBar-darkColor`], If = (e) => (t, r) => {\n  const n = e.rootSelector || \":root\", o = e.colorSchemeSelector;\n  let i = o;\n  if (o === \"class\" && (i = \".%s\"), o === \"data\" && (i = \"[data-%s]\"), o != null && o.startsWith(\"data-\") && !o.includes(\"%s\") && (i = `[${o}=\"%s\"]`), e.defaultColorScheme === t) {\n    if (t === \"dark\") {\n      const s = {};\n      return Mf(e.cssVarPrefix).forEach((c) => {\n        s[c] = r[c], delete r[c];\n      }), i === \"media\" ? {\n        [n]: r,\n        \"@media (prefers-color-scheme: dark)\": {\n          [n]: s\n        }\n      } : i ? {\n        [i.replace(\"%s\", t)]: s,\n        [`${n}, ${i.replace(\"%s\", t)}`]: r\n      } : {\n        [n]: {\n          ...r,\n          ...s\n        }\n      };\n    }\n    if (i && i !== \"media\")\n      return `${n}, ${i.replace(\"%s\", String(t))}`;\n  } else if (t) {\n    if (i === \"media\")\n      return {\n        [`@media (prefers-color-scheme: ${String(t)})`]: {\n          [n]: r\n        }\n      };\n    if (i)\n      return i.replace(\"%s\", String(t));\n  }\n  return n;\n};\nfunction _f(e, t) {\n  t.forEach((r) => {\n    e[r] || (e[r] = {});\n  });\n}\nfunction $(e, t, r) {\n  !e[t] && r && (e[t] = r);\n}\nfunction yr(e) {\n  return typeof e != \"string\" || !e.startsWith(\"hsl\") ? e : Ka(e);\n}\nfunction Ct(e, t) {\n  `${t}Channel` in e || (e[`${t}Channel`] = gr(yr(e[t]), `MUI: Can't create \\`palette.${t}Channel\\` because \\`palette.${t}\\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().\nTo suppress this warning, you need to explicitly provide the \\`palette.${t}Channel\\` as a string (in rgb format, for example \"12 12 12\") or undefined if you want to remove the channel token.`));\n}\nfunction jf(e) {\n  return typeof e == \"number\" ? `${e}px` : typeof e == \"string\" || typeof e == \"function\" || Array.isArray(e) ? e : \"8px\";\n}\nconst pt = (e) => {\n  try {\n    return e();\n  } catch {\n  }\n}, Df = (e = \"mui\") => of(e);\nfunction ro(e, t, r, n) {\n  if (!t)\n    return;\n  t = t === !0 ? {} : t;\n  const o = n === \"dark\" ? \"dark\" : \"light\";\n  if (!r) {\n    e[n] = Af({\n      ...t,\n      palette: {\n        mode: o,\n        ...t == null ? void 0 : t.palette\n      }\n    });\n    return;\n  }\n  const {\n    palette: i,\n    ...s\n  } = fo({\n    ...r,\n    palette: {\n      mode: o,\n      ...t == null ? void 0 : t.palette\n    }\n  });\n  return e[n] = {\n    ...t,\n    palette: i,\n    opacity: {\n      ...ms(o),\n      ...t == null ? void 0 : t.opacity\n    },\n    overlays: (t == null ? void 0 : t.overlays) || hs(o)\n  }, s;\n}\nfunction Lf(e = {}, ...t) {\n  const {\n    colorSchemes: r = {\n      light: !0\n    },\n    defaultColorScheme: n,\n    disableCssColorScheme: o = !1,\n    cssVarPrefix: i = \"mui\",\n    shouldSkipGeneratingVar: s = Nf,\n    colorSchemeSelector: c = r.light && r.dark ? \"media\" : void 0,\n    rootSelector: l = \":root\",\n    ...u\n  } = e, p = Object.keys(r)[0], m = n || (r.light && p !== \"light\" ? \"light\" : p), g = Df(i), {\n    [m]: x,\n    light: y,\n    dark: f,\n    ...S\n  } = r, E = {\n    ...S\n  };\n  let P = x;\n  if ((m === \"dark\" && !(\"dark\" in r) || m === \"light\" && !(\"light\" in r)) && (P = !0), !P)\n    throw new Error( true ? `MUI: The \\`colorSchemes.${m}\\` option is either missing or invalid.` : 0);\n  const T = ro(E, P, u, m);\n  y && !E.light && ro(E, y, void 0, \"light\"), f && !E.dark && ro(E, f, void 0, \"dark\");\n  let b = {\n    defaultColorScheme: m,\n    ...T,\n    cssVarPrefix: i,\n    colorSchemeSelector: c,\n    rootSelector: l,\n    getCssVar: g,\n    colorSchemes: E,\n    font: {\n      ...yf(T.typography),\n      ...T.font\n    },\n    spacing: jf(u.spacing)\n  };\n  Object.keys(b.colorSchemes).forEach((B) => {\n    const d = b.colorSchemes[B].palette, A = (D) => {\n      const j = D.split(\"-\"), W = j[1], z = j[2];\n      return g(D, d[W][z]);\n    };\n    if (d.mode === \"light\" && ($(d.common, \"background\", \"#fff\"), $(d.common, \"onBackground\", \"#000\")), d.mode === \"dark\" && ($(d.common, \"background\", \"#000\"), $(d.common, \"onBackground\", \"#fff\")), _f(d, [\"Alert\", \"AppBar\", \"Avatar\", \"Button\", \"Chip\", \"FilledInput\", \"LinearProgress\", \"Skeleton\", \"Slider\", \"SnackbarContent\", \"SpeedDialAction\", \"StepConnector\", \"StepContent\", \"Switch\", \"TableCell\", \"Tooltip\"]), d.mode === \"light\") {\n      $(d.Alert, \"errorColor\", Ce(d.error.light, 0.6)), $(d.Alert, \"infoColor\", Ce(d.info.light, 0.6)), $(d.Alert, \"successColor\", Ce(d.success.light, 0.6)), $(d.Alert, \"warningColor\", Ce(d.warning.light, 0.6)), $(d.Alert, \"errorFilledBg\", A(\"palette-error-main\")), $(d.Alert, \"infoFilledBg\", A(\"palette-info-main\")), $(d.Alert, \"successFilledBg\", A(\"palette-success-main\")), $(d.Alert, \"warningFilledBg\", A(\"palette-warning-main\")), $(d.Alert, \"errorFilledColor\", pt(() => d.getContrastText(d.error.main))), $(d.Alert, \"infoFilledColor\", pt(() => d.getContrastText(d.info.main))), $(d.Alert, \"successFilledColor\", pt(() => d.getContrastText(d.success.main))), $(d.Alert, \"warningFilledColor\", pt(() => d.getContrastText(d.warning.main))), $(d.Alert, \"errorStandardBg\", Te(d.error.light, 0.9)), $(d.Alert, \"infoStandardBg\", Te(d.info.light, 0.9)), $(d.Alert, \"successStandardBg\", Te(d.success.light, 0.9)), $(d.Alert, \"warningStandardBg\", Te(d.warning.light, 0.9)), $(d.Alert, \"errorIconColor\", A(\"palette-error-main\")), $(d.Alert, \"infoIconColor\", A(\"palette-info-main\")), $(d.Alert, \"successIconColor\", A(\"palette-success-main\")), $(d.Alert, \"warningIconColor\", A(\"palette-warning-main\")), $(d.AppBar, \"defaultBg\", A(\"palette-grey-100\")), $(d.Avatar, \"defaultBg\", A(\"palette-grey-400\")), $(d.Button, \"inheritContainedBg\", A(\"palette-grey-300\")), $(d.Button, \"inheritContainedHoverBg\", A(\"palette-grey-A100\")), $(d.Chip, \"defaultBorder\", A(\"palette-grey-400\")), $(d.Chip, \"defaultAvatarColor\", A(\"palette-grey-700\")), $(d.Chip, \"defaultIconColor\", A(\"palette-grey-700\")), $(d.FilledInput, \"bg\", \"rgba(0, 0, 0, 0.06)\"), $(d.FilledInput, \"hoverBg\", \"rgba(0, 0, 0, 0.09)\"), $(d.FilledInput, \"disabledBg\", \"rgba(0, 0, 0, 0.12)\"), $(d.LinearProgress, \"primaryBg\", Te(d.primary.main, 0.62)), $(d.LinearProgress, \"secondaryBg\", Te(d.secondary.main, 0.62)), $(d.LinearProgress, \"errorBg\", Te(d.error.main, 0.62)), $(d.LinearProgress, \"infoBg\", Te(d.info.main, 0.62)), $(d.LinearProgress, \"successBg\", Te(d.success.main, 0.62)), $(d.LinearProgress, \"warningBg\", Te(d.warning.main, 0.62)), $(d.Skeleton, \"bg\", `rgba(${A(\"palette-text-primaryChannel\")} / 0.11)`), $(d.Slider, \"primaryTrack\", Te(d.primary.main, 0.62)), $(d.Slider, \"secondaryTrack\", Te(d.secondary.main, 0.62)), $(d.Slider, \"errorTrack\", Te(d.error.main, 0.62)), $(d.Slider, \"infoTrack\", Te(d.info.main, 0.62)), $(d.Slider, \"successTrack\", Te(d.success.main, 0.62)), $(d.Slider, \"warningTrack\", Te(d.warning.main, 0.62));\n      const D = Jr(d.background.default, 0.8);\n      $(d.SnackbarContent, \"bg\", D), $(d.SnackbarContent, \"color\", pt(() => d.getContrastText(D))), $(d.SpeedDialAction, \"fabHoverBg\", Jr(d.background.paper, 0.15)), $(d.StepConnector, \"border\", A(\"palette-grey-400\")), $(d.StepContent, \"border\", A(\"palette-grey-400\")), $(d.Switch, \"defaultColor\", A(\"palette-common-white\")), $(d.Switch, \"defaultDisabledColor\", A(\"palette-grey-100\")), $(d.Switch, \"primaryDisabledColor\", Te(d.primary.main, 0.62)), $(d.Switch, \"secondaryDisabledColor\", Te(d.secondary.main, 0.62)), $(d.Switch, \"errorDisabledColor\", Te(d.error.main, 0.62)), $(d.Switch, \"infoDisabledColor\", Te(d.info.main, 0.62)), $(d.Switch, \"successDisabledColor\", Te(d.success.main, 0.62)), $(d.Switch, \"warningDisabledColor\", Te(d.warning.main, 0.62)), $(d.TableCell, \"border\", Te(Xr(d.divider, 1), 0.88)), $(d.Tooltip, \"bg\", Xr(d.grey[700], 0.92));\n    }\n    if (d.mode === \"dark\") {\n      $(d.Alert, \"errorColor\", Te(d.error.light, 0.6)), $(d.Alert, \"infoColor\", Te(d.info.light, 0.6)), $(d.Alert, \"successColor\", Te(d.success.light, 0.6)), $(d.Alert, \"warningColor\", Te(d.warning.light, 0.6)), $(d.Alert, \"errorFilledBg\", A(\"palette-error-dark\")), $(d.Alert, \"infoFilledBg\", A(\"palette-info-dark\")), $(d.Alert, \"successFilledBg\", A(\"palette-success-dark\")), $(d.Alert, \"warningFilledBg\", A(\"palette-warning-dark\")), $(d.Alert, \"errorFilledColor\", pt(() => d.getContrastText(d.error.dark))), $(d.Alert, \"infoFilledColor\", pt(() => d.getContrastText(d.info.dark))), $(d.Alert, \"successFilledColor\", pt(() => d.getContrastText(d.success.dark))), $(d.Alert, \"warningFilledColor\", pt(() => d.getContrastText(d.warning.dark))), $(d.Alert, \"errorStandardBg\", Ce(d.error.light, 0.9)), $(d.Alert, \"infoStandardBg\", Ce(d.info.light, 0.9)), $(d.Alert, \"successStandardBg\", Ce(d.success.light, 0.9)), $(d.Alert, \"warningStandardBg\", Ce(d.warning.light, 0.9)), $(d.Alert, \"errorIconColor\", A(\"palette-error-main\")), $(d.Alert, \"infoIconColor\", A(\"palette-info-main\")), $(d.Alert, \"successIconColor\", A(\"palette-success-main\")), $(d.Alert, \"warningIconColor\", A(\"palette-warning-main\")), $(d.AppBar, \"defaultBg\", A(\"palette-grey-900\")), $(d.AppBar, \"darkBg\", A(\"palette-background-paper\")), $(d.AppBar, \"darkColor\", A(\"palette-text-primary\")), $(d.Avatar, \"defaultBg\", A(\"palette-grey-600\")), $(d.Button, \"inheritContainedBg\", A(\"palette-grey-800\")), $(d.Button, \"inheritContainedHoverBg\", A(\"palette-grey-700\")), $(d.Chip, \"defaultBorder\", A(\"palette-grey-700\")), $(d.Chip, \"defaultAvatarColor\", A(\"palette-grey-300\")), $(d.Chip, \"defaultIconColor\", A(\"palette-grey-300\")), $(d.FilledInput, \"bg\", \"rgba(255, 255, 255, 0.09)\"), $(d.FilledInput, \"hoverBg\", \"rgba(255, 255, 255, 0.13)\"), $(d.FilledInput, \"disabledBg\", \"rgba(255, 255, 255, 0.12)\"), $(d.LinearProgress, \"primaryBg\", Ce(d.primary.main, 0.5)), $(d.LinearProgress, \"secondaryBg\", Ce(d.secondary.main, 0.5)), $(d.LinearProgress, \"errorBg\", Ce(d.error.main, 0.5)), $(d.LinearProgress, \"infoBg\", Ce(d.info.main, 0.5)), $(d.LinearProgress, \"successBg\", Ce(d.success.main, 0.5)), $(d.LinearProgress, \"warningBg\", Ce(d.warning.main, 0.5)), $(d.Skeleton, \"bg\", `rgba(${A(\"palette-text-primaryChannel\")} / 0.13)`), $(d.Slider, \"primaryTrack\", Ce(d.primary.main, 0.5)), $(d.Slider, \"secondaryTrack\", Ce(d.secondary.main, 0.5)), $(d.Slider, \"errorTrack\", Ce(d.error.main, 0.5)), $(d.Slider, \"infoTrack\", Ce(d.info.main, 0.5)), $(d.Slider, \"successTrack\", Ce(d.success.main, 0.5)), $(d.Slider, \"warningTrack\", Ce(d.warning.main, 0.5));\n      const D = Jr(d.background.default, 0.98);\n      $(d.SnackbarContent, \"bg\", D), $(d.SnackbarContent, \"color\", pt(() => d.getContrastText(D))), $(d.SpeedDialAction, \"fabHoverBg\", Jr(d.background.paper, 0.15)), $(d.StepConnector, \"border\", A(\"palette-grey-600\")), $(d.StepContent, \"border\", A(\"palette-grey-600\")), $(d.Switch, \"defaultColor\", A(\"palette-grey-300\")), $(d.Switch, \"defaultDisabledColor\", A(\"palette-grey-600\")), $(d.Switch, \"primaryDisabledColor\", Ce(d.primary.main, 0.55)), $(d.Switch, \"secondaryDisabledColor\", Ce(d.secondary.main, 0.55)), $(d.Switch, \"errorDisabledColor\", Ce(d.error.main, 0.55)), $(d.Switch, \"infoDisabledColor\", Ce(d.info.main, 0.55)), $(d.Switch, \"successDisabledColor\", Ce(d.success.main, 0.55)), $(d.Switch, \"warningDisabledColor\", Ce(d.warning.main, 0.55)), $(d.TableCell, \"border\", Ce(Xr(d.divider, 1), 0.68)), $(d.Tooltip, \"bg\", Xr(d.grey[700], 0.92));\n    }\n    Ct(d.background, \"default\"), Ct(d.background, \"paper\"), Ct(d.common, \"background\"), Ct(d.common, \"onBackground\"), Ct(d, \"divider\"), Object.keys(d).forEach((D) => {\n      const j = d[D];\n      D !== \"tonalOffset\" && j && typeof j == \"object\" && (j.main && $(d[D], \"mainChannel\", gr(yr(j.main))), j.light && $(d[D], \"lightChannel\", gr(yr(j.light))), j.dark && $(d[D], \"darkChannel\", gr(yr(j.dark))), j.contrastText && $(d[D], \"contrastTextChannel\", gr(yr(j.contrastText))), D === \"text\" && (Ct(d[D], \"primary\"), Ct(d[D], \"secondary\")), D === \"action\" && (j.active && Ct(d[D], \"active\"), j.selected && Ct(d[D], \"selected\")));\n    });\n  }), b = t.reduce((B, d) => tt(B, d), b);\n  const h = {\n    prefix: i,\n    disableCssColorScheme: o,\n    shouldSkipGeneratingVar: s,\n    getSelector: If(b)\n  }, {\n    vars: w,\n    generateThemeVars: k,\n    generateStyleSheets: L\n  } = cf(b, h);\n  return b.vars = w, Object.entries(b.colorSchemes[b.defaultColorScheme]).forEach(([B, d]) => {\n    b[B] = d;\n  }), b.generateThemeVars = k, b.generateStyleSheets = L, b.generateSpacing = function() {\n    return Ba(u.spacing, ko(this));\n  }, b.getColorSchemeSelector = lf(c), b.spacing = b.generateSpacing(), b.shouldSkipGeneratingVar = s, b.unstable_sxConfig = {\n    ...Dr,\n    ...u == null ? void 0 : u.unstable_sxConfig\n  }, b.unstable_sx = function(d) {\n    return At({\n      sx: d,\n      theme: this\n    });\n  }, b.toRuntimeSource = ps, b;\n}\nfunction na(e, t, r) {\n  e.colorSchemes && r && (e.colorSchemes[t] = {\n    ...r !== !0 && r,\n    palette: Uo({\n      ...r === !0 ? {} : r.palette,\n      mode: t\n    })\n    // cast type to skip module augmentation test\n  });\n}\nfunction Fn(e = {}, ...t) {\n  const {\n    palette: r,\n    cssVariables: n = !1,\n    colorSchemes: o = r ? void 0 : {\n      light: !0\n    },\n    defaultColorScheme: i = r == null ? void 0 : r.mode,\n    ...s\n  } = e, c = i || \"light\", l = o == null ? void 0 : o[c], u = {\n    ...o,\n    ...r ? {\n      [c]: {\n        ...typeof l != \"boolean\" && l,\n        palette: r\n      }\n    } : void 0\n  };\n  if (n === !1) {\n    if (!(\"colorSchemes\" in e))\n      return fo(e, ...t);\n    let p = r;\n    \"palette\" in e || u[c] && (u[c] !== !0 ? p = u[c].palette : c === \"dark\" && (p = {\n      mode: \"dark\"\n    }));\n    const m = fo({\n      ...e,\n      palette: p\n    }, ...t);\n    return m.defaultColorScheme = c, m.colorSchemes = u, m.palette.mode === \"light\" && (m.colorSchemes.light = {\n      ...u.light !== !0 && u.light,\n      palette: m.palette\n    }, na(m, \"dark\", u.dark)), m.palette.mode === \"dark\" && (m.colorSchemes.dark = {\n      ...u.dark !== !0 && u.dark,\n      palette: m.palette\n    }, na(m, \"light\", u.light)), m;\n  }\n  return !r && !(\"light\" in u) && c === \"light\" && (u.light = !0), Lf({\n    ...s,\n    colorSchemes: u,\n    defaultColorScheme: c,\n    ...typeof n != \"boolean\" && n\n  }, ...t);\n}\nconst gs = Fn();\nfunction Lr() {\n  const e = Fa(gs);\n  return  true && react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(e), e[wt] || e;\n}\nfunction Bf(e) {\n  return e !== \"ownerState\" && e !== \"theme\" && e !== \"sx\" && e !== \"as\";\n}\nconst ys = (e) => Bf(e) && e !== \"classes\", le = Tu({\n  themeId: wt,\n  defaultTheme: gs,\n  rootShouldForwardProp: ys\n});\nfunction oa({\n  theme: e,\n  ...t\n}) {\n  const r = wt in e ? e[wt] : void 0;\n  return /* @__PURE__ */ N.jsx(Rr, {\n    ...t,\n    themeId: r ? wt : void 0,\n    theme: r || e\n  });\n}\nconst Qr = {\n  attribute: \"data-mui-color-scheme\",\n  colorSchemeStorageKey: \"mui-color-scheme\",\n  defaultLightColorScheme: \"light\",\n  defaultDarkColorScheme: \"dark\",\n  modeStorageKey: \"mui-mode\"\n}, {\n  CssVarsProvider: Vf,\n  useColorScheme: zm,\n  getInitColorSchemeScript: Wm\n} = nf({\n  themeId: wt,\n  // @ts-ignore ignore module augmentation tests\n  theme: () => Fn({\n    cssVariables: !0\n  }),\n  colorSchemeStorageKey: Qr.colorSchemeStorageKey,\n  modeStorageKey: Qr.modeStorageKey,\n  defaultColorScheme: {\n    light: Qr.defaultLightColorScheme,\n    dark: Qr.defaultDarkColorScheme\n  },\n  resolveTheme: (e) => {\n    const t = {\n      ...e,\n      typography: fs(e.palette, e.typography)\n    };\n    return t.unstable_sx = function(n) {\n      return At({\n        sx: n,\n        theme: this\n      });\n    }, t;\n  }\n}), Ff = Vf;\nfunction zf({\n  theme: e,\n  ...t\n}) {\n  return typeof e == \"function\" ? /* @__PURE__ */ N.jsx(oa, {\n    theme: e,\n    ...t\n  }) : \"colorSchemes\" in (wt in e ? e[wt] : e) ? /* @__PURE__ */ N.jsx(Ff, {\n    theme: e,\n    ...t\n  }) : /* @__PURE__ */ N.jsx(oa, {\n    theme: e,\n    ...t\n  });\n}\nfunction Wf() {\n  return za;\n}\nconst qe = Ju;\n true && (a.node, a.object.isRequired);\nfunction He(e) {\n  return Xu(e);\n}\nfunction Uf(e) {\n  return Ve(\"MuiSvgIcon\", e);\n}\nFe(\"MuiSvgIcon\", [\"root\", \"colorPrimary\", \"colorSecondary\", \"colorAction\", \"colorError\", \"colorDisabled\", \"fontSizeInherit\", \"fontSizeSmall\", \"fontSizeMedium\", \"fontSizeLarge\"]);\nconst Yf = (e) => {\n  const {\n    color: t,\n    fontSize: r,\n    classes: n\n  } = e, o = {\n    root: [\"root\", t !== \"inherit\" && `color${ee(t)}`, `fontSize${ee(r)}`]\n  };\n  return Ge(o, Uf, n);\n}, Hf = le(\"svg\", {\n  name: \"MuiSvgIcon\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, r.color !== \"inherit\" && t[`color${ee(r.color)}`], t[`fontSize${ee(r.fontSize)}`]];\n  }\n})(qe(({\n  theme: e\n}) => {\n  var t, r, n, o, i, s, c, l, u, p, m, g, x, y;\n  return {\n    userSelect: \"none\",\n    width: \"1em\",\n    height: \"1em\",\n    display: \"inline-block\",\n    flexShrink: 0,\n    transition: (o = (t = e.transitions) == null ? void 0 : t.create) == null ? void 0 : o.call(t, \"fill\", {\n      duration: (n = (r = (e.vars ?? e).transitions) == null ? void 0 : r.duration) == null ? void 0 : n.shorter\n    }),\n    variants: [\n      {\n        props: (f) => !f.hasSvgAsChild,\n        style: {\n          // the <svg> will define the property that has `currentColor`\n          // for example heroicons uses fill=\"none\" and stroke=\"currentColor\"\n          fill: \"currentColor\"\n        }\n      },\n      {\n        props: {\n          fontSize: \"inherit\"\n        },\n        style: {\n          fontSize: \"inherit\"\n        }\n      },\n      {\n        props: {\n          fontSize: \"small\"\n        },\n        style: {\n          fontSize: ((s = (i = e.typography) == null ? void 0 : i.pxToRem) == null ? void 0 : s.call(i, 20)) || \"1.25rem\"\n        }\n      },\n      {\n        props: {\n          fontSize: \"medium\"\n        },\n        style: {\n          fontSize: ((l = (c = e.typography) == null ? void 0 : c.pxToRem) == null ? void 0 : l.call(c, 24)) || \"1.5rem\"\n        }\n      },\n      {\n        props: {\n          fontSize: \"large\"\n        },\n        style: {\n          fontSize: ((p = (u = e.typography) == null ? void 0 : u.pxToRem) == null ? void 0 : p.call(u, 35)) || \"2.1875rem\"\n        }\n      },\n      // TODO v5 deprecate color prop, v6 remove for sx\n      ...Object.entries((e.vars ?? e).palette).filter(([, f]) => f && f.main).map(([f]) => {\n        var S, E;\n        return {\n          props: {\n            color: f\n          },\n          style: {\n            color: (E = (S = (e.vars ?? e).palette) == null ? void 0 : S[f]) == null ? void 0 : E.main\n          }\n        };\n      }),\n      {\n        props: {\n          color: \"action\"\n        },\n        style: {\n          color: (g = (m = (e.vars ?? e).palette) == null ? void 0 : m.action) == null ? void 0 : g.active\n        }\n      },\n      {\n        props: {\n          color: \"disabled\"\n        },\n        style: {\n          color: (y = (x = (e.vars ?? e).palette) == null ? void 0 : x.action) == null ? void 0 : y.disabled\n        }\n      },\n      {\n        props: {\n          color: \"inherit\"\n        },\n        style: {\n          color: void 0\n        }\n      }\n    ]\n  };\n})), yn = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiSvgIcon\"\n  }), {\n    children: o,\n    className: i,\n    color: s = \"inherit\",\n    component: c = \"svg\",\n    fontSize: l = \"medium\",\n    htmlColor: u,\n    inheritViewBox: p = !1,\n    titleAccess: m,\n    viewBox: g = \"0 0 24 24\",\n    ...x\n  } = n, y = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(o) && o.type === \"svg\", f = {\n    ...n,\n    color: s,\n    component: c,\n    fontSize: l,\n    instanceFontSize: t.fontSize,\n    inheritViewBox: p,\n    viewBox: g,\n    hasSvgAsChild: y\n  }, S = {};\n  p || (S.viewBox = g);\n  const E = Yf(f);\n  return /* @__PURE__ */ N.jsxs(Hf, {\n    as: c,\n    className: se(E.root, i),\n    focusable: \"false\",\n    color: u,\n    \"aria-hidden\": m ? void 0 : !0,\n    role: m ? \"img\" : void 0,\n    ref: r,\n    ...S,\n    ...x,\n    ...y && o.props,\n    ownerState: f,\n    children: [y ? o.props.children : o, m ? /* @__PURE__ */ N.jsx(\"title\", {\n      children: m\n    }) : null]\n  });\n});\n true && (yn.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Node passed into the SVG element.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.\n   * @default 'inherit'\n   */\n  color: a.oneOfType([a.oneOf([\"inherit\", \"action\", \"disabled\", \"primary\", \"secondary\", \"error\", \"info\", \"success\", \"warning\"]), a.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.\n   * @default 'medium'\n   */\n  fontSize: a.oneOfType([a.oneOf([\"inherit\", \"large\", \"medium\", \"small\"]), a.string]),\n  /**\n   * Applies a color attribute to the SVG element.\n   */\n  htmlColor: a.string,\n  /**\n   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`\n   * prop will be ignored.\n   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that\n   * `component`'s viewBox to the root node.\n   * @default false\n   */\n  inheritViewBox: a.bool,\n  /**\n   * The shape-rendering attribute. The behavior of the different options is described on the\n   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).\n   * If you are having issues with blurry icons you should investigate this prop.\n   */\n  shapeRendering: a.string,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * Provides a human-readable title for the element that contains it.\n   * https://www.w3.org/TR/SVG-access/#Equivalent\n   */\n  titleAccess: a.string,\n  /**\n   * Allows you to redefine what the coordinates without units mean inside an SVG element.\n   * For example, if the SVG element is 500 (width) by 200 (height),\n   * and you pass viewBox=\"0 0 50 20\",\n   * this means that the coordinates inside the SVG will go from the top left corner (0,0)\n   * to bottom right (50,20) and each unit will be worth 10px.\n   * @default '0 0 24 24'\n   */\n  viewBox: a.string\n});\nyn.muiName = \"SvgIcon\";\nfunction sr(e, t) {\n  function r(n, o) {\n    return /* @__PURE__ */ N.jsx(yn, {\n      \"data-testid\": `${t}Icon`,\n      ref: o,\n      ...n,\n      children: e\n    });\n  }\n  return  true && (r.displayName = `${t}Icon`), r.muiName = yn.muiName, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.memo(/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(r));\n}\nfunction bs(e, t) {\n  if (e == null) return {};\n  var r = {};\n  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {\n    if (t.includes(n)) continue;\n    r[n] = e[n];\n  }\n  return r;\n}\nfunction po(e, t) {\n  return po = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {\n    return r.__proto__ = n, r;\n  }, po(e, t);\n}\nfunction vs(e, t) {\n  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, po(e, t);\n}\nconst ia = {\n  disabled: !1\n};\nvar qf =  true ? a.oneOfType([a.number, a.shape({\n  enter: a.number,\n  exit: a.number,\n  appear: a.number\n}).isRequired]) : 0;\n true && a.oneOfType([a.string, a.shape({\n  enter: a.string,\n  exit: a.string,\n  active: a.string\n}), a.shape({\n  enter: a.string,\n  enterDone: a.string,\n  enterActive: a.string,\n  exit: a.string,\n  exitDone: a.string,\n  exitActive: a.string\n})]);\nconst bn = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar Gf = function(t) {\n  return t.scrollTop;\n}, br = \"unmounted\", _t = \"exited\", jt = \"entering\", Kt = \"entered\", mo = \"exiting\", Et = /* @__PURE__ */ function(e) {\n  vs(t, e);\n  function t(n, o) {\n    var i;\n    i = e.call(this, n, o) || this;\n    var s = o, c = s && !s.isMounting ? n.enter : n.appear, l;\n    return i.appearStatus = null, n.in ? c ? (l = _t, i.appearStatus = jt) : l = Kt : n.unmountOnExit || n.mountOnEnter ? l = br : l = _t, i.state = {\n      status: l\n    }, i.nextCallback = null, i;\n  }\n  t.getDerivedStateFromProps = function(o, i) {\n    var s = o.in;\n    return s && i.status === br ? {\n      status: _t\n    } : null;\n  };\n  var r = t.prototype;\n  return r.componentDidMount = function() {\n    this.updateStatus(!0, this.appearStatus);\n  }, r.componentDidUpdate = function(o) {\n    var i = null;\n    if (o !== this.props) {\n      var s = this.state.status;\n      this.props.in ? s !== jt && s !== Kt && (i = jt) : (s === jt || s === Kt) && (i = mo);\n    }\n    this.updateStatus(!1, i);\n  }, r.componentWillUnmount = function() {\n    this.cancelNextCallback();\n  }, r.getTimeouts = function() {\n    var o = this.props.timeout, i, s, c;\n    return i = s = c = o, o != null && typeof o != \"number\" && (i = o.exit, s = o.enter, c = o.appear !== void 0 ? o.appear : s), {\n      exit: i,\n      enter: s,\n      appear: c\n    };\n  }, r.updateStatus = function(o, i) {\n    if (o === void 0 && (o = !1), i !== null)\n      if (this.cancelNextCallback(), i === jt) {\n        if (this.props.unmountOnExit || this.props.mountOnEnter) {\n          var s = this.props.nodeRef ? this.props.nodeRef.current : react_dom__WEBPACK_IMPORTED_MODULE_1__.findDOMNode(this);\n          s && Gf(s);\n        }\n        this.performEnter(o);\n      } else\n        this.performExit();\n    else this.props.unmountOnExit && this.state.status === _t && this.setState({\n      status: br\n    });\n  }, r.performEnter = function(o) {\n    var i = this, s = this.props.enter, c = this.context ? this.context.isMounting : o, l = this.props.nodeRef ? [c] : [react_dom__WEBPACK_IMPORTED_MODULE_1__.findDOMNode(this), c], u = l[0], p = l[1], m = this.getTimeouts(), g = c ? m.appear : m.enter;\n    if (!o && !s || ia.disabled) {\n      this.safeSetState({\n        status: Kt\n      }, function() {\n        i.props.onEntered(u);\n      });\n      return;\n    }\n    this.props.onEnter(u, p), this.safeSetState({\n      status: jt\n    }, function() {\n      i.props.onEntering(u, p), i.onTransitionEnd(g, function() {\n        i.safeSetState({\n          status: Kt\n        }, function() {\n          i.props.onEntered(u, p);\n        });\n      });\n    });\n  }, r.performExit = function() {\n    var o = this, i = this.props.exit, s = this.getTimeouts(), c = this.props.nodeRef ? void 0 : react_dom__WEBPACK_IMPORTED_MODULE_1__.findDOMNode(this);\n    if (!i || ia.disabled) {\n      this.safeSetState({\n        status: _t\n      }, function() {\n        o.props.onExited(c);\n      });\n      return;\n    }\n    this.props.onExit(c), this.safeSetState({\n      status: mo\n    }, function() {\n      o.props.onExiting(c), o.onTransitionEnd(s.exit, function() {\n        o.safeSetState({\n          status: _t\n        }, function() {\n          o.props.onExited(c);\n        });\n      });\n    });\n  }, r.cancelNextCallback = function() {\n    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);\n  }, r.safeSetState = function(o, i) {\n    i = this.setNextCallback(i), this.setState(o, i);\n  }, r.setNextCallback = function(o) {\n    var i = this, s = !0;\n    return this.nextCallback = function(c) {\n      s && (s = !1, i.nextCallback = null, o(c));\n    }, this.nextCallback.cancel = function() {\n      s = !1;\n    }, this.nextCallback;\n  }, r.onTransitionEnd = function(o, i) {\n    this.setNextCallback(i);\n    var s = this.props.nodeRef ? this.props.nodeRef.current : react_dom__WEBPACK_IMPORTED_MODULE_1__.findDOMNode(this), c = o == null && !this.props.addEndListener;\n    if (!s || c) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n    if (this.props.addEndListener) {\n      var l = this.props.nodeRef ? [this.nextCallback] : [s, this.nextCallback], u = l[0], p = l[1];\n      this.props.addEndListener(u, p);\n    }\n    o != null && setTimeout(this.nextCallback, o);\n  }, r.render = function() {\n    var o = this.state.status;\n    if (o === br)\n      return null;\n    var i = this.props, s = i.children;\n    i.in, i.mountOnEnter, i.unmountOnExit, i.appear, i.enter, i.exit, i.timeout, i.addEndListener, i.onEnter, i.onEntering, i.onEntered, i.onExit, i.onExiting, i.onExited, i.nodeRef;\n    var c = bs(i, [\"children\", \"in\", \"mountOnEnter\", \"unmountOnExit\", \"appear\", \"enter\", \"exit\", \"timeout\", \"addEndListener\", \"onEnter\", \"onEntering\", \"onEntered\", \"onExit\", \"onExiting\", \"onExited\", \"nodeRef\"]);\n    return (\n      // allows for nested Transitions\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(bn.Provider, {\n        value: null\n      }, typeof s == \"function\" ? s(o, c) : react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(react__WEBPACK_IMPORTED_MODULE_0__.Children.only(s), c))\n    );\n  }, t;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nEt.contextType = bn;\nEt.propTypes =  true ? {\n  /**\n   * A React reference to DOM element that need to transition:\n   * https://stackoverflow.com/a/51127130/4671932\n   *\n   *   - When `nodeRef` prop is used, `node` is not passed to callback functions\n   *      (e.g. `onEnter`) because user already has direct access to the node.\n   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new\n   *     `nodeRef` need to be provided to `Transition` with changed `key` prop\n   *     (see\n   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).\n   */\n  nodeRef: a.shape({\n    current: typeof Element > \"u\" ? a.any : function(e, t, r, n, o, i) {\n      var s = e[t];\n      return a.instanceOf(s && \"ownerDocument\" in s ? s.ownerDocument.defaultView.Element : Element)(e, t, r, n, o, i);\n    }\n  }),\n  /**\n   * A `function` child can be used instead of a React element. This function is\n   * called with the current transition status (`'entering'`, `'entered'`,\n   * `'exiting'`, `'exited'`), which can be used to apply context\n   * specific props to a component.\n   *\n   * ```jsx\n   * <Transition in={this.state.in} timeout={150}>\n   *   {state => (\n   *     <MyComponent className={`fade fade-${state}`} />\n   *   )}\n   * </Transition>\n   * ```\n   */\n  children: a.oneOfType([a.func.isRequired, a.element.isRequired]).isRequired,\n  /**\n   * Show the component; triggers the enter or exit states\n   */\n  in: a.bool,\n  /**\n   * By default the child component is mounted immediately along with\n   * the parent `Transition` component. If you want to \"lazy mount\" the component on the\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\n   * mounted, even on \"exited\", unless you also specify `unmountOnExit`.\n   */\n  mountOnEnter: a.bool,\n  /**\n   * By default the child component stays mounted after it reaches the `'exited'` state.\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\n   */\n  unmountOnExit: a.bool,\n  /**\n   * By default the child component does not perform the enter transition when\n   * it first mounts, regardless of the value of `in`. If you want this\n   * behavior, set both `appear` and `in` to `true`.\n   *\n   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop\n   * > only adds an additional enter transition. However, in the\n   * > `<CSSTransition>` component that first enter transition does result in\n   * > additional `.appear-*` classes, that way you can choose to style it\n   * > differently.\n   */\n  appear: a.bool,\n  /**\n   * Enable or disable enter transitions.\n   */\n  enter: a.bool,\n  /**\n   * Enable or disable exit transitions.\n   */\n  exit: a.bool,\n  /**\n   * The duration of the transition, in milliseconds.\n   * Required unless `addEndListener` is provided.\n   *\n   * You may specify a single timeout for all transitions:\n   *\n   * ```jsx\n   * timeout={500}\n   * ```\n   *\n   * or individually:\n   *\n   * ```jsx\n   * timeout={{\n   *  appear: 500,\n   *  enter: 300,\n   *  exit: 500,\n   * }}\n   * ```\n   *\n   * - `appear` defaults to the value of `enter`\n   * - `enter` defaults to `0`\n   * - `exit` defaults to `0`\n   *\n   * @type {number | { enter?: number, exit?: number, appear?: number }}\n   */\n  timeout: function(t) {\n    var r = qf;\n    t.addEndListener || (r = r.isRequired);\n    for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)\n      o[i - 1] = arguments[i];\n    return r.apply(void 0, [t].concat(o));\n  },\n  /**\n   * Add a custom transition end trigger. Called with the transitioning\n   * DOM node and a `done` callback. Allows for more fine grained transition end\n   * logic. Timeouts are still used as a fallback if provided.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * ```jsx\n   * addEndListener={(node, done) => {\n   *   // use the css transitionend event to mark the finish of a transition\n   *   node.addEventListener('transitionend', done, false);\n   * }}\n   * ```\n   */\n  addEndListener: a.func,\n  /**\n   * Callback fired before the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEnter: a.func,\n  /**\n   * Callback fired after the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: a.func,\n  /**\n   * Callback fired after the \"entered\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEntered: a.func,\n  /**\n   * Callback fired before the \"exiting\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExit: a.func,\n  /**\n   * Callback fired after the \"exiting\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExiting: a.func,\n  /**\n   * Callback fired after the \"exited\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExited: a.func\n} : 0;\nfunction Gt() {\n}\nEt.defaultProps = {\n  in: !1,\n  mountOnEnter: !1,\n  unmountOnExit: !1,\n  appear: !1,\n  enter: !0,\n  exit: !0,\n  onEnter: Gt,\n  onEntering: Gt,\n  onEntered: Gt,\n  onExit: Gt,\n  onExiting: Gt,\n  onExited: Gt\n};\nEt.UNMOUNTED = br;\nEt.EXITED = _t;\nEt.ENTERING = jt;\nEt.ENTERED = Kt;\nEt.EXITING = mo;\nfunction Kf(e) {\n  if (e === void 0) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction Yo(e, t) {\n  var r = function(i) {\n    return t && (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(i) ? t(i) : i;\n  }, n = /* @__PURE__ */ Object.create(null);\n  return e && react__WEBPACK_IMPORTED_MODULE_0__.Children.map(e, function(o) {\n    return o;\n  }).forEach(function(o) {\n    n[o.key] = r(o);\n  }), n;\n}\nfunction Xf(e, t) {\n  e = e || {}, t = t || {};\n  function r(p) {\n    return p in t ? t[p] : e[p];\n  }\n  var n = /* @__PURE__ */ Object.create(null), o = [];\n  for (var i in e)\n    i in t ? o.length && (n[i] = o, o = []) : o.push(i);\n  var s, c = {};\n  for (var l in t) {\n    if (n[l])\n      for (s = 0; s < n[l].length; s++) {\n        var u = n[l][s];\n        c[n[l][s]] = r(u);\n      }\n    c[l] = r(l);\n  }\n  for (s = 0; s < o.length; s++)\n    c[o[s]] = r(o[s]);\n  return c;\n}\nfunction Lt(e, t, r) {\n  return r[t] != null ? r[t] : e.props[t];\n}\nfunction Jf(e, t) {\n  return Yo(e.children, function(r) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(r, {\n      onExited: t.bind(null, r),\n      in: !0,\n      appear: Lt(r, \"appear\", e),\n      enter: Lt(r, \"enter\", e),\n      exit: Lt(r, \"exit\", e)\n    });\n  });\n}\nfunction Qf(e, t, r) {\n  var n = Yo(e.children), o = Xf(t, n);\n  return Object.keys(o).forEach(function(i) {\n    var s = o[i];\n    if ((0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(s)) {\n      var c = i in t, l = i in n, u = t[i], p = (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(u) && !u.props.in;\n      l && (!c || p) ? o[i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(s, {\n        onExited: r.bind(null, s),\n        in: !0,\n        exit: Lt(s, \"exit\", e),\n        enter: Lt(s, \"enter\", e)\n      }) : !l && c && !p ? o[i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(s, {\n        in: !1\n      }) : l && c && (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(u) && (o[i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(s, {\n        onExited: r.bind(null, s),\n        in: u.props.in,\n        exit: Lt(s, \"exit\", e),\n        enter: Lt(s, \"enter\", e)\n      }));\n    }\n  }), o;\n}\nvar Zf = Object.values || function(e) {\n  return Object.keys(e).map(function(t) {\n    return e[t];\n  });\n}, ed = {\n  component: \"div\",\n  childFactory: function(t) {\n    return t;\n  }\n}, Ho = /* @__PURE__ */ function(e) {\n  vs(t, e);\n  function t(n, o) {\n    var i;\n    i = e.call(this, n, o) || this;\n    var s = i.handleExited.bind(Kf(i));\n    return i.state = {\n      contextValue: {\n        isMounting: !0\n      },\n      handleExited: s,\n      firstRender: !0\n    }, i;\n  }\n  var r = t.prototype;\n  return r.componentDidMount = function() {\n    this.mounted = !0, this.setState({\n      contextValue: {\n        isMounting: !1\n      }\n    });\n  }, r.componentWillUnmount = function() {\n    this.mounted = !1;\n  }, t.getDerivedStateFromProps = function(o, i) {\n    var s = i.children, c = i.handleExited, l = i.firstRender;\n    return {\n      children: l ? Jf(o, c) : Qf(o, s, c),\n      firstRender: !1\n    };\n  }, r.handleExited = function(o, i) {\n    var s = Yo(this.props.children);\n    o.key in s || (o.props.onExited && o.props.onExited(i), this.mounted && this.setState(function(c) {\n      var l = fn({}, c.children);\n      return delete l[o.key], {\n        children: l\n      };\n    }));\n  }, r.render = function() {\n    var o = this.props, i = o.component, s = o.childFactory, c = bs(o, [\"component\", \"childFactory\"]), l = this.state.contextValue, u = Zf(this.state.children).map(s);\n    return delete c.appear, delete c.enter, delete c.exit, i === null ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(bn.Provider, {\n      value: l\n    }, u) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(bn.Provider, {\n      value: l\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(i, c, u));\n  }, t;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nHo.propTypes =  true ? {\n  /**\n   * `<TransitionGroup>` renders a `<div>` by default. You can change this\n   * behavior by providing a `component` prop.\n   * If you use React v16+ and would like to avoid a wrapping `<div>` element\n   * you can pass in `component={null}`. This is useful if the wrapping div\n   * borks your css styles.\n   */\n  component: a.any,\n  /**\n   * A set of `<Transition>` components, that are toggled `in` and out as they\n   * leave. the `<TransitionGroup>` will inject specific transition props, so\n   * remember to spread them through if you are wrapping the `<Transition>` as\n   * with our `<Fade>` example.\n   *\n   * While this component is meant for multiple `Transition` or `CSSTransition`\n   * children, sometimes you may want to have a single transition child with\n   * content that you want to be transitioned out and in when you change it\n   * (e.g. routes, images etc.) In that case you can change the `key` prop of\n   * the transition child as you change its content, this will cause\n   * `TransitionGroup` to transition the child out and back in.\n   */\n  children: a.node,\n  /**\n   * A convenience prop that enables or disables appear animations\n   * for all children. Note that specifying this will override any defaults set\n   * on individual children Transitions.\n   */\n  appear: a.bool,\n  /**\n   * A convenience prop that enables or disables enter animations\n   * for all children. Note that specifying this will override any defaults set\n   * on individual children Transitions.\n   */\n  enter: a.bool,\n  /**\n   * A convenience prop that enables or disables exit animations\n   * for all children. Note that specifying this will override any defaults set\n   * on individual children Transitions.\n   */\n  exit: a.bool,\n  /**\n   * You may need to apply reactive updates to a child as it is exiting.\n   * This is generally done by using `cloneElement` however in the case of an exiting\n   * child the element has already been removed and not accessible to the consumer.\n   *\n   * If you do need to update a child as it leaves you can provide a `childFactory`\n   * to wrap every child, even the ones that are leaving.\n   *\n   * @type Function(child: ReactElement) -> ReactElement\n   */\n  childFactory: a.func\n} : 0;\nHo.defaultProps = ed;\nconst td = (e) => e.scrollTop;\nfunction vn(e, t) {\n  const {\n    timeout: r,\n    easing: n,\n    style: o = {}\n  } = e;\n  return {\n    duration: o.transitionDuration ?? (typeof r == \"number\" ? r : r[t.mode] || 0),\n    easing: o.transitionTimingFunction ?? (typeof n == \"object\" ? n[t.mode] : n),\n    delay: o.transitionDelay\n  };\n}\nfunction rd(e) {\n  return Ve(\"MuiCollapse\", e);\n}\nFe(\"MuiCollapse\", [\"root\", \"horizontal\", \"vertical\", \"entered\", \"hidden\", \"wrapper\", \"wrapperInner\"]);\nconst nd = (e) => {\n  const {\n    orientation: t,\n    classes: r\n  } = e, n = {\n    root: [\"root\", `${t}`],\n    entered: [\"entered\"],\n    hidden: [\"hidden\"],\n    wrapper: [\"wrapper\", `${t}`],\n    wrapperInner: [\"wrapperInner\", `${t}`]\n  };\n  return Ge(n, rd, r);\n}, od = le(\"div\", {\n  name: \"MuiCollapse\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, t[r.orientation], r.state === \"entered\" && t.entered, r.state === \"exited\" && !r.in && r.collapsedSize === \"0px\" && t.hidden];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  height: 0,\n  overflow: \"hidden\",\n  transition: e.transitions.create(\"height\"),\n  variants: [{\n    props: {\n      orientation: \"horizontal\"\n    },\n    style: {\n      height: \"auto\",\n      width: 0,\n      transition: e.transitions.create(\"width\")\n    }\n  }, {\n    props: {\n      state: \"entered\"\n    },\n    style: {\n      height: \"auto\",\n      overflow: \"visible\"\n    }\n  }, {\n    props: {\n      state: \"entered\",\n      orientation: \"horizontal\"\n    },\n    style: {\n      width: \"auto\"\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.state === \"exited\" && !t.in && t.collapsedSize === \"0px\",\n    style: {\n      visibility: \"hidden\"\n    }\n  }]\n}))), id = le(\"div\", {\n  name: \"MuiCollapse\",\n  slot: \"Wrapper\",\n  overridesResolver: (e, t) => t.wrapper\n})({\n  // Hack to get children with a negative margin to not falsify the height computation.\n  display: \"flex\",\n  width: \"100%\",\n  variants: [{\n    props: {\n      orientation: \"horizontal\"\n    },\n    style: {\n      width: \"auto\",\n      height: \"100%\"\n    }\n  }]\n}), ad = le(\"div\", {\n  name: \"MuiCollapse\",\n  slot: \"WrapperInner\",\n  overridesResolver: (e, t) => t.wrapperInner\n})({\n  width: \"100%\",\n  variants: [{\n    props: {\n      orientation: \"horizontal\"\n    },\n    style: {\n      width: \"auto\",\n      height: \"100%\"\n    }\n  }]\n}), xn = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiCollapse\"\n  }), {\n    addEndListener: o,\n    children: i,\n    className: s,\n    collapsedSize: c = \"0px\",\n    component: l,\n    easing: u,\n    in: p,\n    onEnter: m,\n    onEntered: g,\n    onEntering: x,\n    onExit: y,\n    onExited: f,\n    onExiting: S,\n    orientation: E = \"vertical\",\n    style: P,\n    timeout: T = ds.standard,\n    // eslint-disable-next-line react/prop-types\n    TransitionComponent: b = Et,\n    ...h\n  } = n, w = {\n    ...n,\n    orientation: E,\n    collapsedSize: c\n  }, k = nd(w), L = Lr(), B = Dt(), d = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), A = react__WEBPACK_IMPORTED_MODULE_0__.useRef(), D = typeof c == \"number\" ? `${c}px` : c, j = E === \"horizontal\", W = j ? \"width\" : \"height\", z = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), U = at(r, z), V = (_) => (q) => {\n    if (_) {\n      const G = z.current;\n      q === void 0 ? _(G) : _(G, q);\n    }\n  }, te = () => d.current ? d.current[j ? \"clientWidth\" : \"clientHeight\"] : 0, F = V((_, q) => {\n    d.current && j && (d.current.style.position = \"absolute\"), _.style[W] = D, m && m(_, q);\n  }), R = V((_, q) => {\n    const G = te();\n    d.current && j && (d.current.style.position = \"\");\n    const {\n      duration: re,\n      easing: Z\n    } = vn({\n      style: P,\n      timeout: T,\n      easing: u\n    }, {\n      mode: \"enter\"\n    });\n    if (T === \"auto\") {\n      const ae = L.transitions.getAutoHeightDuration(G);\n      _.style.transitionDuration = `${ae}ms`, A.current = ae;\n    } else\n      _.style.transitionDuration = typeof re == \"string\" ? re : `${re}ms`;\n    _.style[W] = `${G}px`, _.style.transitionTimingFunction = Z, x && x(_, q);\n  }), I = V((_, q) => {\n    _.style[W] = \"auto\", g && g(_, q);\n  }), J = V((_) => {\n    _.style[W] = `${te()}px`, y && y(_);\n  }), Q = V(f), H = V((_) => {\n    const q = te(), {\n      duration: G,\n      easing: re\n    } = vn({\n      style: P,\n      timeout: T,\n      easing: u\n    }, {\n      mode: \"exit\"\n    });\n    if (T === \"auto\") {\n      const Z = L.transitions.getAutoHeightDuration(q);\n      _.style.transitionDuration = `${Z}ms`, A.current = Z;\n    } else\n      _.style.transitionDuration = typeof G == \"string\" ? G : `${G}ms`;\n    _.style[W] = D, _.style.transitionTimingFunction = re, S && S(_);\n  }), X = (_) => {\n    T === \"auto\" && B.start(A.current || 0, _), o && o(z.current, _);\n  };\n  return /* @__PURE__ */ N.jsx(b, {\n    in: p,\n    onEnter: F,\n    onEntered: I,\n    onEntering: R,\n    onExit: J,\n    onExited: Q,\n    onExiting: H,\n    addEndListener: X,\n    nodeRef: z,\n    timeout: T === \"auto\" ? null : T,\n    ...h,\n    children: (_, {\n      ownerState: q,\n      ...G\n    }) => /* @__PURE__ */ N.jsx(od, {\n      as: l,\n      className: se(k.root, s, {\n        entered: k.entered,\n        exited: !p && D === \"0px\" && k.hidden\n      }[_]),\n      style: {\n        [j ? \"minWidth\" : \"minHeight\"]: D,\n        ...P\n      },\n      ref: U,\n      ownerState: {\n        ...w,\n        state: _\n      },\n      ...G,\n      children: /* @__PURE__ */ N.jsx(id, {\n        ownerState: {\n          ...w,\n          state: _\n        },\n        className: k.wrapper,\n        ref: d,\n        children: /* @__PURE__ */ N.jsx(ad, {\n          ownerState: {\n            ...w,\n            state: _\n          },\n          className: k.wrapperInner,\n          children: i\n        })\n      })\n    })\n  });\n});\n true && (xn.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Add a custom transition end trigger. Called with the transitioning DOM\n   * node and a done callback. Allows for more fine grained transition end\n   * logic. Note: Timeouts are still used as a fallback if provided.\n   */\n  addEndListener: a.func,\n  /**\n   * The content node to be collapsed.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The width (horizontal) or height (vertical) of the container when collapsed.\n   * @default '0px'\n   */\n  collapsedSize: a.oneOfType([a.number, a.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: Ja,\n  /**\n   * The transition timing function.\n   * You may specify a single easing or a object containing enter and exit values.\n   */\n  easing: a.oneOfType([a.shape({\n    enter: a.string,\n    exit: a.string\n  }), a.string]),\n  /**\n   * If `true`, the component will transition in.\n   */\n  in: a.bool,\n  /**\n   * @ignore\n   */\n  onEnter: a.func,\n  /**\n   * @ignore\n   */\n  onEntered: a.func,\n  /**\n   * @ignore\n   */\n  onEntering: a.func,\n  /**\n   * @ignore\n   */\n  onExit: a.func,\n  /**\n   * @ignore\n   */\n  onExited: a.func,\n  /**\n   * @ignore\n   */\n  onExiting: a.func,\n  /**\n   * The transition orientation.\n   * @default 'vertical'\n   */\n  orientation: a.oneOf([\"horizontal\", \"vertical\"]),\n  /**\n   * @ignore\n   */\n  style: a.object,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   *\n   * Set to 'auto' to automatically calculate transition time based on height.\n   * @default duration.standard\n   */\n  timeout: a.oneOfType([a.oneOf([\"auto\"]), a.number, a.shape({\n    appear: a.number,\n    enter: a.number,\n    exit: a.number\n  })])\n});\nxn && (xn.muiSupportAuto = !0);\nfunction Bt(e, t) {\n  const {\n    className: r,\n    elementType: n,\n    ownerState: o,\n    externalForwardedProps: i,\n    internalForwardedProps: s,\n    shouldForwardComponentProp: c = !1,\n    ...l\n  } = t, {\n    component: u,\n    slots: p = {\n      [e]: void 0\n    },\n    slotProps: m = {\n      [e]: void 0\n    },\n    ...g\n  } = i, x = p[e] || n, y = rs(m[e], o), {\n    props: {\n      component: f,\n      ...S\n    },\n    internalRef: E\n  } = ts({\n    className: r,\n    ...l,\n    externalForwardedProps: e === \"root\" ? g : void 0,\n    externalSlotProps: y\n  }), P = at(E, y == null ? void 0 : y.ref, t.ref), T = e === \"root\" ? f || u : f, b = es(x, {\n    ...e === \"root\" && !u && !p[e] && s,\n    ...e !== \"root\" && !p[e] && s,\n    ...S,\n    ...T && !c && {\n      as: T\n    },\n    ...T && c && {\n      component: T\n    },\n    ref: P\n  }, o);\n  return [x, b];\n}\nclass Sn {\n  constructor() {\n    cr(this, \"mountEffect\", () => {\n      this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());\n    });\n    this.ref = {\n      current: null\n    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;\n  }\n  /** React ref to the ripple instance */\n  /** If the ripple component should be mounted */\n  /** Promise that resolves when the ripple component is mounted */\n  /** If the ripple component has been mounted */\n  /** React state hook setter */\n  static create() {\n    return new Sn();\n  }\n  static use() {\n    const t = Za(Sn.create).current, [r, n] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1);\n    return t.shouldMount = r, t.setShouldMount = n, react__WEBPACK_IMPORTED_MODULE_0__.useEffect(t.mountEffect, [r]), t;\n  }\n  mount() {\n    return this.mounted || (this.mounted = cd(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;\n  }\n  /* Ripple API */\n  start(...t) {\n    this.mount().then(() => {\n      var r;\n      return (r = this.ref.current) == null ? void 0 : r.start(...t);\n    });\n  }\n  stop(...t) {\n    this.mount().then(() => {\n      var r;\n      return (r = this.ref.current) == null ? void 0 : r.stop(...t);\n    });\n  }\n  pulsate(...t) {\n    this.mount().then(() => {\n      var r;\n      return (r = this.ref.current) == null ? void 0 : r.pulsate(...t);\n    });\n  }\n}\nfunction sd() {\n  return Sn.use();\n}\nfunction cd() {\n  let e, t;\n  const r = new Promise((n, o) => {\n    e = n, t = o;\n  });\n  return r.resolve = e, r.reject = t, r;\n}\nfunction xs(e) {\n  const {\n    className: t,\n    classes: r,\n    pulsate: n = !1,\n    rippleX: o,\n    rippleY: i,\n    rippleSize: s,\n    in: c,\n    onExited: l,\n    timeout: u\n  } = e, [p, m] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1), g = se(t, r.ripple, r.rippleVisible, n && r.ripplePulsate), x = {\n    width: s,\n    height: s,\n    top: -(s / 2) + i,\n    left: -(s / 2) + o\n  }, y = se(r.child, p && r.childLeaving, n && r.childPulsate);\n  return !c && !p && m(!0), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!c && l != null) {\n      const f = setTimeout(l, u);\n      return () => {\n        clearTimeout(f);\n      };\n    }\n  }, [l, c, u]), /* @__PURE__ */ N.jsx(\"span\", {\n    className: g,\n    style: x,\n    children: /* @__PURE__ */ N.jsx(\"span\", {\n      className: y\n    })\n  });\n}\n true && (xs.propTypes = {\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object.isRequired,\n  className: a.string,\n  /**\n   * @ignore - injected from TransitionGroup\n   */\n  in: a.bool,\n  /**\n   * @ignore - injected from TransitionGroup\n   */\n  onExited: a.func,\n  /**\n   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.\n   */\n  pulsate: a.bool,\n  /**\n   * Diameter of the ripple.\n   */\n  rippleSize: a.number,\n  /**\n   * Horizontal position of the ripple center.\n   */\n  rippleX: a.number,\n  /**\n   * Vertical position of the ripple center.\n   */\n  rippleY: a.number,\n  /**\n   * exit delay\n   */\n  timeout: a.number.isRequired\n});\nconst nt = Fe(\"MuiTouchRipple\", [\"root\", \"ripple\", \"rippleVisible\", \"ripplePulsate\", \"child\", \"childLeaving\", \"childPulsate\"]), ho = 550, ld = 80, ud = Ir`\n  0% {\n    transform: scale(0);\n    opacity: 0.1;\n  }\n\n  100% {\n    transform: scale(1);\n    opacity: 0.3;\n  }\n`, fd = Ir`\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n`, dd = Ir`\n  0% {\n    transform: scale(1);\n  }\n\n  50% {\n    transform: scale(0.92);\n  }\n\n  100% {\n    transform: scale(1);\n  }\n`, pd = le(\"span\", {\n  name: \"MuiTouchRipple\",\n  slot: \"Root\"\n})({\n  overflow: \"hidden\",\n  pointerEvents: \"none\",\n  position: \"absolute\",\n  zIndex: 0,\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n  borderRadius: \"inherit\"\n}), md = le(xs, {\n  name: \"MuiTouchRipple\",\n  slot: \"Ripple\"\n})`\n  opacity: 0;\n  position: absolute;\n\n  &.${nt.rippleVisible} {\n    opacity: 0.3;\n    transform: scale(1);\n    animation-name: ${ud};\n    animation-duration: ${ho}ms;\n    animation-timing-function: ${({\n  theme: e\n}) => e.transitions.easing.easeInOut};\n  }\n\n  &.${nt.ripplePulsate} {\n    animation-duration: ${({\n  theme: e\n}) => e.transitions.duration.shorter}ms;\n  }\n\n  & .${nt.child} {\n    opacity: 1;\n    display: block;\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    background-color: currentColor;\n  }\n\n  & .${nt.childLeaving} {\n    opacity: 0;\n    animation-name: ${fd};\n    animation-duration: ${ho}ms;\n    animation-timing-function: ${({\n  theme: e\n}) => e.transitions.easing.easeInOut};\n  }\n\n  & .${nt.childPulsate} {\n    position: absolute;\n    /* @noflip */\n    left: 0px;\n    top: 0;\n    animation-name: ${dd};\n    animation-duration: 2500ms;\n    animation-timing-function: ${({\n  theme: e\n}) => e.transitions.easing.easeInOut};\n    animation-iteration-count: infinite;\n    animation-delay: 200ms;\n  }\n`, Ss = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiTouchRipple\"\n  }), {\n    center: o = !1,\n    classes: i = {},\n    className: s,\n    ...c\n  } = n, [l, u] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]), p = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0), m = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    m.current && (m.current(), m.current = null);\n  }, [l]);\n  const g = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!1), x = Dt(), y = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), f = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), S = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((b) => {\n    const {\n      pulsate: h,\n      rippleX: w,\n      rippleY: k,\n      rippleSize: L,\n      cb: B\n    } = b;\n    u((d) => [...d, /* @__PURE__ */ N.jsx(md, {\n      classes: {\n        ripple: se(i.ripple, nt.ripple),\n        rippleVisible: se(i.rippleVisible, nt.rippleVisible),\n        ripplePulsate: se(i.ripplePulsate, nt.ripplePulsate),\n        child: se(i.child, nt.child),\n        childLeaving: se(i.childLeaving, nt.childLeaving),\n        childPulsate: se(i.childPulsate, nt.childPulsate)\n      },\n      timeout: ho,\n      pulsate: h,\n      rippleX: w,\n      rippleY: k,\n      rippleSize: L\n    }, p.current)]), p.current += 1, m.current = B;\n  }, [i]), E = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((b = {}, h = {}, w = () => {\n  }) => {\n    const {\n      pulsate: k = !1,\n      center: L = o || h.pulsate,\n      fakeElement: B = !1\n      // For test purposes\n    } = h;\n    if ((b == null ? void 0 : b.type) === \"mousedown\" && g.current) {\n      g.current = !1;\n      return;\n    }\n    (b == null ? void 0 : b.type) === \"touchstart\" && (g.current = !0);\n    const d = B ? null : f.current, A = d ? d.getBoundingClientRect() : {\n      width: 0,\n      height: 0,\n      left: 0,\n      top: 0\n    };\n    let D, j, W;\n    if (L || b === void 0 || b.clientX === 0 && b.clientY === 0 || !b.clientX && !b.touches)\n      D = Math.round(A.width / 2), j = Math.round(A.height / 2);\n    else {\n      const {\n        clientX: z,\n        clientY: U\n      } = b.touches && b.touches.length > 0 ? b.touches[0] : b;\n      D = Math.round(z - A.left), j = Math.round(U - A.top);\n    }\n    if (L)\n      W = Math.sqrt((2 * A.width ** 2 + A.height ** 2) / 3), W % 2 === 0 && (W += 1);\n    else {\n      const z = Math.max(Math.abs((d ? d.clientWidth : 0) - D), D) * 2 + 2, U = Math.max(Math.abs((d ? d.clientHeight : 0) - j), j) * 2 + 2;\n      W = Math.sqrt(z ** 2 + U ** 2);\n    }\n    b != null && b.touches ? y.current === null && (y.current = () => {\n      S({\n        pulsate: k,\n        rippleX: D,\n        rippleY: j,\n        rippleSize: W,\n        cb: w\n      });\n    }, x.start(ld, () => {\n      y.current && (y.current(), y.current = null);\n    })) : S({\n      pulsate: k,\n      rippleX: D,\n      rippleY: j,\n      rippleSize: W,\n      cb: w\n    });\n  }, [o, S, x]), P = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    E({}, {\n      pulsate: !0\n    });\n  }, [E]), T = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((b, h) => {\n    if (x.clear(), (b == null ? void 0 : b.type) === \"touchend\" && y.current) {\n      y.current(), y.current = null, x.start(0, () => {\n        T(b, h);\n      });\n      return;\n    }\n    y.current = null, u((w) => w.length > 0 ? w.slice(1) : w), m.current = h;\n  }, [x]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(r, () => ({\n    pulsate: P,\n    start: E,\n    stop: T\n  }), [P, E, T]), /* @__PURE__ */ N.jsx(pd, {\n    className: se(nt.root, i.root, s),\n    ref: f,\n    ...c,\n    children: /* @__PURE__ */ N.jsx(Ho, {\n      component: null,\n      exit: !0,\n      children: l\n    })\n  });\n});\n true && (Ss.propTypes = {\n  /**\n   * If `true`, the ripple starts at the center of the component\n   * rather than at the point of interaction.\n   */\n  center: a.bool,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string\n});\nfunction hd(e) {\n  return Ve(\"MuiButtonBase\", e);\n}\nconst gd = Fe(\"MuiButtonBase\", [\"root\", \"disabled\", \"focusVisible\"]), yd = (e) => {\n  const {\n    disabled: t,\n    focusVisible: r,\n    focusVisibleClassName: n,\n    classes: o\n  } = e, s = Ge({\n    root: [\"root\", t && \"disabled\", r && \"focusVisible\"]\n  }, hd, o);\n  return r && n && (s.root += ` ${n}`), s;\n}, bd = le(\"button\", {\n  name: \"MuiButtonBase\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => t.root\n})({\n  display: \"inline-flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  position: \"relative\",\n  boxSizing: \"border-box\",\n  WebkitTapHighlightColor: \"transparent\",\n  backgroundColor: \"transparent\",\n  // Reset default value\n  // We disable the focus ring for mouse, touch and keyboard users.\n  outline: 0,\n  border: 0,\n  margin: 0,\n  // Remove the margin in Safari\n  borderRadius: 0,\n  padding: 0,\n  // Remove the padding in Firefox\n  cursor: \"pointer\",\n  userSelect: \"none\",\n  verticalAlign: \"middle\",\n  MozAppearance: \"none\",\n  // Reset\n  WebkitAppearance: \"none\",\n  // Reset\n  textDecoration: \"none\",\n  // So we take precedent over the style of a native <a /> element.\n  color: \"inherit\",\n  \"&::-moz-focus-inner\": {\n    borderStyle: \"none\"\n    // Remove Firefox dotted outline.\n  },\n  [`&.${gd.disabled}`]: {\n    pointerEvents: \"none\",\n    // Disable link interactions\n    cursor: \"default\"\n  },\n  \"@media print\": {\n    colorAdjust: \"exact\"\n  }\n}), $r = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiButtonBase\"\n  }), {\n    action: o,\n    centerRipple: i = !1,\n    children: s,\n    className: c,\n    component: l = \"button\",\n    disabled: u = !1,\n    disableRipple: p = !1,\n    disableTouchRipple: m = !1,\n    focusRipple: g = !1,\n    focusVisibleClassName: x,\n    LinkComponent: y = \"a\",\n    onBlur: f,\n    onClick: S,\n    onContextMenu: E,\n    onDragLeave: P,\n    onFocus: T,\n    onFocusVisible: b,\n    onKeyDown: h,\n    onKeyUp: w,\n    onMouseDown: k,\n    onMouseLeave: L,\n    onMouseUp: B,\n    onTouchEnd: d,\n    onTouchMove: A,\n    onTouchStart: D,\n    tabIndex: j = 0,\n    TouchRippleProps: W,\n    touchRippleRef: z,\n    type: U,\n    ...V\n  } = n, te = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), F = sd(), R = at(F.ref, z), [I, J] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1);\n  u && I && J(!1), react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(o, () => ({\n    focusVisible: () => {\n      J(!0), te.current.focus();\n    }\n  }), []);\n  const Q = F.shouldMount && !p && !u;\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    I && g && !p && F.pulsate();\n  }, [p, g, I, F]);\n  const H = Tt(F, \"start\", k, m), X = Tt(F, \"stop\", E, m), _ = Tt(F, \"stop\", P, m), q = Tt(F, \"stop\", B, m), G = Tt(F, \"stop\", (M) => {\n    I && M.preventDefault(), L && L(M);\n  }, m), re = Tt(F, \"start\", D, m), Z = Tt(F, \"stop\", d, m), ae = Tt(F, \"stop\", A, m), O = Tt(F, \"stop\", (M) => {\n    hn(M.target) || J(!1), f && f(M);\n  }, !1), ye = Qt((M) => {\n    te.current || (te.current = M.currentTarget), hn(M.target) && (J(!0), b && b(M)), T && T(M);\n  }), Ee = () => {\n    const M = te.current;\n    return l && l !== \"button\" && !(M.tagName === \"A\" && M.href);\n  }, Me = Qt((M) => {\n    g && !M.repeat && I && M.key === \" \" && F.stop(M, () => {\n      F.start(M);\n    }), M.target === M.currentTarget && Ee() && M.key === \" \" && M.preventDefault(), h && h(M), M.target === M.currentTarget && Ee() && M.key === \"Enter\" && !u && (M.preventDefault(), S && S(M));\n  }), Qe = Qt((M) => {\n    g && M.key === \" \" && I && !M.defaultPrevented && F.stop(M, () => {\n      F.pulsate(M);\n    }), w && w(M), S && M.target === M.currentTarget && Ee() && M.key === \" \" && !M.defaultPrevented && S(M);\n  });\n  let ve = l;\n  ve === \"button\" && (V.href || V.to) && (ve = y);\n  const Pe = {};\n  ve === \"button\" ? (Pe.type = U === void 0 ? \"button\" : U, Pe.disabled = u) : (!V.href && !V.to && (Pe.role = \"button\"), u && (Pe[\"aria-disabled\"] = u));\n  const ze = at(r, te), Le = {\n    ...n,\n    centerRipple: i,\n    component: l,\n    disabled: u,\n    disableRipple: p,\n    disableTouchRipple: m,\n    focusRipple: g,\n    tabIndex: j,\n    focusVisible: I\n  }, v = yd(Le);\n  return /* @__PURE__ */ N.jsxs(bd, {\n    as: ve,\n    className: se(v.root, c),\n    ownerState: Le,\n    onBlur: O,\n    onClick: S,\n    onContextMenu: X,\n    onFocus: ye,\n    onKeyDown: Me,\n    onKeyUp: Qe,\n    onMouseDown: H,\n    onMouseLeave: G,\n    onMouseUp: q,\n    onDragLeave: _,\n    onTouchEnd: Z,\n    onTouchMove: ae,\n    onTouchStart: re,\n    ref: ze,\n    tabIndex: u ? -1 : j,\n    type: U,\n    ...Pe,\n    ...V,\n    children: [s, Q ? /* @__PURE__ */ N.jsx(Ss, {\n      ref: R,\n      center: i,\n      ...W\n    }) : null]\n  });\n});\nfunction Tt(e, t, r, n = !1) {\n  return Qt((o) => (r && r(o), n || e[t](o), !0));\n}\n true && ($r.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * A ref for imperative actions.\n   * It currently only supports `focusVisible()` action.\n   */\n  action: Lo,\n  /**\n   * If `true`, the ripples are centered.\n   * They won't start at the cursor interaction position.\n   * @default false\n   */\n  centerRipple: a.bool,\n  /**\n   * The content of the component.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: Ja,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: a.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   *\n   *  Without a ripple there is no styling for :focus-visible by default. Be sure\n   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.\n   * @default false\n   */\n  disableRipple: a.bool,\n  /**\n   * If `true`, the touch ripple effect is disabled.\n   * @default false\n   */\n  disableTouchRipple: a.bool,\n  /**\n   * If `true`, the base button will have a keyboard focus ripple.\n   * @default false\n   */\n  focusRipple: a.bool,\n  /**\n   * This prop can help identify which element has keyboard focus.\n   * The class name will be applied when the element gains the focus through keyboard interaction.\n   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).\n   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).\n   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components\n   * if needed.\n   */\n  focusVisibleClassName: a.string,\n  /**\n   * @ignore\n   */\n  href: a.any,\n  /**\n   * The component used to render a link when the `href` prop is provided.\n   * @default 'a'\n   */\n  LinkComponent: a.elementType,\n  /**\n   * @ignore\n   */\n  onBlur: a.func,\n  /**\n   * @ignore\n   */\n  onClick: a.func,\n  /**\n   * @ignore\n   */\n  onContextMenu: a.func,\n  /**\n   * @ignore\n   */\n  onDragLeave: a.func,\n  /**\n   * @ignore\n   */\n  onFocus: a.func,\n  /**\n   * Callback fired when the component is focused with a keyboard.\n   * We trigger a `onFocus` callback too.\n   */\n  onFocusVisible: a.func,\n  /**\n   * @ignore\n   */\n  onKeyDown: a.func,\n  /**\n   * @ignore\n   */\n  onKeyUp: a.func,\n  /**\n   * @ignore\n   */\n  onMouseDown: a.func,\n  /**\n   * @ignore\n   */\n  onMouseLeave: a.func,\n  /**\n   * @ignore\n   */\n  onMouseUp: a.func,\n  /**\n   * @ignore\n   */\n  onTouchEnd: a.func,\n  /**\n   * @ignore\n   */\n  onTouchMove: a.func,\n  /**\n   * @ignore\n   */\n  onTouchStart: a.func,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * @default 0\n   */\n  tabIndex: a.number,\n  /**\n   * Props applied to the `TouchRipple` element.\n   */\n  TouchRippleProps: a.object,\n  /**\n   * A ref that points to the `TouchRipple` element.\n   */\n  touchRippleRef: a.oneOfType([a.func, a.shape({\n    current: a.shape({\n      pulsate: a.func.isRequired,\n      start: a.func.isRequired,\n      stop: a.func.isRequired\n    })\n  })]),\n  /**\n   * @ignore\n   */\n  type: a.oneOfType([a.oneOf([\"button\", \"reset\", \"submit\"]), a.string])\n});\nfunction vd(e) {\n  return typeof e.main == \"string\";\n}\nfunction xd(e, t = []) {\n  if (!vd(e))\n    return !1;\n  for (const r of t)\n    if (!e.hasOwnProperty(r) || typeof e[r] != \"string\")\n      return !1;\n  return !0;\n}\nfunction Pt(e = []) {\n  return ([, t]) => t && xd(t, e);\n}\nfunction Sd(e) {\n  return Ve(\"MuiCircularProgress\", e);\n}\nFe(\"MuiCircularProgress\", [\"root\", \"determinate\", \"indeterminate\", \"colorPrimary\", \"colorSecondary\", \"svg\", \"circle\", \"circleDeterminate\", \"circleIndeterminate\", \"circleDisableShrink\"]);\nconst $t = 44, go = Ir`\n  0% {\n    transform: rotate(0deg);\n  }\n\n  100% {\n    transform: rotate(360deg);\n  }\n`, yo = Ir`\n  0% {\n    stroke-dasharray: 1px, 200px;\n    stroke-dashoffset: 0;\n  }\n\n  50% {\n    stroke-dasharray: 100px, 200px;\n    stroke-dashoffset: -15px;\n  }\n\n  100% {\n    stroke-dasharray: 1px, 200px;\n    stroke-dashoffset: -126px;\n  }\n`, Ed = typeof go != \"string\" ? $o`\n        animation: ${go} 1.4s linear infinite;\n      ` : null, Cd = typeof yo != \"string\" ? $o`\n        animation: ${yo} 1.4s ease-in-out infinite;\n      ` : null, Td = (e) => {\n  const {\n    classes: t,\n    variant: r,\n    color: n,\n    disableShrink: o\n  } = e, i = {\n    root: [\"root\", r, `color${ee(n)}`],\n    svg: [\"svg\"],\n    circle: [\"circle\", `circle${ee(r)}`, o && \"circleDisableShrink\"]\n  };\n  return Ge(i, Sd, t);\n}, wd = le(\"span\", {\n  name: \"MuiCircularProgress\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, t[r.variant], t[`color${ee(r.color)}`]];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  display: \"inline-block\",\n  variants: [{\n    props: {\n      variant: \"determinate\"\n    },\n    style: {\n      transition: e.transitions.create(\"transform\")\n    }\n  }, {\n    props: {\n      variant: \"indeterminate\"\n    },\n    style: Ed || {\n      animation: `${go} 1.4s linear infinite`\n    }\n  }, ...Object.entries(e.palette).filter(Pt()).map(([t]) => ({\n    props: {\n      color: t\n    },\n    style: {\n      color: (e.vars || e).palette[t].main\n    }\n  }))]\n}))), Od = le(\"svg\", {\n  name: \"MuiCircularProgress\",\n  slot: \"Svg\",\n  overridesResolver: (e, t) => t.svg\n})({\n  display: \"block\"\n  // Keeps the progress centered\n}), Rd = le(\"circle\", {\n  name: \"MuiCircularProgress\",\n  slot: \"Circle\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.circle, t[`circle${ee(r.variant)}`], r.disableShrink && t.circleDisableShrink];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  stroke: \"currentColor\",\n  variants: [{\n    props: {\n      variant: \"determinate\"\n    },\n    style: {\n      transition: e.transitions.create(\"stroke-dashoffset\")\n    }\n  }, {\n    props: {\n      variant: \"indeterminate\"\n    },\n    style: {\n      // Some default value that looks fine waiting for the animation to kicks in.\n      strokeDasharray: \"80px, 200px\",\n      strokeDashoffset: 0\n      // Add the unit to fix a Edge 16 and below bug.\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.variant === \"indeterminate\" && !t.disableShrink,\n    style: Cd || {\n      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.\n      animation: `${yo} 1.4s ease-in-out infinite`\n    }\n  }]\n}))), Es = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiCircularProgress\"\n  }), {\n    className: o,\n    color: i = \"primary\",\n    disableShrink: s = !1,\n    size: c = 40,\n    style: l,\n    thickness: u = 3.6,\n    value: p = 0,\n    variant: m = \"indeterminate\",\n    ...g\n  } = n, x = {\n    ...n,\n    color: i,\n    disableShrink: s,\n    size: c,\n    thickness: u,\n    value: p,\n    variant: m\n  }, y = Td(x), f = {}, S = {}, E = {};\n  if (m === \"determinate\") {\n    const P = 2 * Math.PI * (($t - u) / 2);\n    f.strokeDasharray = P.toFixed(3), E[\"aria-valuenow\"] = Math.round(p), f.strokeDashoffset = `${((100 - p) / 100 * P).toFixed(3)}px`, S.transform = \"rotate(-90deg)\";\n  }\n  return /* @__PURE__ */ N.jsx(wd, {\n    className: se(y.root, o),\n    style: {\n      width: c,\n      height: c,\n      ...S,\n      ...l\n    },\n    ownerState: x,\n    ref: r,\n    role: \"progressbar\",\n    ...E,\n    ...g,\n    children: /* @__PURE__ */ N.jsx(Od, {\n      className: y.svg,\n      ownerState: x,\n      viewBox: `${$t / 2} ${$t / 2} ${$t} ${$t}`,\n      children: /* @__PURE__ */ N.jsx(Rd, {\n        className: y.circle,\n        style: f,\n        ownerState: x,\n        cx: $t,\n        cy: $t,\n        r: ($t - u) / 2,\n        fill: \"none\",\n        strokeWidth: u\n      })\n    })\n  });\n});\n true && (Es.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'primary'\n   */\n  color: a.oneOfType([a.oneOf([\"inherit\", \"primary\", \"secondary\", \"error\", \"info\", \"success\", \"warning\"]), a.string]),\n  /**\n   * If `true`, the shrink animation is disabled.\n   * This only works if variant is `indeterminate`.\n   * @default false\n   */\n  disableShrink: ar(a.bool, (e) => e.disableShrink && e.variant && e.variant !== \"indeterminate\" ? new Error(\"MUI: You have provided the `disableShrink` prop with a variant other than `indeterminate`. This will have no effect.\") : null),\n  /**\n   * The size of the component.\n   * If using a number, the pixel unit is assumed.\n   * If using a string, you need to provide the CSS unit, for example '3rem'.\n   * @default 40\n   */\n  size: a.oneOfType([a.number, a.string]),\n  /**\n   * @ignore\n   */\n  style: a.object,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * The thickness of the circle.\n   * @default 3.6\n   */\n  thickness: a.number,\n  /**\n   * The value of the progress indicator for the determinate variant.\n   * Value between 0 and 100.\n   * @default 0\n   */\n  value: a.number,\n  /**\n   * The variant to use.\n   * Use indeterminate when there is no progress value.\n   * @default 'indeterminate'\n   */\n  variant: a.oneOf([\"determinate\", \"indeterminate\"])\n});\nfunction $d(e) {\n  return Ve(\"MuiIconButton\", e);\n}\nconst aa = Fe(\"MuiIconButton\", [\"root\", \"disabled\", \"colorInherit\", \"colorPrimary\", \"colorSecondary\", \"colorError\", \"colorInfo\", \"colorSuccess\", \"colorWarning\", \"edgeStart\", \"edgeEnd\", \"sizeSmall\", \"sizeMedium\", \"sizeLarge\", \"loading\", \"loadingIndicator\", \"loadingWrapper\"]), Pd = (e) => {\n  const {\n    classes: t,\n    disabled: r,\n    color: n,\n    edge: o,\n    size: i,\n    loading: s\n  } = e, c = {\n    root: [\"root\", s && \"loading\", r && \"disabled\", n !== \"default\" && `color${ee(n)}`, o && `edge${ee(o)}`, `size${ee(i)}`],\n    loadingIndicator: [\"loadingIndicator\"],\n    loadingWrapper: [\"loadingWrapper\"]\n  };\n  return Ge(c, $d, t);\n}, kd = le($r, {\n  name: \"MuiIconButton\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, r.loading && t.loading, r.color !== \"default\" && t[`color${ee(r.color)}`], r.edge && t[`edge${ee(r.edge)}`], t[`size${ee(r.size)}`]];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  textAlign: \"center\",\n  flex: \"0 0 auto\",\n  fontSize: e.typography.pxToRem(24),\n  padding: 8,\n  borderRadius: \"50%\",\n  color: (e.vars || e).palette.action.active,\n  transition: e.transitions.create(\"background-color\", {\n    duration: e.transitions.duration.shortest\n  }),\n  variants: [{\n    props: (t) => !t.disableRipple,\n    style: {\n      \"--IconButton-hoverBg\": e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : De(e.palette.action.active, e.palette.action.hoverOpacity),\n      \"&:hover\": {\n        backgroundColor: \"var(--IconButton-hoverBg)\",\n        // Reset on touch devices, it doesn't add specificity\n        \"@media (hover: none)\": {\n          backgroundColor: \"transparent\"\n        }\n      }\n    }\n  }, {\n    props: {\n      edge: \"start\"\n    },\n    style: {\n      marginLeft: -12\n    }\n  }, {\n    props: {\n      edge: \"start\",\n      size: \"small\"\n    },\n    style: {\n      marginLeft: -3\n    }\n  }, {\n    props: {\n      edge: \"end\"\n    },\n    style: {\n      marginRight: -12\n    }\n  }, {\n    props: {\n      edge: \"end\",\n      size: \"small\"\n    },\n    style: {\n      marginRight: -3\n    }\n  }]\n})), qe(({\n  theme: e\n}) => ({\n  variants: [{\n    props: {\n      color: \"inherit\"\n    },\n    style: {\n      color: \"inherit\"\n    }\n  }, ...Object.entries(e.palette).filter(Pt()).map(([t]) => ({\n    props: {\n      color: t\n    },\n    style: {\n      color: (e.vars || e).palette[t].main\n    }\n  })), ...Object.entries(e.palette).filter(Pt()).map(([t]) => ({\n    props: {\n      color: t\n    },\n    style: {\n      \"--IconButton-hoverBg\": e.vars ? `rgba(${(e.vars || e).palette[t].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : De((e.vars || e).palette[t].main, e.palette.action.hoverOpacity)\n    }\n  })), {\n    props: {\n      size: \"small\"\n    },\n    style: {\n      padding: 5,\n      fontSize: e.typography.pxToRem(18)\n    }\n  }, {\n    props: {\n      size: \"large\"\n    },\n    style: {\n      padding: 12,\n      fontSize: e.typography.pxToRem(28)\n    }\n  }],\n  [`&.${aa.disabled}`]: {\n    backgroundColor: \"transparent\",\n    color: (e.vars || e).palette.action.disabled\n  },\n  [`&.${aa.loading}`]: {\n    color: \"transparent\"\n  }\n}))), Ad = le(\"span\", {\n  name: \"MuiIconButton\",\n  slot: \"LoadingIndicator\",\n  overridesResolver: (e, t) => t.loadingIndicator\n})(({\n  theme: e\n}) => ({\n  display: \"none\",\n  position: \"absolute\",\n  visibility: \"visible\",\n  top: \"50%\",\n  left: \"50%\",\n  transform: \"translate(-50%, -50%)\",\n  color: (e.vars || e).palette.action.disabled,\n  variants: [{\n    props: {\n      loading: !0\n    },\n    style: {\n      display: \"flex\"\n    }\n  }]\n})), Cs = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiIconButton\"\n  }), {\n    edge: o = !1,\n    children: i,\n    className: s,\n    color: c = \"default\",\n    disabled: l = !1,\n    disableFocusRipple: u = !1,\n    size: p = \"medium\",\n    id: m,\n    loading: g = null,\n    loadingIndicator: x,\n    ...y\n  } = n, f = Qa(m), S = x ?? /* @__PURE__ */ N.jsx(Es, {\n    \"aria-labelledby\": f,\n    color: \"inherit\",\n    size: 16\n  }), E = {\n    ...n,\n    edge: o,\n    color: c,\n    disabled: l,\n    disableFocusRipple: u,\n    loading: g,\n    loadingIndicator: S,\n    size: p\n  }, P = Pd(E);\n  return /* @__PURE__ */ N.jsxs(kd, {\n    id: f,\n    className: se(P.root, s),\n    centerRipple: !0,\n    focusRipple: !u,\n    disabled: l || g,\n    ref: r,\n    ...y,\n    ownerState: E,\n    children: [typeof g == \"boolean\" && // use plain HTML span to minimize the runtime overhead\n    /* @__PURE__ */ N.jsx(\"span\", {\n      className: P.loadingWrapper,\n      style: {\n        display: \"contents\"\n      },\n      children: /* @__PURE__ */ N.jsx(Ad, {\n        className: P.loadingIndicator,\n        ownerState: E,\n        children: g && S\n      })\n    }), i]\n  });\n});\n true && (Cs.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The icon to display.\n   */\n  children: ar(a.node, (e) => react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(e.children).some((r) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(r) && r.props.onClick) ? new Error([\"MUI: You are providing an onClick event listener to a child of a button element.\", \"Prefer applying it to the IconButton directly.\", \"This guarantees that the whole <button> will be responsive to click events.\"].join(`\n`)) : null),\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'default'\n   */\n  color: a.oneOfType([a.oneOf([\"inherit\", \"default\", \"primary\", \"secondary\", \"error\", \"info\", \"success\", \"warning\"]), a.string]),\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: a.bool,\n  /**\n   * If `true`, the  keyboard focus ripple is disabled.\n   * @default false\n   */\n  disableFocusRipple: a.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   *\n   *  Without a ripple there is no styling for :focus-visible by default. Be sure\n   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.\n   * @default false\n   */\n  disableRipple: a.bool,\n  /**\n   * If given, uses a negative margin to counteract the padding on one\n   * side (this is often helpful for aligning the left or right\n   * side of the icon with content above or below, without ruining the border\n   * size and shape).\n   * @default false\n   */\n  edge: a.oneOf([\"end\", \"start\", !1]),\n  /**\n   * @ignore\n   */\n  id: a.string,\n  /**\n   * If `true`, the loading indicator is visible and the button is disabled.\n   * If `true | false`, the loading wrapper is always rendered before the children to prevent [Google Translation Crash](https://github.com/mui/material-ui/issues/27853).\n   * @default null\n   */\n  loading: a.bool,\n  /**\n   * Element placed before the children if the button is in loading state.\n   * The node should contain an element with `role=\"progressbar\"` with an accessible name.\n   * By default, it renders a `CircularProgress` that is labeled by the button itself.\n   * @default <CircularProgress color=\"inherit\" size={16} />\n   */\n  loadingIndicator: a.node,\n  /**\n   * The size of the component.\n   * `small` is equivalent to the dense button styling.\n   * @default 'medium'\n   */\n  size: a.oneOfType([a.oneOf([\"small\", \"medium\", \"large\"]), a.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nfunction Nd(e) {\n  return Ve(\"MuiTypography\", e);\n}\nconst sa = Fe(\"MuiTypography\", [\"root\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"subtitle1\", \"subtitle2\", \"body1\", \"body2\", \"inherit\", \"button\", \"caption\", \"overline\", \"alignLeft\", \"alignRight\", \"alignCenter\", \"alignJustify\", \"noWrap\", \"gutterBottom\", \"paragraph\"]), Md = {\n  primary: !0,\n  secondary: !0,\n  error: !0,\n  info: !0,\n  success: !0,\n  warning: !0,\n  textPrimary: !0,\n  textSecondary: !0,\n  textDisabled: !0\n}, Id = Wf(), _d = (e) => {\n  const {\n    align: t,\n    gutterBottom: r,\n    noWrap: n,\n    paragraph: o,\n    variant: i,\n    classes: s\n  } = e, c = {\n    root: [\"root\", i, e.align !== \"inherit\" && `align${ee(t)}`, r && \"gutterBottom\", n && \"noWrap\", o && \"paragraph\"]\n  };\n  return Ge(c, Nd, s);\n}, jd = le(\"span\", {\n  name: \"MuiTypography\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, r.variant && t[r.variant], r.align !== \"inherit\" && t[`align${ee(r.align)}`], r.noWrap && t.noWrap, r.gutterBottom && t.gutterBottom, r.paragraph && t.paragraph];\n  }\n})(qe(({\n  theme: e\n}) => {\n  var t;\n  return {\n    margin: 0,\n    variants: [{\n      props: {\n        variant: \"inherit\"\n      },\n      style: {\n        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.\n        font: \"inherit\",\n        lineHeight: \"inherit\",\n        letterSpacing: \"inherit\"\n      }\n    }, ...Object.entries(e.typography).filter(([r, n]) => r !== \"inherit\" && n && typeof n == \"object\").map(([r, n]) => ({\n      props: {\n        variant: r\n      },\n      style: n\n    })), ...Object.entries(e.palette).filter(Pt()).map(([r]) => ({\n      props: {\n        color: r\n      },\n      style: {\n        color: (e.vars || e).palette[r].main\n      }\n    })), ...Object.entries(((t = e.palette) == null ? void 0 : t.text) || {}).filter(([, r]) => typeof r == \"string\").map(([r]) => ({\n      props: {\n        color: `text${ee(r)}`\n      },\n      style: {\n        color: (e.vars || e).palette.text[r]\n      }\n    })), {\n      props: ({\n        ownerState: r\n      }) => r.align !== \"inherit\",\n      style: {\n        textAlign: \"var(--Typography-textAlign)\"\n      }\n    }, {\n      props: ({\n        ownerState: r\n      }) => r.noWrap,\n      style: {\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        whiteSpace: \"nowrap\"\n      }\n    }, {\n      props: ({\n        ownerState: r\n      }) => r.gutterBottom,\n      style: {\n        marginBottom: \"0.35em\"\n      }\n    }, {\n      props: ({\n        ownerState: r\n      }) => r.paragraph,\n      style: {\n        marginBottom: 16\n      }\n    }]\n  };\n})), ca = {\n  h1: \"h1\",\n  h2: \"h2\",\n  h3: \"h3\",\n  h4: \"h4\",\n  h5: \"h5\",\n  h6: \"h6\",\n  subtitle1: \"h6\",\n  subtitle2: \"h6\",\n  body1: \"p\",\n  body2: \"p\",\n  inherit: \"p\"\n}, bt = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const {\n    color: n,\n    ...o\n  } = He({\n    props: t,\n    name: \"MuiTypography\"\n  }), i = !Md[n], s = Id({\n    ...o,\n    ...i && {\n      color: n\n    }\n  }), {\n    align: c = \"inherit\",\n    className: l,\n    component: u,\n    gutterBottom: p = !1,\n    noWrap: m = !1,\n    paragraph: g = !1,\n    variant: x = \"body1\",\n    variantMapping: y = ca,\n    ...f\n  } = s, S = {\n    ...s,\n    align: c,\n    color: n,\n    className: l,\n    component: u,\n    gutterBottom: p,\n    noWrap: m,\n    paragraph: g,\n    variant: x,\n    variantMapping: y\n  }, E = u || (g ? \"p\" : y[x] || ca[x]) || \"span\", P = _d(S);\n  return /* @__PURE__ */ N.jsx(jd, {\n    as: E,\n    ref: r,\n    className: se(P.root, l),\n    ...f,\n    ownerState: S,\n    style: {\n      ...c !== \"inherit\" && {\n        \"--Typography-textAlign\": c\n      },\n      ...f.style\n    }\n  });\n});\n true && (bt.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Set the text-align on the component.\n   * @default 'inherit'\n   */\n  align: a.oneOf([\"center\", \"inherit\", \"justify\", \"left\", \"right\"]),\n  /**\n   * The content of the component.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   */\n  color: a.oneOfType([a.oneOf([\"primary\", \"secondary\", \"success\", \"error\", \"info\", \"warning\", \"textPrimary\", \"textSecondary\", \"textDisabled\"]), a.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * If `true`, the text will have a bottom margin.\n   * @default false\n   */\n  gutterBottom: a.bool,\n  /**\n   * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.\n   *\n   * Note that text overflow can only happen with block or inline-block level elements\n   * (the element needs to have a width in order to overflow).\n   * @default false\n   */\n  noWrap: a.bool,\n  /**\n   * If `true`, the element will be a paragraph element.\n   * @default false\n   * @deprecated Use the `component` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  paragraph: a.bool,\n  /**\n   * @ignore\n   */\n  style: a.object,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * Applies the theme typography styles.\n   * @default 'body1'\n   */\n  variant: a.oneOfType([a.oneOf([\"body1\", \"body2\", \"button\", \"caption\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"inherit\", \"overline\", \"subtitle1\", \"subtitle2\"]), a.string]),\n  /**\n   * The component maps the variant prop to a range of different HTML element types.\n   * For instance, subtitle1 to `<h6>`.\n   * If you wish to change that mapping, you can provide your own.\n   * Alternatively, you can use the `component` prop.\n   * @default {\n   *   h1: 'h1',\n   *   h2: 'h2',\n   *   h3: 'h3',\n   *   h4: 'h4',\n   *   h5: 'h5',\n   *   h6: 'h6',\n   *   subtitle1: 'h6',\n   *   subtitle2: 'h6',\n   *   body1: 'p',\n   *   body2: 'p',\n   *   inherit: 'p',\n   * }\n   */\n  variantMapping: a.object\n});\nvar Ke = \"top\", st = \"bottom\", ct = \"right\", Xe = \"left\", qo = \"auto\", Br = [Ke, st, ct, Xe], er = \"start\", Pr = \"end\", Dd = \"clippingParents\", Ts = \"viewport\", pr = \"popper\", Ld = \"reference\", la = /* @__PURE__ */ Br.reduce(function(e, t) {\n  return e.concat([t + \"-\" + er, t + \"-\" + Pr]);\n}, []), ws = /* @__PURE__ */ [].concat(Br, [qo]).reduce(function(e, t) {\n  return e.concat([t, t + \"-\" + er, t + \"-\" + Pr]);\n}, []), Bd = \"beforeRead\", Vd = \"read\", Fd = \"afterRead\", zd = \"beforeMain\", Wd = \"main\", Ud = \"afterMain\", Yd = \"beforeWrite\", Hd = \"write\", qd = \"afterWrite\", Gd = [Bd, Vd, Fd, zd, Wd, Ud, Yd, Hd, qd];\nfunction St(e) {\n  return e ? (e.nodeName || \"\").toLowerCase() : null;\n}\nfunction rt(e) {\n  if (e == null)\n    return window;\n  if (e.toString() !== \"[object Window]\") {\n    var t = e.ownerDocument;\n    return t && t.defaultView || window;\n  }\n  return e;\n}\nfunction zt(e) {\n  var t = rt(e).Element;\n  return e instanceof t || e instanceof Element;\n}\nfunction it(e) {\n  var t = rt(e).HTMLElement;\n  return e instanceof t || e instanceof HTMLElement;\n}\nfunction Go(e) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var t = rt(e).ShadowRoot;\n  return e instanceof t || e instanceof ShadowRoot;\n}\nfunction Kd(e) {\n  var t = e.state;\n  Object.keys(t.elements).forEach(function(r) {\n    var n = t.styles[r] || {}, o = t.attributes[r] || {}, i = t.elements[r];\n    !it(i) || !St(i) || (Object.assign(i.style, n), Object.keys(o).forEach(function(s) {\n      var c = o[s];\n      c === !1 ? i.removeAttribute(s) : i.setAttribute(s, c === !0 ? \"\" : c);\n    }));\n  });\n}\nfunction Xd(e) {\n  var t = e.state, r = {\n    popper: {\n      position: t.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow), function() {\n    Object.keys(t.elements).forEach(function(n) {\n      var o = t.elements[n], i = t.attributes[n] || {}, s = Object.keys(t.styles.hasOwnProperty(n) ? t.styles[n] : r[n]), c = s.reduce(function(l, u) {\n        return l[u] = \"\", l;\n      }, {});\n      !it(o) || !St(o) || (Object.assign(o.style, c), Object.keys(i).forEach(function(l) {\n        o.removeAttribute(l);\n      }));\n    });\n  };\n}\nconst Jd = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: Kd,\n  effect: Xd,\n  requires: [\"computeStyles\"]\n};\nfunction xt(e) {\n  return e.split(\"-\")[0];\n}\nvar Vt = Math.max, En = Math.min, tr = Math.round;\nfunction bo() {\n  var e = navigator.userAgentData;\n  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {\n    return t.brand + \"/\" + t.version;\n  }).join(\" \") : navigator.userAgent;\n}\nfunction Os() {\n  return !/^((?!chrome|android).)*safari/i.test(bo());\n}\nfunction rr(e, t, r) {\n  t === void 0 && (t = !1), r === void 0 && (r = !1);\n  var n = e.getBoundingClientRect(), o = 1, i = 1;\n  t && it(e) && (o = e.offsetWidth > 0 && tr(n.width) / e.offsetWidth || 1, i = e.offsetHeight > 0 && tr(n.height) / e.offsetHeight || 1);\n  var s = zt(e) ? rt(e) : window, c = s.visualViewport, l = !Os() && r, u = (n.left + (l && c ? c.offsetLeft : 0)) / o, p = (n.top + (l && c ? c.offsetTop : 0)) / i, m = n.width / o, g = n.height / i;\n  return {\n    width: m,\n    height: g,\n    top: p,\n    right: u + m,\n    bottom: p + g,\n    left: u,\n    x: u,\n    y: p\n  };\n}\nfunction Ko(e) {\n  var t = rr(e), r = e.offsetWidth, n = e.offsetHeight;\n  return Math.abs(t.width - r) <= 1 && (r = t.width), Math.abs(t.height - n) <= 1 && (n = t.height), {\n    x: e.offsetLeft,\n    y: e.offsetTop,\n    width: r,\n    height: n\n  };\n}\nfunction Rs(e, t) {\n  var r = t.getRootNode && t.getRootNode();\n  if (e.contains(t))\n    return !0;\n  if (r && Go(r)) {\n    var n = t;\n    do {\n      if (n && e.isSameNode(n))\n        return !0;\n      n = n.parentNode || n.host;\n    } while (n);\n  }\n  return !1;\n}\nfunction Rt(e) {\n  return rt(e).getComputedStyle(e);\n}\nfunction Qd(e) {\n  return [\"table\", \"td\", \"th\"].indexOf(St(e)) >= 0;\n}\nfunction It(e) {\n  return ((zt(e) ? e.ownerDocument : (\n    // $FlowFixMe[prop-missing]\n    e.document\n  )) || window.document).documentElement;\n}\nfunction zn(e) {\n  return St(e) === \"html\" ? e : (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    e.parentNode || // DOM Element detected\n    (Go(e) ? e.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    It(e)\n  );\n}\nfunction ua(e) {\n  return !it(e) || // https://github.com/popperjs/popper-core/issues/837\n  Rt(e).position === \"fixed\" ? null : e.offsetParent;\n}\nfunction Zd(e) {\n  var t = /firefox/i.test(bo()), r = /Trident/i.test(bo());\n  if (r && it(e)) {\n    var n = Rt(e);\n    if (n.position === \"fixed\")\n      return null;\n  }\n  var o = zn(e);\n  for (Go(o) && (o = o.host); it(o) && [\"html\", \"body\"].indexOf(St(o)) < 0; ) {\n    var i = Rt(o);\n    if (i.transform !== \"none\" || i.perspective !== \"none\" || i.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(i.willChange) !== -1 || t && i.willChange === \"filter\" || t && i.filter && i.filter !== \"none\")\n      return o;\n    o = o.parentNode;\n  }\n  return null;\n}\nfunction Vr(e) {\n  for (var t = rt(e), r = ua(e); r && Qd(r) && Rt(r).position === \"static\"; )\n    r = ua(r);\n  return r && (St(r) === \"html\" || St(r) === \"body\" && Rt(r).position === \"static\") ? t : r || Zd(e) || t;\n}\nfunction Xo(e) {\n  return [\"top\", \"bottom\"].indexOf(e) >= 0 ? \"x\" : \"y\";\n}\nfunction xr(e, t, r) {\n  return Vt(e, En(t, r));\n}\nfunction ep(e, t, r) {\n  var n = xr(e, t, r);\n  return n > r ? r : n;\n}\nfunction $s() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction Ps(e) {\n  return Object.assign({}, $s(), e);\n}\nfunction ks(e, t) {\n  return t.reduce(function(r, n) {\n    return r[n] = e, r;\n  }, {});\n}\nvar tp = function(t, r) {\n  return t = typeof t == \"function\" ? t(Object.assign({}, r.rects, {\n    placement: r.placement\n  })) : t, Ps(typeof t != \"number\" ? t : ks(t, Br));\n};\nfunction rp(e) {\n  var t, r = e.state, n = e.name, o = e.options, i = r.elements.arrow, s = r.modifiersData.popperOffsets, c = xt(r.placement), l = Xo(c), u = [Xe, ct].indexOf(c) >= 0, p = u ? \"height\" : \"width\";\n  if (!(!i || !s)) {\n    var m = tp(o.padding, r), g = Ko(i), x = l === \"y\" ? Ke : Xe, y = l === \"y\" ? st : ct, f = r.rects.reference[p] + r.rects.reference[l] - s[l] - r.rects.popper[p], S = s[l] - r.rects.reference[l], E = Vr(i), P = E ? l === \"y\" ? E.clientHeight || 0 : E.clientWidth || 0 : 0, T = f / 2 - S / 2, b = m[x], h = P - g[p] - m[y], w = P / 2 - g[p] / 2 + T, k = xr(b, w, h), L = l;\n    r.modifiersData[n] = (t = {}, t[L] = k, t.centerOffset = k - w, t);\n  }\n}\nfunction np(e) {\n  var t = e.state, r = e.options, n = r.element, o = n === void 0 ? \"[data-popper-arrow]\" : n;\n  o != null && (typeof o == \"string\" && (o = t.elements.popper.querySelector(o), !o) || Rs(t.elements.popper, o) && (t.elements.arrow = o));\n}\nconst op = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: rp,\n  effect: np,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction nr(e) {\n  return e.split(\"-\")[1];\n}\nvar ip = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction ap(e, t) {\n  var r = e.x, n = e.y, o = t.devicePixelRatio || 1;\n  return {\n    x: tr(r * o) / o || 0,\n    y: tr(n * o) / o || 0\n  };\n}\nfunction fa(e) {\n  var t, r = e.popper, n = e.popperRect, o = e.placement, i = e.variation, s = e.offsets, c = e.position, l = e.gpuAcceleration, u = e.adaptive, p = e.roundOffsets, m = e.isFixed, g = s.x, x = g === void 0 ? 0 : g, y = s.y, f = y === void 0 ? 0 : y, S = typeof p == \"function\" ? p({\n    x,\n    y: f\n  }) : {\n    x,\n    y: f\n  };\n  x = S.x, f = S.y;\n  var E = s.hasOwnProperty(\"x\"), P = s.hasOwnProperty(\"y\"), T = Xe, b = Ke, h = window;\n  if (u) {\n    var w = Vr(r), k = \"clientHeight\", L = \"clientWidth\";\n    if (w === rt(r) && (w = It(r), Rt(w).position !== \"static\" && c === \"absolute\" && (k = \"scrollHeight\", L = \"scrollWidth\")), w = w, o === Ke || (o === Xe || o === ct) && i === Pr) {\n      b = st;\n      var B = m && w === h && h.visualViewport ? h.visualViewport.height : (\n        // $FlowFixMe[prop-missing]\n        w[k]\n      );\n      f -= B - n.height, f *= l ? 1 : -1;\n    }\n    if (o === Xe || (o === Ke || o === st) && i === Pr) {\n      T = ct;\n      var d = m && w === h && h.visualViewport ? h.visualViewport.width : (\n        // $FlowFixMe[prop-missing]\n        w[L]\n      );\n      x -= d - n.width, x *= l ? 1 : -1;\n    }\n  }\n  var A = Object.assign({\n    position: c\n  }, u && ip), D = p === !0 ? ap({\n    x,\n    y: f\n  }, rt(r)) : {\n    x,\n    y: f\n  };\n  if (x = D.x, f = D.y, l) {\n    var j;\n    return Object.assign({}, A, (j = {}, j[b] = P ? \"0\" : \"\", j[T] = E ? \"0\" : \"\", j.transform = (h.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + f + \"px)\" : \"translate3d(\" + x + \"px, \" + f + \"px, 0)\", j));\n  }\n  return Object.assign({}, A, (t = {}, t[b] = P ? f + \"px\" : \"\", t[T] = E ? x + \"px\" : \"\", t.transform = \"\", t));\n}\nfunction sp(e) {\n  var t = e.state, r = e.options, n = r.gpuAcceleration, o = n === void 0 ? !0 : n, i = r.adaptive, s = i === void 0 ? !0 : i, c = r.roundOffsets, l = c === void 0 ? !0 : c, u = {\n    placement: xt(t.placement),\n    variation: nr(t.placement),\n    popper: t.elements.popper,\n    popperRect: t.rects.popper,\n    gpuAcceleration: o,\n    isFixed: t.options.strategy === \"fixed\"\n  };\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, fa(Object.assign({}, u, {\n    offsets: t.modifiersData.popperOffsets,\n    position: t.options.strategy,\n    adaptive: s,\n    roundOffsets: l\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, fa(Object.assign({}, u, {\n    offsets: t.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets: l\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-placement\": t.placement\n  });\n}\nconst cp = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: sp,\n  data: {}\n};\nvar Zr = {\n  passive: !0\n};\nfunction lp(e) {\n  var t = e.state, r = e.instance, n = e.options, o = n.scroll, i = o === void 0 ? !0 : o, s = n.resize, c = s === void 0 ? !0 : s, l = rt(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n  return i && u.forEach(function(p) {\n    p.addEventListener(\"scroll\", r.update, Zr);\n  }), c && l.addEventListener(\"resize\", r.update, Zr), function() {\n    i && u.forEach(function(p) {\n      p.removeEventListener(\"scroll\", r.update, Zr);\n    }), c && l.removeEventListener(\"resize\", r.update, Zr);\n  };\n}\nconst up = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect: lp,\n  data: {}\n};\nvar fp = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction un(e) {\n  return e.replace(/left|right|bottom|top/g, function(t) {\n    return fp[t];\n  });\n}\nvar dp = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction da(e) {\n  return e.replace(/start|end/g, function(t) {\n    return dp[t];\n  });\n}\nfunction Jo(e) {\n  var t = rt(e), r = t.pageXOffset, n = t.pageYOffset;\n  return {\n    scrollLeft: r,\n    scrollTop: n\n  };\n}\nfunction Qo(e) {\n  return rr(It(e)).left + Jo(e).scrollLeft;\n}\nfunction pp(e, t) {\n  var r = rt(e), n = It(e), o = r.visualViewport, i = n.clientWidth, s = n.clientHeight, c = 0, l = 0;\n  if (o) {\n    i = o.width, s = o.height;\n    var u = Os();\n    (u || !u && t === \"fixed\") && (c = o.offsetLeft, l = o.offsetTop);\n  }\n  return {\n    width: i,\n    height: s,\n    x: c + Qo(e),\n    y: l\n  };\n}\nfunction mp(e) {\n  var t, r = It(e), n = Jo(e), o = (t = e.ownerDocument) == null ? void 0 : t.body, i = Vt(r.scrollWidth, r.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), s = Vt(r.scrollHeight, r.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), c = -n.scrollLeft + Qo(e), l = -n.scrollTop;\n  return Rt(o || r).direction === \"rtl\" && (c += Vt(r.clientWidth, o ? o.clientWidth : 0) - i), {\n    width: i,\n    height: s,\n    x: c,\n    y: l\n  };\n}\nfunction Zo(e) {\n  var t = Rt(e), r = t.overflow, n = t.overflowX, o = t.overflowY;\n  return /auto|scroll|overlay|hidden/.test(r + o + n);\n}\nfunction As(e) {\n  return [\"html\", \"body\", \"#document\"].indexOf(St(e)) >= 0 ? e.ownerDocument.body : it(e) && Zo(e) ? e : As(zn(e));\n}\nfunction Sr(e, t) {\n  var r;\n  t === void 0 && (t = []);\n  var n = As(e), o = n === ((r = e.ownerDocument) == null ? void 0 : r.body), i = rt(n), s = o ? [i].concat(i.visualViewport || [], Zo(n) ? n : []) : n, c = t.concat(s);\n  return o ? c : (\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    c.concat(Sr(zn(s)))\n  );\n}\nfunction vo(e) {\n  return Object.assign({}, e, {\n    left: e.x,\n    top: e.y,\n    right: e.x + e.width,\n    bottom: e.y + e.height\n  });\n}\nfunction hp(e, t) {\n  var r = rr(e, !1, t === \"fixed\");\n  return r.top = r.top + e.clientTop, r.left = r.left + e.clientLeft, r.bottom = r.top + e.clientHeight, r.right = r.left + e.clientWidth, r.width = e.clientWidth, r.height = e.clientHeight, r.x = r.left, r.y = r.top, r;\n}\nfunction pa(e, t, r) {\n  return t === Ts ? vo(pp(e, r)) : zt(t) ? hp(t, r) : vo(mp(It(e)));\n}\nfunction gp(e) {\n  var t = Sr(zn(e)), r = [\"absolute\", \"fixed\"].indexOf(Rt(e).position) >= 0, n = r && it(e) ? Vr(e) : e;\n  return zt(n) ? t.filter(function(o) {\n    return zt(o) && Rs(o, n) && St(o) !== \"body\";\n  }) : [];\n}\nfunction yp(e, t, r, n) {\n  var o = t === \"clippingParents\" ? gp(e) : [].concat(t), i = [].concat(o, [r]), s = i[0], c = i.reduce(function(l, u) {\n    var p = pa(e, u, n);\n    return l.top = Vt(p.top, l.top), l.right = En(p.right, l.right), l.bottom = En(p.bottom, l.bottom), l.left = Vt(p.left, l.left), l;\n  }, pa(e, s, n));\n  return c.width = c.right - c.left, c.height = c.bottom - c.top, c.x = c.left, c.y = c.top, c;\n}\nfunction Ns(e) {\n  var t = e.reference, r = e.element, n = e.placement, o = n ? xt(n) : null, i = n ? nr(n) : null, s = t.x + t.width / 2 - r.width / 2, c = t.y + t.height / 2 - r.height / 2, l;\n  switch (o) {\n    case Ke:\n      l = {\n        x: s,\n        y: t.y - r.height\n      };\n      break;\n    case st:\n      l = {\n        x: s,\n        y: t.y + t.height\n      };\n      break;\n    case ct:\n      l = {\n        x: t.x + t.width,\n        y: c\n      };\n      break;\n    case Xe:\n      l = {\n        x: t.x - r.width,\n        y: c\n      };\n      break;\n    default:\n      l = {\n        x: t.x,\n        y: t.y\n      };\n  }\n  var u = o ? Xo(o) : null;\n  if (u != null) {\n    var p = u === \"y\" ? \"height\" : \"width\";\n    switch (i) {\n      case er:\n        l[u] = l[u] - (t[p] / 2 - r[p] / 2);\n        break;\n      case Pr:\n        l[u] = l[u] + (t[p] / 2 - r[p] / 2);\n        break;\n    }\n  }\n  return l;\n}\nfunction kr(e, t) {\n  t === void 0 && (t = {});\n  var r = t, n = r.placement, o = n === void 0 ? e.placement : n, i = r.strategy, s = i === void 0 ? e.strategy : i, c = r.boundary, l = c === void 0 ? Dd : c, u = r.rootBoundary, p = u === void 0 ? Ts : u, m = r.elementContext, g = m === void 0 ? pr : m, x = r.altBoundary, y = x === void 0 ? !1 : x, f = r.padding, S = f === void 0 ? 0 : f, E = Ps(typeof S != \"number\" ? S : ks(S, Br)), P = g === pr ? Ld : pr, T = e.rects.popper, b = e.elements[y ? P : g], h = yp(zt(b) ? b : b.contextElement || It(e.elements.popper), l, p, s), w = rr(e.elements.reference), k = Ns({\n    reference: w,\n    element: T,\n    strategy: \"absolute\",\n    placement: o\n  }), L = vo(Object.assign({}, T, k)), B = g === pr ? L : w, d = {\n    top: h.top - B.top + E.top,\n    bottom: B.bottom - h.bottom + E.bottom,\n    left: h.left - B.left + E.left,\n    right: B.right - h.right + E.right\n  }, A = e.modifiersData.offset;\n  if (g === pr && A) {\n    var D = A[o];\n    Object.keys(d).forEach(function(j) {\n      var W = [ct, st].indexOf(j) >= 0 ? 1 : -1, z = [Ke, st].indexOf(j) >= 0 ? \"y\" : \"x\";\n      d[j] += D[z] * W;\n    });\n  }\n  return d;\n}\nfunction bp(e, t) {\n  t === void 0 && (t = {});\n  var r = t, n = r.placement, o = r.boundary, i = r.rootBoundary, s = r.padding, c = r.flipVariations, l = r.allowedAutoPlacements, u = l === void 0 ? ws : l, p = nr(n), m = p ? c ? la : la.filter(function(y) {\n    return nr(y) === p;\n  }) : Br, g = m.filter(function(y) {\n    return u.indexOf(y) >= 0;\n  });\n  g.length === 0 && (g = m);\n  var x = g.reduce(function(y, f) {\n    return y[f] = kr(e, {\n      placement: f,\n      boundary: o,\n      rootBoundary: i,\n      padding: s\n    })[xt(f)], y;\n  }, {});\n  return Object.keys(x).sort(function(y, f) {\n    return x[y] - x[f];\n  });\n}\nfunction vp(e) {\n  if (xt(e) === qo)\n    return [];\n  var t = un(e);\n  return [da(e), t, da(t)];\n}\nfunction xp(e) {\n  var t = e.state, r = e.options, n = e.name;\n  if (!t.modifiersData[n]._skip) {\n    for (var o = r.mainAxis, i = o === void 0 ? !0 : o, s = r.altAxis, c = s === void 0 ? !0 : s, l = r.fallbackPlacements, u = r.padding, p = r.boundary, m = r.rootBoundary, g = r.altBoundary, x = r.flipVariations, y = x === void 0 ? !0 : x, f = r.allowedAutoPlacements, S = t.options.placement, E = xt(S), P = E === S, T = l || (P || !y ? [un(S)] : vp(S)), b = [S].concat(T).reduce(function(H, X) {\n      return H.concat(xt(X) === qo ? bp(t, {\n        placement: X,\n        boundary: p,\n        rootBoundary: m,\n        padding: u,\n        flipVariations: y,\n        allowedAutoPlacements: f\n      }) : X);\n    }, []), h = t.rects.reference, w = t.rects.popper, k = /* @__PURE__ */ new Map(), L = !0, B = b[0], d = 0; d < b.length; d++) {\n      var A = b[d], D = xt(A), j = nr(A) === er, W = [Ke, st].indexOf(D) >= 0, z = W ? \"width\" : \"height\", U = kr(t, {\n        placement: A,\n        boundary: p,\n        rootBoundary: m,\n        altBoundary: g,\n        padding: u\n      }), V = W ? j ? ct : Xe : j ? st : Ke;\n      h[z] > w[z] && (V = un(V));\n      var te = un(V), F = [];\n      if (i && F.push(U[D] <= 0), c && F.push(U[V] <= 0, U[te] <= 0), F.every(function(H) {\n        return H;\n      })) {\n        B = A, L = !1;\n        break;\n      }\n      k.set(A, F);\n    }\n    if (L)\n      for (var R = y ? 3 : 1, I = function(X) {\n        var _ = b.find(function(q) {\n          var G = k.get(q);\n          if (G)\n            return G.slice(0, X).every(function(re) {\n              return re;\n            });\n        });\n        if (_)\n          return B = _, \"break\";\n      }, J = R; J > 0; J--) {\n        var Q = I(J);\n        if (Q === \"break\") break;\n      }\n    t.placement !== B && (t.modifiersData[n]._skip = !0, t.placement = B, t.reset = !0);\n  }\n}\nconst Sp = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: xp,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\nfunction ma(e, t, r) {\n  return r === void 0 && (r = {\n    x: 0,\n    y: 0\n  }), {\n    top: e.top - t.height - r.y,\n    right: e.right - t.width + r.x,\n    bottom: e.bottom - t.height + r.y,\n    left: e.left - t.width - r.x\n  };\n}\nfunction ha(e) {\n  return [Ke, ct, st, Xe].some(function(t) {\n    return e[t] >= 0;\n  });\n}\nfunction Ep(e) {\n  var t = e.state, r = e.name, n = t.rects.reference, o = t.rects.popper, i = t.modifiersData.preventOverflow, s = kr(t, {\n    elementContext: \"reference\"\n  }), c = kr(t, {\n    altBoundary: !0\n  }), l = ma(s, n), u = ma(c, o, i), p = ha(l), m = ha(u);\n  t.modifiersData[r] = {\n    referenceClippingOffsets: l,\n    popperEscapeOffsets: u,\n    isReferenceHidden: p,\n    hasPopperEscaped: m\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-reference-hidden\": p,\n    \"data-popper-escaped\": m\n  });\n}\nconst Cp = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: Ep\n};\nfunction Tp(e, t, r) {\n  var n = xt(e), o = [Xe, Ke].indexOf(n) >= 0 ? -1 : 1, i = typeof r == \"function\" ? r(Object.assign({}, t, {\n    placement: e\n  })) : r, s = i[0], c = i[1];\n  return s = s || 0, c = (c || 0) * o, [Xe, ct].indexOf(n) >= 0 ? {\n    x: c,\n    y: s\n  } : {\n    x: s,\n    y: c\n  };\n}\nfunction wp(e) {\n  var t = e.state, r = e.options, n = e.name, o = r.offset, i = o === void 0 ? [0, 0] : o, s = ws.reduce(function(p, m) {\n    return p[m] = Tp(m, t.rects, i), p;\n  }, {}), c = s[t.placement], l = c.x, u = c.y;\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += u), t.modifiersData[n] = s;\n}\nconst Op = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: wp\n};\nfunction Rp(e) {\n  var t = e.state, r = e.name;\n  t.modifiersData[r] = Ns({\n    reference: t.rects.reference,\n    element: t.rects.popper,\n    strategy: \"absolute\",\n    placement: t.placement\n  });\n}\nconst $p = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: Rp,\n  data: {}\n};\nfunction Pp(e) {\n  return e === \"x\" ? \"y\" : \"x\";\n}\nfunction kp(e) {\n  var t = e.state, r = e.options, n = e.name, o = r.mainAxis, i = o === void 0 ? !0 : o, s = r.altAxis, c = s === void 0 ? !1 : s, l = r.boundary, u = r.rootBoundary, p = r.altBoundary, m = r.padding, g = r.tether, x = g === void 0 ? !0 : g, y = r.tetherOffset, f = y === void 0 ? 0 : y, S = kr(t, {\n    boundary: l,\n    rootBoundary: u,\n    padding: m,\n    altBoundary: p\n  }), E = xt(t.placement), P = nr(t.placement), T = !P, b = Xo(E), h = Pp(b), w = t.modifiersData.popperOffsets, k = t.rects.reference, L = t.rects.popper, B = typeof f == \"function\" ? f(Object.assign({}, t.rects, {\n    placement: t.placement\n  })) : f, d = typeof B == \"number\" ? {\n    mainAxis: B,\n    altAxis: B\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, B), A = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, D = {\n    x: 0,\n    y: 0\n  };\n  if (w) {\n    if (i) {\n      var j, W = b === \"y\" ? Ke : Xe, z = b === \"y\" ? st : ct, U = b === \"y\" ? \"height\" : \"width\", V = w[b], te = V + S[W], F = V - S[z], R = x ? -L[U] / 2 : 0, I = P === er ? k[U] : L[U], J = P === er ? -L[U] : -k[U], Q = t.elements.arrow, H = x && Q ? Ko(Q) : {\n        width: 0,\n        height: 0\n      }, X = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : $s(), _ = X[W], q = X[z], G = xr(0, k[U], H[U]), re = T ? k[U] / 2 - R - G - _ - d.mainAxis : I - G - _ - d.mainAxis, Z = T ? -k[U] / 2 + R + G + q + d.mainAxis : J + G + q + d.mainAxis, ae = t.elements.arrow && Vr(t.elements.arrow), O = ae ? b === \"y\" ? ae.clientTop || 0 : ae.clientLeft || 0 : 0, ye = (j = A == null ? void 0 : A[b]) != null ? j : 0, Ee = V + re - ye - O, Me = V + Z - ye, Qe = xr(x ? En(te, Ee) : te, V, x ? Vt(F, Me) : F);\n      w[b] = Qe, D[b] = Qe - V;\n    }\n    if (c) {\n      var ve, Pe = b === \"x\" ? Ke : Xe, ze = b === \"x\" ? st : ct, Le = w[h], v = h === \"y\" ? \"height\" : \"width\", M = Le + S[Pe], Y = Le - S[ze], oe = [Ke, Xe].indexOf(E) !== -1, Re = (ve = A == null ? void 0 : A[h]) != null ? ve : 0, ue = oe ? M : Le - k[v] - L[v] - Re + d.altAxis, K = oe ? Le + k[v] + L[v] - Re - d.altAxis : Y, be = x && oe ? ep(ue, Le, K) : xr(x ? ue : M, Le, x ? K : Y);\n      w[h] = be, D[h] = be - Le;\n    }\n    t.modifiersData[n] = D;\n  }\n}\nconst Ap = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: kp,\n  requiresIfExists: [\"offset\"]\n};\nfunction Np(e) {\n  return {\n    scrollLeft: e.scrollLeft,\n    scrollTop: e.scrollTop\n  };\n}\nfunction Mp(e) {\n  return e === rt(e) || !it(e) ? Jo(e) : Np(e);\n}\nfunction Ip(e) {\n  var t = e.getBoundingClientRect(), r = tr(t.width) / e.offsetWidth || 1, n = tr(t.height) / e.offsetHeight || 1;\n  return r !== 1 || n !== 1;\n}\nfunction _p(e, t, r) {\n  r === void 0 && (r = !1);\n  var n = it(t), o = it(t) && Ip(t), i = It(t), s = rr(e, o, r), c = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, l = {\n    x: 0,\n    y: 0\n  };\n  return (n || !n && !r) && ((St(t) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n  Zo(i)) && (c = Mp(t)), it(t) ? (l = rr(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : i && (l.x = Qo(i))), {\n    x: s.left + c.scrollLeft - l.x,\n    y: s.top + c.scrollTop - l.y,\n    width: s.width,\n    height: s.height\n  };\n}\nfunction jp(e) {\n  var t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), n = [];\n  e.forEach(function(i) {\n    t.set(i.name, i);\n  });\n  function o(i) {\n    r.add(i.name);\n    var s = [].concat(i.requires || [], i.requiresIfExists || []);\n    s.forEach(function(c) {\n      if (!r.has(c)) {\n        var l = t.get(c);\n        l && o(l);\n      }\n    }), n.push(i);\n  }\n  return e.forEach(function(i) {\n    r.has(i.name) || o(i);\n  }), n;\n}\nfunction Dp(e) {\n  var t = jp(e);\n  return Gd.reduce(function(r, n) {\n    return r.concat(t.filter(function(o) {\n      return o.phase === n;\n    }));\n  }, []);\n}\nfunction Lp(e) {\n  var t;\n  return function() {\n    return t || (t = new Promise(function(r) {\n      Promise.resolve().then(function() {\n        t = void 0, r(e());\n      });\n    })), t;\n  };\n}\nfunction Bp(e) {\n  var t = e.reduce(function(r, n) {\n    var o = r[n.name];\n    return r[n.name] = o ? Object.assign({}, o, n, {\n      options: Object.assign({}, o.options, n.options),\n      data: Object.assign({}, o.data, n.data)\n    }) : n, r;\n  }, {});\n  return Object.keys(t).map(function(r) {\n    return t[r];\n  });\n}\nvar ga = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction ya() {\n  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)\n    t[r] = arguments[r];\n  return !t.some(function(n) {\n    return !(n && typeof n.getBoundingClientRect == \"function\");\n  });\n}\nfunction Vp(e) {\n  e === void 0 && (e = {});\n  var t = e, r = t.defaultModifiers, n = r === void 0 ? [] : r, o = t.defaultOptions, i = o === void 0 ? ga : o;\n  return function(c, l, u) {\n    u === void 0 && (u = i);\n    var p = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, ga, i),\n      modifiersData: {},\n      elements: {\n        reference: c,\n        popper: l\n      },\n      attributes: {},\n      styles: {}\n    }, m = [], g = !1, x = {\n      state: p,\n      setOptions: function(E) {\n        var P = typeof E == \"function\" ? E(p.options) : E;\n        f(), p.options = Object.assign({}, i, p.options, P), p.scrollParents = {\n          reference: zt(c) ? Sr(c) : c.contextElement ? Sr(c.contextElement) : [],\n          popper: Sr(l)\n        };\n        var T = Dp(Bp([].concat(n, p.options.modifiers)));\n        return p.orderedModifiers = T.filter(function(b) {\n          return b.enabled;\n        }), y(), x.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function() {\n        if (!g) {\n          var E = p.elements, P = E.reference, T = E.popper;\n          if (ya(P, T)) {\n            p.rects = {\n              reference: _p(P, Vr(T), p.options.strategy === \"fixed\"),\n              popper: Ko(T)\n            }, p.reset = !1, p.placement = p.options.placement, p.orderedModifiers.forEach(function(d) {\n              return p.modifiersData[d.name] = Object.assign({}, d.data);\n            });\n            for (var b = 0; b < p.orderedModifiers.length; b++) {\n              if (p.reset === !0) {\n                p.reset = !1, b = -1;\n                continue;\n              }\n              var h = p.orderedModifiers[b], w = h.fn, k = h.options, L = k === void 0 ? {} : k, B = h.name;\n              typeof w == \"function\" && (p = w({\n                state: p,\n                options: L,\n                name: B,\n                instance: x\n              }) || p);\n            }\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: Lp(function() {\n        return new Promise(function(S) {\n          x.forceUpdate(), S(p);\n        });\n      }),\n      destroy: function() {\n        f(), g = !0;\n      }\n    };\n    if (!ya(c, l))\n      return x;\n    x.setOptions(u).then(function(S) {\n      !g && u.onFirstUpdate && u.onFirstUpdate(S);\n    });\n    function y() {\n      p.orderedModifiers.forEach(function(S) {\n        var E = S.name, P = S.options, T = P === void 0 ? {} : P, b = S.effect;\n        if (typeof b == \"function\") {\n          var h = b({\n            state: p,\n            name: E,\n            instance: x,\n            options: T\n          }), w = function() {\n          };\n          m.push(h || w);\n        }\n      });\n    }\n    function f() {\n      m.forEach(function(S) {\n        return S();\n      }), m = [];\n    }\n    return x;\n  };\n}\nvar Fp = [up, $p, cp, Jd, Op, Sp, Ap, op, Cp], zp = /* @__PURE__ */ Vp({\n  defaultModifiers: Fp\n});\nfunction Wp(e) {\n  return typeof e == \"function\" ? e() : e;\n}\nconst Cn = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const {\n    children: n,\n    container: o,\n    disablePortal: i = !1\n  } = t, [s, c] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), l = at(/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(n) ? Bo(n) : null, r);\n  if (Ft(() => {\n    i || c(Wp(o) || document.body);\n  }, [o, i]), Ft(() => {\n    if (s && !i)\n      return uo(r, s), () => {\n        uo(r, null);\n      };\n  }, [r, s, i]), i) {\n    if (/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(n)) {\n      const u = {\n        ref: l\n      };\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(n, u);\n    }\n    return n;\n  }\n  return s && /* @__PURE__ */ react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(n, s);\n});\n true && (Cn.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //  To update them, edit the TypeScript types and run `pnpm proptypes`. \n  // \n  /**\n   * The children to render into the `container`.\n   */\n  children: a.node,\n  /**\n   * An HTML element or function that returns one.\n   * The `container` will have the portal children appended to it.\n   *\n   * You can also provide a callback, which is called in a React layout effect.\n   * This lets you set the container from a ref, and also makes server-side rendering possible.\n   *\n   * By default, it uses the body of the top-level document object,\n   * so it's simply `document.body` most of the time.\n   */\n  container: a.oneOfType([Or, a.func]),\n  /**\n   * The `children` will be under the DOM hierarchy of the parent component.\n   * @default false\n   */\n  disablePortal: a.bool\n});\n true && (Cn.propTypes = Do(Cn.propTypes));\nfunction Up(e) {\n  return Ve(\"MuiPopper\", e);\n}\nFe(\"MuiPopper\", [\"root\"]);\nfunction Yp(e, t) {\n  if (t === \"ltr\")\n    return e;\n  switch (e) {\n    case \"bottom-end\":\n      return \"bottom-start\";\n    case \"bottom-start\":\n      return \"bottom-end\";\n    case \"top-end\":\n      return \"top-start\";\n    case \"top-start\":\n      return \"top-end\";\n    default:\n      return e;\n  }\n}\nfunction Tn(e) {\n  return typeof e == \"function\" ? e() : e;\n}\nfunction Wn(e) {\n  return e.nodeType !== void 0;\n}\nfunction Hp(e) {\n  return !Wn(e);\n}\nconst qp = (e) => {\n  const {\n    classes: t\n  } = e;\n  return Ge({\n    root: [\"root\"]\n  }, Up, t);\n}, Gp = {}, Kp = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const {\n    anchorEl: n,\n    children: o,\n    direction: i,\n    disablePortal: s,\n    modifiers: c,\n    open: l,\n    placement: u,\n    popperOptions: p,\n    popperRef: m,\n    slotProps: g = {},\n    slots: x = {},\n    TransitionProps: y,\n    // @ts-ignore internal logic\n    ownerState: f,\n    // prevent from spreading to DOM, it can come from the parent component e.g. Select.\n    ...S\n  } = t, E = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), P = at(E, r), T = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), b = at(T, m), h = react__WEBPACK_IMPORTED_MODULE_0__.useRef(b);\n  Ft(() => {\n    h.current = b;\n  }, [b]), react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(m, () => T.current, []);\n  const w = Yp(u, i), [k, L] = react__WEBPACK_IMPORTED_MODULE_0__.useState(w), [B, d] = react__WEBPACK_IMPORTED_MODULE_0__.useState(Tn(n));\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    T.current && T.current.forceUpdate();\n  }), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    n && d(Tn(n));\n  }, [n]), Ft(() => {\n    if (!B || !l)\n      return;\n    const z = (te) => {\n      L(te.placement);\n    };\n    if ( true && B && Wn(B) && B.nodeType === 1) {\n      const te = B.getBoundingClientRect();\n       true && te.top === 0 && te.left === 0 && te.right === 0 && te.bottom === 0 && console.warn([\"MUI: The `anchorEl` prop provided to the component is invalid.\", \"The anchor element should be part of the document layout.\", \"Make sure the element is present in the document or that it's not display none.\"].join(`\n`));\n    }\n    let U = [{\n      name: \"preventOverflow\",\n      options: {\n        altBoundary: s\n      }\n    }, {\n      name: \"flip\",\n      options: {\n        altBoundary: s\n      }\n    }, {\n      name: \"onUpdate\",\n      enabled: !0,\n      phase: \"afterWrite\",\n      fn: ({\n        state: te\n      }) => {\n        z(te);\n      }\n    }];\n    c != null && (U = U.concat(c)), p && p.modifiers != null && (U = U.concat(p.modifiers));\n    const V = zp(B, E.current, {\n      placement: w,\n      ...p,\n      modifiers: U\n    });\n    return h.current(V), () => {\n      V.destroy(), h.current(null);\n    };\n  }, [B, s, c, l, p, w]);\n  const A = {\n    placement: k\n  };\n  y !== null && (A.TransitionProps = y);\n  const D = qp(t), j = x.root ?? \"div\", W = Yu({\n    elementType: j,\n    externalSlotProps: g.root,\n    externalForwardedProps: S,\n    additionalProps: {\n      role: \"tooltip\",\n      ref: P\n    },\n    ownerState: t,\n    className: D.root\n  });\n  return /* @__PURE__ */ N.jsx(j, {\n    ...W,\n    children: typeof o == \"function\" ? o(A) : o\n  });\n}), Ms = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const {\n    anchorEl: n,\n    children: o,\n    container: i,\n    direction: s = \"ltr\",\n    disablePortal: c = !1,\n    keepMounted: l = !1,\n    modifiers: u,\n    open: p,\n    placement: m = \"bottom\",\n    popperOptions: g = Gp,\n    popperRef: x,\n    style: y,\n    transition: f = !1,\n    slotProps: S = {},\n    slots: E = {},\n    ...P\n  } = t, [T, b] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!0), h = () => {\n    b(!1);\n  }, w = () => {\n    b(!0);\n  };\n  if (!l && !p && (!f || T))\n    return null;\n  let k;\n  if (i)\n    k = i;\n  else if (n) {\n    const d = Tn(n);\n    k = d && Wn(d) ? zi(d).body : zi(null).body;\n  }\n  const L = !p && l && (!f || T) ? \"none\" : void 0, B = f ? {\n    in: p,\n    onEnter: h,\n    onExited: w\n  } : void 0;\n  return /* @__PURE__ */ N.jsx(Cn, {\n    disablePortal: c,\n    container: k,\n    children: /* @__PURE__ */ N.jsx(Kp, {\n      anchorEl: n,\n      direction: s,\n      disablePortal: c,\n      modifiers: u,\n      ref: r,\n      open: f ? !T : p,\n      placement: m,\n      popperOptions: g,\n      popperRef: x,\n      slotProps: S,\n      slots: E,\n      ...P,\n      style: {\n        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.\n        position: \"fixed\",\n        // Fix Popper.js display issue\n        top: 0,\n        left: 0,\n        display: L,\n        ...y\n      },\n      TransitionProps: B,\n      children: o\n    })\n  });\n});\n true && (Ms.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //  To update them, edit the TypeScript types and run `pnpm proptypes`. \n  // \n  /**\n   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),\n   * or a function that returns either.\n   * It's used to set the position of the popper.\n   * The return value will passed as the reference object of the Popper instance.\n   */\n  anchorEl: ar(a.oneOfType([Or, a.object, a.func]), (e) => {\n    if (e.open) {\n      const t = Tn(e.anchorEl);\n      if (t && Wn(t) && t.nodeType === 1) {\n        const r = t.getBoundingClientRect();\n        if ( true && r.top === 0 && r.left === 0 && r.right === 0 && r.bottom === 0)\n          return new Error([\"MUI: The `anchorEl` prop provided to the component is invalid.\", \"The anchor element should be part of the document layout.\", \"Make sure the element is present in the document or that it's not display none.\"].join(`\n`));\n      } else if (!t || typeof t.getBoundingClientRect != \"function\" || Hp(t) && t.contextElement != null && t.contextElement.nodeType !== 1)\n        return new Error([\"MUI: The `anchorEl` prop provided to the component is invalid.\", \"It should be an HTML element instance or a virtualElement \", \"(https://popper.js.org/docs/v2/virtual-elements/).\"].join(`\n`));\n    }\n    return null;\n  }),\n  /**\n   * Popper render function or node.\n   */\n  children: a.oneOfType([a.node, a.func]),\n  /**\n   * An HTML element or function that returns one.\n   * The `container` will have the portal children appended to it.\n   *\n   * You can also provide a callback, which is called in a React layout effect.\n   * This lets you set the container from a ref, and also makes server-side rendering possible.\n   *\n   * By default, it uses the body of the top-level document object,\n   * so it's simply `document.body` most of the time.\n   */\n  container: a.oneOfType([Or, a.func]),\n  /**\n   * Direction of the text.\n   * @default 'ltr'\n   */\n  direction: a.oneOf([\"ltr\", \"rtl\"]),\n  /**\n   * The `children` will be under the DOM hierarchy of the parent component.\n   * @default false\n   */\n  disablePortal: a.bool,\n  /**\n   * Always keep the children in the DOM.\n   * This prop can be useful in SEO situation or\n   * when you want to maximize the responsiveness of the Popper.\n   * @default false\n   */\n  keepMounted: a.bool,\n  /**\n   * Popper.js is based on a \"plugin-like\" architecture,\n   * most of its features are fully encapsulated \"modifiers\".\n   *\n   * A modifier is a function that is called each time Popper.js needs to\n   * compute the position of the popper.\n   * For this reason, modifiers should be very performant to avoid bottlenecks.\n   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).\n   */\n  modifiers: a.arrayOf(a.shape({\n    data: a.object,\n    effect: a.func,\n    enabled: a.bool,\n    fn: a.func,\n    name: a.any,\n    options: a.object,\n    phase: a.oneOf([\"afterMain\", \"afterRead\", \"afterWrite\", \"beforeMain\", \"beforeRead\", \"beforeWrite\", \"main\", \"read\", \"write\"]),\n    requires: a.arrayOf(a.string),\n    requiresIfExists: a.arrayOf(a.string)\n  })),\n  /**\n   * If `true`, the component is shown.\n   */\n  open: a.bool.isRequired,\n  /**\n   * Popper placement.\n   * @default 'bottom'\n   */\n  placement: a.oneOf([\"auto-end\", \"auto-start\", \"auto\", \"bottom-end\", \"bottom-start\", \"bottom\", \"left-end\", \"left-start\", \"left\", \"right-end\", \"right-start\", \"right\", \"top-end\", \"top-start\", \"top\"]),\n  /**\n   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.\n   * @default {}\n   */\n  popperOptions: a.shape({\n    modifiers: a.array,\n    onFirstUpdate: a.func,\n    placement: a.oneOf([\"auto-end\", \"auto-start\", \"auto\", \"bottom-end\", \"bottom-start\", \"bottom\", \"left-end\", \"left-start\", \"left\", \"right-end\", \"right-start\", \"right\", \"top-end\", \"top-start\", \"top\"]),\n    strategy: a.oneOf([\"absolute\", \"fixed\"])\n  }),\n  /**\n   * A ref that points to the used popper instance.\n   */\n  popperRef: Lo,\n  /**\n   * The props used for each slot inside the Popper.\n   * @default {}\n   */\n  slotProps: a.shape({\n    root: a.oneOfType([a.func, a.object])\n  }),\n  /**\n   * The components used for each slot inside the Popper.\n   * Either a string to use a HTML element or a component.\n   * @default {}\n   */\n  slots: a.shape({\n    root: a.elementType\n  }),\n  /**\n   * Help supporting a react-transition-group/Transition component.\n   * @default false\n   */\n  transition: a.bool\n});\nconst Xp = le(Ms, {\n  name: \"MuiPopper\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => t.root\n})({}), ei = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = is(), o = He({\n    props: t,\n    name: \"MuiPopper\"\n  }), {\n    anchorEl: i,\n    component: s,\n    components: c,\n    componentsProps: l,\n    container: u,\n    disablePortal: p,\n    keepMounted: m,\n    modifiers: g,\n    open: x,\n    placement: y,\n    popperOptions: f,\n    popperRef: S,\n    transition: E,\n    slots: P,\n    slotProps: T,\n    ...b\n  } = o, h = (P == null ? void 0 : P.root) ?? (c == null ? void 0 : c.Root), w = {\n    anchorEl: i,\n    container: u,\n    disablePortal: p,\n    keepMounted: m,\n    modifiers: g,\n    open: x,\n    placement: y,\n    popperOptions: f,\n    popperRef: S,\n    transition: E,\n    ...b\n  };\n  return /* @__PURE__ */ N.jsx(Xp, {\n    as: s,\n    direction: n ? \"rtl\" : \"ltr\",\n    slots: {\n      root: h\n    },\n    slotProps: T ?? l,\n    ...w,\n    ref: r\n  });\n});\n true && (ei.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //  To update them, edit the TypeScript types and run `pnpm proptypes`. \n  // \n  /**\n   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),\n   * or a function that returns either.\n   * It's used to set the position of the popper.\n   * The return value will passed as the reference object of the Popper instance.\n   */\n  anchorEl: a.oneOfType([Or, a.object, a.func]),\n  /**\n   * Popper render function or node.\n   */\n  children: a.oneOfType([a.node, a.func]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * The components used for each slot inside the Popper.\n   * Either a string to use a HTML element or a component.\n   *\n   * @deprecated use the `slots` prop instead. This prop will be removed in v7. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).\n   * @default {}\n   */\n  components: a.shape({\n    Root: a.elementType\n  }),\n  /**\n   * The props used for each slot inside the Popper.\n   *\n   * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).\n   * @default {}\n   */\n  componentsProps: a.shape({\n    root: a.oneOfType([a.func, a.object])\n  }),\n  /**\n   * An HTML element or function that returns one.\n   * The `container` will have the portal children appended to it.\n   *\n   * You can also provide a callback, which is called in a React layout effect.\n   * This lets you set the container from a ref, and also makes server-side rendering possible.\n   *\n   * By default, it uses the body of the top-level document object,\n   * so it's simply `document.body` most of the time.\n   */\n  container: a.oneOfType([Or, a.func]),\n  /**\n   * The `children` will be under the DOM hierarchy of the parent component.\n   * @default false\n   */\n  disablePortal: a.bool,\n  /**\n   * Always keep the children in the DOM.\n   * This prop can be useful in SEO situation or\n   * when you want to maximize the responsiveness of the Popper.\n   * @default false\n   */\n  keepMounted: a.bool,\n  /**\n   * Popper.js is based on a \"plugin-like\" architecture,\n   * most of its features are fully encapsulated \"modifiers\".\n   *\n   * A modifier is a function that is called each time Popper.js needs to\n   * compute the position of the popper.\n   * For this reason, modifiers should be very performant to avoid bottlenecks.\n   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).\n   */\n  modifiers: a.arrayOf(a.shape({\n    data: a.object,\n    effect: a.func,\n    enabled: a.bool,\n    fn: a.func,\n    name: a.any,\n    options: a.object,\n    phase: a.oneOf([\"afterMain\", \"afterRead\", \"afterWrite\", \"beforeMain\", \"beforeRead\", \"beforeWrite\", \"main\", \"read\", \"write\"]),\n    requires: a.arrayOf(a.string),\n    requiresIfExists: a.arrayOf(a.string)\n  })),\n  /**\n   * If `true`, the component is shown.\n   */\n  open: a.bool.isRequired,\n  /**\n   * Popper placement.\n   * @default 'bottom'\n   */\n  placement: a.oneOf([\"auto-end\", \"auto-start\", \"auto\", \"bottom-end\", \"bottom-start\", \"bottom\", \"left-end\", \"left-start\", \"left\", \"right-end\", \"right-start\", \"right\", \"top-end\", \"top-start\", \"top\"]),\n  /**\n   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.\n   * @default {}\n   */\n  popperOptions: a.shape({\n    modifiers: a.array,\n    onFirstUpdate: a.func,\n    placement: a.oneOf([\"auto-end\", \"auto-start\", \"auto\", \"bottom-end\", \"bottom-start\", \"bottom\", \"left-end\", \"left-start\", \"left\", \"right-end\", \"right-start\", \"right\", \"top-end\", \"top-start\", \"top\"]),\n    strategy: a.oneOf([\"absolute\", \"fixed\"])\n  }),\n  /**\n   * A ref that points to the used popper instance.\n   */\n  popperRef: Lo,\n  /**\n   * The props used for each slot inside the Popper.\n   * @default {}\n   */\n  slotProps: a.shape({\n    root: a.oneOfType([a.func, a.object])\n  }),\n  /**\n   * The components used for each slot inside the Popper.\n   * Either a string to use a HTML element or a component.\n   * @default {}\n   */\n  slots: a.shape({\n    root: a.elementType\n  }),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * Help supporting a react-transition-group/Transition component.\n   * @default false\n   */\n  transition: a.bool\n});\nfunction Jp(e) {\n  return Ve(\"MuiListSubheader\", e);\n}\nFe(\"MuiListSubheader\", [\"root\", \"colorPrimary\", \"colorInherit\", \"gutters\", \"inset\", \"sticky\"]);\nconst Qp = (e) => {\n  const {\n    classes: t,\n    color: r,\n    disableGutters: n,\n    inset: o,\n    disableSticky: i\n  } = e, s = {\n    root: [\"root\", r !== \"default\" && `color${ee(r)}`, !n && \"gutters\", o && \"inset\", !i && \"sticky\"]\n  };\n  return Ge(s, Jp, t);\n}, Zp = le(\"li\", {\n  name: \"MuiListSubheader\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, r.color !== \"default\" && t[`color${ee(r.color)}`], !r.disableGutters && t.gutters, r.inset && t.inset, !r.disableSticky && t.sticky];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  boxSizing: \"border-box\",\n  lineHeight: \"48px\",\n  listStyle: \"none\",\n  color: (e.vars || e).palette.text.secondary,\n  fontFamily: e.typography.fontFamily,\n  fontWeight: e.typography.fontWeightMedium,\n  fontSize: e.typography.pxToRem(14),\n  variants: [{\n    props: {\n      color: \"primary\"\n    },\n    style: {\n      color: (e.vars || e).palette.primary.main\n    }\n  }, {\n    props: {\n      color: \"inherit\"\n    },\n    style: {\n      color: \"inherit\"\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !t.disableGutters,\n    style: {\n      paddingLeft: 16,\n      paddingRight: 16\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.inset,\n    style: {\n      paddingLeft: 72\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !t.disableSticky,\n    style: {\n      position: \"sticky\",\n      top: 0,\n      zIndex: 1,\n      backgroundColor: (e.vars || e).palette.background.paper\n    }\n  }]\n}))), wn = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiListSubheader\"\n  }), {\n    className: o,\n    color: i = \"default\",\n    component: s = \"li\",\n    disableGutters: c = !1,\n    disableSticky: l = !1,\n    inset: u = !1,\n    ...p\n  } = n, m = {\n    ...n,\n    color: i,\n    component: s,\n    disableGutters: c,\n    disableSticky: l,\n    inset: u\n  }, g = Qp(m);\n  return /* @__PURE__ */ N.jsx(Zp, {\n    as: s,\n    className: se(g.root, o),\n    ref: r,\n    ownerState: m,\n    ...p\n  });\n});\nwn && (wn.muiSkipListHighlight = !0);\n true && (wn.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The content of the component.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The color of the component. It supports those theme colors that make sense for this component.\n   * @default 'default'\n   */\n  color: a.oneOf([\"default\", \"inherit\", \"primary\"]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * If `true`, the List Subheader will not have gutters.\n   * @default false\n   */\n  disableGutters: a.bool,\n  /**\n   * If `true`, the List Subheader will not stick to the top during scroll.\n   * @default false\n   */\n  disableSticky: a.bool,\n  /**\n   * If `true`, the List Subheader is indented.\n   * @default false\n   */\n  inset: a.bool,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nconst em = sr(/* @__PURE__ */ N.jsx(\"path\", {\n  d: \"M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z\"\n}), \"Cancel\");\nfunction tm(e) {\n  return Ve(\"MuiChip\", e);\n}\nconst ie = Fe(\"MuiChip\", [\"root\", \"sizeSmall\", \"sizeMedium\", \"colorDefault\", \"colorError\", \"colorInfo\", \"colorPrimary\", \"colorSecondary\", \"colorSuccess\", \"colorWarning\", \"disabled\", \"clickable\", \"clickableColorPrimary\", \"clickableColorSecondary\", \"deletable\", \"deletableColorPrimary\", \"deletableColorSecondary\", \"outlined\", \"filled\", \"outlinedPrimary\", \"outlinedSecondary\", \"filledPrimary\", \"filledSecondary\", \"avatar\", \"avatarSmall\", \"avatarMedium\", \"avatarColorPrimary\", \"avatarColorSecondary\", \"icon\", \"iconSmall\", \"iconMedium\", \"iconColorPrimary\", \"iconColorSecondary\", \"label\", \"labelSmall\", \"labelMedium\", \"deleteIcon\", \"deleteIconSmall\", \"deleteIconMedium\", \"deleteIconColorPrimary\", \"deleteIconColorSecondary\", \"deleteIconOutlinedColorPrimary\", \"deleteIconOutlinedColorSecondary\", \"deleteIconFilledColorPrimary\", \"deleteIconFilledColorSecondary\", \"focusVisible\"]), rm = (e) => {\n  const {\n    classes: t,\n    disabled: r,\n    size: n,\n    color: o,\n    iconColor: i,\n    onDelete: s,\n    clickable: c,\n    variant: l\n  } = e, u = {\n    root: [\"root\", l, r && \"disabled\", `size${ee(n)}`, `color${ee(o)}`, c && \"clickable\", c && `clickableColor${ee(o)}`, s && \"deletable\", s && `deletableColor${ee(o)}`, `${l}${ee(o)}`],\n    label: [\"label\", `label${ee(n)}`],\n    avatar: [\"avatar\", `avatar${ee(n)}`, `avatarColor${ee(o)}`],\n    icon: [\"icon\", `icon${ee(n)}`, `iconColor${ee(i)}`],\n    deleteIcon: [\"deleteIcon\", `deleteIcon${ee(n)}`, `deleteIconColor${ee(o)}`, `deleteIcon${ee(l)}Color${ee(o)}`]\n  };\n  return Ge(u, tm, t);\n}, nm = le(\"div\", {\n  name: \"MuiChip\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e, {\n      color: n,\n      iconColor: o,\n      clickable: i,\n      onDelete: s,\n      size: c,\n      variant: l\n    } = r;\n    return [{\n      [`& .${ie.avatar}`]: t.avatar\n    }, {\n      [`& .${ie.avatar}`]: t[`avatar${ee(c)}`]\n    }, {\n      [`& .${ie.avatar}`]: t[`avatarColor${ee(n)}`]\n    }, {\n      [`& .${ie.icon}`]: t.icon\n    }, {\n      [`& .${ie.icon}`]: t[`icon${ee(c)}`]\n    }, {\n      [`& .${ie.icon}`]: t[`iconColor${ee(o)}`]\n    }, {\n      [`& .${ie.deleteIcon}`]: t.deleteIcon\n    }, {\n      [`& .${ie.deleteIcon}`]: t[`deleteIcon${ee(c)}`]\n    }, {\n      [`& .${ie.deleteIcon}`]: t[`deleteIconColor${ee(n)}`]\n    }, {\n      [`& .${ie.deleteIcon}`]: t[`deleteIcon${ee(l)}Color${ee(n)}`]\n    }, t.root, t[`size${ee(c)}`], t[`color${ee(n)}`], i && t.clickable, i && n !== \"default\" && t[`clickableColor${ee(n)})`], s && t.deletable, s && n !== \"default\" && t[`deletableColor${ee(n)}`], t[l], t[`${l}${ee(n)}`]];\n  }\n})(qe(({\n  theme: e\n}) => {\n  const t = e.palette.mode === \"light\" ? e.palette.grey[700] : e.palette.grey[300];\n  return {\n    maxWidth: \"100%\",\n    fontFamily: e.typography.fontFamily,\n    fontSize: e.typography.pxToRem(13),\n    display: \"inline-flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    height: 32,\n    color: (e.vars || e).palette.text.primary,\n    backgroundColor: (e.vars || e).palette.action.selected,\n    borderRadius: 32 / 2,\n    whiteSpace: \"nowrap\",\n    transition: e.transitions.create([\"background-color\", \"box-shadow\"]),\n    // reset cursor explicitly in case ButtonBase is used\n    cursor: \"unset\",\n    // We disable the focus ring for mouse, touch and keyboard users.\n    outline: 0,\n    textDecoration: \"none\",\n    border: 0,\n    // Remove `button` border\n    padding: 0,\n    // Remove `button` padding\n    verticalAlign: \"middle\",\n    boxSizing: \"border-box\",\n    [`&.${ie.disabled}`]: {\n      opacity: (e.vars || e).palette.action.disabledOpacity,\n      pointerEvents: \"none\"\n    },\n    [`& .${ie.avatar}`]: {\n      marginLeft: 5,\n      marginRight: -6,\n      width: 24,\n      height: 24,\n      color: e.vars ? e.vars.palette.Chip.defaultAvatarColor : t,\n      fontSize: e.typography.pxToRem(12)\n    },\n    [`& .${ie.avatarColorPrimary}`]: {\n      color: (e.vars || e).palette.primary.contrastText,\n      backgroundColor: (e.vars || e).palette.primary.dark\n    },\n    [`& .${ie.avatarColorSecondary}`]: {\n      color: (e.vars || e).palette.secondary.contrastText,\n      backgroundColor: (e.vars || e).palette.secondary.dark\n    },\n    [`& .${ie.avatarSmall}`]: {\n      marginLeft: 4,\n      marginRight: -4,\n      width: 18,\n      height: 18,\n      fontSize: e.typography.pxToRem(10)\n    },\n    [`& .${ie.icon}`]: {\n      marginLeft: 5,\n      marginRight: -6\n    },\n    [`& .${ie.deleteIcon}`]: {\n      WebkitTapHighlightColor: \"transparent\",\n      color: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.26)` : De(e.palette.text.primary, 0.26),\n      fontSize: 22,\n      cursor: \"pointer\",\n      margin: \"0 5px 0 -6px\",\n      \"&:hover\": {\n        color: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.4)` : De(e.palette.text.primary, 0.4)\n      }\n    },\n    variants: [{\n      props: {\n        size: \"small\"\n      },\n      style: {\n        height: 24,\n        [`& .${ie.icon}`]: {\n          fontSize: 18,\n          marginLeft: 4,\n          marginRight: -4\n        },\n        [`& .${ie.deleteIcon}`]: {\n          fontSize: 16,\n          marginRight: 4,\n          marginLeft: -4\n        }\n      }\n    }, ...Object.entries(e.palette).filter(Pt([\"contrastText\"])).map(([r]) => ({\n      props: {\n        color: r\n      },\n      style: {\n        backgroundColor: (e.vars || e).palette[r].main,\n        color: (e.vars || e).palette[r].contrastText,\n        [`& .${ie.deleteIcon}`]: {\n          color: e.vars ? `rgba(${e.vars.palette[r].contrastTextChannel} / 0.7)` : De(e.palette[r].contrastText, 0.7),\n          \"&:hover, &:active\": {\n            color: (e.vars || e).palette[r].contrastText\n          }\n        }\n      }\n    })), {\n      props: (r) => r.iconColor === r.color,\n      style: {\n        [`& .${ie.icon}`]: {\n          color: e.vars ? e.vars.palette.Chip.defaultIconColor : t\n        }\n      }\n    }, {\n      props: (r) => r.iconColor === r.color && r.color !== \"default\",\n      style: {\n        [`& .${ie.icon}`]: {\n          color: \"inherit\"\n        }\n      }\n    }, {\n      props: {\n        onDelete: !0\n      },\n      style: {\n        [`&.${ie.focusVisible}`]: {\n          backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : De(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)\n        }\n      }\n    }, ...Object.entries(e.palette).filter(Pt([\"dark\"])).map(([r]) => ({\n      props: {\n        color: r,\n        onDelete: !0\n      },\n      style: {\n        [`&.${ie.focusVisible}`]: {\n          background: (e.vars || e).palette[r].dark\n        }\n      }\n    })), {\n      props: {\n        clickable: !0\n      },\n      style: {\n        userSelect: \"none\",\n        WebkitTapHighlightColor: \"transparent\",\n        cursor: \"pointer\",\n        \"&:hover\": {\n          backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : De(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)\n        },\n        [`&.${ie.focusVisible}`]: {\n          backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : De(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)\n        },\n        \"&:active\": {\n          boxShadow: (e.vars || e).shadows[1]\n        }\n      }\n    }, ...Object.entries(e.palette).filter(Pt([\"dark\"])).map(([r]) => ({\n      props: {\n        color: r,\n        clickable: !0\n      },\n      style: {\n        [`&:hover, &.${ie.focusVisible}`]: {\n          backgroundColor: (e.vars || e).palette[r].dark\n        }\n      }\n    })), {\n      props: {\n        variant: \"outlined\"\n      },\n      style: {\n        backgroundColor: \"transparent\",\n        border: e.vars ? `1px solid ${e.vars.palette.Chip.defaultBorder}` : `1px solid ${e.palette.mode === \"light\" ? e.palette.grey[400] : e.palette.grey[700]}`,\n        [`&.${ie.clickable}:hover`]: {\n          backgroundColor: (e.vars || e).palette.action.hover\n        },\n        [`&.${ie.focusVisible}`]: {\n          backgroundColor: (e.vars || e).palette.action.focus\n        },\n        [`& .${ie.avatar}`]: {\n          marginLeft: 4\n        },\n        [`& .${ie.avatarSmall}`]: {\n          marginLeft: 2\n        },\n        [`& .${ie.icon}`]: {\n          marginLeft: 4\n        },\n        [`& .${ie.iconSmall}`]: {\n          marginLeft: 2\n        },\n        [`& .${ie.deleteIcon}`]: {\n          marginRight: 5\n        },\n        [`& .${ie.deleteIconSmall}`]: {\n          marginRight: 3\n        }\n      }\n    }, ...Object.entries(e.palette).filter(Pt()).map(([r]) => ({\n      props: {\n        variant: \"outlined\",\n        color: r\n      },\n      style: {\n        color: (e.vars || e).palette[r].main,\n        border: `1px solid ${e.vars ? `rgba(${e.vars.palette[r].mainChannel} / 0.7)` : De(e.palette[r].main, 0.7)}`,\n        [`&.${ie.clickable}:hover`]: {\n          backgroundColor: e.vars ? `rgba(${e.vars.palette[r].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : De(e.palette[r].main, e.palette.action.hoverOpacity)\n        },\n        [`&.${ie.focusVisible}`]: {\n          backgroundColor: e.vars ? `rgba(${e.vars.palette[r].mainChannel} / ${e.vars.palette.action.focusOpacity})` : De(e.palette[r].main, e.palette.action.focusOpacity)\n        },\n        [`& .${ie.deleteIcon}`]: {\n          color: e.vars ? `rgba(${e.vars.palette[r].mainChannel} / 0.7)` : De(e.palette[r].main, 0.7),\n          \"&:hover, &:active\": {\n            color: (e.vars || e).palette[r].main\n          }\n        }\n      }\n    }))]\n  };\n})), om = le(\"span\", {\n  name: \"MuiChip\",\n  slot: \"Label\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e, {\n      size: n\n    } = r;\n    return [t.label, t[`label${ee(n)}`]];\n  }\n})({\n  overflow: \"hidden\",\n  textOverflow: \"ellipsis\",\n  paddingLeft: 12,\n  paddingRight: 12,\n  whiteSpace: \"nowrap\",\n  variants: [{\n    props: {\n      variant: \"outlined\"\n    },\n    style: {\n      paddingLeft: 11,\n      paddingRight: 11\n    }\n  }, {\n    props: {\n      size: \"small\"\n    },\n    style: {\n      paddingLeft: 8,\n      paddingRight: 8\n    }\n  }, {\n    props: {\n      size: \"small\",\n      variant: \"outlined\"\n    },\n    style: {\n      paddingLeft: 7,\n      paddingRight: 7\n    }\n  }]\n});\nfunction ba(e) {\n  return e.key === \"Backspace\" || e.key === \"Delete\";\n}\nconst Is = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiChip\"\n  }), {\n    avatar: o,\n    className: i,\n    clickable: s,\n    color: c = \"default\",\n    component: l,\n    deleteIcon: u,\n    disabled: p = !1,\n    icon: m,\n    label: g,\n    onClick: x,\n    onDelete: y,\n    onKeyDown: f,\n    onKeyUp: S,\n    size: E = \"medium\",\n    variant: P = \"filled\",\n    tabIndex: T,\n    skipFocusWhenDisabled: b = !1,\n    // TODO v6: Rename to `focusableWhenDisabled`.\n    ...h\n  } = n, w = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), k = at(w, r), L = (F) => {\n    F.stopPropagation(), y && y(F);\n  }, B = (F) => {\n    F.currentTarget === F.target && ba(F) && F.preventDefault(), f && f(F);\n  }, d = (F) => {\n    F.currentTarget === F.target && y && ba(F) && y(F), S && S(F);\n  }, A = s !== !1 && x ? !0 : s, D = A || y ? $r : l || \"div\", j = {\n    ...n,\n    component: D,\n    disabled: p,\n    size: E,\n    color: c,\n    iconColor: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(m) && m.props.color || c,\n    onDelete: !!y,\n    clickable: A,\n    variant: P\n  }, W = rm(j), z = D === $r ? {\n    component: l || \"div\",\n    focusVisibleClassName: W.focusVisible,\n    ...y && {\n      disableRipple: !0\n    }\n  } : {};\n  let U = null;\n  y && (U = u && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(u) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(u, {\n    className: se(u.props.className, W.deleteIcon),\n    onClick: L\n  }) : /* @__PURE__ */ N.jsx(em, {\n    className: se(W.deleteIcon),\n    onClick: L\n  }));\n  let V = null;\n  o && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(o) && (V = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(o, {\n    className: se(W.avatar, o.props.className)\n  }));\n  let te = null;\n  return m && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(m) && (te = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(m, {\n    className: se(W.icon, m.props.className)\n  })),  true && V && te && console.error(\"MUI: The Chip component can not handle the avatar and the icon prop at the same time. Pick one.\"), /* @__PURE__ */ N.jsxs(nm, {\n    as: D,\n    className: se(W.root, i),\n    disabled: A && p ? !0 : void 0,\n    onClick: x,\n    onKeyDown: B,\n    onKeyUp: d,\n    ref: k,\n    tabIndex: b && p ? -1 : T,\n    ownerState: j,\n    ...z,\n    ...h,\n    children: [V || te, /* @__PURE__ */ N.jsx(om, {\n      className: se(W.label),\n      ownerState: j,\n      children: g\n    }), U]\n  });\n});\n true && (Is.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The Avatar element to display.\n   */\n  avatar: a.element,\n  /**\n   * This prop isn't supported.\n   * Use the `component` prop if you need to change the children structure.\n   */\n  children: Bu,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * If `true`, the chip will appear clickable, and will raise when pressed,\n   * even if the onClick prop is not defined.\n   * If `false`, the chip will not appear clickable, even if onClick prop is defined.\n   * This can be used, for example,\n   * along with the component prop to indicate an anchor Chip is clickable.\n   * Note: this controls the UI and does not affect the onClick event.\n   */\n  clickable: a.bool,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'default'\n   */\n  color: a.oneOfType([a.oneOf([\"default\", \"primary\", \"secondary\", \"error\", \"info\", \"success\", \"warning\"]), a.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * Override the default delete icon element. Shown only if `onDelete` is set.\n   */\n  deleteIcon: a.element,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: a.bool,\n  /**\n   * Icon element.\n   */\n  icon: a.element,\n  /**\n   * The content of the component.\n   */\n  label: a.node,\n  /**\n   * @ignore\n   */\n  onClick: a.func,\n  /**\n   * Callback fired when the delete icon is clicked.\n   * If set, the delete icon will be shown.\n   */\n  onDelete: a.func,\n  /**\n   * @ignore\n   */\n  onKeyDown: a.func,\n  /**\n   * @ignore\n   */\n  onKeyUp: a.func,\n  /**\n   * The size of the component.\n   * @default 'medium'\n   */\n  size: a.oneOfType([a.oneOf([\"medium\", \"small\"]), a.string]),\n  /**\n   * If `true`, allows the disabled chip to escape focus.\n   * If `false`, allows the disabled chip to receive focus.\n   * @default false\n   */\n  skipFocusWhenDisabled: a.bool,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * @ignore\n   */\n  tabIndex: a.number,\n  /**\n   * The variant to use.\n   * @default 'filled'\n   */\n  variant: a.oneOfType([a.oneOf([\"filled\", \"outlined\"]), a.string])\n});\nconst im = sr(/* @__PURE__ */ N.jsx(\"path\", {\n  d: \"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\"\n}), \"Person\");\nfunction am(e) {\n  return Ve(\"MuiAvatar\", e);\n}\nFe(\"MuiAvatar\", [\"root\", \"colorDefault\", \"circular\", \"rounded\", \"square\", \"img\", \"fallback\"]);\nconst sm = (e) => {\n  const {\n    classes: t,\n    variant: r,\n    colorDefault: n\n  } = e;\n  return Ge({\n    root: [\"root\", r, n && \"colorDefault\"],\n    img: [\"img\"],\n    fallback: [\"fallback\"]\n  }, am, t);\n}, cm = le(\"div\", {\n  name: \"MuiAvatar\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, t[r.variant], r.colorDefault && t.colorDefault];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  position: \"relative\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  flexShrink: 0,\n  width: 40,\n  height: 40,\n  fontFamily: e.typography.fontFamily,\n  fontSize: e.typography.pxToRem(20),\n  lineHeight: 1,\n  borderRadius: \"50%\",\n  overflow: \"hidden\",\n  userSelect: \"none\",\n  variants: [{\n    props: {\n      variant: \"rounded\"\n    },\n    style: {\n      borderRadius: (e.vars || e).shape.borderRadius\n    }\n  }, {\n    props: {\n      variant: \"square\"\n    },\n    style: {\n      borderRadius: 0\n    }\n  }, {\n    props: {\n      colorDefault: !0\n    },\n    style: {\n      color: (e.vars || e).palette.background.default,\n      ...e.vars ? {\n        backgroundColor: e.vars.palette.Avatar.defaultBg\n      } : {\n        backgroundColor: e.palette.grey[400],\n        ...e.applyStyles(\"dark\", {\n          backgroundColor: e.palette.grey[600]\n        })\n      }\n    }\n  }]\n}))), lm = le(\"img\", {\n  name: \"MuiAvatar\",\n  slot: \"Img\",\n  overridesResolver: (e, t) => t.img\n})({\n  width: \"100%\",\n  height: \"100%\",\n  textAlign: \"center\",\n  // Handle non-square image.\n  objectFit: \"cover\",\n  // Hide alt text.\n  color: \"transparent\",\n  // Hide the image broken icon, only works on Chrome.\n  textIndent: 1e4\n}), um = le(im, {\n  name: \"MuiAvatar\",\n  slot: \"Fallback\",\n  overridesResolver: (e, t) => t.fallback\n})({\n  width: \"75%\",\n  height: \"75%\"\n});\nfunction fm({\n  crossOrigin: e,\n  referrerPolicy: t,\n  src: r,\n  srcSet: n\n}) {\n  const [o, i] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!r && !n)\n      return;\n    i(!1);\n    let s = !0;\n    const c = new Image();\n    return c.onload = () => {\n      s && i(\"loaded\");\n    }, c.onerror = () => {\n      s && i(\"error\");\n    }, c.crossOrigin = e, c.referrerPolicy = t, c.src = r, n && (c.srcset = n), () => {\n      s = !1;\n    };\n  }, [e, t, r, n]), o;\n}\nconst _s = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiAvatar\"\n  }), {\n    alt: o,\n    children: i,\n    className: s,\n    component: c = \"div\",\n    slots: l = {},\n    slotProps: u = {},\n    imgProps: p,\n    sizes: m,\n    src: g,\n    srcSet: x,\n    variant: y = \"circular\",\n    ...f\n  } = n;\n  let S = null;\n  const E = {\n    ...n,\n    component: c,\n    variant: y\n  }, P = fm({\n    ...p,\n    ...typeof u.img == \"function\" ? u.img(E) : u.img,\n    src: g,\n    srcSet: x\n  }), T = g || x, b = T && P !== \"error\";\n  E.colorDefault = !b, delete E.ownerState;\n  const h = sm(E), [w, k] = Bt(\"img\", {\n    className: h.img,\n    elementType: lm,\n    externalForwardedProps: {\n      slots: l,\n      slotProps: {\n        img: {\n          ...p,\n          ...u.img\n        }\n      }\n    },\n    additionalProps: {\n      alt: o,\n      src: g,\n      srcSet: x,\n      sizes: m\n    },\n    ownerState: E\n  });\n  return b ? S = /* @__PURE__ */ N.jsx(w, {\n    ...k\n  }) : i || i === 0 ? S = i : T && o ? S = o[0] : S = /* @__PURE__ */ N.jsx(um, {\n    ownerState: E,\n    className: h.fallback\n  }), /* @__PURE__ */ N.jsx(cm, {\n    as: c,\n    className: se(h.root, s),\n    ref: r,\n    ...f,\n    ownerState: E,\n    children: S\n  });\n});\n true && (_s.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Used in combination with `src` or `srcSet` to\n   * provide an alt attribute for the rendered `img` element.\n   */\n  alt: a.string,\n  /**\n   * Used to render icon or text elements inside the Avatar if `src` is not set.\n   * This can be an element, or just a string.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attributes) applied to the `img` element if the component is used to display an image.\n   * It can be used to listen for the loading error event.\n   * @deprecated Use `slotProps.img` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  imgProps: a.object,\n  /**\n   * The `sizes` attribute for the `img` element.\n   */\n  sizes: a.string,\n  /**\n   * The props used for each slot inside.\n   * @default {}\n   */\n  slotProps: a.shape({\n    img: a.oneOfType([a.func, a.object])\n  }),\n  /**\n   * The components used for each slot inside.\n   * @default {}\n   */\n  slots: a.shape({\n    img: a.elementType\n  }),\n  /**\n   * The `src` attribute for the `img` element.\n   */\n  src: a.string,\n  /**\n   * The `srcSet` attribute for the `img` element.\n   * Use this attribute for responsive image display.\n   */\n  srcSet: a.string,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * The shape of the avatar.\n   * @default 'circular'\n   */\n  variant: a.oneOfType([a.oneOf([\"circular\", \"rounded\", \"square\"]), a.string])\n});\nconst dm = Fe(\"MuiBox\", [\"root\"]), pm = Fn(), dt = bu({\n  themeId: wt,\n  defaultTheme: pm,\n  defaultClassName: dm.root,\n  generateClassName: Wa.generate\n});\n true && (dt.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * @ignore\n   */\n  children: a.node,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nfunction xo(e) {\n  return `scale(${e}, ${e ** 2})`;\n}\nconst mm = {\n  entering: {\n    opacity: 1,\n    transform: xo(1)\n  },\n  entered: {\n    opacity: 1,\n    transform: \"none\"\n  }\n}, no = typeof navigator < \"u\" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\\/)15(.|_)4/i.test(navigator.userAgent), On = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const {\n    addEndListener: n,\n    appear: o = !0,\n    children: i,\n    easing: s,\n    in: c,\n    onEnter: l,\n    onEntered: u,\n    onEntering: p,\n    onExit: m,\n    onExited: g,\n    onExiting: x,\n    style: y,\n    timeout: f = \"auto\",\n    // eslint-disable-next-line react/prop-types\n    TransitionComponent: S = Et,\n    ...E\n  } = t, P = Dt(), T = react__WEBPACK_IMPORTED_MODULE_0__.useRef(), b = Lr(), h = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), w = at(h, Bo(i), r), k = (z) => (U) => {\n    if (z) {\n      const V = h.current;\n      U === void 0 ? z(V) : z(V, U);\n    }\n  }, L = k(p), B = k((z, U) => {\n    td(z);\n    const {\n      duration: V,\n      delay: te,\n      easing: F\n    } = vn({\n      style: y,\n      timeout: f,\n      easing: s\n    }, {\n      mode: \"enter\"\n    });\n    let R;\n    f === \"auto\" ? (R = b.transitions.getAutoHeightDuration(z.clientHeight), T.current = R) : R = V, z.style.transition = [b.transitions.create(\"opacity\", {\n      duration: R,\n      delay: te\n    }), b.transitions.create(\"transform\", {\n      duration: no ? R : R * 0.666,\n      delay: te,\n      easing: F\n    })].join(\",\"), l && l(z, U);\n  }), d = k(u), A = k(x), D = k((z) => {\n    const {\n      duration: U,\n      delay: V,\n      easing: te\n    } = vn({\n      style: y,\n      timeout: f,\n      easing: s\n    }, {\n      mode: \"exit\"\n    });\n    let F;\n    f === \"auto\" ? (F = b.transitions.getAutoHeightDuration(z.clientHeight), T.current = F) : F = U, z.style.transition = [b.transitions.create(\"opacity\", {\n      duration: F,\n      delay: V\n    }), b.transitions.create(\"transform\", {\n      duration: no ? F : F * 0.666,\n      delay: no ? V : V || F * 0.333,\n      easing: te\n    })].join(\",\"), z.style.opacity = 0, z.style.transform = xo(0.75), m && m(z);\n  }), j = k(g), W = (z) => {\n    f === \"auto\" && P.start(T.current || 0, z), n && n(h.current, z);\n  };\n  return /* @__PURE__ */ N.jsx(S, {\n    appear: o,\n    in: c,\n    nodeRef: h,\n    onEnter: B,\n    onEntered: d,\n    onEntering: L,\n    onExit: D,\n    onExited: j,\n    onExiting: A,\n    addEndListener: W,\n    timeout: f === \"auto\" ? null : f,\n    ...E,\n    children: (z, {\n      ownerState: U,\n      ...V\n    }) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(i, {\n      style: {\n        opacity: 0,\n        transform: xo(0.75),\n        visibility: z === \"exited\" && !c ? \"hidden\" : void 0,\n        ...mm[z],\n        ...y,\n        ...i.props.style\n      },\n      ref: w,\n      ...V\n    })\n  });\n});\n true && (On.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Add a custom transition end trigger. Called with the transitioning DOM\n   * node and a done callback. Allows for more fine grained transition end\n   * logic. Note: Timeouts are still used as a fallback if provided.\n   */\n  addEndListener: a.func,\n  /**\n   * Perform the enter transition when it first mounts if `in` is also `true`.\n   * Set this to `false` to disable this behavior.\n   * @default true\n   */\n  appear: a.bool,\n  /**\n   * A single child content element.\n   */\n  children: jo.isRequired,\n  /**\n   * The transition timing function.\n   * You may specify a single easing or a object containing enter and exit values.\n   */\n  easing: a.oneOfType([a.shape({\n    enter: a.string,\n    exit: a.string\n  }), a.string]),\n  /**\n   * If `true`, the component will transition in.\n   */\n  in: a.bool,\n  /**\n   * @ignore\n   */\n  onEnter: a.func,\n  /**\n   * @ignore\n   */\n  onEntered: a.func,\n  /**\n   * @ignore\n   */\n  onEntering: a.func,\n  /**\n   * @ignore\n   */\n  onExit: a.func,\n  /**\n   * @ignore\n   */\n  onExited: a.func,\n  /**\n   * @ignore\n   */\n  onExiting: a.func,\n  /**\n   * @ignore\n   */\n  style: a.object,\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   *\n   * Set to 'auto' to automatically calculate transition time based on height.\n   * @default 'auto'\n   */\n  timeout: a.oneOfType([a.oneOf([\"auto\"]), a.number, a.shape({\n    appear: a.number,\n    enter: a.number,\n    exit: a.number\n  })])\n});\nOn && (On.muiSupportAuto = !0);\nconst or = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext({});\n true && (or.displayName = \"ListContext\");\nfunction hm(e) {\n  return Ve(\"MuiList\", e);\n}\nFe(\"MuiList\", [\"root\", \"padding\", \"dense\", \"subheader\"]);\nconst gm = (e) => {\n  const {\n    classes: t,\n    disablePadding: r,\n    dense: n,\n    subheader: o\n  } = e;\n  return Ge({\n    root: [\"root\", !r && \"padding\", n && \"dense\", o && \"subheader\"]\n  }, hm, t);\n}, ym = le(\"ul\", {\n  name: \"MuiList\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, !r.disablePadding && t.padding, r.dense && t.dense, r.subheader && t.subheader];\n  }\n})({\n  listStyle: \"none\",\n  margin: 0,\n  padding: 0,\n  position: \"relative\",\n  variants: [{\n    props: ({\n      ownerState: e\n    }) => !e.disablePadding,\n    style: {\n      paddingTop: 8,\n      paddingBottom: 8\n    }\n  }, {\n    props: ({\n      ownerState: e\n    }) => e.subheader,\n    style: {\n      paddingTop: 0\n    }\n  }]\n}), ti = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiList\"\n  }), {\n    children: o,\n    className: i,\n    component: s = \"ul\",\n    dense: c = !1,\n    disablePadding: l = !1,\n    subheader: u,\n    ...p\n  } = n, m = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    dense: c\n  }), [c]), g = {\n    ...n,\n    component: s,\n    dense: c,\n    disablePadding: l\n  }, x = gm(g);\n  return /* @__PURE__ */ N.jsx(or.Provider, {\n    value: m,\n    children: /* @__PURE__ */ N.jsxs(ym, {\n      as: s,\n      className: se(x.root, i),\n      ref: r,\n      ownerState: g,\n      ...p,\n      children: [u, o]\n    })\n  });\n});\n true && (ti.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The content of the component.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * If `true`, compact vertical padding designed for keyboard and mouse input is used for\n   * the list and list items.\n   * The prop is available to descendant components as the `dense` context.\n   * @default false\n   */\n  dense: a.bool,\n  /**\n   * If `true`, vertical padding is removed from the list.\n   * @default false\n   */\n  disablePadding: a.bool,\n  /**\n   * The content of the subheader, normally `ListSubheader`.\n   */\n  subheader: a.node,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nfunction bm(e) {\n  return Ve(\"MuiListItemButton\", e);\n}\nconst mr = Fe(\"MuiListItemButton\", [\"root\", \"focusVisible\", \"dense\", \"alignItemsFlexStart\", \"disabled\", \"divider\", \"gutters\", \"selected\"]), vm = (e, t) => {\n  const {\n    ownerState: r\n  } = e;\n  return [t.root, r.dense && t.dense, r.alignItems === \"flex-start\" && t.alignItemsFlexStart, r.divider && t.divider, !r.disableGutters && t.gutters];\n}, xm = (e) => {\n  const {\n    alignItems: t,\n    classes: r,\n    dense: n,\n    disabled: o,\n    disableGutters: i,\n    divider: s,\n    selected: c\n  } = e, u = Ge({\n    root: [\"root\", n && \"dense\", !i && \"gutters\", s && \"divider\", o && \"disabled\", t === \"flex-start\" && \"alignItemsFlexStart\", c && \"selected\"]\n  }, bm, r);\n  return {\n    ...r,\n    ...u\n  };\n}, Sm = le($r, {\n  shouldForwardProp: (e) => ys(e) || e === \"classes\",\n  name: \"MuiListItemButton\",\n  slot: \"Root\",\n  overridesResolver: vm\n})(qe(({\n  theme: e\n}) => ({\n  display: \"flex\",\n  flexGrow: 1,\n  justifyContent: \"flex-start\",\n  alignItems: \"center\",\n  position: \"relative\",\n  textDecoration: \"none\",\n  minWidth: 0,\n  boxSizing: \"border-box\",\n  textAlign: \"left\",\n  paddingTop: 8,\n  paddingBottom: 8,\n  transition: e.transitions.create(\"background-color\", {\n    duration: e.transitions.duration.shortest\n  }),\n  \"&:hover\": {\n    textDecoration: \"none\",\n    backgroundColor: (e.vars || e).palette.action.hover,\n    // Reset on touch devices, it doesn't add specificity\n    \"@media (hover: none)\": {\n      backgroundColor: \"transparent\"\n    }\n  },\n  [`&.${mr.selected}`]: {\n    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : De(e.palette.primary.main, e.palette.action.selectedOpacity),\n    [`&.${mr.focusVisible}`]: {\n      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : De(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)\n    }\n  },\n  [`&.${mr.selected}:hover`]: {\n    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : De(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),\n    // Reset on touch devices, it doesn't add specificity\n    \"@media (hover: none)\": {\n      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : De(e.palette.primary.main, e.palette.action.selectedOpacity)\n    }\n  },\n  [`&.${mr.focusVisible}`]: {\n    backgroundColor: (e.vars || e).palette.action.focus\n  },\n  [`&.${mr.disabled}`]: {\n    opacity: (e.vars || e).palette.action.disabledOpacity\n  },\n  variants: [{\n    props: ({\n      ownerState: t\n    }) => t.divider,\n    style: {\n      borderBottom: `1px solid ${(e.vars || e).palette.divider}`,\n      backgroundClip: \"padding-box\"\n    }\n  }, {\n    props: {\n      alignItems: \"flex-start\"\n    },\n    style: {\n      alignItems: \"flex-start\"\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !t.disableGutters,\n    style: {\n      paddingLeft: 16,\n      paddingRight: 16\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.dense,\n    style: {\n      paddingTop: 4,\n      paddingBottom: 4\n    }\n  }]\n}))), ri = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiListItemButton\"\n  }), {\n    alignItems: o = \"center\",\n    autoFocus: i = !1,\n    component: s = \"div\",\n    children: c,\n    dense: l = !1,\n    disableGutters: u = !1,\n    divider: p = !1,\n    focusVisibleClassName: m,\n    selected: g = !1,\n    className: x,\n    ...y\n  } = n, f = react__WEBPACK_IMPORTED_MODULE_0__.useContext(or), S = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    dense: l || f.dense || !1,\n    alignItems: o,\n    disableGutters: u\n  }), [o, f.dense, l, u]), E = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  Ft(() => {\n    i && (E.current ? E.current.focus() :  true && console.error(\"MUI: Unable to set focus to a ListItemButton whose component has not been rendered.\"));\n  }, [i]);\n  const P = {\n    ...n,\n    alignItems: o,\n    dense: S.dense,\n    disableGutters: u,\n    divider: p,\n    selected: g\n  }, T = xm(P), b = at(E, r);\n  return /* @__PURE__ */ N.jsx(or.Provider, {\n    value: S,\n    children: /* @__PURE__ */ N.jsx(Sm, {\n      ref: b,\n      href: y.href || y.to,\n      component: (y.href || y.to) && s === \"div\" ? \"button\" : s,\n      focusVisibleClassName: se(T.focusVisible, m),\n      ownerState: P,\n      className: se(T.root, x),\n      ...y,\n      classes: T,\n      children: c\n    })\n  });\n});\n true && (ri.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Defines the `align-items` style property.\n   * @default 'center'\n   */\n  alignItems: a.oneOf([\"center\", \"flex-start\"]),\n  /**\n   * If `true`, the list item is focused during the first mount.\n   * Focus will also be triggered if the value changes from false to true.\n   * @default false\n   */\n  autoFocus: a.bool,\n  /**\n   * The content of the component if a `ListItemSecondaryAction` is used it must\n   * be the last child.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: a.elementType,\n  /**\n   * If `true`, compact vertical padding designed for keyboard and mouse input is used.\n   * The prop defaults to the value inherited from the parent List component.\n   * @default false\n   */\n  dense: a.bool,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: a.bool,\n  /**\n   * If `true`, the left and right padding is removed.\n   * @default false\n   */\n  disableGutters: a.bool,\n  /**\n   * If `true`, a 1px light border is added to the bottom of the list item.\n   * @default false\n   */\n  divider: a.bool,\n  /**\n   * This prop can help identify which element has keyboard focus.\n   * The class name will be applied when the element gains the focus through keyboard interaction.\n   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).\n   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).\n   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components\n   * if needed.\n   */\n  focusVisibleClassName: a.string,\n  /**\n   * @ignore\n   */\n  href: a.string,\n  /**\n   * Use to apply selected styling.\n   * @default false\n   */\n  selected: a.bool,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nfunction Em(e) {\n  return Ve(\"MuiListItemIcon\", e);\n}\nFe(\"MuiListItemIcon\", [\"root\", \"alignItemsFlexStart\"]);\nconst Cm = (e) => {\n  const {\n    alignItems: t,\n    classes: r\n  } = e;\n  return Ge({\n    root: [\"root\", t === \"flex-start\" && \"alignItemsFlexStart\"]\n  }, Em, r);\n}, Tm = le(\"div\", {\n  name: \"MuiListItemIcon\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.root, r.alignItems === \"flex-start\" && t.alignItemsFlexStart];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  minWidth: 56,\n  color: (e.vars || e).palette.action.active,\n  flexShrink: 0,\n  display: \"inline-flex\",\n  variants: [{\n    props: {\n      alignItems: \"flex-start\"\n    },\n    style: {\n      marginTop: 8\n    }\n  }]\n}))), ni = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiListItemIcon\"\n  }), {\n    className: o,\n    ...i\n  } = n, s = react__WEBPACK_IMPORTED_MODULE_0__.useContext(or), c = {\n    ...n,\n    alignItems: s.alignItems\n  }, l = Cm(c);\n  return /* @__PURE__ */ N.jsx(Tm, {\n    className: se(l.root, o),\n    ownerState: c,\n    ref: r,\n    ...i\n  });\n});\n true && (ni.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The content of the component, normally `Icon`, `SvgIcon`,\n   * or a `@mui/icons-material` SVG icon element.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nfunction wm(e) {\n  return Ve(\"MuiListItemText\", e);\n}\nconst en = Fe(\"MuiListItemText\", [\"root\", \"multiline\", \"dense\", \"inset\", \"primary\", \"secondary\"]), Om = (e) => {\n  const {\n    classes: t,\n    inset: r,\n    primary: n,\n    secondary: o,\n    dense: i\n  } = e;\n  return Ge({\n    root: [\"root\", r && \"inset\", i && \"dense\", n && o && \"multiline\"],\n    primary: [\"primary\"],\n    secondary: [\"secondary\"]\n  }, wm, t);\n}, Rm = le(\"div\", {\n  name: \"MuiListItemText\",\n  slot: \"Root\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [{\n      [`& .${en.primary}`]: t.primary\n    }, {\n      [`& .${en.secondary}`]: t.secondary\n    }, t.root, r.inset && t.inset, r.primary && r.secondary && t.multiline, r.dense && t.dense];\n  }\n})({\n  flex: \"1 1 auto\",\n  minWidth: 0,\n  marginTop: 4,\n  marginBottom: 4,\n  [`.${sa.root}:where(& .${en.primary})`]: {\n    display: \"block\"\n  },\n  [`.${sa.root}:where(& .${en.secondary})`]: {\n    display: \"block\"\n  },\n  variants: [{\n    props: ({\n      ownerState: e\n    }) => e.primary && e.secondary,\n    style: {\n      marginTop: 6,\n      marginBottom: 6\n    }\n  }, {\n    props: ({\n      ownerState: e\n    }) => e.inset,\n    style: {\n      paddingLeft: 56\n    }\n  }]\n}), oi = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiListItemText\"\n  }), {\n    children: o,\n    className: i,\n    disableTypography: s = !1,\n    inset: c = !1,\n    primary: l,\n    primaryTypographyProps: u,\n    secondary: p,\n    secondaryTypographyProps: m,\n    slots: g = {},\n    slotProps: x = {},\n    ...y\n  } = n, {\n    dense: f\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(or);\n  let S = l ?? o, E = p;\n  const P = {\n    ...n,\n    disableTypography: s,\n    inset: c,\n    primary: !!S,\n    secondary: !!E,\n    dense: f\n  }, T = Om(P), b = {\n    slots: g,\n    slotProps: {\n      primary: u,\n      secondary: m,\n      ...x\n    }\n  }, [h, w] = Bt(\"primary\", {\n    className: T.primary,\n    elementType: bt,\n    externalForwardedProps: b,\n    ownerState: P\n  }), [k, L] = Bt(\"secondary\", {\n    className: T.secondary,\n    elementType: bt,\n    externalForwardedProps: b,\n    ownerState: P\n  });\n  return S != null && S.type !== bt && !s && (S = /* @__PURE__ */ N.jsx(h, {\n    variant: f ? \"body2\" : \"body1\",\n    component: w != null && w.variant ? void 0 : \"span\",\n    ...w,\n    children: S\n  })), E != null && E.type !== bt && !s && (E = /* @__PURE__ */ N.jsx(k, {\n    variant: \"body2\",\n    color: \"textSecondary\",\n    ...L,\n    children: E\n  })), /* @__PURE__ */ N.jsxs(Rm, {\n    className: se(T.root, i),\n    ownerState: P,\n    ref: r,\n    ...y,\n    children: [S, E]\n  });\n});\n true && (oi.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * Alias for the `primary` prop.\n   */\n  children: a.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * If `true`, the children won't be wrapped by a Typography component.\n   * This can be useful to render an alternative Typography variant by wrapping\n   * the `children` (or `primary`) text, and optional `secondary` text\n   * with the Typography component.\n   * @default false\n   */\n  disableTypography: a.bool,\n  /**\n   * If `true`, the children are indented.\n   * This should be used if there is no left avatar or left icon.\n   * @default false\n   */\n  inset: a.bool,\n  /**\n   * The main content element.\n   */\n  primary: a.node,\n  /**\n   * These props will be forwarded to the primary typography component\n   * (as long as disableTypography is not `true`).\n   * @deprecated Use `slotProps.primary` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  primaryTypographyProps: a.object,\n  /**\n   * The secondary content element.\n   */\n  secondary: a.node,\n  /**\n   * These props will be forwarded to the secondary typography component\n   * (as long as disableTypography is not `true`).\n   * @deprecated Use `slotProps.secondary` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  secondaryTypographyProps: a.object,\n  /**\n   * The props used for each slot inside.\n   * @default {}\n   */\n  slotProps: a.shape({\n    primary: a.oneOfType([a.func, a.object]),\n    secondary: a.oneOfType([a.func, a.object])\n  }),\n  /**\n   * The components used for each slot inside.\n   * @default {}\n   */\n  slots: a.shape({\n    primary: a.elementType,\n    secondary: a.elementType\n  }),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object])\n});\nfunction $m(e) {\n  return Ve(\"MuiTooltip\", e);\n}\nconst Ne = Fe(\"MuiTooltip\", [\"popper\", \"popperInteractive\", \"popperArrow\", \"popperClose\", \"tooltip\", \"tooltipArrow\", \"touch\", \"tooltipPlacementLeft\", \"tooltipPlacementRight\", \"tooltipPlacementTop\", \"tooltipPlacementBottom\", \"arrow\"]);\nfunction Pm(e) {\n  return Math.round(e * 1e5) / 1e5;\n}\nconst km = (e) => {\n  const {\n    classes: t,\n    disableInteractive: r,\n    arrow: n,\n    touch: o,\n    placement: i\n  } = e, s = {\n    popper: [\"popper\", !r && \"popperInteractive\", n && \"popperArrow\"],\n    tooltip: [\"tooltip\", n && \"tooltipArrow\", o && \"touch\", `tooltipPlacement${ee(i.split(\"-\")[0])}`],\n    arrow: [\"arrow\"]\n  };\n  return Ge(s, $m, t);\n}, Am = le(ei, {\n  name: \"MuiTooltip\",\n  slot: \"Popper\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.popper, !r.disableInteractive && t.popperInteractive, r.arrow && t.popperArrow, !r.open && t.popperClose];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  zIndex: (e.vars || e).zIndex.tooltip,\n  pointerEvents: \"none\",\n  variants: [{\n    props: ({\n      ownerState: t\n    }) => !t.disableInteractive,\n    style: {\n      pointerEvents: \"auto\"\n    }\n  }, {\n    props: ({\n      open: t\n    }) => !t,\n    style: {\n      pointerEvents: \"none\"\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.arrow,\n    style: {\n      [`&[data-popper-placement*=\"bottom\"] .${Ne.arrow}`]: {\n        top: 0,\n        marginTop: \"-0.71em\",\n        \"&::before\": {\n          transformOrigin: \"0 100%\"\n        }\n      },\n      [`&[data-popper-placement*=\"top\"] .${Ne.arrow}`]: {\n        bottom: 0,\n        marginBottom: \"-0.71em\",\n        \"&::before\": {\n          transformOrigin: \"100% 0\"\n        }\n      },\n      [`&[data-popper-placement*=\"right\"] .${Ne.arrow}`]: {\n        height: \"1em\",\n        width: \"0.71em\",\n        \"&::before\": {\n          transformOrigin: \"100% 100%\"\n        }\n      },\n      [`&[data-popper-placement*=\"left\"] .${Ne.arrow}`]: {\n        height: \"1em\",\n        width: \"0.71em\",\n        \"&::before\": {\n          transformOrigin: \"0 0\"\n        }\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.arrow && !t.isRtl,\n    style: {\n      [`&[data-popper-placement*=\"right\"] .${Ne.arrow}`]: {\n        left: 0,\n        marginLeft: \"-0.71em\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.arrow && !!t.isRtl,\n    style: {\n      [`&[data-popper-placement*=\"right\"] .${Ne.arrow}`]: {\n        right: 0,\n        marginRight: \"-0.71em\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.arrow && !t.isRtl,\n    style: {\n      [`&[data-popper-placement*=\"left\"] .${Ne.arrow}`]: {\n        right: 0,\n        marginRight: \"-0.71em\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.arrow && !!t.isRtl,\n    style: {\n      [`&[data-popper-placement*=\"left\"] .${Ne.arrow}`]: {\n        left: 0,\n        marginLeft: \"-0.71em\"\n      }\n    }\n  }]\n}))), Nm = le(\"div\", {\n  name: \"MuiTooltip\",\n  slot: \"Tooltip\",\n  overridesResolver: (e, t) => {\n    const {\n      ownerState: r\n    } = e;\n    return [t.tooltip, r.touch && t.touch, r.arrow && t.tooltipArrow, t[`tooltipPlacement${ee(r.placement.split(\"-\")[0])}`]];\n  }\n})(qe(({\n  theme: e\n}) => ({\n  backgroundColor: e.vars ? e.vars.palette.Tooltip.bg : De(e.palette.grey[700], 0.92),\n  borderRadius: (e.vars || e).shape.borderRadius,\n  color: (e.vars || e).palette.common.white,\n  fontFamily: e.typography.fontFamily,\n  padding: \"4px 8px\",\n  fontSize: e.typography.pxToRem(11),\n  maxWidth: 300,\n  margin: 2,\n  wordWrap: \"break-word\",\n  fontWeight: e.typography.fontWeightMedium,\n  [`.${Ne.popper}[data-popper-placement*=\"left\"] &`]: {\n    transformOrigin: \"right center\"\n  },\n  [`.${Ne.popper}[data-popper-placement*=\"right\"] &`]: {\n    transformOrigin: \"left center\"\n  },\n  [`.${Ne.popper}[data-popper-placement*=\"top\"] &`]: {\n    transformOrigin: \"center bottom\",\n    marginBottom: \"14px\"\n  },\n  [`.${Ne.popper}[data-popper-placement*=\"bottom\"] &`]: {\n    transformOrigin: \"center top\",\n    marginTop: \"14px\"\n  },\n  variants: [{\n    props: ({\n      ownerState: t\n    }) => t.arrow,\n    style: {\n      position: \"relative\",\n      margin: 0\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.touch,\n    style: {\n      padding: \"8px 16px\",\n      fontSize: e.typography.pxToRem(14),\n      lineHeight: `${Pm(16 / 14)}em`,\n      fontWeight: e.typography.fontWeightRegular\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !t.isRtl,\n    style: {\n      [`.${Ne.popper}[data-popper-placement*=\"left\"] &`]: {\n        marginRight: \"14px\"\n      },\n      [`.${Ne.popper}[data-popper-placement*=\"right\"] &`]: {\n        marginLeft: \"14px\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !t.isRtl && t.touch,\n    style: {\n      [`.${Ne.popper}[data-popper-placement*=\"left\"] &`]: {\n        marginRight: \"24px\"\n      },\n      [`.${Ne.popper}[data-popper-placement*=\"right\"] &`]: {\n        marginLeft: \"24px\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !!t.isRtl,\n    style: {\n      [`.${Ne.popper}[data-popper-placement*=\"left\"] &`]: {\n        marginLeft: \"14px\"\n      },\n      [`.${Ne.popper}[data-popper-placement*=\"right\"] &`]: {\n        marginRight: \"14px\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => !!t.isRtl && t.touch,\n    style: {\n      [`.${Ne.popper}[data-popper-placement*=\"left\"] &`]: {\n        marginLeft: \"24px\"\n      },\n      [`.${Ne.popper}[data-popper-placement*=\"right\"] &`]: {\n        marginRight: \"24px\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.touch,\n    style: {\n      [`.${Ne.popper}[data-popper-placement*=\"top\"] &`]: {\n        marginBottom: \"24px\"\n      }\n    }\n  }, {\n    props: ({\n      ownerState: t\n    }) => t.touch,\n    style: {\n      [`.${Ne.popper}[data-popper-placement*=\"bottom\"] &`]: {\n        marginTop: \"24px\"\n      }\n    }\n  }]\n}))), Mm = le(\"span\", {\n  name: \"MuiTooltip\",\n  slot: \"Arrow\",\n  overridesResolver: (e, t) => t.arrow\n})(qe(({\n  theme: e\n}) => ({\n  overflow: \"hidden\",\n  position: \"absolute\",\n  width: \"1em\",\n  height: \"0.71em\",\n  boxSizing: \"border-box\",\n  color: e.vars ? e.vars.palette.Tooltip.bg : De(e.palette.grey[700], 0.9),\n  \"&::before\": {\n    content: '\"\"',\n    margin: \"auto\",\n    display: \"block\",\n    width: \"100%\",\n    height: \"100%\",\n    backgroundColor: \"currentColor\",\n    transform: \"rotate(45deg)\"\n  }\n})));\nlet tn = !1;\nconst va = new Vn();\nlet hr = {\n  x: 0,\n  y: 0\n};\nfunction rn(e, t) {\n  return (r, ...n) => {\n    t && t(r, ...n), e(r, ...n);\n  };\n}\nconst js = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(t, r) {\n  const n = He({\n    props: t,\n    name: \"MuiTooltip\"\n  }), {\n    arrow: o = !1,\n    children: i,\n    classes: s,\n    components: c = {},\n    componentsProps: l = {},\n    describeChild: u = !1,\n    disableFocusListener: p = !1,\n    disableHoverListener: m = !1,\n    disableInteractive: g = !1,\n    disableTouchListener: x = !1,\n    enterDelay: y = 100,\n    enterNextDelay: f = 0,\n    enterTouchDelay: S = 700,\n    followCursor: E = !1,\n    id: P,\n    leaveDelay: T = 0,\n    leaveTouchDelay: b = 1500,\n    onClose: h,\n    onOpen: w,\n    open: k,\n    placement: L = \"bottom\",\n    PopperComponent: B,\n    PopperProps: d = {},\n    slotProps: A = {},\n    slots: D = {},\n    title: j,\n    TransitionComponent: W,\n    TransitionProps: z,\n    ...U\n  } = n, V = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(i) ? i : /* @__PURE__ */ N.jsx(\"span\", {\n    children: i\n  }), te = Lr(), F = is(), [R, I] = react__WEBPACK_IMPORTED_MODULE_0__.useState(), [J, Q] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), H = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!1), X = g || E, _ = Dt(), q = Dt(), G = Dt(), re = Dt(), [Z, ae] = Vu({\n    controlled: k,\n    default: !1,\n    name: \"Tooltip\",\n    state: \"open\"\n  });\n  let O = Z;\n  if (true) {\n    const {\n      current: ne\n    } = react__WEBPACK_IMPORTED_MODULE_0__.useRef(k !== void 0);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      R && R.disabled && !ne && j !== \"\" && R.tagName.toLowerCase() === \"button\" && console.warn([\"MUI: You are providing a disabled `button` child to the Tooltip component.\", \"A disabled element does not fire events.\", \"Tooltip needs to listen to the child element's events to display the title.\", \"\", \"Add a simple wrapper element, such as a `span`.\"].join(`\n`));\n    }, [j, R, ne]);\n  }\n  const ye = Qa(P), Ee = react__WEBPACK_IMPORTED_MODULE_0__.useRef(), Me = Qt(() => {\n    Ee.current !== void 0 && (document.body.style.WebkitUserSelect = Ee.current, Ee.current = void 0), re.clear();\n  });\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => Me, [Me]);\n  const Qe = (ne) => {\n    va.clear(), tn = !0, ae(!0), w && !O && w(ne);\n  }, ve = Qt(\n    /**\n     * @param {React.SyntheticEvent | Event} event\n     */\n    (ne) => {\n      va.start(800 + T, () => {\n        tn = !1;\n      }), ae(!1), h && O && h(ne), _.start(te.transitions.duration.shortest, () => {\n        H.current = !1;\n      });\n    }\n  ), Pe = (ne) => {\n    H.current && ne.type !== \"touchstart\" || (R && R.removeAttribute(\"title\"), q.clear(), G.clear(), y || tn && f ? q.start(tn ? f : y, () => {\n      Qe(ne);\n    }) : Qe(ne));\n  }, ze = (ne) => {\n    q.clear(), G.start(T, () => {\n      ve(ne);\n    });\n  }, [, Le] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1), v = (ne) => {\n    hn(ne.target) || (Le(!1), ze(ne));\n  }, M = (ne) => {\n    R || I(ne.currentTarget), hn(ne.target) && (Le(!0), Pe(ne));\n  }, Y = (ne) => {\n    H.current = !0;\n    const ft = V.props;\n    ft.onTouchStart && ft.onTouchStart(ne);\n  }, oe = (ne) => {\n    Y(ne), G.clear(), _.clear(), Me(), Ee.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = \"none\", re.start(S, () => {\n      document.body.style.WebkitUserSelect = Ee.current, Pe(ne);\n    });\n  }, Re = (ne) => {\n    V.props.onTouchEnd && V.props.onTouchEnd(ne), Me(), G.start(b, () => {\n      ve(ne);\n    });\n  };\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!O)\n      return;\n    function ne(ft) {\n      ft.key === \"Escape\" && ve(ft);\n    }\n    return document.addEventListener(\"keydown\", ne), () => {\n      document.removeEventListener(\"keydown\", ne);\n    };\n  }, [ve, O]);\n  const ue = at(Bo(V), I, r);\n  !j && j !== 0 && (O = !1);\n  const K = react__WEBPACK_IMPORTED_MODULE_0__.useRef(), be = (ne) => {\n    const ft = V.props;\n    ft.onMouseMove && ft.onMouseMove(ne), hr = {\n      x: ne.clientX,\n      y: ne.clientY\n    }, K.current && K.current.update();\n  }, we = {}, Oe = typeof j == \"string\";\n  u ? (we.title = !O && Oe && !m ? j : null, we[\"aria-describedby\"] = O ? ye : null) : (we[\"aria-label\"] = Oe ? j : null, we[\"aria-labelledby\"] = O && !Oe ? ye : null);\n  const ce = {\n    ...we,\n    ...U,\n    ...V.props,\n    className: se(U.className, V.props.className),\n    onTouchStart: Y,\n    ref: ue,\n    ...E ? {\n      onMouseMove: be\n    } : {}\n  };\n   true && (ce[\"data-mui-internal-clone-element\"] = !0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    R && !R.getAttribute(\"data-mui-internal-clone-element\") && console.error([\"MUI: The `children` component of the Tooltip is not forwarding its props correctly.\", \"Please make sure that props are spread on the same element that the ref is applied to.\"].join(`\n`));\n  }, [R]));\n  const Ie = {};\n  x || (ce.onTouchStart = oe, ce.onTouchEnd = Re), m || (ce.onMouseOver = rn(Pe, ce.onMouseOver), ce.onMouseLeave = rn(ze, ce.onMouseLeave), X || (Ie.onMouseOver = Pe, Ie.onMouseLeave = ze)), p || (ce.onFocus = rn(M, ce.onFocus), ce.onBlur = rn(v, ce.onBlur), X || (Ie.onFocus = M, Ie.onBlur = v)),  true && V.props.title && console.error([\"MUI: You have provided a `title` prop to the child of <Tooltip />.\", `Remove this title prop \\`${V.props.title}\\` or the Tooltip component.`].join(`\n`));\n  const We = {\n    ...n,\n    isRtl: F,\n    arrow: o,\n    disableInteractive: X,\n    placement: L,\n    PopperComponentProp: B,\n    touch: H.current\n  }, Ue = typeof A.popper == \"function\" ? A.popper(We) : A.popper, ut = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    var ft, ii;\n    let ne = [{\n      name: \"arrow\",\n      enabled: !!J,\n      options: {\n        element: J,\n        padding: 4\n      }\n    }];\n    return (ft = d.popperOptions) != null && ft.modifiers && (ne = ne.concat(d.popperOptions.modifiers)), (ii = Ue == null ? void 0 : Ue.popperOptions) != null && ii.modifiers && (ne = ne.concat(Ue.popperOptions.modifiers)), {\n      ...d.popperOptions,\n      ...Ue == null ? void 0 : Ue.popperOptions,\n      modifiers: ne\n    };\n  }, [J, d.popperOptions, Ue == null ? void 0 : Ue.popperOptions]), Un = km(We), Bs = typeof A.transition == \"function\" ? A.transition(We) : A.transition, zr = {\n    slots: {\n      popper: c.Popper,\n      transition: c.Transition ?? W,\n      tooltip: c.Tooltip,\n      arrow: c.Arrow,\n      ...D\n    },\n    slotProps: {\n      arrow: A.arrow ?? l.arrow,\n      popper: {\n        ...d,\n        ...Ue ?? l.popper\n      },\n      // resolvedPopperProps can be spread because it's already an object\n      tooltip: A.tooltip ?? l.tooltip,\n      transition: {\n        ...z,\n        ...Bs ?? l.transition\n      }\n    }\n  }, [Vs, Fs] = Bt(\"popper\", {\n    elementType: Am,\n    externalForwardedProps: zr,\n    ownerState: We,\n    className: se(Un.popper, d == null ? void 0 : d.className)\n  }), [zs, Ws] = Bt(\"transition\", {\n    elementType: On,\n    externalForwardedProps: zr,\n    ownerState: We\n  }), [Us, Ys] = Bt(\"tooltip\", {\n    elementType: Nm,\n    className: Un.tooltip,\n    externalForwardedProps: zr,\n    ownerState: We\n  }), [Hs, qs] = Bt(\"arrow\", {\n    elementType: Mm,\n    className: Un.arrow,\n    externalForwardedProps: zr,\n    ownerState: We,\n    ref: Q\n  });\n  return /* @__PURE__ */ N.jsxs(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: [/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(V, ce), /* @__PURE__ */ N.jsx(Vs, {\n      as: B ?? ei,\n      placement: L,\n      anchorEl: E ? {\n        getBoundingClientRect: () => ({\n          top: hr.y,\n          left: hr.x,\n          right: hr.x,\n          bottom: hr.y,\n          width: 0,\n          height: 0\n        })\n      } : R,\n      popperRef: K,\n      open: R ? O : !1,\n      id: ye,\n      transition: !0,\n      ...Ie,\n      ...Fs,\n      popperOptions: ut,\n      children: ({\n        TransitionProps: ne\n      }) => /* @__PURE__ */ N.jsx(zs, {\n        timeout: te.transitions.duration.shorter,\n        ...ne,\n        ...Ws,\n        children: /* @__PURE__ */ N.jsxs(Us, {\n          ...Ys,\n          children: [j, o ? /* @__PURE__ */ N.jsx(Hs, {\n            ...qs\n          }) : null]\n        })\n      })\n    })]\n  });\n});\n true && (js.propTypes = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * If `true`, adds an arrow to the tooltip.\n   * @default false\n   */\n  arrow: a.bool,\n  /**\n   * Tooltip reference element.\n   */\n  children: jo.isRequired,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: a.object,\n  /**\n   * @ignore\n   */\n  className: a.string,\n  /**\n   * The components used for each slot inside.\n   *\n   * @deprecated use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   *\n   * @default {}\n   */\n  components: a.shape({\n    Arrow: a.elementType,\n    Popper: a.elementType,\n    Tooltip: a.elementType,\n    Transition: a.elementType\n  }),\n  /**\n   * The extra props for the slot components.\n   * You can override the existing props or add new ones.\n   *\n   * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   *\n   * @default {}\n   */\n  componentsProps: a.shape({\n    arrow: a.object,\n    popper: a.object,\n    tooltip: a.object,\n    transition: a.object\n  }),\n  /**\n   * Set to `true` if the `title` acts as an accessible description.\n   * By default the `title` acts as an accessible label for the child.\n   * @default false\n   */\n  describeChild: a.bool,\n  /**\n   * Do not respond to focus-visible events.\n   * @default false\n   */\n  disableFocusListener: a.bool,\n  /**\n   * Do not respond to hover events.\n   * @default false\n   */\n  disableHoverListener: a.bool,\n  /**\n   * Makes a tooltip not interactive, i.e. it will close when the user\n   * hovers over the tooltip before the `leaveDelay` is expired.\n   * @default false\n   */\n  disableInteractive: a.bool,\n  /**\n   * Do not respond to long press touch events.\n   * @default false\n   */\n  disableTouchListener: a.bool,\n  /**\n   * The number of milliseconds to wait before showing the tooltip.\n   * This prop won't impact the enter touch delay (`enterTouchDelay`).\n   * @default 100\n   */\n  enterDelay: a.number,\n  /**\n   * The number of milliseconds to wait before showing the tooltip when one was already recently opened.\n   * @default 0\n   */\n  enterNextDelay: a.number,\n  /**\n   * The number of milliseconds a user must touch the element before showing the tooltip.\n   * @default 700\n   */\n  enterTouchDelay: a.number,\n  /**\n   * If `true`, the tooltip follow the cursor over the wrapped element.\n   * @default false\n   */\n  followCursor: a.bool,\n  /**\n   * This prop is used to help implement the accessibility logic.\n   * If you don't provide this prop. It falls back to a randomly generated id.\n   */\n  id: a.string,\n  /**\n   * The number of milliseconds to wait before hiding the tooltip.\n   * This prop won't impact the leave touch delay (`leaveTouchDelay`).\n   * @default 0\n   */\n  leaveDelay: a.number,\n  /**\n   * The number of milliseconds after the user stops touching an element before hiding the tooltip.\n   * @default 1500\n   */\n  leaveTouchDelay: a.number,\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback.\n   */\n  onClose: a.func,\n  /**\n   * Callback fired when the component requests to be open.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback.\n   */\n  onOpen: a.func,\n  /**\n   * If `true`, the component is shown.\n   */\n  open: a.bool,\n  /**\n   * Tooltip placement.\n   * @default 'bottom'\n   */\n  placement: a.oneOf([\"bottom-end\", \"bottom-start\", \"bottom\", \"left-end\", \"left-start\", \"left\", \"right-end\", \"right-start\", \"right\", \"top-end\", \"top-start\", \"top\"]),\n  /**\n   * The component used for the popper.\n   * @deprecated use the `slots.popper` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  PopperComponent: a.elementType,\n  /**\n   * Props applied to the [`Popper`](https://mui.com/material-ui/api/popper/) element.\n   * @deprecated use the `slotProps.popper` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   * @default {}\n   */\n  PopperProps: a.object,\n  /**\n   * The props used for each slot inside.\n   * @default {}\n   */\n  slotProps: a.shape({\n    arrow: a.oneOfType([a.func, a.object]),\n    popper: a.oneOfType([a.func, a.object]),\n    tooltip: a.oneOfType([a.func, a.object]),\n    transition: a.oneOfType([a.func, a.object])\n  }),\n  /**\n   * The components used for each slot inside.\n   * @default {}\n   */\n  slots: a.shape({\n    arrow: a.elementType,\n    popper: a.elementType,\n    tooltip: a.elementType,\n    transition: a.elementType\n  }),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: a.oneOfType([a.arrayOf(a.oneOfType([a.func, a.object, a.bool])), a.func, a.object]),\n  /**\n   * Tooltip title. Zero-length titles string, undefined, null and false are never displayed.\n   */\n  title: a.node,\n  /**\n   * The component used for the transition.\n   * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.\n   * @deprecated use the `slots.transition` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  TransitionComponent: a.elementType,\n  /**\n   * Props applied to the transition element.\n   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.\n   * @deprecated use the `slotProps.transition` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   * @default {}\n   */\n  TransitionProps: a.object\n});\nconst Im = sr(/* @__PURE__ */ N.jsx(\"path\", {\n  d: \"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8m0-12.5c-2.49 0-4.5 2.01-4.5 4.5s2.01 4.5 4.5 4.5 4.5-2.01 4.5-4.5-2.01-4.5-4.5-4.5m0 5.5c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1\"\n}), \"AlbumOutlined\"), _m = ({\n  userName: e = \"\",\n  designation: t = \"\",\n  userimg: r = \"\",\n  isCollapse: n = !1,\n  onLogout: o\n}) => {\n  const i = Lr();\n  return /* @__PURE__ */ N.jsx(dt, { children: n ? \"\" : /* @__PURE__ */ N.jsxs(\n    dt,\n    {\n      display: \"flex\",\n      alignItems: \"center\",\n      gap: 2,\n      sx: {\n        m: 3,\n        p: 2,\n        borderRadius: \"8px\",\n        bgcolor: i.palette.secondary.main + 20\n      },\n      children: [\n        /* @__PURE__ */ N.jsx(_s, { alt: \"Remy Sharp\", src: r }),\n        /* @__PURE__ */ N.jsxs(dt, { children: [\n          /* @__PURE__ */ N.jsx(bt, { variant: \"h6\", children: e }),\n          /* @__PURE__ */ N.jsx(bt, { variant: \"caption\", children: t })\n        ] }),\n        /* @__PURE__ */ N.jsx(dt, { sx: { ml: \"auto\" }, onClick: o, children: /* @__PURE__ */ N.jsx(js, { title: \"Logout\", placement: \"top\", children: /* @__PURE__ */ N.jsx(Cs, { color: \"primary\", \"aria-label\": \"logout\", size: \"small\", children: /* @__PURE__ */ N.jsx(Im, {}) }) }) })\n      ]\n    }\n  ) });\n}, Fr = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  width: \"270px\",\n  collapsewidth: \"80px\",\n  textColor: \"#8D939D\",\n  isCollapse: !1,\n  themeColor: \"#5d87ff\"\n});\nlet jm = () => {\n  alert(\"Logout Successfully\");\n};\nconst Um = ({\n  children: e,\n  width: t = \"260px\",\n  collapsewidth: r = \"80px\",\n  textColor: n = \"#2b2b2b\",\n  isCollapse: o = !1,\n  themeColor: i = \"#5d87ff\",\n  themeSecondaryColor: s = \"#49beff\",\n  mode: c = \"light\",\n  direction: l = \"ltr\",\n  userName: u = \"Mathew\",\n  designation: p = \"Designer\",\n  showProfile: m = !0,\n  userimg: g = \"https://bootstrapdemos.adminmart.com/modernize/dist/assets/images/profile/user-1.jpg\",\n  onLogout: x = jm\n}) => {\n  const [y, f] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1), S = o && !y ? r : t, E = Fn({\n    direction: l,\n    palette: {\n      mode: c,\n      primary: {\n        main: i\n      },\n      secondary: {\n        main: s,\n        contrastText: \"#fff\"\n      }\n    }\n  });\n  return c === \"dark\" && (n = \"rgba(255,255,255, 0.9)\"), /* @__PURE__ */ N.jsx(zf, { theme: E, children: /* @__PURE__ */ N.jsx(\n    dt,\n    {\n      dir: l,\n      sx: {\n        width: S,\n        flexShrink: 0,\n        fontFamily: \"inherit\",\n        color: n\n      },\n      children: /* @__PURE__ */ N.jsxs(dt, { sx: { width: S }, children: [\n        /* @__PURE__ */ N.jsx(\n          Fr.Provider,\n          {\n            value: { textColor: n, isCollapse: o, width: t, collapsewidth: r, themeColor: i },\n            children: e\n          }\n        ),\n        m ? /* @__PURE__ */ N.jsx(\n          _m,\n          {\n            userName: u,\n            designation: p,\n            userimg: g,\n            isCollapse: o,\n            onLogout: x\n          }\n        ) : null\n      ] })\n    }\n  ) });\n}, Ym = ({ children: e, subHeading: t = \"menu\" }) => {\n  const r = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Fr);\n  return /* @__PURE__ */ N.jsx(dt, { sx: { px: r.isCollapse ? 2 : 3, pt: 2 }, children: /* @__PURE__ */ N.jsx(\n    ti,\n    {\n      component: \"nav\",\n      subheader: /* @__PURE__ */ N.jsx(\n        wn,\n        {\n          component: \"div\",\n          sx: {\n            paddingY: \"3px\",\n            color: r.textColor,\n            paddingX: \"0px\",\n            lineHeight: \"20px\",\n            fontWeight: \"bold\",\n            fontSize: \"12px\",\n            background: \"transparent\"\n          },\n          children: r.isCollapse ? \"...\" : t\n        }\n      ),\n      children: e\n    }\n  ) });\n}, Dm = sr(/* @__PURE__ */ N.jsx(\"path\", {\n  d: \"m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z\"\n}), \"ExpandLess\"), Lm = sr(/* @__PURE__ */ N.jsx(\"path\", {\n  d: \"M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z\"\n}), \"ExpandMore\"), Ds = sr(/* @__PURE__ */ N.jsx(\"path\", {\n  d: \"M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2m0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8\"\n}), \"CircleOutlined\"), Hm = ({\n  children: e,\n  title: t = \"\",\n  icon: r,\n  borderRadius: n = \"8px\",\n  textFontSize: o = \"14px\",\n  disabled: i = !1\n}) => {\n  const s = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Fr), [c, l] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1), u = () => {\n    l(!c);\n  }, p = le(ri)(() => ({\n    whiteSpace: \"nowrap\",\n    marginBottom: \"2px\",\n    padding: \"10px 12px\",\n    borderRadius: n,\n    color: c ? \"#fff\" : s.textColor,\n    cursor: i ? \"default\" : \"pointer\",\n    opacity: i ? \"0.6\" : \"1\",\n    backgroundColor: c ? s.themeColor : \"\",\n    \".MuiListItemIcon-root\": {\n      color: c ? \"#fff\" : s.textColor\n    },\n    \"&:hover\": {\n      backgroundColor: c ? s.themeColor : s.themeColor + 20,\n      color: c ? \"#fff\" : s.themeColor,\n      \".MuiListItemIcon-root\": {\n        color: c ? \"#fff\" : s.themeColor\n      }\n    }\n  })), m = le(ni)(() => ({\n    display: \"flex\",\n    gap: \"10px\",\n    marginBottom: \"0px\",\n    padding: \"0px\",\n    minWidth: \"30px\",\n    cursor: \"pointer\",\n    color: \"inherit\"\n  }));\n  return /* @__PURE__ */ N.jsxs(dt, { children: [\n    /* @__PURE__ */ N.jsxs(p, { onClick: u, sx: { display: \"flex\", gap: \"15px\" }, children: [\n      /* @__PURE__ */ N.jsx(m, { style: { minWidth: \"0px\" }, children: r || /* @__PURE__ */ N.jsx(Ds, {}) }),\n      !s.isCollapse && /* @__PURE__ */ N.jsxs(N.Fragment, { children: [\n        /* @__PURE__ */ N.jsx(oi, { sx: { my: 0 }, children: /* @__PURE__ */ N.jsx(bt, { fontSize: o, sx: { lineHeight: \"1\" }, variant: \"caption\", children: t }) }),\n        c ? /* @__PURE__ */ N.jsx(Dm, {}) : /* @__PURE__ */ N.jsx(Lm, {})\n      ] })\n    ] }),\n    /* @__PURE__ */ N.jsx(xn, { in: c, timeout: \"auto\", unmountOnExit: !0, children: /* @__PURE__ */ N.jsx(ti, { component: \"div\", disablePadding: !0, children: e }) })\n  ] });\n}, Ls = ({\n  component: e = \"a\",\n  children: t,\n  ...r\n}) => /* @__PURE__ */ N.jsx(e, { ...r, style: { textDecoration: \"none\" }, children: t }), qm = ({\n  children: e,\n  icon: t,\n  component: r,\n  badge: n = !1,\n  link: o = \"/\",\n  badgeColor: i = \"secondary\",\n  badgeContent: s = \"6\",\n  badgeTextColor: c = \"#fff\",\n  textFontSize: l = \"14px\",\n  borderRadius: u = \"8px\",\n  disabled: p = !1,\n  badgeType: m = \"filled\",\n  target: g = \"\",\n  isSelected: x = !1\n}) => {\n  const y = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Fr), f = Lr(), S = le(ri)(() => ({\n    whiteSpace: \"nowrap\",\n    marginBottom: \"2px\",\n    padding: \"10px 12px\",\n    width: \"100%\",\n    textAlign: f.direction === \"ltr\" ? \"left\" : \"right\",\n    borderRadius: u,\n    color: y.textColor,\n    cursor: p ? \"default\" : \"pointer\",\n    opacity: p ? \"0.6\" : \"1\",\n    \".MuiListItemIcon-root\": {\n      color: y.textColor\n    },\n    \"&:hover\": {\n      backgroundColor: p ? \"#fff\" : y.themeColor + 20,\n      color: y.themeColor,\n      \".MuiListItemIcon-root\": {\n        color: y.themeColor\n      }\n    },\n    \"&.Mui-selected\": {\n      color: \"white\",\n      backgroundColor: y.themeColor,\n      \"&:hover\": {\n        backgroundColor: y.themeColor,\n        color: \"white\"\n      },\n      \".MuiListItemIcon-root\": {\n        color: \"#fff\"\n      }\n    }\n  })), E = le(ni)(() => ({\n    display: \"flex\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    gap: \"10px\",\n    marginBottom: \"0px\",\n    padding: \"0px\",\n    cursor: \"pointer\",\n    color: \"inherit\"\n  }));\n  return /* @__PURE__ */ N.jsx(dt, { children: /* @__PURE__ */ N.jsx(Ls, { component: r, href: o, to: o, children: /* @__PURE__ */ N.jsxs(\n    S,\n    {\n      sx: { display: \"flex\", gap: \"15px\" },\n      target: g,\n      selected: !!x,\n      children: [\n        /* @__PURE__ */ N.jsx(\n          E,\n          {\n            sx: {\n              minWidth: \"0px\"\n            },\n            children: t || /* @__PURE__ */ N.jsx(Ds, {})\n          }\n        ),\n        y.isCollapse ? null : /* @__PURE__ */ N.jsxs(N.Fragment, { children: [\n          /* @__PURE__ */ N.jsx(oi, { sx: { my: 0 }, children: /* @__PURE__ */ N.jsx(\n            bt,\n            {\n              fontSize: l,\n              sx: { lineHeight: \"1\" },\n              variant: \"caption\",\n              children: e\n            }\n          ) }),\n          n && /* @__PURE__ */ N.jsx(\n            Is,\n            {\n              label: s,\n              color: i,\n              variant: m,\n              size: \"small\",\n              sx: { color: c }\n            }\n          )\n        ] })\n      ]\n    }\n  ) }) });\n}, Gm = ({\n  children: e,\n  img: t = \"https://adminmart.com/wp-content/uploads/2024/03/logo-admin-mart-news.png\",\n  href: r = \"/\",\n  component: n\n}) => {\n  const o = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Fr), i = le(\"span\")(() => ({\n    whiteSpace: \"nowrap\",\n    overflow: o.isCollapse ? \"hidden\" : \"visible\",\n    WebkitLineClamp: \"1\",\n    display: \"block\",\n    padding: \"15px 22px\",\n    textOverflow: \"ellipsis\"\n  }));\n  return /* @__PURE__ */ N.jsx(Ls, { href: r, component: n, to: r, children: /* @__PURE__ */ N.jsx(i, { children: t === \"\" ? /* @__PURE__ */ N.jsx(bt, { variant: \"body1\", children: e }) : /* @__PURE__ */ N.jsx(\n    dt,\n    {\n      component: \"img\",\n      sx: {\n        display: \"flex\",\n        alignItems: \"center\"\n      },\n      src: t\n    }\n  ) }) });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbXVpLXNpZGViYXIvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUMyQjtBQUM4RjtBQUN6RjtBQUNMO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxtQkFBbUIs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Q0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxXQUFXLGFBQWEsU0FBUyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBcUMsR0FBRyxDQUFpQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaURBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FB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QUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQXFDO0FBQ3BEO0FBQ0EsRUFBRSxFQUFFLENBQUU7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFxQztBQUNwRDtBQUNBLEVBQUUsRUFBRSxDQUFFO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBcUM7QUFDcEQ7QUFDQSxFQUFFLEVBQUUsQ0FBRTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFLEVBQUUseUJBQXlCO0FBQ2xELFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FB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O0FBQ3J0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFxQyxJQUFJLGdEQUFlO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtFQUErRSxZQUFZLHVCQUF1QixXQUFXLGFBQWEsV0FBVztBQUNySjtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxQ0FBcUMsSUFBSSxtQ0FBbUM7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQyxzQ0FBc0MsSUFBSSxtQ0FBbUM7QUFDNUg7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyx5QkFBeUIsNkNBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBVSxpREFBaUQsaURBQWdCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdURBQXVELE1BQU07QUFDN0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtGQUFrRixZQUFZO0FBQzlGO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUssdUVBQXVFO0FBQzVFO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCLDZDQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEJBQTBCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLDBHQUEwRyxjQUFjO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0QsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUErQjtBQUMzQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSx3QkFBd0IsNkNBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdURBQXVELFlBQVk7QUFDbkU7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQywwQkFBMEIsNkNBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCLDJDQUFVO0FBQzNCLFNBQVMsNENBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDJCQUEyQiw2Q0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyx3QkFBd0IsNkNBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxTQUFTLDBDQUFTO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsUUFBUSxZQUFZO0FBQ3BCLHNDQUFzQyxvQ0FBb0MsSUFBSSxzQ0FBc0M7QUFDcEgsVUFBVSxnQkFBZ0I7QUFDMUIsd0NBQXdDLG9DQUFvQyxTQUFTLHVDQUF1QyxJQUFJLG1DQUFtQztBQUNuSztBQUNBLEdBQUc7QUFDSCxRQUFRLFlBQVk7QUFDcEIsc0NBQXNDLG9DQUFvQyxTQUFTLHVDQUF1QyxJQUFJLG1DQUFtQztBQUNqSztBQUNBO0FBQ0Esd0NBQXdDLG9DQUFvQyxJQUFJLHNDQUFzQztBQUN0SDtBQUNBLEdBQUc7QUFDSCxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBLEdBQUc7QUFDSCxRQUFRLFlBQVk7QUFDcEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUNBQWlDLDhCQUE4QjtBQUMvRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLDBCQUEwQiw2Q0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksU0FBUyw2Q0FBWSxVQUFVLDBDQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNEJBQTRCLHlDQUFRO0FBQ3ZDO0FBQ0EsMENBQTBDLEtBQXFDO0FBQy9FLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQywwQkFBMEIsNkNBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJLFNBQVMsNkNBQVk7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBT0UiLCJzb3VyY2VzIjpbIi9ob21lL2pvYW8vRG9jdW1lbnRvcy9Qb3J0YWwtQ29uc3VsL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9yZWFjdC1tdWktc2lkZWJhci9kaXN0L2luZGV4LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBHcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBLcyA9IChlLCB0LCByKSA9PiB0IGluIGUgPyBHcyhlLCB0LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiByIH0pIDogZVt0XSA9IHI7XG52YXIgY3IgPSAoZSwgdCwgcikgPT4gS3MoZSwgdHlwZW9mIHQgIT0gXCJzeW1ib2xcIiA/IHQgKyBcIlwiIDogdCwgcik7XG5pbXBvcnQgKiBhcyBDIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHl0LCB7IGZvcndhcmRSZWYgYXMgWHMsIHVzZUNvbnRleHQgYXMgSnMsIENoaWxkcmVuIGFzIFFzLCBpc1ZhbGlkRWxlbWVudCBhcyBubiwgY2xvbmVFbGVtZW50IGFzIG9uIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBacyBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgV3IgZnJvbSBcInJlYWN0LWRvbVwiO1xuZnVuY3Rpb24gZWMoZSkge1xuICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIFwiZGVmYXVsdFwiKSA/IGUuZGVmYXVsdCA6IGU7XG59XG52YXIgVXIgPSB7IGV4cG9ydHM6IHt9IH0sIGxyID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGFpO1xuZnVuY3Rpb24gdGMoKSB7XG4gIGlmIChhaSkgcmV0dXJuIGxyO1xuICBhaSA9IDE7XG4gIHZhciBlID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLCB0ID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpO1xuICBmdW5jdGlvbiByKG4sIG8sIGkpIHtcbiAgICB2YXIgcyA9IG51bGw7XG4gICAgaWYgKGkgIT09IHZvaWQgMCAmJiAocyA9IFwiXCIgKyBpKSwgby5rZXkgIT09IHZvaWQgMCAmJiAocyA9IFwiXCIgKyBvLmtleSksIFwia2V5XCIgaW4gbykge1xuICAgICAgaSA9IHt9O1xuICAgICAgZm9yICh2YXIgYyBpbiBvKVxuICAgICAgICBjICE9PSBcImtleVwiICYmIChpW2NdID0gb1tjXSk7XG4gICAgfSBlbHNlIGkgPSBvO1xuICAgIHJldHVybiBvID0gaS5yZWYsIHtcbiAgICAgICQkdHlwZW9mOiBlLFxuICAgICAgdHlwZTogbixcbiAgICAgIGtleTogcyxcbiAgICAgIHJlZjogbyAhPT0gdm9pZCAwID8gbyA6IG51bGwsXG4gICAgICBwcm9wczogaVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGxyLkZyYWdtZW50ID0gdCwgbHIuanN4ID0gciwgbHIuanN4cyA9IHIsIGxyO1xufVxudmFyIHVyID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBzaTtcbmZ1bmN0aW9uIHJjKCkge1xuICByZXR1cm4gc2kgfHwgKHNpID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGUodikge1xuICAgICAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIHYgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gdi4kJHR5cGVvZiA9PT0gdGUgPyBudWxsIDogdi5kaXNwbGF5TmFtZSB8fCB2Lm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgdiA9PSBcInN0cmluZ1wiKSByZXR1cm4gdjtcbiAgICAgIHN3aXRjaCAodikge1xuICAgICAgICBjYXNlIHc6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBoOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIEw6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBrOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBEOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgajpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdiA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2LnRhZyA9PSBcIm51bWJlclwiICYmIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICksIHYuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIGQ6XG4gICAgICAgICAgICByZXR1cm4gKHYuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIEI6XG4gICAgICAgICAgICByZXR1cm4gKHYuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIEE6XG4gICAgICAgICAgICB2YXIgTSA9IHYucmVuZGVyO1xuICAgICAgICAgICAgcmV0dXJuIHYgPSB2LmRpc3BsYXlOYW1lLCB2IHx8ICh2ID0gTS5kaXNwbGF5TmFtZSB8fCBNLm5hbWUgfHwgXCJcIiwgdiA9IHYgIT09IFwiXCIgPyBcIkZvcndhcmRSZWYoXCIgKyB2ICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIiksIHY7XG4gICAgICAgICAgY2FzZSBXOlxuICAgICAgICAgICAgcmV0dXJuIE0gPSB2LmRpc3BsYXlOYW1lIHx8IG51bGwsIE0gIT09IG51bGwgPyBNIDogZSh2LnR5cGUpIHx8IFwiTWVtb1wiO1xuICAgICAgICAgIGNhc2UgejpcbiAgICAgICAgICAgIE0gPSB2Ll9wYXlsb2FkLCB2ID0gdi5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBlKHYoTSkpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0KHYpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcih2KSB7XG4gICAgICB0cnkge1xuICAgICAgICB0KHYpO1xuICAgICAgICB2YXIgTSA9ICExO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIE0gPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChNKSB7XG4gICAgICAgIE0gPSBjb25zb2xlO1xuICAgICAgICB2YXIgWSA9IE0uZXJyb3IsIG9lID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnICYmIHZbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2LmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIFkuY2FsbChcbiAgICAgICAgICBNLFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBvZVxuICAgICAgICApLCB0KHYpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBuKCkge1xuICAgIH1cbiAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgaWYgKEggPT09IDApIHtcbiAgICAgICAgWCA9IGNvbnNvbGUubG9nLCBfID0gY29uc29sZS5pbmZvLCBxID0gY29uc29sZS53YXJuLCBHID0gY29uc29sZS5lcnJvciwgcmUgPSBjb25zb2xlLmdyb3VwLCBaID0gY29uc29sZS5ncm91cENvbGxhcHNlZCwgYWUgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICB2YXIgdiA9IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgIHZhbHVlOiBuLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogdixcbiAgICAgICAgICBsb2c6IHYsXG4gICAgICAgICAgd2FybjogdixcbiAgICAgICAgICBlcnJvcjogdixcbiAgICAgICAgICBncm91cDogdixcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogdixcbiAgICAgICAgICBncm91cEVuZDogdlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIEgrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgIGlmIChILS0sIEggPT09IDApIHtcbiAgICAgICAgdmFyIHYgPSB7IGNvbmZpZ3VyYWJsZTogITAsIGVudW1lcmFibGU6ICEwLCB3cml0YWJsZTogITAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGxvZzogSSh7fSwgdiwgeyB2YWx1ZTogWCB9KSxcbiAgICAgICAgICBpbmZvOiBJKHt9LCB2LCB7IHZhbHVlOiBfIH0pLFxuICAgICAgICAgIHdhcm46IEkoe30sIHYsIHsgdmFsdWU6IHEgfSksXG4gICAgICAgICAgZXJyb3I6IEkoe30sIHYsIHsgdmFsdWU6IEcgfSksXG4gICAgICAgICAgZ3JvdXA6IEkoe30sIHYsIHsgdmFsdWU6IHJlIH0pLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBJKHt9LCB2LCB7IHZhbHVlOiBaIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBJKHt9LCB2LCB7IHZhbHVlOiBhZSB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIDAgPiBIICYmIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzKHYpIHtcbiAgICAgIGlmIChPID09PSB2b2lkIDApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoWSkge1xuICAgICAgICAgIHZhciBNID0gWS5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBPID0gTSAmJiBNWzFdIHx8IFwiXCIsIHllID0gLTEgPCBZLnN0YWNrLmluZGV4T2YoYFxuICAgIGF0YCkgPyBcIiAoPGFub255bW91cz4pXCIgOiAtMSA8IFkuc3RhY2suaW5kZXhPZihcIkBcIikgPyBcIkB1bmtub3duOjA6MFwiIDogXCJcIjtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIGBcbmAgKyBPICsgdiArIHllO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjKHYsIE0pIHtcbiAgICAgIGlmICghdiB8fCBFZSkgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgWSA9IE1lLmdldCh2KTtcbiAgICAgIGlmIChZICE9PSB2b2lkIDApIHJldHVybiBZO1xuICAgICAgRWUgPSAhMCwgWSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlLCBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBvZSA9IG51bGw7XG4gICAgICBvZSA9IEYuSCwgRi5IID0gbnVsbCwgbygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIFJlID0ge1xuICAgICAgICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoTSkge1xuICAgICAgICAgICAgICAgIHZhciBXZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkoV2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksIHR5cGVvZiBSZWZsZWN0ID09IFwib2JqZWN0XCIgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KFdlLCBbXSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh1dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgVWUgPSB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KHYsIFtdLCBXZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIFdlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIFVlID0gdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2LmNhbGwoV2UucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodXQpIHtcbiAgICAgICAgICAgICAgICAgIFVlID0gdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChXZSA9IHYoKSkgJiYgdHlwZW9mIFdlLmNhdGNoID09IFwiZnVuY3Rpb25cIiAmJiBXZS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAodXQpIHtcbiAgICAgICAgICAgICAgaWYgKHV0ICYmIFVlICYmIHR5cGVvZiB1dC5zdGFjayA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiBbdXQuc3RhY2ssIFVlLnN0YWNrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgIFJlLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICBcIm5hbWVcIlxuICAgICAgICApO1xuICAgICAgICB1ZSAmJiB1ZS5jb25maWd1cmFibGUgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgIFJlLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgICB7IHZhbHVlOiBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiIH1cbiAgICAgICAgKTtcbiAgICAgICAgdmFyIEsgPSBSZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSwgYmUgPSBLWzBdLCB3ZSA9IEtbMV07XG4gICAgICAgIGlmIChiZSAmJiB3ZSkge1xuICAgICAgICAgIHZhciBPZSA9IGJlLnNwbGl0KGBcbmApLCBjZSA9IHdlLnNwbGl0KGBcbmApO1xuICAgICAgICAgIGZvciAoSyA9IHVlID0gMDsgdWUgPCBPZS5sZW5ndGggJiYgIU9lW3VlXS5pbmNsdWRlcyhcbiAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICApOyApXG4gICAgICAgICAgICB1ZSsrO1xuICAgICAgICAgIGZvciAoOyBLIDwgY2UubGVuZ3RoICYmICFjZVtLXS5pbmNsdWRlcyhcbiAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICApOyApXG4gICAgICAgICAgICBLKys7XG4gICAgICAgICAgaWYgKHVlID09PSBPZS5sZW5ndGggfHwgSyA9PT0gY2UubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh1ZSA9IE9lLmxlbmd0aCAtIDEsIEsgPSBjZS5sZW5ndGggLSAxOyAxIDw9IHVlICYmIDAgPD0gSyAmJiBPZVt1ZV0gIT09IGNlW0tdOyApXG4gICAgICAgICAgICAgIEstLTtcbiAgICAgICAgICBmb3IgKDsgMSA8PSB1ZSAmJiAwIDw9IEs7IHVlLS0sIEstLSlcbiAgICAgICAgICAgIGlmIChPZVt1ZV0gIT09IGNlW0tdKSB7XG4gICAgICAgICAgICAgIGlmICh1ZSAhPT0gMSB8fCBLICE9PSAxKVxuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAodWUtLSwgSy0tLCAwID4gSyB8fCBPZVt1ZV0gIT09IGNlW0tdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBJZSA9IGBcbmAgKyBPZVt1ZV0ucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCIgYXQgXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYuZGlzcGxheU5hbWUgJiYgSWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJiAoSWUgPSBJZS5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgdi5kaXNwbGF5TmFtZSkpLCB0eXBlb2YgdiA9PSBcImZ1bmN0aW9uXCIgJiYgTWUuc2V0KHYsIEllKSwgSWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEgPD0gdWUgJiYgMCA8PSBLKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIEVlID0gITEsIEYuSCA9IG9lLCBpKCksIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gWTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPZSA9IChPZSA9IHYgPyB2LmRpc3BsYXlOYW1lIHx8IHYubmFtZSA6IFwiXCIpID8gcyhPZSkgOiBcIlwiLCB0eXBlb2YgdiA9PSBcImZ1bmN0aW9uXCIgJiYgTWUuc2V0KHYsIE9lKSwgT2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGwodikge1xuICAgICAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAodHlwZW9mIHYgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBNID0gdi5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBjKFxuICAgICAgICAgIHYsXG4gICAgICAgICAgISghTSB8fCAhTS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2ID09IFwic3RyaW5nXCIpIHJldHVybiBzKHYpO1xuICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgIGNhc2UgRDpcbiAgICAgICAgICByZXR1cm4gcyhcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIGo6XG4gICAgICAgICAgcmV0dXJuIHMoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHYgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoICh2LiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBBOlxuICAgICAgICAgICAgcmV0dXJuIHYgPSBjKHYucmVuZGVyLCAhMSksIHY7XG4gICAgICAgICAgY2FzZSBXOlxuICAgICAgICAgICAgcmV0dXJuIGwodi50eXBlKTtcbiAgICAgICAgICBjYXNlIHo6XG4gICAgICAgICAgICBNID0gdi5fcGF5bG9hZCwgdiA9IHYuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gbCh2KE0pKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdSgpIHtcbiAgICAgIHZhciB2ID0gRi5BO1xuICAgICAgcmV0dXJuIHYgPT09IG51bGwgPyBudWxsIDogdi5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwKHYpIHtcbiAgICAgIGlmIChSLmNhbGwodiwgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIE0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHYsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKE0gJiYgTS5pc1JlYWN0V2FybmluZykgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHYua2V5ICE9PSB2b2lkIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG0odiwgTSkge1xuICAgICAgZnVuY3Rpb24gWSgpIHtcbiAgICAgICAgdmUgfHwgKHZlID0gITAsIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3BlY2lhbC1wcm9wcylcIixcbiAgICAgICAgICBNXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgICAgWS5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodiwgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IFksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgdmFyIHYgPSBlKHRoaXMudHlwZSk7XG4gICAgICByZXR1cm4gUGVbdl0gfHwgKFBlW3ZdID0gITAsIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiQWNjZXNzaW5nIGVsZW1lbnQucmVmIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiByZWYgaXMgbm93IGEgcmVndWxhciBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgSlNYIEVsZW1lbnQgdHlwZSBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiXG4gICAgICApKSwgdiA9IHRoaXMucHJvcHMucmVmLCB2ICE9PSB2b2lkIDAgPyB2IDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24geCh2LCBNLCBZLCBvZSwgUmUsIHVlKSB7XG4gICAgICByZXR1cm4gWSA9IHVlLnJlZiwgdiA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IGIsXG4gICAgICAgIHR5cGU6IHYsXG4gICAgICAgIGtleTogTSxcbiAgICAgICAgcHJvcHM6IHVlLFxuICAgICAgICBfb3duZXI6IFJlXG4gICAgICB9LCAoWSAhPT0gdm9pZCAwID8gWSA6IG51bGwpICE9PSBudWxsID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHYsIFwicmVmXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGdldDogZ1xuICAgICAgfSkgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodiwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSksIHYuX3N0b3JlID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2Ll9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2LCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSksIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodi5wcm9wcyksIE9iamVjdC5mcmVlemUodikpLCB2O1xuICAgIH1cbiAgICBmdW5jdGlvbiB5KHYsIE0sIFksIG9lLCBSZSwgdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdiA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2ID09IFwiZnVuY3Rpb25cIiB8fCB2ID09PSB3IHx8IHYgPT09IEwgfHwgdiA9PT0gayB8fCB2ID09PSBEIHx8IHYgPT09IGogfHwgdiA9PT0gVSB8fCB0eXBlb2YgdiA9PSBcIm9iamVjdFwiICYmIHYgIT09IG51bGwgJiYgKHYuJCR0eXBlb2YgPT09IHogfHwgdi4kJHR5cGVvZiA9PT0gVyB8fCB2LiQkdHlwZW9mID09PSBkIHx8IHYuJCR0eXBlb2YgPT09IEIgfHwgdi4kJHR5cGVvZiA9PT0gQSB8fCB2LiQkdHlwZW9mID09PSBKIHx8IHYuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkpIHtcbiAgICAgICAgdmFyIEsgPSBNLmNoaWxkcmVuO1xuICAgICAgICBpZiAoSyAhPT0gdm9pZCAwKVxuICAgICAgICAgIGlmIChvZSlcbiAgICAgICAgICAgIGlmIChRKEspKSB7XG4gICAgICAgICAgICAgIGZvciAob2UgPSAwOyBvZSA8IEsubGVuZ3RoOyBvZSsrKVxuICAgICAgICAgICAgICAgIGYoS1tvZV0sIHYpO1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoSyk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2UgZihLLCB2KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBLID0gXCJcIiwgKHYgPT09IHZvaWQgMCB8fCB0eXBlb2YgdiA9PSBcIm9iamVjdFwiICYmIHYgIT09IG51bGwgJiYgT2JqZWN0LmtleXModikubGVuZ3RoID09PSAwKSAmJiAoSyArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCIpLCB2ID09PSBudWxsID8gb2UgPSBcIm51bGxcIiA6IFEodikgPyBvZSA9IFwiYXJyYXlcIiA6IHYgIT09IHZvaWQgMCAmJiB2LiQkdHlwZW9mID09PSBiID8gKG9lID0gXCI8XCIgKyAoZSh2LnR5cGUpIHx8IFwiVW5rbm93blwiKSArIFwiIC8+XCIsIEsgPSBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSA6IG9lID0gdHlwZW9mIHYsIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIixcbiAgICAgICAgICBvZSxcbiAgICAgICAgICBLXG4gICAgICAgICk7XG4gICAgICBpZiAoUi5jYWxsKE0sIFwia2V5XCIpKSB7XG4gICAgICAgIEsgPSBlKHYpO1xuICAgICAgICB2YXIgYmUgPSBPYmplY3Qua2V5cyhNKS5maWx0ZXIoZnVuY3Rpb24oT2UpIHtcbiAgICAgICAgICByZXR1cm4gT2UgIT09IFwia2V5XCI7XG4gICAgICAgIH0pO1xuICAgICAgICBvZSA9IDAgPCBiZS5sZW5ndGggPyBcIntrZXk6IHNvbWVLZXksIFwiICsgYmUuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7a2V5OiBzb21lS2V5fVwiLCB6ZVtLICsgb2VdIHx8IChiZSA9IDAgPCBiZS5sZW5ndGggPyBcIntcIiArIGJlLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiwgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XG4gIGxldCBwcm9wcyA9ICVzO1xuICA8JXMgey4uLnByb3BzfSAvPlxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XG4gIGxldCBwcm9wcyA9ICVzO1xuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+YCxcbiAgICAgICAgICBvZSxcbiAgICAgICAgICBLLFxuICAgICAgICAgIGJlLFxuICAgICAgICAgIEtcbiAgICAgICAgKSwgemVbSyArIG9lXSA9ICEwKTtcbiAgICAgIH1cbiAgICAgIGlmIChLID0gbnVsbCwgWSAhPT0gdm9pZCAwICYmIChyKFkpLCBLID0gXCJcIiArIFkpLCBwKE0pICYmIChyKE0ua2V5KSwgSyA9IFwiXCIgKyBNLmtleSksIFwia2V5XCIgaW4gTSkge1xuICAgICAgICBZID0ge307XG4gICAgICAgIGZvciAodmFyIHdlIGluIE0pXG4gICAgICAgICAgd2UgIT09IFwia2V5XCIgJiYgKFlbd2VdID0gTVt3ZV0pO1xuICAgICAgfSBlbHNlIFkgPSBNO1xuICAgICAgcmV0dXJuIEsgJiYgbShcbiAgICAgICAgWSxcbiAgICAgICAgdHlwZW9mIHYgPT0gXCJmdW5jdGlvblwiID8gdi5kaXNwbGF5TmFtZSB8fCB2Lm5hbWUgfHwgXCJVbmtub3duXCIgOiB2XG4gICAgICApLCB4KHYsIEssIHVlLCBSZSwgdSgpLCBZKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZih2LCBNKSB7XG4gICAgICBpZiAodHlwZW9mIHYgPT0gXCJvYmplY3RcIiAmJiB2ICYmIHYuJCR0eXBlb2YgIT09IFFlKSB7XG4gICAgICAgIGlmIChRKHYpKVxuICAgICAgICAgIGZvciAodmFyIFkgPSAwOyBZIDwgdi5sZW5ndGg7IFkrKykge1xuICAgICAgICAgICAgdmFyIG9lID0gdltZXTtcbiAgICAgICAgICAgIFMob2UpICYmIEUob2UsIE0pO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUyh2KSlcbiAgICAgICAgICB2Ll9zdG9yZSAmJiAodi5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKHYgPT09IG51bGwgfHwgdHlwZW9mIHYgIT0gXCJvYmplY3RcIiA/IFkgPSBudWxsIDogKFkgPSBWICYmIHZbVl0gfHwgdltcIkBAaXRlcmF0b3JcIl0sIFkgPSB0eXBlb2YgWSA9PSBcImZ1bmN0aW9uXCIgPyBZIDogbnVsbCksIHR5cGVvZiBZID09IFwiZnVuY3Rpb25cIiAmJiBZICE9PSB2LmVudHJpZXMgJiYgKFkgPSBZLmNhbGwodiksIFkgIT09IHYpKVxuICAgICAgICAgIGZvciAoOyAhKHYgPSBZLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgUyh2LnZhbHVlKSAmJiBFKHYudmFsdWUsIE0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBTKHYpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdiA9PSBcIm9iamVjdFwiICYmIHYgIT09IG51bGwgJiYgdi4kJHR5cGVvZiA9PT0gYjtcbiAgICB9XG4gICAgZnVuY3Rpb24gRSh2LCBNKSB7XG4gICAgICBpZiAodi5fc3RvcmUgJiYgIXYuX3N0b3JlLnZhbGlkYXRlZCAmJiB2LmtleSA9PSBudWxsICYmICh2Ll9zdG9yZS52YWxpZGF0ZWQgPSAxLCBNID0gUChNKSwgIUxlW01dKSkge1xuICAgICAgICBMZVtNXSA9ICEwO1xuICAgICAgICB2YXIgWSA9IFwiXCI7XG4gICAgICAgIHYgJiYgdi5fb3duZXIgIT0gbnVsbCAmJiB2Ll9vd25lciAhPT0gdSgpICYmIChZID0gbnVsbCwgdHlwZW9mIHYuX293bmVyLnRhZyA9PSBcIm51bWJlclwiID8gWSA9IGUodi5fb3duZXIudHlwZSkgOiB0eXBlb2Ygdi5fb3duZXIubmFtZSA9PSBcInN0cmluZ1wiICYmIChZID0gdi5fb3duZXIubmFtZSksIFkgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIFkgKyBcIi5cIik7XG4gICAgICAgIHZhciBvZSA9IEYuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICBGLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBSZSA9IGwodi50eXBlKTtcbiAgICAgICAgICByZXR1cm4gb2UgJiYgKFJlICs9IG9lKCkgfHwgXCJcIiksIFJlO1xuICAgICAgICB9LCBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBNLFxuICAgICAgICAgIFlcbiAgICAgICAgKSwgRi5nZXRDdXJyZW50U3RhY2sgPSBvZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUCh2KSB7XG4gICAgICB2YXIgTSA9IFwiXCIsIFkgPSB1KCk7XG4gICAgICByZXR1cm4gWSAmJiAoWSA9IGUoWS50eXBlKSkgJiYgKE0gPSBgXG5cbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFxcYGAgKyBZICsgXCJgLlwiKSwgTSB8fCAodiA9IGUodikpICYmIChNID0gYFxuXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxgICsgdiArIFwiPi5cIiksIE07XG4gICAgfVxuICAgIHZhciBUID0geXQsIGIgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksIGggPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCB3ID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBrID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBMID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBCID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLCBkID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIEEgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIEQgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIGogPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgVyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCB6ID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIFUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBWID0gU3ltYm9sLml0ZXJhdG9yLCB0ZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLCBGID0gVC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsIFIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBJID0gT2JqZWN0LmFzc2lnbiwgSiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLCBRID0gQXJyYXkuaXNBcnJheSwgSCA9IDAsIFgsIF8sIHEsIEcsIHJlLCBaLCBhZTtcbiAgICBuLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIHZhciBPLCB5ZSwgRWUgPSAhMSwgTWUgPSBuZXcgKHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXApKCksIFFlID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksIHZlLCBQZSA9IHt9LCB6ZSA9IHt9LCBMZSA9IHt9O1xuICAgIHVyLkZyYWdtZW50ID0gdywgdXIuanN4ID0gZnVuY3Rpb24odiwgTSwgWSwgb2UsIFJlKSB7XG4gICAgICByZXR1cm4geSh2LCBNLCBZLCAhMSwgb2UsIFJlKTtcbiAgICB9LCB1ci5qc3hzID0gZnVuY3Rpb24odiwgTSwgWSwgb2UsIFJlKSB7XG4gICAgICByZXR1cm4geSh2LCBNLCBZLCAhMCwgb2UsIFJlKTtcbiAgICB9O1xuICB9KCkpLCB1cjtcbn1cbnZhciBjaTtcbmZ1bmN0aW9uIG5jKCkge1xuICByZXR1cm4gY2kgfHwgKGNpID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gVXIuZXhwb3J0cyA9IHRjKCkgOiBVci5leHBvcnRzID0gcmMoKSksIFVyLmV4cG9ydHM7XG59XG52YXIgTiA9IG5jKCk7XG5jb25zdCBFciA9IHtcbiAgYmxhY2s6IFwiIzAwMFwiLFxuICB3aGl0ZTogXCIjZmZmXCJcbn0sIFd0ID0ge1xuICA1MDogXCIjZmZlYmVlXCIsXG4gIDEwMDogXCIjZmZjZGQyXCIsXG4gIDIwMDogXCIjZWY5YTlhXCIsXG4gIDMwMDogXCIjZTU3MzczXCIsXG4gIDQwMDogXCIjZWY1MzUwXCIsXG4gIDUwMDogXCIjZjQ0MzM2XCIsXG4gIDYwMDogXCIjZTUzOTM1XCIsXG4gIDcwMDogXCIjZDMyZjJmXCIsXG4gIDgwMDogXCIjYzYyODI4XCIsXG4gIDkwMDogXCIjYjcxYzFjXCIsXG4gIEExMDA6IFwiI2ZmOGE4MFwiLFxuICBBMjAwOiBcIiNmZjUyNTJcIixcbiAgQTQwMDogXCIjZmYxNzQ0XCIsXG4gIEE3MDA6IFwiI2Q1MDAwMFwiXG59LCBVdCA9IHtcbiAgNTA6IFwiI2YzZTVmNVwiLFxuICAxMDA6IFwiI2UxYmVlN1wiLFxuICAyMDA6IFwiI2NlOTNkOFwiLFxuICAzMDA6IFwiI2JhNjhjOFwiLFxuICA0MDA6IFwiI2FiNDdiY1wiLFxuICA1MDA6IFwiIzljMjdiMFwiLFxuICA2MDA6IFwiIzhlMjRhYVwiLFxuICA3MDA6IFwiIzdiMWZhMlwiLFxuICA4MDA6IFwiIzZhMWI5YVwiLFxuICA5MDA6IFwiIzRhMTQ4Y1wiLFxuICBBMTAwOiBcIiNlYTgwZmNcIixcbiAgQTIwMDogXCIjZTA0MGZiXCIsXG4gIEE0MDA6IFwiI2Q1MDBmOVwiLFxuICBBNzAwOiBcIiNhYTAwZmZcIlxufSwgWXQgPSB7XG4gIDUwOiBcIiNlM2YyZmRcIixcbiAgMTAwOiBcIiNiYmRlZmJcIixcbiAgMjAwOiBcIiM5MGNhZjlcIixcbiAgMzAwOiBcIiM2NGI1ZjZcIixcbiAgNDAwOiBcIiM0MmE1ZjVcIixcbiAgNTAwOiBcIiMyMTk2ZjNcIixcbiAgNjAwOiBcIiMxZTg4ZTVcIixcbiAgNzAwOiBcIiMxOTc2ZDJcIixcbiAgODAwOiBcIiMxNTY1YzBcIixcbiAgOTAwOiBcIiMwZDQ3YTFcIixcbiAgQTEwMDogXCIjODJiMWZmXCIsXG4gIEEyMDA6IFwiIzQ0OGFmZlwiLFxuICBBNDAwOiBcIiMyOTc5ZmZcIixcbiAgQTcwMDogXCIjMjk2MmZmXCJcbn0sIEh0ID0ge1xuICA1MDogXCIjZTFmNWZlXCIsXG4gIDEwMDogXCIjYjNlNWZjXCIsXG4gIDIwMDogXCIjODFkNGZhXCIsXG4gIDMwMDogXCIjNGZjM2Y3XCIsXG4gIDQwMDogXCIjMjliNmY2XCIsXG4gIDUwMDogXCIjMDNhOWY0XCIsXG4gIDYwMDogXCIjMDM5YmU1XCIsXG4gIDcwMDogXCIjMDI4OGQxXCIsXG4gIDgwMDogXCIjMDI3N2JkXCIsXG4gIDkwMDogXCIjMDE1NzliXCIsXG4gIEExMDA6IFwiIzgwZDhmZlwiLFxuICBBMjAwOiBcIiM0MGM0ZmZcIixcbiAgQTQwMDogXCIjMDBiMGZmXCIsXG4gIEE3MDA6IFwiIzAwOTFlYVwiXG59LCBxdCA9IHtcbiAgNTA6IFwiI2U4ZjVlOVwiLFxuICAxMDA6IFwiI2M4ZTZjOVwiLFxuICAyMDA6IFwiI2E1ZDZhN1wiLFxuICAzMDA6IFwiIzgxYzc4NFwiLFxuICA0MDA6IFwiIzY2YmI2YVwiLFxuICA1MDA6IFwiIzRjYWY1MFwiLFxuICA2MDA6IFwiIzQzYTA0N1wiLFxuICA3MDA6IFwiIzM4OGUzY1wiLFxuICA4MDA6IFwiIzJlN2QzMlwiLFxuICA5MDA6IFwiIzFiNWUyMFwiLFxuICBBMTAwOiBcIiNiOWY2Y2FcIixcbiAgQTIwMDogXCIjNjlmMGFlXCIsXG4gIEE0MDA6IFwiIzAwZTY3NlwiLFxuICBBNzAwOiBcIiMwMGM4NTNcIlxufSwgZnIgPSB7XG4gIDUwOiBcIiNmZmYzZTBcIixcbiAgMTAwOiBcIiNmZmUwYjJcIixcbiAgMjAwOiBcIiNmZmNjODBcIixcbiAgMzAwOiBcIiNmZmI3NGRcIixcbiAgNDAwOiBcIiNmZmE3MjZcIixcbiAgNTAwOiBcIiNmZjk4MDBcIixcbiAgNjAwOiBcIiNmYjhjMDBcIixcbiAgNzAwOiBcIiNmNTdjMDBcIixcbiAgODAwOiBcIiNlZjZjMDBcIixcbiAgOTAwOiBcIiNlNjUxMDBcIixcbiAgQTEwMDogXCIjZmZkMTgwXCIsXG4gIEEyMDA6IFwiI2ZmYWI0MFwiLFxuICBBNDAwOiBcIiNmZjkxMDBcIixcbiAgQTcwMDogXCIjZmY2ZDAwXCJcbn0sIG9jID0ge1xuICA1MDogXCIjZmFmYWZhXCIsXG4gIDEwMDogXCIjZjVmNWY1XCIsXG4gIDIwMDogXCIjZWVlZWVlXCIsXG4gIDMwMDogXCIjZTBlMGUwXCIsXG4gIDQwMDogXCIjYmRiZGJkXCIsXG4gIDUwMDogXCIjOWU5ZTllXCIsXG4gIDYwMDogXCIjNzU3NTc1XCIsXG4gIDcwMDogXCIjNjE2MTYxXCIsXG4gIDgwMDogXCIjNDI0MjQyXCIsXG4gIDkwMDogXCIjMjEyMTIxXCIsXG4gIEExMDA6IFwiI2Y1ZjVmNVwiLFxuICBBMjAwOiBcIiNlZWVlZWVcIixcbiAgQTQwMDogXCIjYmRiZGJkXCIsXG4gIEE3MDA6IFwiIzYxNjE2MVwiXG59O1xuZnVuY3Rpb24ga3QoZSwgLi4udCkge1xuICBjb25zdCByID0gbmV3IFVSTChgaHR0cHM6Ly9tdWkuY29tL3Byb2R1Y3Rpb24tZXJyb3IvP2NvZGU9JHtlfWApO1xuICByZXR1cm4gdC5mb3JFYWNoKChuKSA9PiByLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJhcmdzW11cIiwgbikpLCBgTWluaWZpZWQgTVVJIGVycm9yICMke2V9OyB2aXNpdCAke3J9IGZvciB0aGUgZnVsbCBtZXNzYWdlLmA7XG59XG5jb25zdCB3dCA9IFwiJCRtYXRlcmlhbFwiO1xuZnVuY3Rpb24gZm4oKSB7XG4gIHJldHVybiBmbiA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIHIgPSBhcmd1bWVudHNbdF07XG4gICAgICBmb3IgKHZhciBuIGluIHIpICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbChyLCBuKSAmJiAoZVtuXSA9IHJbbl0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGljKGUpIHtcbiAgaWYgKGUuc2hlZXQpXG4gICAgcmV0dXJuIGUuc2hlZXQ7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyB0KyspXG4gICAgaWYgKGRvY3VtZW50LnN0eWxlU2hlZXRzW3RdLm93bmVyTm9kZSA9PT0gZSlcbiAgICAgIHJldHVybiBkb2N1bWVudC5zdHlsZVNoZWV0c1t0XTtcbn1cbmZ1bmN0aW9uIGFjKGUpIHtcbiAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHJldHVybiB0LnNldEF0dHJpYnV0ZShcImRhdGEtZW1vdGlvblwiLCBlLmtleSksIGUubm9uY2UgIT09IHZvaWQgMCAmJiB0LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIGUubm9uY2UpLCB0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpKSwgdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXNcIiwgXCJcIiksIHQ7XG59XG52YXIgc2MgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGUocikge1xuICAgIHZhciBuID0gdGhpcztcbiAgICB0aGlzLl9pbnNlcnRUYWcgPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIG4udGFncy5sZW5ndGggPT09IDAgPyBuLmluc2VydGlvblBvaW50ID8gaSA9IG4uaW5zZXJ0aW9uUG9pbnQubmV4dFNpYmxpbmcgOiBuLnByZXBlbmQgPyBpID0gbi5jb250YWluZXIuZmlyc3RDaGlsZCA6IGkgPSBuLmJlZm9yZSA6IGkgPSBuLnRhZ3Nbbi50YWdzLmxlbmd0aCAtIDFdLm5leHRTaWJsaW5nLCBuLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUobywgaSksIG4udGFncy5wdXNoKG8pO1xuICAgIH0sIHRoaXMuaXNTcGVlZHkgPSByLnNwZWVkeSA9PT0gdm9pZCAwID8gITAgOiByLnNwZWVkeSwgdGhpcy50YWdzID0gW10sIHRoaXMuY3RyID0gMCwgdGhpcy5ub25jZSA9IHIubm9uY2UsIHRoaXMua2V5ID0gci5rZXksIHRoaXMuY29udGFpbmVyID0gci5jb250YWluZXIsIHRoaXMucHJlcGVuZCA9IHIucHJlcGVuZCwgdGhpcy5pbnNlcnRpb25Qb2ludCA9IHIuaW5zZXJ0aW9uUG9pbnQsIHRoaXMuYmVmb3JlID0gbnVsbDtcbiAgfVxuICB2YXIgdCA9IGUucHJvdG90eXBlO1xuICByZXR1cm4gdC5oeWRyYXRlID0gZnVuY3Rpb24obikge1xuICAgIG4uZm9yRWFjaCh0aGlzLl9pbnNlcnRUYWcpO1xuICB9LCB0Lmluc2VydCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLmN0ciAlICh0aGlzLmlzU3BlZWR5ID8gNjVlMyA6IDEpID09PSAwICYmIHRoaXMuX2luc2VydFRhZyhhYyh0aGlzKSk7XG4gICAgdmFyIG8gPSB0aGlzLnRhZ3NbdGhpcy50YWdzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0aGlzLmlzU3BlZWR5KSB7XG4gICAgICB2YXIgaSA9IGljKG8pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaS5pbnNlcnRSdWxlKG4sIGkuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgby5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuKSk7XG4gICAgdGhpcy5jdHIrKztcbiAgfSwgdC5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGFncy5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICAgIHZhciBvO1xuICAgICAgcmV0dXJuIChvID0gbi5wYXJlbnROb2RlKSA9PSBudWxsID8gdm9pZCAwIDogby5yZW1vdmVDaGlsZChuKTtcbiAgICB9KSwgdGhpcy50YWdzID0gW10sIHRoaXMuY3RyID0gMDtcbiAgfSwgZTtcbn0oKSwgWWUgPSBcIi1tcy1cIiwgZG4gPSBcIi1tb3otXCIsIGZlID0gXCItd2Via2l0LVwiLCB4YSA9IFwiY29tbVwiLCBTbyA9IFwicnVsZVwiLCBFbyA9IFwiZGVjbFwiLCBjYyA9IFwiQGltcG9ydFwiLCBTYSA9IFwiQGtleWZyYW1lc1wiLCBsYyA9IFwiQGxheWVyXCIsIHVjID0gTWF0aC5hYnMsIFJuID0gU3RyaW5nLmZyb21DaGFyQ29kZSwgZmMgPSBPYmplY3QuYXNzaWduO1xuZnVuY3Rpb24gZGMoZSwgdCkge1xuICByZXR1cm4gQmUoZSwgMCkgXiA0NSA/ICgoKHQgPDwgMiBeIEJlKGUsIDApKSA8PCAyIF4gQmUoZSwgMSkpIDw8IDIgXiBCZShlLCAyKSkgPDwgMiBeIEJlKGUsIDMpIDogMDtcbn1cbmZ1bmN0aW9uIEVhKGUpIHtcbiAgcmV0dXJuIGUudHJpbSgpO1xufVxuZnVuY3Rpb24gcGMoZSwgdCkge1xuICByZXR1cm4gKGUgPSB0LmV4ZWMoZSkpID8gZVswXSA6IGU7XG59XG5mdW5jdGlvbiBkZShlLCB0LCByKSB7XG4gIHJldHVybiBlLnJlcGxhY2UodCwgcik7XG59XG5mdW5jdGlvbiBvbyhlLCB0KSB7XG4gIHJldHVybiBlLmluZGV4T2YodCk7XG59XG5mdW5jdGlvbiBCZShlLCB0KSB7XG4gIHJldHVybiBlLmNoYXJDb2RlQXQodCkgfCAwO1xufVxuZnVuY3Rpb24gQ3IoZSwgdCwgcikge1xuICByZXR1cm4gZS5zbGljZSh0LCByKTtcbn1cbmZ1bmN0aW9uIG10KGUpIHtcbiAgcmV0dXJuIGUubGVuZ3RoO1xufVxuZnVuY3Rpb24gQ28oZSkge1xuICByZXR1cm4gZS5sZW5ndGg7XG59XG5mdW5jdGlvbiBZcihlLCB0KSB7XG4gIHJldHVybiB0LnB1c2goZSksIGU7XG59XG5mdW5jdGlvbiBtYyhlLCB0KSB7XG4gIHJldHVybiBlLm1hcCh0KS5qb2luKFwiXCIpO1xufVxudmFyICRuID0gMSwgWnQgPSAxLCBDYSA9IDAsIEplID0gMCwgamUgPSAwLCBpciA9IFwiXCI7XG5mdW5jdGlvbiBQbihlLCB0LCByLCBuLCBvLCBpLCBzKSB7XG4gIHJldHVybiB7IHZhbHVlOiBlLCByb290OiB0LCBwYXJlbnQ6IHIsIHR5cGU6IG4sIHByb3BzOiBvLCBjaGlsZHJlbjogaSwgbGluZTogJG4sIGNvbHVtbjogWnQsIGxlbmd0aDogcywgcmV0dXJuOiBcIlwiIH07XG59XG5mdW5jdGlvbiBkcihlLCB0KSB7XG4gIHJldHVybiBmYyhQbihcIlwiLCBudWxsLCBudWxsLCBcIlwiLCBudWxsLCBudWxsLCAwKSwgZSwgeyBsZW5ndGg6IC1lLmxlbmd0aCB9LCB0KTtcbn1cbmZ1bmN0aW9uIGhjKCkge1xuICByZXR1cm4gamU7XG59XG5mdW5jdGlvbiBnYygpIHtcbiAgcmV0dXJuIGplID0gSmUgPiAwID8gQmUoaXIsIC0tSmUpIDogMCwgWnQtLSwgamUgPT09IDEwICYmIChadCA9IDEsICRuLS0pLCBqZTtcbn1cbmZ1bmN0aW9uIGV0KCkge1xuICByZXR1cm4gamUgPSBKZSA8IENhID8gQmUoaXIsIEplKyspIDogMCwgWnQrKywgamUgPT09IDEwICYmIChadCA9IDEsICRuKyspLCBqZTtcbn1cbmZ1bmN0aW9uIHZ0KCkge1xuICByZXR1cm4gQmUoaXIsIEplKTtcbn1cbmZ1bmN0aW9uIGFuKCkge1xuICByZXR1cm4gSmU7XG59XG5mdW5jdGlvbiBBcihlLCB0KSB7XG4gIHJldHVybiBDcihpciwgZSwgdCk7XG59XG5mdW5jdGlvbiBUcihlKSB7XG4gIHN3aXRjaCAoZSkge1xuICAgIC8vIFxcMCBcXHQgXFxuIFxcciBcXHMgd2hpdGVzcGFjZSB0b2tlblxuICAgIGNhc2UgMDpcbiAgICBjYXNlIDk6XG4gICAgY2FzZSAxMDpcbiAgICBjYXNlIDEzOlxuICAgIGNhc2UgMzI6XG4gICAgICByZXR1cm4gNTtcbiAgICAvLyAhICsgLCAvID4gQCB+IGlzb2xhdGUgdG9rZW5cbiAgICBjYXNlIDMzOlxuICAgIGNhc2UgNDM6XG4gICAgY2FzZSA0NDpcbiAgICBjYXNlIDQ3OlxuICAgIGNhc2UgNjI6XG4gICAgY2FzZSA2NDpcbiAgICBjYXNlIDEyNjpcbiAgICAvLyA7IHsgfSBicmVha3BvaW50IHRva2VuXG4gICAgY2FzZSA1OTpcbiAgICBjYXNlIDEyMzpcbiAgICBjYXNlIDEyNTpcbiAgICAgIHJldHVybiA0O1xuICAgIC8vIDogYWNjb21wYW5pZWQgdG9rZW5cbiAgICBjYXNlIDU4OlxuICAgICAgcmV0dXJuIDM7XG4gICAgLy8gXCIgJyAoIFsgb3BlbmluZyBkZWxpbWl0IHRva2VuXG4gICAgY2FzZSAzNDpcbiAgICBjYXNlIDM5OlxuICAgIGNhc2UgNDA6XG4gICAgY2FzZSA5MTpcbiAgICAgIHJldHVybiAyO1xuICAgIC8vICkgXSBjbG9zaW5nIGRlbGltaXQgdG9rZW5cbiAgICBjYXNlIDQxOlxuICAgIGNhc2UgOTM6XG4gICAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIFRhKGUpIHtcbiAgcmV0dXJuICRuID0gWnQgPSAxLCBDYSA9IG10KGlyID0gZSksIEplID0gMCwgW107XG59XG5mdW5jdGlvbiB3YShlKSB7XG4gIHJldHVybiBpciA9IFwiXCIsIGU7XG59XG5mdW5jdGlvbiBzbihlKSB7XG4gIHJldHVybiBFYShBcihKZSAtIDEsIGlvKGUgPT09IDkxID8gZSArIDIgOiBlID09PSA0MCA/IGUgKyAxIDogZSkpKTtcbn1cbmZ1bmN0aW9uIHljKGUpIHtcbiAgZm9yICg7IChqZSA9IHZ0KCkpICYmIGplIDwgMzM7IClcbiAgICBldCgpO1xuICByZXR1cm4gVHIoZSkgPiAyIHx8IFRyKGplKSA+IDMgPyBcIlwiIDogXCIgXCI7XG59XG5mdW5jdGlvbiBiYyhlLCB0KSB7XG4gIGZvciAoOyAtLXQgJiYgZXQoKSAmJiAhKGplIDwgNDggfHwgamUgPiAxMDIgfHwgamUgPiA1NyAmJiBqZSA8IDY1IHx8IGplID4gNzAgJiYgamUgPCA5Nyk7IClcbiAgICA7XG4gIHJldHVybiBBcihlLCBhbigpICsgKHQgPCA2ICYmIHZ0KCkgPT0gMzIgJiYgZXQoKSA9PSAzMikpO1xufVxuZnVuY3Rpb24gaW8oZSkge1xuICBmb3IgKDsgZXQoKTsgKVxuICAgIHN3aXRjaCAoamUpIHtcbiAgICAgIC8vIF0gKSBcIiAnXG4gICAgICBjYXNlIGU6XG4gICAgICAgIHJldHVybiBKZTtcbiAgICAgIC8vIFwiICdcbiAgICAgIGNhc2UgMzQ6XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBlICE9PSAzNCAmJiBlICE9PSAzOSAmJiBpbyhqZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gKFxuICAgICAgY2FzZSA0MDpcbiAgICAgICAgZSA9PT0gNDEgJiYgaW8oZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gXFxcbiAgICAgIGNhc2UgOTI6XG4gICAgICAgIGV0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIEplO1xufVxuZnVuY3Rpb24gdmMoZSwgdCkge1xuICBmb3IgKDsgZXQoKSAmJiBlICsgamUgIT09IDU3OyApXG4gICAgaWYgKGUgKyBqZSA9PT0gODQgJiYgdnQoKSA9PT0gNDcpXG4gICAgICBicmVhaztcbiAgcmV0dXJuIFwiLypcIiArIEFyKHQsIEplIC0gMSkgKyBcIipcIiArIFJuKGUgPT09IDQ3ID8gZSA6IGV0KCkpO1xufVxuZnVuY3Rpb24geGMoZSkge1xuICBmb3IgKDsgIVRyKHZ0KCkpOyApXG4gICAgZXQoKTtcbiAgcmV0dXJuIEFyKGUsIEplKTtcbn1cbmZ1bmN0aW9uIFNjKGUpIHtcbiAgcmV0dXJuIHdhKGNuKFwiXCIsIG51bGwsIG51bGwsIG51bGwsIFtcIlwiXSwgZSA9IFRhKGUpLCAwLCBbMF0sIGUpKTtcbn1cbmZ1bmN0aW9uIGNuKGUsIHQsIHIsIG4sIG8sIGksIHMsIGMsIGwpIHtcbiAgZm9yICh2YXIgdSA9IDAsIHAgPSAwLCBtID0gcywgZyA9IDAsIHggPSAwLCB5ID0gMCwgZiA9IDEsIFMgPSAxLCBFID0gMSwgUCA9IDAsIFQgPSBcIlwiLCBiID0gbywgaCA9IGksIHcgPSBuLCBrID0gVDsgUzsgKVxuICAgIHN3aXRjaCAoeSA9IFAsIFAgPSBldCgpKSB7XG4gICAgICAvLyAoXG4gICAgICBjYXNlIDQwOlxuICAgICAgICBpZiAoeSAhPSAxMDggJiYgQmUoaywgbSAtIDEpID09IDU4KSB7XG4gICAgICAgICAgb28oayArPSBkZShzbihQKSwgXCImXCIsIFwiJlxcZlwiKSwgXCImXFxmXCIpICE9IC0xICYmIChFID0gLTEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBcIiAnIFtcbiAgICAgIGNhc2UgMzQ6XG4gICAgICBjYXNlIDM5OlxuICAgICAgY2FzZSA5MTpcbiAgICAgICAgayArPSBzbihQKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBcXHQgXFxuIFxcciBcXHNcbiAgICAgIGNhc2UgOTpcbiAgICAgIGNhc2UgMTA6XG4gICAgICBjYXNlIDEzOlxuICAgICAgY2FzZSAzMjpcbiAgICAgICAgayArPSB5Yyh5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBcXFxuICAgICAgY2FzZSA5MjpcbiAgICAgICAgayArPSBiYyhhbigpIC0gMSwgNyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgLy8gL1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAgc3dpdGNoICh2dCgpKSB7XG4gICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgWXIoRWModmMoZXQoKSwgYW4oKSksIHQsIHIpLCBsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBrICs9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8ge1xuICAgICAgY2FzZSAxMjMgKiBmOlxuICAgICAgICBjW3UrK10gPSBtdChrKSAqIEU7XG4gICAgICAvLyB9IDsgXFwwXG4gICAgICBjYXNlIDEyNSAqIGY6XG4gICAgICBjYXNlIDU5OlxuICAgICAgY2FzZSAwOlxuICAgICAgICBzd2l0Y2ggKFApIHtcbiAgICAgICAgICAvLyBcXDAgfVxuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDEyNTpcbiAgICAgICAgICAgIFMgPSAwO1xuICAgICAgICAgIC8vIDtcbiAgICAgICAgICBjYXNlIDU5ICsgcDpcbiAgICAgICAgICAgIEUgPT0gLTEgJiYgKGsgPSBkZShrLCAvXFxmL2csIFwiXCIpKSwgeCA+IDAgJiYgbXQoaykgLSBtICYmIFlyKHggPiAzMiA/IHVpKGsgKyBcIjtcIiwgbiwgciwgbSAtIDEpIDogdWkoZGUoaywgXCIgXCIsIFwiXCIpICsgXCI7XCIsIG4sIHIsIG0gLSAyKSwgbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBAIDtcbiAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgayArPSBcIjtcIjtcbiAgICAgICAgICAvLyB7IHJ1bGUvYXQtcnVsZVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoWXIodyA9IGxpKGssIHQsIHIsIHUsIHAsIG8sIGMsIFQsIGIgPSBbXSwgaCA9IFtdLCBtKSwgaSksIFAgPT09IDEyMylcbiAgICAgICAgICAgICAgaWYgKHAgPT09IDApXG4gICAgICAgICAgICAgICAgY24oaywgdCwgdywgdywgYiwgaSwgbSwgYywgaCk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGcgPT09IDk5ICYmIEJlKGssIDMpID09PSAxMTAgPyAxMDAgOiBnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBkIGwgbSBzXG4gICAgICAgICAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA4OlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDk6XG4gICAgICAgICAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgICAgICAgICAgY24oZSwgdywgdywgbiAmJiBZcihsaShlLCB3LCB3LCAwLCAwLCBvLCBjLCBULCBvLCBiID0gW10sIG0pLCBoKSwgbywgaCwgbSwgYywgbiA/IGIgOiBoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjbihrLCB3LCB3LCB3LCBbXCJcIl0sIGgsIDAsIGMsIGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1ID0gcCA9IHggPSAwLCBmID0gRSA9IDEsIFQgPSBrID0gXCJcIiwgbSA9IHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gOlxuICAgICAgY2FzZSA1ODpcbiAgICAgICAgbSA9IDEgKyBtdChrKSwgeCA9IHk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoZiA8IDEpIHtcbiAgICAgICAgICBpZiAoUCA9PSAxMjMpXG4gICAgICAgICAgICAtLWY7XG4gICAgICAgICAgZWxzZSBpZiAoUCA9PSAxMjUgJiYgZisrID09IDAgJiYgZ2MoKSA9PSAxMjUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGsgKz0gUm4oUCksIFAgKiBmKSB7XG4gICAgICAgICAgLy8gJlxuICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICBFID0gcCA+IDAgPyAxIDogKGsgKz0gXCJcXGZcIiwgLTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gLFxuICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICBjW3UrK10gPSAobXQoaykgLSAxKSAqIEUsIEUgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gQFxuICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICB2dCgpID09PSA0NSAmJiAoayArPSBzbihldCgpKSksIGcgPSB2dCgpLCBwID0gbSA9IG10KFQgPSBrICs9IHhjKGFuKCkpKSwgUCsrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gLVxuICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICB5ID09PSA0NSAmJiBtdChrKSA9PSAyICYmIChmID0gMCk7XG4gICAgICAgIH1cbiAgICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gbGkoZSwgdCwgciwgbiwgbywgaSwgcywgYywgbCwgdSwgcCkge1xuICBmb3IgKHZhciBtID0gbyAtIDEsIGcgPSBvID09PSAwID8gaSA6IFtcIlwiXSwgeCA9IENvKGcpLCB5ID0gMCwgZiA9IDAsIFMgPSAwOyB5IDwgbjsgKyt5KVxuICAgIGZvciAodmFyIEUgPSAwLCBQID0gQ3IoZSwgbSArIDEsIG0gPSB1YyhmID0gc1t5XSkpLCBUID0gZTsgRSA8IHg7ICsrRSlcbiAgICAgIChUID0gRWEoZiA+IDAgPyBnW0VdICsgXCIgXCIgKyBQIDogZGUoUCwgLyZcXGYvZywgZ1tFXSkpKSAmJiAobFtTKytdID0gVCk7XG4gIHJldHVybiBQbihlLCB0LCByLCBvID09PSAwID8gU28gOiBjLCBsLCB1LCBwKTtcbn1cbmZ1bmN0aW9uIEVjKGUsIHQsIHIpIHtcbiAgcmV0dXJuIFBuKGUsIHQsIHIsIHhhLCBSbihoYygpKSwgQ3IoZSwgMiwgLTIpLCAwKTtcbn1cbmZ1bmN0aW9uIHVpKGUsIHQsIHIsIG4pIHtcbiAgcmV0dXJuIFBuKGUsIHQsIHIsIEVvLCBDcihlLCAwLCBuKSwgQ3IoZSwgbiArIDEsIC0xKSwgbik7XG59XG5mdW5jdGlvbiBYdChlLCB0KSB7XG4gIGZvciAodmFyIHIgPSBcIlwiLCBuID0gQ28oZSksIG8gPSAwOyBvIDwgbjsgbysrKVxuICAgIHIgKz0gdChlW29dLCBvLCBlLCB0KSB8fCBcIlwiO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENjKGUsIHQsIHIsIG4pIHtcbiAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICBjYXNlIGxjOlxuICAgICAgaWYgKGUuY2hpbGRyZW4ubGVuZ3RoKSBicmVhaztcbiAgICBjYXNlIGNjOlxuICAgIGNhc2UgRW86XG4gICAgICByZXR1cm4gZS5yZXR1cm4gPSBlLnJldHVybiB8fCBlLnZhbHVlO1xuICAgIGNhc2UgeGE6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBjYXNlIFNhOlxuICAgICAgcmV0dXJuIGUucmV0dXJuID0gZS52YWx1ZSArIFwie1wiICsgWHQoZS5jaGlsZHJlbiwgbikgKyBcIn1cIjtcbiAgICBjYXNlIFNvOlxuICAgICAgZS52YWx1ZSA9IGUucHJvcHMuam9pbihcIixcIik7XG4gIH1cbiAgcmV0dXJuIG10KHIgPSBYdChlLmNoaWxkcmVuLCBuKSkgPyBlLnJldHVybiA9IGUudmFsdWUgKyBcIntcIiArIHIgKyBcIn1cIiA6IFwiXCI7XG59XG5mdW5jdGlvbiBUYyhlKSB7XG4gIHZhciB0ID0gQ28oZSk7XG4gIHJldHVybiBmdW5jdGlvbihyLCBuLCBvLCBpKSB7XG4gICAgZm9yICh2YXIgcyA9IFwiXCIsIGMgPSAwOyBjIDwgdDsgYysrKVxuICAgICAgcyArPSBlW2NdKHIsIG4sIG8sIGkpIHx8IFwiXCI7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5mdW5jdGlvbiB3YyhlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdC5yb290IHx8ICh0ID0gdC5yZXR1cm4pICYmIGUodCk7XG4gIH07XG59XG5mdW5jdGlvbiBPYShlKSB7XG4gIHZhciB0ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIHRbcl0gPT09IHZvaWQgMCAmJiAodFtyXSA9IGUocikpLCB0W3JdO1xuICB9O1xufVxudmFyIE9jID0gZnVuY3Rpb24odCwgciwgbikge1xuICBmb3IgKHZhciBvID0gMCwgaSA9IDA7IG8gPSBpLCBpID0gdnQoKSwgbyA9PT0gMzggJiYgaSA9PT0gMTIgJiYgKHJbbl0gPSAxKSwgIVRyKGkpOyApXG4gICAgZXQoKTtcbiAgcmV0dXJuIEFyKHQsIEplKTtcbn0sIFJjID0gZnVuY3Rpb24odCwgcikge1xuICB2YXIgbiA9IC0xLCBvID0gNDQ7XG4gIGRvXG4gICAgc3dpdGNoIChUcihvKSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBvID09PSAzOCAmJiB2dCgpID09PSAxMiAmJiAocltuXSA9IDEpLCB0W25dICs9IE9jKEplIC0gMSwgciwgbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0W25dICs9IHNuKG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgaWYgKG8gPT09IDQ0KSB7XG4gICAgICAgICAgdFsrK25dID0gdnQoKSA9PT0gNTggPyBcIiZcXGZcIiA6IFwiXCIsIHJbbl0gPSB0W25dLmxlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRbbl0gKz0gUm4obyk7XG4gICAgfVxuICB3aGlsZSAobyA9IGV0KCkpO1xuICByZXR1cm4gdDtcbn0sICRjID0gZnVuY3Rpb24odCwgcikge1xuICByZXR1cm4gd2EoUmMoVGEodCksIHIpKTtcbn0sIGZpID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFBjID0gZnVuY3Rpb24odCkge1xuICBpZiAoISh0LnR5cGUgIT09IFwicnVsZVwiIHx8ICF0LnBhcmVudCB8fCAvLyBwb3NpdGl2ZSAubGVuZ3RoIGluZGljYXRlcyB0aGF0IHRoaXMgcnVsZSBjb250YWlucyBwc2V1ZG9cbiAgLy8gbmVnYXRpdmUgLmxlbmd0aCBpbmRpY2F0ZXMgdGhhdCB0aGlzIHJ1bGUgaGFzIGJlZW4gYWxyZWFkeSBwcmVmaXhlZFxuICB0Lmxlbmd0aCA8IDEpKSB7XG4gICAgZm9yICh2YXIgciA9IHQudmFsdWUsIG4gPSB0LnBhcmVudCwgbyA9IHQuY29sdW1uID09PSBuLmNvbHVtbiAmJiB0LmxpbmUgPT09IG4ubGluZTsgbi50eXBlICE9PSBcInJ1bGVcIjsgKVxuICAgICAgaWYgKG4gPSBuLnBhcmVudCwgIW4pIHJldHVybjtcbiAgICBpZiAoISh0LnByb3BzLmxlbmd0aCA9PT0gMSAmJiByLmNoYXJDb2RlQXQoMCkgIT09IDU4ICYmICFmaS5nZXQobikpICYmICFvKSB7XG4gICAgICBmaS5zZXQodCwgITApO1xuICAgICAgZm9yICh2YXIgaSA9IFtdLCBzID0gJGMociwgaSksIGMgPSBuLnByb3BzLCBsID0gMCwgdSA9IDA7IGwgPCBzLmxlbmd0aDsgbCsrKVxuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IGMubGVuZ3RoOyBwKyssIHUrKylcbiAgICAgICAgICB0LnByb3BzW3VdID0gaVtsXSA/IHNbbF0ucmVwbGFjZSgvJlxcZi9nLCBjW3BdKSA6IGNbcF0gKyBcIiBcIiArIHNbbF07XG4gICAgfVxuICB9XG59LCBrYyA9IGZ1bmN0aW9uKHQpIHtcbiAgaWYgKHQudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICB2YXIgciA9IHQudmFsdWU7XG4gICAgLy8gY2hhcmNvZGUgZm9yIGxcbiAgICByLmNoYXJDb2RlQXQoMCkgPT09IDEwOCAmJiAvLyBjaGFyY29kZSBmb3IgYlxuICAgIHIuY2hhckNvZGVBdCgyKSA9PT0gOTggJiYgKHQucmV0dXJuID0gXCJcIiwgdC52YWx1ZSA9IFwiXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gUmEoZSwgdCkge1xuICBzd2l0Y2ggKGRjKGUsIHQpKSB7XG4gICAgLy8gY29sb3ItYWRqdXN0XG4gICAgY2FzZSA1MTAzOlxuICAgICAgcmV0dXJuIGZlICsgXCJwcmludC1cIiArIGUgKyBlO1xuICAgIC8vIGFuaW1hdGlvbiwgYW5pbWF0aW9uLShkZWxheXxkaXJlY3Rpb258ZHVyYXRpb258ZmlsbC1tb2RlfGl0ZXJhdGlvbi1jb3VudHxuYW1lfHBsYXktc3RhdGV8dGltaW5nLWZ1bmN0aW9uKVxuICAgIGNhc2UgNTczNzpcbiAgICBjYXNlIDQyMDE6XG4gICAgY2FzZSAzMTc3OlxuICAgIGNhc2UgMzQzMzpcbiAgICBjYXNlIDE2NDE6XG4gICAgY2FzZSA0NDU3OlxuICAgIGNhc2UgMjkyMTpcbiAgICAvLyB0ZXh0LWRlY29yYXRpb24sIGZpbHRlciwgY2xpcC1wYXRoLCBiYWNrZmFjZS12aXNpYmlsaXR5LCBjb2x1bW4sIGJveC1kZWNvcmF0aW9uLWJyZWFrXG4gICAgY2FzZSA1NTcyOlxuICAgIGNhc2UgNjM1NjpcbiAgICBjYXNlIDU4NDQ6XG4gICAgY2FzZSAzMTkxOlxuICAgIGNhc2UgNjY0NTpcbiAgICBjYXNlIDMwMDU6XG4gICAgLy8gbWFzaywgbWFzay1pbWFnZSwgbWFzay0obW9kZXxjbGlwfHNpemUpLCBtYXNrLShyZXBlYXR8b3JpZ2luKSwgbWFzay1wb3NpdGlvbiwgbWFzay1jb21wb3NpdGUsXG4gICAgY2FzZSA2MzkxOlxuICAgIGNhc2UgNTg3OTpcbiAgICBjYXNlIDU2MjM6XG4gICAgY2FzZSA2MTM1OlxuICAgIGNhc2UgNDU5OTpcbiAgICBjYXNlIDQ4NTU6XG4gICAgLy8gYmFja2dyb3VuZC1jbGlwLCBjb2x1bW5zLCBjb2x1bW4tKGNvdW50fGZpbGx8Z2FwfHJ1bGV8cnVsZS1jb2xvcnxydWxlLXN0eWxlfHJ1bGUtd2lkdGh8c3Bhbnx3aWR0aClcbiAgICBjYXNlIDQyMTU6XG4gICAgY2FzZSA2Mzg5OlxuICAgIGNhc2UgNTEwOTpcbiAgICBjYXNlIDUzNjU6XG4gICAgY2FzZSA1NjIxOlxuICAgIGNhc2UgMzgyOTpcbiAgICAgIHJldHVybiBmZSArIGUgKyBlO1xuICAgIC8vIGFwcGVhcmFuY2UsIHVzZXItc2VsZWN0LCB0cmFuc2Zvcm0sIGh5cGhlbnMsIHRleHQtc2l6ZS1hZGp1c3RcbiAgICBjYXNlIDUzNDk6XG4gICAgY2FzZSA0MjQ2OlxuICAgIGNhc2UgNDgxMDpcbiAgICBjYXNlIDY5Njg6XG4gICAgY2FzZSAyNzU2OlxuICAgICAgcmV0dXJuIGZlICsgZSArIGRuICsgZSArIFllICsgZSArIGU7XG4gICAgLy8gZmxleCwgZmxleC1kaXJlY3Rpb25cbiAgICBjYXNlIDY4Mjg6XG4gICAgY2FzZSA0MjY4OlxuICAgICAgcmV0dXJuIGZlICsgZSArIFllICsgZSArIGU7XG4gICAgLy8gb3JkZXJcbiAgICBjYXNlIDYxNjU6XG4gICAgICByZXR1cm4gZmUgKyBlICsgWWUgKyBcImZsZXgtXCIgKyBlICsgZTtcbiAgICAvLyBhbGlnbi1pdGVtc1xuICAgIGNhc2UgNTE4NzpcbiAgICAgIHJldHVybiBmZSArIGUgKyBkZShlLCAvKFxcdyspLisoOlteXSspLywgZmUgKyBcImJveC0kMSQyXCIgKyBZZSArIFwiZmxleC0kMSQyXCIpICsgZTtcbiAgICAvLyBhbGlnbi1zZWxmXG4gICAgY2FzZSA1NDQzOlxuICAgICAgcmV0dXJuIGZlICsgZSArIFllICsgXCJmbGV4LWl0ZW0tXCIgKyBkZShlLCAvZmxleC18LXNlbGYvLCBcIlwiKSArIGU7XG4gICAgLy8gYWxpZ24tY29udGVudFxuICAgIGNhc2UgNDY3NTpcbiAgICAgIHJldHVybiBmZSArIGUgKyBZZSArIFwiZmxleC1saW5lLXBhY2tcIiArIGRlKGUsIC9hbGlnbi1jb250ZW50fGZsZXgtfC1zZWxmLywgXCJcIikgKyBlO1xuICAgIC8vIGZsZXgtc2hyaW5rXG4gICAgY2FzZSA1NTQ4OlxuICAgICAgcmV0dXJuIGZlICsgZSArIFllICsgZGUoZSwgXCJzaHJpbmtcIiwgXCJuZWdhdGl2ZVwiKSArIGU7XG4gICAgLy8gZmxleC1iYXNpc1xuICAgIGNhc2UgNTI5MjpcbiAgICAgIHJldHVybiBmZSArIGUgKyBZZSArIGRlKGUsIFwiYmFzaXNcIiwgXCJwcmVmZXJyZWQtc2l6ZVwiKSArIGU7XG4gICAgLy8gZmxleC1ncm93XG4gICAgY2FzZSA2MDYwOlxuICAgICAgcmV0dXJuIGZlICsgXCJib3gtXCIgKyBkZShlLCBcIi1ncm93XCIsIFwiXCIpICsgZmUgKyBlICsgWWUgKyBkZShlLCBcImdyb3dcIiwgXCJwb3NpdGl2ZVwiKSArIGU7XG4gICAgLy8gdHJhbnNpdGlvblxuICAgIGNhc2UgNDU1NDpcbiAgICAgIHJldHVybiBmZSArIGRlKGUsIC8oW14tXSkodHJhbnNmb3JtKS9nLCBcIiQxXCIgKyBmZSArIFwiJDJcIikgKyBlO1xuICAgIC8vIGN1cnNvclxuICAgIGNhc2UgNjE4NzpcbiAgICAgIHJldHVybiBkZShkZShkZShlLCAvKHpvb20tfGdyYWIpLywgZmUgKyBcIiQxXCIpLCAvKGltYWdlLXNldCkvLCBmZSArIFwiJDFcIiksIGUsIFwiXCIpICsgZTtcbiAgICAvLyBiYWNrZ3JvdW5kLCBiYWNrZ3JvdW5kLWltYWdlXG4gICAgY2FzZSA1NDk1OlxuICAgIGNhc2UgMzk1OTpcbiAgICAgIHJldHVybiBkZShlLCAvKGltYWdlLXNldFxcKFteXSopLywgZmUgKyBcIiQxJGAkMVwiKTtcbiAgICAvLyBqdXN0aWZ5LWNvbnRlbnRcbiAgICBjYXNlIDQ5Njg6XG4gICAgICByZXR1cm4gZGUoZGUoZSwgLyguKzopKGZsZXgtKT8oLiopLywgZmUgKyBcImJveC1wYWNrOiQzXCIgKyBZZSArIFwiZmxleC1wYWNrOiQzXCIpLCAvcy4rLWJbXjtdKy8sIFwianVzdGlmeVwiKSArIGZlICsgZSArIGU7XG4gICAgLy8gKG1hcmdpbnxwYWRkaW5nKS1pbmxpbmUtKHN0YXJ0fGVuZClcbiAgICBjYXNlIDQwOTU6XG4gICAgY2FzZSAzNTgzOlxuICAgIGNhc2UgNDA2ODpcbiAgICBjYXNlIDI1MzI6XG4gICAgICByZXR1cm4gZGUoZSwgLyguKyktaW5saW5lKC4rKS8sIGZlICsgXCIkMSQyXCIpICsgZTtcbiAgICAvLyAobWlufG1heCk/KHdpZHRofGhlaWdodHxpbmxpbmUtc2l6ZXxibG9jay1zaXplKVxuICAgIGNhc2UgODExNjpcbiAgICBjYXNlIDcwNTk6XG4gICAgY2FzZSA1NzUzOlxuICAgIGNhc2UgNTUzNTpcbiAgICBjYXNlIDU0NDU6XG4gICAgY2FzZSA1NzAxOlxuICAgIGNhc2UgNDkzMzpcbiAgICBjYXNlIDQ2Nzc6XG4gICAgY2FzZSA1NTMzOlxuICAgIGNhc2UgNTc4OTpcbiAgICBjYXNlIDUwMjE6XG4gICAgY2FzZSA0NzY1OlxuICAgICAgaWYgKG10KGUpIC0gMSAtIHQgPiA2KSBzd2l0Y2ggKEJlKGUsIHQgKyAxKSkge1xuICAgICAgICAvLyAobSlheC1jb250ZW50LCAobSlpbi1jb250ZW50XG4gICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgIGlmIChCZShlLCB0ICsgNCkgIT09IDQ1KSBicmVhaztcbiAgICAgICAgLy8gKGYpaWxsLWF2YWlsYWJsZSwgKGYpaXQtY29udGVudFxuICAgICAgICBjYXNlIDEwMjpcbiAgICAgICAgICByZXR1cm4gZGUoZSwgLyguKzopKC4rKS0oW15dKykvLCBcIiQxXCIgKyBmZSArIFwiJDItJDMkMVwiICsgZG4gKyAoQmUoZSwgdCArIDMpID09IDEwOCA/IFwiJDNcIiA6IFwiJDItJDNcIikpICsgZTtcbiAgICAgICAgLy8gKHMpdHJldGNoXG4gICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgIHJldHVybiB+b28oZSwgXCJzdHJldGNoXCIpID8gUmEoZGUoZSwgXCJzdHJldGNoXCIsIFwiZmlsbC1hdmFpbGFibGVcIiksIHQpICsgZSA6IGU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAvLyBwb3NpdGlvbjogc3RpY2t5XG4gICAgY2FzZSA0OTQ5OlxuICAgICAgaWYgKEJlKGUsIHQgKyAxKSAhPT0gMTE1KSBicmVhaztcbiAgICAvLyBkaXNwbGF5OiAoZmxleHxpbmxpbmUtZmxleClcbiAgICBjYXNlIDY0NDQ6XG4gICAgICBzd2l0Y2ggKEJlKGUsIG10KGUpIC0gMyAtICh+b28oZSwgXCIhaW1wb3J0YW50XCIpICYmIDEwKSkpIHtcbiAgICAgICAgLy8gc3RpYyhrKXlcbiAgICAgICAgY2FzZSAxMDc6XG4gICAgICAgICAgcmV0dXJuIGRlKGUsIFwiOlwiLCBcIjpcIiArIGZlKSArIGU7XG4gICAgICAgIC8vIChpbmxpbmUtKT9mbChlKXhcbiAgICAgICAgY2FzZSAxMDE6XG4gICAgICAgICAgcmV0dXJuIGRlKGUsIC8oLis6KShbXjshXSspKDt8IS4rKT8vLCBcIiQxXCIgKyBmZSArIChCZShlLCAxNCkgPT09IDQ1ID8gXCJpbmxpbmUtXCIgOiBcIlwiKSArIFwiYm94JDMkMVwiICsgZmUgKyBcIiQyJDMkMVwiICsgWWUgKyBcIiQyYm94JDNcIikgKyBlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgLy8gd3JpdGluZy1tb2RlXG4gICAgY2FzZSA1OTM2OlxuICAgICAgc3dpdGNoIChCZShlLCB0ICsgMTEpKSB7XG4gICAgICAgIC8vIHZlcnRpY2FsLWwocilcbiAgICAgICAgY2FzZSAxMTQ6XG4gICAgICAgICAgcmV0dXJuIGZlICsgZSArIFllICsgZGUoZSwgL1tzdmhdXFx3Ky1bdGJscl17Mn0vLCBcInRiXCIpICsgZTtcbiAgICAgICAgLy8gdmVydGljYWwtcihsKVxuICAgICAgICBjYXNlIDEwODpcbiAgICAgICAgICByZXR1cm4gZmUgKyBlICsgWWUgKyBkZShlLCAvW3N2aF1cXHcrLVt0YmxyXXsyfS8sIFwidGItcmxcIikgKyBlO1xuICAgICAgICAvLyBob3Jpem9udGFsKC0pdGJcbiAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICByZXR1cm4gZmUgKyBlICsgWWUgKyBkZShlLCAvW3N2aF1cXHcrLVt0YmxyXXsyfS8sIFwibHJcIikgKyBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZlICsgZSArIFllICsgZSArIGU7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG52YXIgQWMgPSBmdW5jdGlvbih0LCByLCBuLCBvKSB7XG4gIGlmICh0Lmxlbmd0aCA+IC0xICYmICF0LnJldHVybikgc3dpdGNoICh0LnR5cGUpIHtcbiAgICBjYXNlIEVvOlxuICAgICAgdC5yZXR1cm4gPSBSYSh0LnZhbHVlLCB0Lmxlbmd0aCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNhOlxuICAgICAgcmV0dXJuIFh0KFtkcih0LCB7XG4gICAgICAgIHZhbHVlOiBkZSh0LnZhbHVlLCBcIkBcIiwgXCJAXCIgKyBmZSlcbiAgICAgIH0pXSwgbyk7XG4gICAgY2FzZSBTbzpcbiAgICAgIGlmICh0Lmxlbmd0aCkgcmV0dXJuIG1jKHQucHJvcHMsIGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgc3dpdGNoIChwYyhpLCAvKDo6cGxhY1xcdyt8OnJlYWQtXFx3KykvKSkge1xuICAgICAgICAgIC8vIDpyZWFkLShvbmx5fHdyaXRlKVxuICAgICAgICAgIGNhc2UgXCI6cmVhZC1vbmx5XCI6XG4gICAgICAgICAgY2FzZSBcIjpyZWFkLXdyaXRlXCI6XG4gICAgICAgICAgICByZXR1cm4gWHQoW2RyKHQsIHtcbiAgICAgICAgICAgICAgcHJvcHM6IFtkZShpLCAvOihyZWFkLVxcdyspLywgXCI6XCIgKyBkbiArIFwiJDFcIildXG4gICAgICAgICAgICB9KV0sIG8pO1xuICAgICAgICAgIC8vIDpwbGFjZWhvbGRlclxuICAgICAgICAgIGNhc2UgXCI6OnBsYWNlaG9sZGVyXCI6XG4gICAgICAgICAgICByZXR1cm4gWHQoW2RyKHQsIHtcbiAgICAgICAgICAgICAgcHJvcHM6IFtkZShpLCAvOihwbGFjXFx3KykvLCBcIjpcIiArIGZlICsgXCJpbnB1dC0kMVwiKV1cbiAgICAgICAgICAgIH0pLCBkcih0LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBbZGUoaSwgLzoocGxhY1xcdyspLywgXCI6XCIgKyBkbiArIFwiJDFcIildXG4gICAgICAgICAgICB9KSwgZHIodCwge1xuICAgICAgICAgICAgICBwcm9wczogW2RlKGksIC86KHBsYWNcXHcrKS8sIFllICsgXCJpbnB1dC0kMVwiKV1cbiAgICAgICAgICAgIH0pXSwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9KTtcbiAgfVxufSwgTmMgPSBbQWNdLCBNYyA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIHIgPSB0LmtleTtcbiAgaWYgKHIgPT09IFwiY3NzXCIpIHtcbiAgICB2YXIgbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVtkYXRhLWVtb3Rpb25dOm5vdChbZGF0YS1zXSlcIik7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChuLCBmdW5jdGlvbihmKSB7XG4gICAgICB2YXIgUyA9IGYuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbW90aW9uXCIpO1xuICAgICAgUy5pbmRleE9mKFwiIFwiKSAhPT0gLTEgJiYgKGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZiksIGYuc2V0QXR0cmlidXRlKFwiZGF0YS1zXCIsIFwiXCIpKTtcbiAgICB9KTtcbiAgfVxuICB2YXIgbyA9IHQuc3R5bGlzUGx1Z2lucyB8fCBOYywgaSA9IHt9LCBzLCBjID0gW107XG4gIHMgPSB0LmNvbnRhaW5lciB8fCBkb2N1bWVudC5oZWFkLCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKFxuICAgIC8vIHRoaXMgbWVhbnMgd2Ugd2lsbCBpZ25vcmUgZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhIHNwYWNlIGluIHRoZW0gd2hpY2hcbiAgICAvLyBtZWFucyB0aGF0IHRoZSBzdHlsZSBlbGVtZW50cyB3ZSdyZSBsb29raW5nIGF0IGFyZSBvbmx5IEVtb3Rpb24gMTEgc2VydmVyLXJlbmRlcmVkIHN0eWxlIGVsZW1lbnRzXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZGF0YS1lbW90aW9uXj1cIicgKyByICsgJyBcIl0nKSxcbiAgICBmdW5jdGlvbihmKSB7XG4gICAgICBmb3IgKHZhciBTID0gZi5nZXRBdHRyaWJ1dGUoXCJkYXRhLWVtb3Rpb25cIikuc3BsaXQoXCIgXCIpLCBFID0gMTsgRSA8IFMubGVuZ3RoOyBFKyspXG4gICAgICAgIGlbU1tFXV0gPSAhMDtcbiAgICAgIGMucHVzaChmKTtcbiAgICB9XG4gICk7XG4gIHZhciBsLCB1ID0gW1BjLCBrY107XG4gIHtcbiAgICB2YXIgcCwgbSA9IFtDYywgd2MoZnVuY3Rpb24oZikge1xuICAgICAgcC5pbnNlcnQoZik7XG4gICAgfSldLCBnID0gVGModS5jb25jYXQobywgbSkpLCB4ID0gZnVuY3Rpb24oUykge1xuICAgICAgcmV0dXJuIFh0KFNjKFMpLCBnKTtcbiAgICB9O1xuICAgIGwgPSBmdW5jdGlvbihTLCBFLCBQLCBUKSB7XG4gICAgICBwID0gUCwgeChTID8gUyArIFwie1wiICsgRS5zdHlsZXMgKyBcIn1cIiA6IEUuc3R5bGVzKSwgVCAmJiAoeS5pbnNlcnRlZFtFLm5hbWVdID0gITApO1xuICAgIH07XG4gIH1cbiAgdmFyIHkgPSB7XG4gICAga2V5OiByLFxuICAgIHNoZWV0OiBuZXcgc2Moe1xuICAgICAga2V5OiByLFxuICAgICAgY29udGFpbmVyOiBzLFxuICAgICAgbm9uY2U6IHQubm9uY2UsXG4gICAgICBzcGVlZHk6IHQuc3BlZWR5LFxuICAgICAgcHJlcGVuZDogdC5wcmVwZW5kLFxuICAgICAgaW5zZXJ0aW9uUG9pbnQ6IHQuaW5zZXJ0aW9uUG9pbnRcbiAgICB9KSxcbiAgICBub25jZTogdC5ub25jZSxcbiAgICBpbnNlcnRlZDogaSxcbiAgICByZWdpc3RlcmVkOiB7fSxcbiAgICBpbnNlcnQ6IGxcbiAgfTtcbiAgcmV0dXJuIHkuc2hlZXQuaHlkcmF0ZShjKSwgeTtcbn0sIEhyID0geyBleHBvcnRzOiB7fSB9LCBwZSA9IHt9O1xuLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgZGk7XG5mdW5jdGlvbiBJYygpIHtcbiAgaWYgKGRpKSByZXR1cm4gcGU7XG4gIGRpID0gMTtcbiAgdmFyIGUgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yLCB0ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpIDogNjAxMDMsIHIgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSA6IDYwMTA2LCBuID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSA6IDYwMTA3LCBvID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSA6IDYwMTA4LCBpID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSA6IDYwMTE0LCBzID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSA6IDYwMTA5LCBjID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpIDogNjAxMTAsIGwgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIikgOiA2MDExMSwgdSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuY29uY3VycmVudF9tb2RlXCIpIDogNjAxMTEsIHAgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpIDogNjAxMTIsIG0gPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpIDogNjAxMTMsIGcgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIikgOiA2MDEyMCwgeCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSA6IDYwMTE1LCB5ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpIDogNjAxMTYsIGYgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmJsb2NrXCIpIDogNjAxMjEsIFMgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmZ1bmRhbWVudGFsXCIpIDogNjAxMTcsIEUgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnJlc3BvbmRlclwiKSA6IDYwMTE4LCBQID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKSA6IDYwMTE5O1xuICBmdW5jdGlvbiBUKGgpIHtcbiAgICBpZiAodHlwZW9mIGggPT0gXCJvYmplY3RcIiAmJiBoICE9PSBudWxsKSB7XG4gICAgICB2YXIgdyA9IGguJCR0eXBlb2Y7XG4gICAgICBzd2l0Y2ggKHcpIHtcbiAgICAgICAgY2FzZSB0OlxuICAgICAgICAgIHN3aXRjaCAoaCA9IGgudHlwZSwgaCkge1xuICAgICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgY2FzZSBuOlxuICAgICAgICAgICAgY2FzZSBpOlxuICAgICAgICAgICAgY2FzZSBvOlxuICAgICAgICAgICAgY2FzZSBtOlxuICAgICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHN3aXRjaCAoaCA9IGggJiYgaC4kJHR5cGVvZiwgaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgYzpcbiAgICAgICAgICAgICAgICBjYXNlIHA6XG4gICAgICAgICAgICAgICAgY2FzZSB5OlxuICAgICAgICAgICAgICAgIGNhc2UgeDpcbiAgICAgICAgICAgICAgICBjYXNlIHM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgcjpcbiAgICAgICAgICByZXR1cm4gdztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IHU7XG4gIH1cbiAgcmV0dXJuIHBlLkFzeW5jTW9kZSA9IGwsIHBlLkNvbmN1cnJlbnRNb2RlID0gdSwgcGUuQ29udGV4dENvbnN1bWVyID0gYywgcGUuQ29udGV4dFByb3ZpZGVyID0gcywgcGUuRWxlbWVudCA9IHQsIHBlLkZvcndhcmRSZWYgPSBwLCBwZS5GcmFnbWVudCA9IG4sIHBlLkxhenkgPSB5LCBwZS5NZW1vID0geCwgcGUuUG9ydGFsID0gciwgcGUuUHJvZmlsZXIgPSBpLCBwZS5TdHJpY3RNb2RlID0gbywgcGUuU3VzcGVuc2UgPSBtLCBwZS5pc0FzeW5jTW9kZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gYihoKSB8fCBUKGgpID09PSBsO1xuICB9LCBwZS5pc0NvbmN1cnJlbnRNb2RlID0gYiwgcGUuaXNDb250ZXh0Q29uc3VtZXIgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IGM7XG4gIH0sIHBlLmlzQ29udGV4dFByb3ZpZGVyID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSBzO1xuICB9LCBwZS5pc0VsZW1lbnQgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBoID09IFwib2JqZWN0XCIgJiYgaCAhPT0gbnVsbCAmJiBoLiQkdHlwZW9mID09PSB0O1xuICB9LCBwZS5pc0ZvcndhcmRSZWYgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IHA7XG4gIH0sIHBlLmlzRnJhZ21lbnQgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IG47XG4gIH0sIHBlLmlzTGF6eSA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0geTtcbiAgfSwgcGUuaXNNZW1vID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSB4O1xuICB9LCBwZS5pc1BvcnRhbCA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0gcjtcbiAgfSwgcGUuaXNQcm9maWxlciA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0gaTtcbiAgfSwgcGUuaXNTdHJpY3RNb2RlID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSBvO1xuICB9LCBwZS5pc1N1c3BlbnNlID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSBtO1xuICB9LCBwZS5pc1ZhbGlkRWxlbWVudFR5cGUgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBoID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGggPT0gXCJmdW5jdGlvblwiIHx8IGggPT09IG4gfHwgaCA9PT0gdSB8fCBoID09PSBpIHx8IGggPT09IG8gfHwgaCA9PT0gbSB8fCBoID09PSBnIHx8IHR5cGVvZiBoID09IFwib2JqZWN0XCIgJiYgaCAhPT0gbnVsbCAmJiAoaC4kJHR5cGVvZiA9PT0geSB8fCBoLiQkdHlwZW9mID09PSB4IHx8IGguJCR0eXBlb2YgPT09IHMgfHwgaC4kJHR5cGVvZiA9PT0gYyB8fCBoLiQkdHlwZW9mID09PSBwIHx8IGguJCR0eXBlb2YgPT09IFMgfHwgaC4kJHR5cGVvZiA9PT0gRSB8fCBoLiQkdHlwZW9mID09PSBQIHx8IGguJCR0eXBlb2YgPT09IGYpO1xuICB9LCBwZS50eXBlT2YgPSBULCBwZTtcbn1cbnZhciBtZSA9IHt9O1xuLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgcGk7XG5mdW5jdGlvbiBfYygpIHtcbiAgcmV0dXJuIHBpIHx8IChwaSA9IDEsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5mb3IsIHQgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIikgOiA2MDEwMywgciA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpIDogNjAxMDYsIG4gPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpIDogNjAxMDcsIG8gPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpIDogNjAxMDgsIGkgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpIDogNjAxMTQsIHMgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpIDogNjAxMDksIGMgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIikgOiA2MDExMCwgbCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuYXN5bmNfbW9kZVwiKSA6IDYwMTExLCB1ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIikgOiA2MDExMSwgcCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIikgOiA2MDExMiwgbSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIikgOiA2MDExMywgZyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSA6IDYwMTIwLCB4ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpIDogNjAxMTUsIHkgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIikgOiA2MDExNiwgZiA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuYmxvY2tcIikgOiA2MDEyMSwgUyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZnVuZGFtZW50YWxcIikgOiA2MDExNywgRSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucmVzcG9uZGVyXCIpIDogNjAxMTgsIFAgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpIDogNjAxMTk7XG4gICAgZnVuY3Rpb24gVChPKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIE8gPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgTyA9PSBcImZ1bmN0aW9uXCIgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgICAgIE8gPT09IG4gfHwgTyA9PT0gdSB8fCBPID09PSBpIHx8IE8gPT09IG8gfHwgTyA9PT0gbSB8fCBPID09PSBnIHx8IHR5cGVvZiBPID09IFwib2JqZWN0XCIgJiYgTyAhPT0gbnVsbCAmJiAoTy4kJHR5cGVvZiA9PT0geSB8fCBPLiQkdHlwZW9mID09PSB4IHx8IE8uJCR0eXBlb2YgPT09IHMgfHwgTy4kJHR5cGVvZiA9PT0gYyB8fCBPLiQkdHlwZW9mID09PSBwIHx8IE8uJCR0eXBlb2YgPT09IFMgfHwgTy4kJHR5cGVvZiA9PT0gRSB8fCBPLiQkdHlwZW9mID09PSBQIHx8IE8uJCR0eXBlb2YgPT09IGYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiKE8pIHtcbiAgICAgIGlmICh0eXBlb2YgTyA9PSBcIm9iamVjdFwiICYmIE8gIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHllID0gTy4kJHR5cGVvZjtcbiAgICAgICAgc3dpdGNoICh5ZSkge1xuICAgICAgICAgIGNhc2UgdDpcbiAgICAgICAgICAgIHZhciBFZSA9IE8udHlwZTtcbiAgICAgICAgICAgIHN3aXRjaCAoRWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgICAgIGNhc2UgbjpcbiAgICAgICAgICAgICAgY2FzZSBpOlxuICAgICAgICAgICAgICBjYXNlIG86XG4gICAgICAgICAgICAgIGNhc2UgbTpcbiAgICAgICAgICAgICAgICByZXR1cm4gRWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFyIE1lID0gRWUgJiYgRWUuJCR0eXBlb2Y7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChNZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBjOlxuICAgICAgICAgICAgICAgICAgY2FzZSBwOlxuICAgICAgICAgICAgICAgICAgY2FzZSB5OlxuICAgICAgICAgICAgICAgICAgY2FzZSB4OlxuICAgICAgICAgICAgICAgICAgY2FzZSBzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWU7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgcjpcbiAgICAgICAgICAgIHJldHVybiB5ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaCA9IGwsIHcgPSB1LCBrID0gYywgTCA9IHMsIEIgPSB0LCBkID0gcCwgQSA9IG4sIEQgPSB5LCBqID0geCwgVyA9IHIsIHogPSBpLCBVID0gbywgViA9IG0sIHRlID0gITE7XG4gICAgZnVuY3Rpb24gRihPKSB7XG4gICAgICByZXR1cm4gdGUgfHwgKHRlID0gITAsIGNvbnNvbGUud2FybihcIlRoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlIFJlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuXCIpKSwgUihPKSB8fCBiKE8pID09PSBsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSB1O1xuICAgIH1cbiAgICBmdW5jdGlvbiBJKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBKKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSBzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBRKE8pIHtcbiAgICAgIHJldHVybiB0eXBlb2YgTyA9PSBcIm9iamVjdFwiICYmIE8gIT09IG51bGwgJiYgTy4kJHR5cGVvZiA9PT0gdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gSChPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gWChPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gXyhPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0geTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcShPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0geDtcbiAgICB9XG4gICAgZnVuY3Rpb24gRyhPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmUoTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFooTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IG87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFlKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSBtO1xuICAgIH1cbiAgICBtZS5Bc3luY01vZGUgPSBoLCBtZS5Db25jdXJyZW50TW9kZSA9IHcsIG1lLkNvbnRleHRDb25zdW1lciA9IGssIG1lLkNvbnRleHRQcm92aWRlciA9IEwsIG1lLkVsZW1lbnQgPSBCLCBtZS5Gb3J3YXJkUmVmID0gZCwgbWUuRnJhZ21lbnQgPSBBLCBtZS5MYXp5ID0gRCwgbWUuTWVtbyA9IGosIG1lLlBvcnRhbCA9IFcsIG1lLlByb2ZpbGVyID0geiwgbWUuU3RyaWN0TW9kZSA9IFUsIG1lLlN1c3BlbnNlID0gViwgbWUuaXNBc3luY01vZGUgPSBGLCBtZS5pc0NvbmN1cnJlbnRNb2RlID0gUiwgbWUuaXNDb250ZXh0Q29uc3VtZXIgPSBJLCBtZS5pc0NvbnRleHRQcm92aWRlciA9IEosIG1lLmlzRWxlbWVudCA9IFEsIG1lLmlzRm9yd2FyZFJlZiA9IEgsIG1lLmlzRnJhZ21lbnQgPSBYLCBtZS5pc0xhenkgPSBfLCBtZS5pc01lbW8gPSBxLCBtZS5pc1BvcnRhbCA9IEcsIG1lLmlzUHJvZmlsZXIgPSByZSwgbWUuaXNTdHJpY3RNb2RlID0gWiwgbWUuaXNTdXNwZW5zZSA9IGFlLCBtZS5pc1ZhbGlkRWxlbWVudFR5cGUgPSBULCBtZS50eXBlT2YgPSBiO1xuICB9KCkpLCBtZTtcbn1cbnZhciBtaTtcbmZ1bmN0aW9uIGpjKCkge1xuICByZXR1cm4gbWkgfHwgKG1pID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gSHIuZXhwb3J0cyA9IEljKCkgOiBIci5leHBvcnRzID0gX2MoKSksIEhyLmV4cG9ydHM7XG59XG52YXIgWW4sIGhpO1xuZnVuY3Rpb24gRGMoKSB7XG4gIGlmIChoaSkgcmV0dXJuIFluO1xuICBoaSA9IDE7XG4gIHZhciBlID0gamMoKSwgdCA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogITAsXG4gICAgY29udGV4dFR5cGU6ICEwLFxuICAgIGNvbnRleHRUeXBlczogITAsXG4gICAgZGVmYXVsdFByb3BzOiAhMCxcbiAgICBkaXNwbGF5TmFtZTogITAsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiAhMCxcbiAgICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6ICEwLFxuICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogITAsXG4gICAgbWl4aW5zOiAhMCxcbiAgICBwcm9wVHlwZXM6ICEwLFxuICAgIHR5cGU6ICEwXG4gIH0sIHIgPSB7XG4gICAgbmFtZTogITAsXG4gICAgbGVuZ3RoOiAhMCxcbiAgICBwcm90b3R5cGU6ICEwLFxuICAgIGNhbGxlcjogITAsXG4gICAgY2FsbGVlOiAhMCxcbiAgICBhcmd1bWVudHM6ICEwLFxuICAgIGFyaXR5OiAhMFxuICB9LCBuID0ge1xuICAgICQkdHlwZW9mOiAhMCxcbiAgICByZW5kZXI6ICEwLFxuICAgIGRlZmF1bHRQcm9wczogITAsXG4gICAgZGlzcGxheU5hbWU6ICEwLFxuICAgIHByb3BUeXBlczogITBcbiAgfSwgbyA9IHtcbiAgICAkJHR5cGVvZjogITAsXG4gICAgY29tcGFyZTogITAsXG4gICAgZGVmYXVsdFByb3BzOiAhMCxcbiAgICBkaXNwbGF5TmFtZTogITAsXG4gICAgcHJvcFR5cGVzOiAhMCxcbiAgICB0eXBlOiAhMFxuICB9LCBpID0ge307XG4gIGlbZS5Gb3J3YXJkUmVmXSA9IG4sIGlbZS5NZW1vXSA9IG87XG4gIGZ1bmN0aW9uIHMoeSkge1xuICAgIHJldHVybiBlLmlzTWVtbyh5KSA/IG8gOiBpW3kuJCR0eXBlb2ZdIHx8IHQ7XG4gIH1cbiAgdmFyIGMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGwgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcywgdSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBtID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBnID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgZnVuY3Rpb24geCh5LCBmLCBTKSB7XG4gICAgaWYgKHR5cGVvZiBmICE9IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChnKSB7XG4gICAgICAgIHZhciBFID0gbShmKTtcbiAgICAgICAgRSAmJiBFICE9PSBnICYmIHgoeSwgRSwgUyk7XG4gICAgICB9XG4gICAgICB2YXIgUCA9IGwoZik7XG4gICAgICB1ICYmIChQID0gUC5jb25jYXQodShmKSkpO1xuICAgICAgZm9yICh2YXIgVCA9IHMoeSksIGIgPSBzKGYpLCBoID0gMDsgaCA8IFAubGVuZ3RoOyArK2gpIHtcbiAgICAgICAgdmFyIHcgPSBQW2hdO1xuICAgICAgICBpZiAoIXJbd10gJiYgIShTICYmIFNbd10pICYmICEoYiAmJiBiW3ddKSAmJiAhKFQgJiYgVFt3XSkpIHtcbiAgICAgICAgICB2YXIgayA9IHAoZiwgdyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGMoeSwgdywgayk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB5O1xuICB9XG4gIHJldHVybiBZbiA9IHgsIFluO1xufVxuRGMoKTtcbnZhciBMYyA9ICEwO1xuZnVuY3Rpb24gJGEoZSwgdCwgcikge1xuICB2YXIgbiA9IFwiXCI7XG4gIHJldHVybiByLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICBlW29dICE9PSB2b2lkIDAgPyB0LnB1c2goZVtvXSArIFwiO1wiKSA6IG8gJiYgKG4gKz0gbyArIFwiIFwiKTtcbiAgfSksIG47XG59XG52YXIgVG8gPSBmdW5jdGlvbih0LCByLCBuKSB7XG4gIHZhciBvID0gdC5rZXkgKyBcIi1cIiArIHIubmFtZTtcbiAgLy8gd2Ugb25seSBuZWVkIHRvIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSByZWdpc3RlcmVkIGNhY2hlIGlmIHRoZVxuICAvLyBjbGFzcyBuYW1lIGNvdWxkIGJlIHVzZWQgZnVydGhlciBkb3duXG4gIC8vIHRoZSB0cmVlIGJ1dCBpZiBpdCdzIGEgc3RyaW5nIHRhZywgd2Uga25vdyBpdCB3b24ndFxuICAvLyBzbyB3ZSBkb24ndCBoYXZlIHRvIGFkZCBpdCB0byByZWdpc3RlcmVkIGNhY2hlLlxuICAvLyB0aGlzIGltcHJvdmVzIG1lbW9yeSB1c2FnZSBzaW5jZSB3ZSBjYW4gYXZvaWQgc3RvcmluZyB0aGUgd2hvbGUgc3R5bGUgc3RyaW5nXG4gIChuID09PSAhMSB8fCAvLyB3ZSBuZWVkIHRvIGFsd2F5cyBzdG9yZSBpdCBpZiB3ZSdyZSBpbiBjb21wYXQgbW9kZSBhbmRcbiAgLy8gaW4gbm9kZSBzaW5jZSBlbW90aW9uLXNlcnZlciByZWxpZXMgb24gd2hldGhlciBhIHN0eWxlIGlzIGluXG4gIC8vIHRoZSByZWdpc3RlcmVkIGNhY2hlIHRvIGtub3cgd2hldGhlciBhIHN0eWxlIGlzIGdsb2JhbCBvciBub3RcbiAgLy8gYWxzbywgbm90ZSB0aGF0IHRoaXMgY2hlY2sgd2lsbCBiZSBkZWFkIGNvZGUgZWxpbWluYXRlZCBpbiB0aGUgYnJvd3NlclxuICBMYyA9PT0gITEpICYmIHQucmVnaXN0ZXJlZFtvXSA9PT0gdm9pZCAwICYmICh0LnJlZ2lzdGVyZWRbb10gPSByLnN0eWxlcyk7XG59LCB3byA9IGZ1bmN0aW9uKHQsIHIsIG4pIHtcbiAgVG8odCwgciwgbik7XG4gIHZhciBvID0gdC5rZXkgKyBcIi1cIiArIHIubmFtZTtcbiAgaWYgKHQuaW5zZXJ0ZWRbci5uYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgdmFyIGkgPSByO1xuICAgIGRvXG4gICAgICB0Lmluc2VydChyID09PSBpID8gXCIuXCIgKyBvIDogXCJcIiwgaSwgdC5zaGVldCwgITApLCBpID0gaS5uZXh0O1xuICAgIHdoaWxlIChpICE9PSB2b2lkIDApO1xuICB9XG59O1xuZnVuY3Rpb24gQmMoZSkge1xuICBmb3IgKHZhciB0ID0gMCwgciwgbiA9IDAsIG8gPSBlLmxlbmd0aDsgbyA+PSA0OyArK24sIG8gLT0gNClcbiAgICByID0gZS5jaGFyQ29kZUF0KG4pICYgMjU1IHwgKGUuY2hhckNvZGVBdCgrK24pICYgMjU1KSA8PCA4IHwgKGUuY2hhckNvZGVBdCgrK24pICYgMjU1KSA8PCAxNiB8IChlLmNoYXJDb2RlQXQoKytuKSAmIDI1NSkgPDwgMjQsIHIgPSAvKiBNYXRoLmltdWwoaywgbSk6ICovXG4gICAgKHIgJiA2NTUzNSkgKiAxNTQwNDgzNDc3ICsgKChyID4+PiAxNikgKiA1OTc5NyA8PCAxNiksIHIgXj0gLyogayA+Pj4gcjogKi9cbiAgICByID4+PiAyNCwgdCA9IC8qIE1hdGguaW11bChrLCBtKTogKi9cbiAgICAociAmIDY1NTM1KSAqIDE1NDA0ODM0NzcgKyAoKHIgPj4+IDE2KSAqIDU5Nzk3IDw8IDE2KSBeIC8qIE1hdGguaW11bChoLCBtKTogKi9cbiAgICAodCAmIDY1NTM1KSAqIDE1NDA0ODM0NzcgKyAoKHQgPj4+IDE2KSAqIDU5Nzk3IDw8IDE2KTtcbiAgc3dpdGNoIChvKSB7XG4gICAgY2FzZSAzOlxuICAgICAgdCBePSAoZS5jaGFyQ29kZUF0KG4gKyAyKSAmIDI1NSkgPDwgMTY7XG4gICAgY2FzZSAyOlxuICAgICAgdCBePSAoZS5jaGFyQ29kZUF0KG4gKyAxKSAmIDI1NSkgPDwgODtcbiAgICBjYXNlIDE6XG4gICAgICB0IF49IGUuY2hhckNvZGVBdChuKSAmIDI1NSwgdCA9IC8qIE1hdGguaW11bChoLCBtKTogKi9cbiAgICAgICh0ICYgNjU1MzUpICogMTU0MDQ4MzQ3NyArICgodCA+Pj4gMTYpICogNTk3OTcgPDwgMTYpO1xuICB9XG4gIHJldHVybiB0IF49IHQgPj4+IDEzLCB0ID0gLyogTWF0aC5pbXVsKGgsIG0pOiAqL1xuICAodCAmIDY1NTM1KSAqIDE1NDA0ODM0NzcgKyAoKHQgPj4+IDE2KSAqIDU5Nzk3IDw8IDE2KSwgKCh0IF4gdCA+Pj4gMTUpID4+PiAwKS50b1N0cmluZygzNik7XG59XG52YXIgVmMgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAxLFxuICBhc3BlY3RSYXRpbzogMSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IDEsXG4gIGJvcmRlckltYWdlU2xpY2U6IDEsXG4gIGJvcmRlckltYWdlV2lkdGg6IDEsXG4gIGJveEZsZXg6IDEsXG4gIGJveEZsZXhHcm91cDogMSxcbiAgYm94T3JkaW5hbEdyb3VwOiAxLFxuICBjb2x1bW5Db3VudDogMSxcbiAgY29sdW1uczogMSxcbiAgZmxleDogMSxcbiAgZmxleEdyb3c6IDEsXG4gIGZsZXhQb3NpdGl2ZTogMSxcbiAgZmxleFNocmluazogMSxcbiAgZmxleE5lZ2F0aXZlOiAxLFxuICBmbGV4T3JkZXI6IDEsXG4gIGdyaWRSb3c6IDEsXG4gIGdyaWRSb3dFbmQ6IDEsXG4gIGdyaWRSb3dTcGFuOiAxLFxuICBncmlkUm93U3RhcnQ6IDEsXG4gIGdyaWRDb2x1bW46IDEsXG4gIGdyaWRDb2x1bW5FbmQ6IDEsXG4gIGdyaWRDb2x1bW5TcGFuOiAxLFxuICBncmlkQ29sdW1uU3RhcnQ6IDEsXG4gIG1zR3JpZFJvdzogMSxcbiAgbXNHcmlkUm93U3BhbjogMSxcbiAgbXNHcmlkQ29sdW1uOiAxLFxuICBtc0dyaWRDb2x1bW5TcGFuOiAxLFxuICBmb250V2VpZ2h0OiAxLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBvcGFjaXR5OiAxLFxuICBvcmRlcjogMSxcbiAgb3JwaGFuczogMSxcbiAgc2NhbGU6IDEsXG4gIHRhYlNpemU6IDEsXG4gIHdpZG93czogMSxcbiAgekluZGV4OiAxLFxuICB6b29tOiAxLFxuICBXZWJraXRMaW5lQ2xhbXA6IDEsXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IDEsXG4gIGZsb29kT3BhY2l0eTogMSxcbiAgc3RvcE9wYWNpdHk6IDEsXG4gIHN0cm9rZURhc2hhcnJheTogMSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogMSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogMSxcbiAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn0sIEZjID0gL1tBLVpdfF5tcy9nLCB6YyA9IC9fRU1PXyhbXl9dKz8pXyhbXl0qPylfRU1PXy9nLCBQYSA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQuY2hhckNvZGVBdCgxKSA9PT0gNDU7XG59LCBnaSA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQgIT0gbnVsbCAmJiB0eXBlb2YgdCAhPSBcImJvb2xlYW5cIjtcbn0sIEhuID0gLyogQF9fUFVSRV9fICovIE9hKGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIFBhKGUpID8gZSA6IGUucmVwbGFjZShGYywgXCItJCZcIikudG9Mb3dlckNhc2UoKTtcbn0pLCB5aSA9IGZ1bmN0aW9uKHQsIHIpIHtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcImFuaW1hdGlvblwiOlxuICAgIGNhc2UgXCJhbmltYXRpb25OYW1lXCI6XG4gICAgICBpZiAodHlwZW9mIHIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHIucmVwbGFjZSh6YywgZnVuY3Rpb24obiwgbywgaSkge1xuICAgICAgICAgIHJldHVybiBodCA9IHtcbiAgICAgICAgICAgIG5hbWU6IG8sXG4gICAgICAgICAgICBzdHlsZXM6IGksXG4gICAgICAgICAgICBuZXh0OiBodFxuICAgICAgICAgIH0sIG87XG4gICAgICAgIH0pO1xuICB9XG4gIHJldHVybiBWY1t0XSAhPT0gMSAmJiAhUGEodCkgJiYgdHlwZW9mIHIgPT0gXCJudW1iZXJcIiAmJiByICE9PSAwID8gciArIFwicHhcIiA6IHI7XG59O1xuZnVuY3Rpb24gd3IoZSwgdCwgcikge1xuICBpZiAociA9PSBudWxsKVxuICAgIHJldHVybiBcIlwiO1xuICB2YXIgbiA9IHI7XG4gIGlmIChuLl9fZW1vdGlvbl9zdHlsZXMgIT09IHZvaWQgMClcbiAgICByZXR1cm4gbjtcbiAgc3dpdGNoICh0eXBlb2Ygcikge1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgIHZhciBvID0gcjtcbiAgICAgIGlmIChvLmFuaW0gPT09IDEpXG4gICAgICAgIHJldHVybiBodCA9IHtcbiAgICAgICAgICBuYW1lOiBvLm5hbWUsXG4gICAgICAgICAgc3R5bGVzOiBvLnN0eWxlcyxcbiAgICAgICAgICBuZXh0OiBodFxuICAgICAgICB9LCBvLm5hbWU7XG4gICAgICB2YXIgaSA9IHI7XG4gICAgICBpZiAoaS5zdHlsZXMgIT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgcyA9IGkubmV4dDtcbiAgICAgICAgaWYgKHMgIT09IHZvaWQgMClcbiAgICAgICAgICBmb3IgKDsgcyAhPT0gdm9pZCAwOyApXG4gICAgICAgICAgICBodCA9IHtcbiAgICAgICAgICAgICAgbmFtZTogcy5uYW1lLFxuICAgICAgICAgICAgICBzdHlsZXM6IHMuc3R5bGVzLFxuICAgICAgICAgICAgICBuZXh0OiBodFxuICAgICAgICAgICAgfSwgcyA9IHMubmV4dDtcbiAgICAgICAgdmFyIGMgPSBpLnN0eWxlcyArIFwiO1wiO1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBXYyhlLCB0LCByKTtcbiAgICB9XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6IHtcbiAgICAgIGlmIChlICE9PSB2b2lkIDApIHtcbiAgICAgICAgdmFyIGwgPSBodCwgdSA9IHIoZSk7XG4gICAgICAgIHJldHVybiBodCA9IGwsIHdyKGUsIHQsIHUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBwID0gcjtcbiAgaWYgKHQgPT0gbnVsbClcbiAgICByZXR1cm4gcDtcbiAgdmFyIG0gPSB0W3BdO1xuICByZXR1cm4gbSAhPT0gdm9pZCAwID8gbSA6IHA7XG59XG5mdW5jdGlvbiBXYyhlLCB0LCByKSB7XG4gIHZhciBuID0gXCJcIjtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpXG4gICAgZm9yICh2YXIgbyA9IDA7IG8gPCByLmxlbmd0aDsgbysrKVxuICAgICAgbiArPSB3cihlLCB0LCByW29dKSArIFwiO1wiO1xuICBlbHNlXG4gICAgZm9yICh2YXIgaSBpbiByKSB7XG4gICAgICB2YXIgcyA9IHJbaV07XG4gICAgICBpZiAodHlwZW9mIHMgIT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgYyA9IHM7XG4gICAgICAgIHQgIT0gbnVsbCAmJiB0W2NdICE9PSB2b2lkIDAgPyBuICs9IGkgKyBcIntcIiArIHRbY10gKyBcIn1cIiA6IGdpKGMpICYmIChuICs9IEhuKGkpICsgXCI6XCIgKyB5aShpLCBjKSArIFwiO1wiKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzKSAmJiB0eXBlb2Ygc1swXSA9PSBcInN0cmluZ1wiICYmICh0ID09IG51bGwgfHwgdFtzWzBdXSA9PT0gdm9pZCAwKSlcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzLmxlbmd0aDsgbCsrKVxuICAgICAgICAgIGdpKHNbbF0pICYmIChuICs9IEhuKGkpICsgXCI6XCIgKyB5aShpLCBzW2xdKSArIFwiO1wiKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgdSA9IHdyKGUsIHQsIHMpO1xuICAgICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgICBjYXNlIFwiYW5pbWF0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcImFuaW1hdGlvbk5hbWVcIjoge1xuICAgICAgICAgICAgbiArPSBIbihpKSArIFwiOlwiICsgdSArIFwiO1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBuICs9IGkgKyBcIntcIiArIHUgKyBcIn1cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIG47XG59XG52YXIgYmkgPSAvbGFiZWw6XFxzKihbXlxcczt7XSspXFxzKig7fCQpL2csIGh0O1xuZnVuY3Rpb24gTnIoZSwgdCwgcikge1xuICBpZiAoZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGVbMF0gPT0gXCJvYmplY3RcIiAmJiBlWzBdICE9PSBudWxsICYmIGVbMF0uc3R5bGVzICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIGVbMF07XG4gIHZhciBuID0gITAsIG8gPSBcIlwiO1xuICBodCA9IHZvaWQgMDtcbiAgdmFyIGkgPSBlWzBdO1xuICBpZiAoaSA9PSBudWxsIHx8IGkucmF3ID09PSB2b2lkIDApXG4gICAgbiA9ICExLCBvICs9IHdyKHIsIHQsIGkpO1xuICBlbHNlIHtcbiAgICB2YXIgcyA9IGk7XG4gICAgbyArPSBzWzBdO1xuICB9XG4gIGZvciAodmFyIGMgPSAxOyBjIDwgZS5sZW5ndGg7IGMrKylcbiAgICBpZiAobyArPSB3cihyLCB0LCBlW2NdKSwgbikge1xuICAgICAgdmFyIGwgPSBpO1xuICAgICAgbyArPSBsW2NdO1xuICAgIH1cbiAgYmkubGFzdEluZGV4ID0gMDtcbiAgZm9yICh2YXIgdSA9IFwiXCIsIHA7IChwID0gYmkuZXhlYyhvKSkgIT09IG51bGw7IClcbiAgICB1ICs9IFwiLVwiICsgcFsxXTtcbiAgdmFyIG0gPSBCYyhvKSArIHU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbSxcbiAgICBzdHlsZXM6IG8sXG4gICAgbmV4dDogaHRcbiAgfTtcbn1cbnZhciBVYyA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQoKTtcbn0sIGthID0gQy51c2VJbnNlcnRpb25FZmZlY3QgPyBDLnVzZUluc2VydGlvbkVmZmVjdCA6ICExLCBBYSA9IGthIHx8IFVjLCB2aSA9IGthIHx8IEMudXNlTGF5b3V0RWZmZWN0LCBOYSA9IC8qIEBfX1BVUkVfXyAqLyBDLmNyZWF0ZUNvbnRleHQoXG4gIC8vIHdlJ3JlIGRvaW5nIHRoaXMgdG8gYXZvaWQgcHJlY29uc3RydWN0J3MgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIGluIHRoaXMgb25lIGNhc2VcbiAgLy8gYmVjYXVzZSB0aGlzIG1vZHVsZSBpcyBwcmltYXJpbHkgaW50ZW5kZWQgZm9yIHRoZSBicm93c2VyIGFuZCBub2RlXG4gIC8vIGJ1dCBpdCdzIGFsc28gcmVxdWlyZWQgaW4gcmVhY3QgbmF0aXZlIGFuZCBzaW1pbGFyIGVudmlyb25tZW50cyBzb21ldGltZXNcbiAgLy8gYW5kIHdlIGNvdWxkIGhhdmUgYSBzcGVjaWFsIGJ1aWxkIGp1c3QgZm9yIHRoYXRcbiAgLy8gYnV0IHRoaXMgaXMgbXVjaCBlYXNpZXIgYW5kIHRoZSBuYXRpdmUgcGFja2FnZXNcbiAgLy8gbWlnaHQgdXNlIGEgZGlmZmVyZW50IHRoZW1lIGNvbnRleHQgaW4gdGhlIGZ1dHVyZSBhbnl3YXlcbiAgdHlwZW9mIEhUTUxFbGVtZW50IDwgXCJ1XCIgPyAvKiBAX19QVVJFX18gKi8gTWMoe1xuICAgIGtleTogXCJjc3NcIlxuICB9KSA6IG51bGxcbik7XG5OYS5Qcm92aWRlcjtcbnZhciBPbyA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBYcyhmdW5jdGlvbihyLCBuKSB7XG4gICAgdmFyIG8gPSBKcyhOYSk7XG4gICAgcmV0dXJuIHQociwgbywgbik7XG4gIH0pO1xufSwgTXIgPSAvKiBAX19QVVJFX18gKi8gQy5jcmVhdGVDb250ZXh0KHt9KSwgUm8gPSB7fS5oYXNPd25Qcm9wZXJ0eSwgYW8gPSBcIl9fRU1PVElPTl9UWVBFX1BMRUFTRV9ET19OT1RfVVNFX19cIiwgWWMgPSBmdW5jdGlvbih0LCByKSB7XG4gIHZhciBuID0ge307XG4gIGZvciAodmFyIG8gaW4gcilcbiAgICBSby5jYWxsKHIsIG8pICYmIChuW29dID0gcltvXSk7XG4gIHJldHVybiBuW2FvXSA9IHQsIG47XG59LCBIYyA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIHIgPSB0LmNhY2hlLCBuID0gdC5zZXJpYWxpemVkLCBvID0gdC5pc1N0cmluZ1RhZztcbiAgcmV0dXJuIFRvKHIsIG4sIG8pLCBBYShmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gd28ociwgbiwgbyk7XG4gIH0pLCBudWxsO1xufSwgcWMgPSAvKiBAX19QVVJFX18gKi8gT28oZnVuY3Rpb24oZSwgdCwgcikge1xuICB2YXIgbiA9IGUuY3NzO1xuICB0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIHQucmVnaXN0ZXJlZFtuXSAhPT0gdm9pZCAwICYmIChuID0gdC5yZWdpc3RlcmVkW25dKTtcbiAgdmFyIG8gPSBlW2FvXSwgaSA9IFtuXSwgcyA9IFwiXCI7XG4gIHR5cGVvZiBlLmNsYXNzTmFtZSA9PSBcInN0cmluZ1wiID8gcyA9ICRhKHQucmVnaXN0ZXJlZCwgaSwgZS5jbGFzc05hbWUpIDogZS5jbGFzc05hbWUgIT0gbnVsbCAmJiAocyA9IGUuY2xhc3NOYW1lICsgXCIgXCIpO1xuICB2YXIgYyA9IE5yKGksIHZvaWQgMCwgQy51c2VDb250ZXh0KE1yKSk7XG4gIHMgKz0gdC5rZXkgKyBcIi1cIiArIGMubmFtZTtcbiAgdmFyIGwgPSB7fTtcbiAgZm9yICh2YXIgdSBpbiBlKVxuICAgIFJvLmNhbGwoZSwgdSkgJiYgdSAhPT0gXCJjc3NcIiAmJiB1ICE9PSBhbyAmJiAobFt1XSA9IGVbdV0pO1xuICByZXR1cm4gbC5jbGFzc05hbWUgPSBzLCByICYmIChsLnJlZiA9IHIpLCAvKiBAX19QVVJFX18gKi8gQy5jcmVhdGVFbGVtZW50KEMuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBDLmNyZWF0ZUVsZW1lbnQoSGMsIHtcbiAgICBjYWNoZTogdCxcbiAgICBzZXJpYWxpemVkOiBjLFxuICAgIGlzU3RyaW5nVGFnOiB0eXBlb2YgbyA9PSBcInN0cmluZ1wiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gQy5jcmVhdGVFbGVtZW50KG8sIGwpKTtcbn0pLCBHYyA9IHFjLCBLYyA9IGZ1bmN0aW9uKHQsIHIpIHtcbiAgdmFyIG4gPSBhcmd1bWVudHM7XG4gIGlmIChyID09IG51bGwgfHwgIVJvLmNhbGwociwgXCJjc3NcIikpXG4gICAgcmV0dXJuIEMuY3JlYXRlRWxlbWVudC5hcHBseSh2b2lkIDAsIG4pO1xuICB2YXIgbyA9IG4ubGVuZ3RoLCBpID0gbmV3IEFycmF5KG8pO1xuICBpWzBdID0gR2MsIGlbMV0gPSBZYyh0LCByKTtcbiAgZm9yICh2YXIgcyA9IDI7IHMgPCBvOyBzKyspXG4gICAgaVtzXSA9IG5bc107XG4gIHJldHVybiBDLmNyZWF0ZUVsZW1lbnQuYXBwbHkobnVsbCwgaSk7XG59O1xuKGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHQ7XG4gIHQgfHwgKHQgPSBlLkpTWCB8fCAoZS5KU1ggPSB7fSkpO1xufSkoS2MpO1xudmFyIFhjID0gLyogQF9fUFVSRV9fICovIE9vKGZ1bmN0aW9uKGUsIHQpIHtcbiAgdmFyIHIgPSBlLnN0eWxlcywgbiA9IE5yKFtyXSwgdm9pZCAwLCBDLnVzZUNvbnRleHQoTXIpKSwgbyA9IEMudXNlUmVmKCk7XG4gIHJldHVybiB2aShmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IHQua2V5ICsgXCItZ2xvYmFsXCIsIHMgPSBuZXcgdC5zaGVldC5jb25zdHJ1Y3Rvcih7XG4gICAgICBrZXk6IGksXG4gICAgICBub25jZTogdC5zaGVldC5ub25jZSxcbiAgICAgIGNvbnRhaW5lcjogdC5zaGVldC5jb250YWluZXIsXG4gICAgICBzcGVlZHk6IHQuc2hlZXQuaXNTcGVlZHlcbiAgICB9KSwgYyA9ICExLCBsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1lbW90aW9uPVwiJyArIGkgKyBcIiBcIiArIG4ubmFtZSArICdcIl0nKTtcbiAgICByZXR1cm4gdC5zaGVldC50YWdzLmxlbmd0aCAmJiAocy5iZWZvcmUgPSB0LnNoZWV0LnRhZ3NbMF0pLCBsICE9PSBudWxsICYmIChjID0gITAsIGwuc2V0QXR0cmlidXRlKFwiZGF0YS1lbW90aW9uXCIsIGkpLCBzLmh5ZHJhdGUoW2xdKSksIG8uY3VycmVudCA9IFtzLCBjXSwgZnVuY3Rpb24oKSB7XG4gICAgICBzLmZsdXNoKCk7XG4gICAgfTtcbiAgfSwgW3RdKSwgdmkoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSBvLmN1cnJlbnQsIHMgPSBpWzBdLCBjID0gaVsxXTtcbiAgICBpZiAoYykge1xuICAgICAgaVsxXSA9ICExO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobi5uZXh0ICE9PSB2b2lkIDAgJiYgd28odCwgbi5uZXh0LCAhMCksIHMudGFncy5sZW5ndGgpIHtcbiAgICAgIHZhciBsID0gcy50YWdzW3MudGFncy5sZW5ndGggLSAxXS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICBzLmJlZm9yZSA9IGwsIHMuZmx1c2goKTtcbiAgICB9XG4gICAgdC5pbnNlcnQoXCJcIiwgbiwgcywgITEpO1xuICB9LCBbdCwgbi5uYW1lXSksIG51bGw7XG59KTtcbmZ1bmN0aW9uICRvKCkge1xuICBmb3IgKHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShlKSwgciA9IDA7IHIgPCBlOyByKyspXG4gICAgdFtyXSA9IGFyZ3VtZW50c1tyXTtcbiAgcmV0dXJuIE5yKHQpO1xufVxuZnVuY3Rpb24gSXIoKSB7XG4gIHZhciBlID0gJG8uYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpLCB0ID0gXCJhbmltYXRpb24tXCIgKyBlLm5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogdCxcbiAgICBzdHlsZXM6IFwiQGtleWZyYW1lcyBcIiArIHQgKyBcIntcIiArIGUuc3R5bGVzICsgXCJ9XCIsXG4gICAgYW5pbTogMSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJfRU1PX1wiICsgdGhpcy5uYW1lICsgXCJfXCIgKyB0aGlzLnN0eWxlcyArIFwiX0VNT19cIjtcbiAgICB9XG4gIH07XG59XG52YXIgSmMgPSAvXigoY2hpbGRyZW58ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUx8a2V5fHJlZnxhdXRvRm9jdXN8ZGVmYXVsdFZhbHVlfGRlZmF1bHRDaGVja2VkfGlubmVySFRNTHxzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmd8c3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nfHZhbHVlTGlua3xhYmJyfGFjY2VwdHxhY2NlcHRDaGFyc2V0fGFjY2Vzc0tleXxhY3Rpb258YWxsb3d8YWxsb3dVc2VyTWVkaWF8YWxsb3dQYXltZW50UmVxdWVzdHxhbGxvd0Z1bGxTY3JlZW58YWxsb3dUcmFuc3BhcmVuY3l8YWx0fGFzeW5jfGF1dG9Db21wbGV0ZXxhdXRvUGxheXxjYXB0dXJlfGNlbGxQYWRkaW5nfGNlbGxTcGFjaW5nfGNoYWxsZW5nZXxjaGFyU2V0fGNoZWNrZWR8Y2l0ZXxjbGFzc0lEfGNsYXNzTmFtZXxjb2xzfGNvbFNwYW58Y29udGVudHxjb250ZW50RWRpdGFibGV8Y29udGV4dE1lbnV8Y29udHJvbHN8Y29udHJvbHNMaXN0fGNvb3Jkc3xjcm9zc09yaWdpbnxkYXRhfGRhdGVUaW1lfGRlY29kaW5nfGRlZmF1bHR8ZGVmZXJ8ZGlyfGRpc2FibGVkfGRpc2FibGVQaWN0dXJlSW5QaWN0dXJlfGRpc2FibGVSZW1vdGVQbGF5YmFja3xkb3dubG9hZHxkcmFnZ2FibGV8ZW5jVHlwZXxlbnRlcktleUhpbnR8ZmV0Y2hwcmlvcml0eXxmZXRjaFByaW9yaXR5fGZvcm18Zm9ybUFjdGlvbnxmb3JtRW5jVHlwZXxmb3JtTWV0aG9kfGZvcm1Ob1ZhbGlkYXRlfGZvcm1UYXJnZXR8ZnJhbWVCb3JkZXJ8aGVhZGVyc3xoZWlnaHR8aGlkZGVufGhpZ2h8aHJlZnxocmVmTGFuZ3xodG1sRm9yfGh0dHBFcXVpdnxpZHxpbnB1dE1vZGV8aW50ZWdyaXR5fGlzfGtleVBhcmFtc3xrZXlUeXBlfGtpbmR8bGFiZWx8bGFuZ3xsaXN0fGxvYWRpbmd8bG9vcHxsb3d8bWFyZ2luSGVpZ2h0fG1hcmdpbldpZHRofG1heHxtYXhMZW5ndGh8bWVkaWF8bWVkaWFHcm91cHxtZXRob2R8bWlufG1pbkxlbmd0aHxtdWx0aXBsZXxtdXRlZHxuYW1lfG5vbmNlfG5vVmFsaWRhdGV8b3BlbnxvcHRpbXVtfHBhdHRlcm58cGxhY2Vob2xkZXJ8cGxheXNJbmxpbmV8cG9zdGVyfHByZWxvYWR8cHJvZmlsZXxyYWRpb0dyb3VwfHJlYWRPbmx5fHJlZmVycmVyUG9saWN5fHJlbHxyZXF1aXJlZHxyZXZlcnNlZHxyb2xlfHJvd3N8cm93U3BhbnxzYW5kYm94fHNjb3BlfHNjb3BlZHxzY3JvbGxpbmd8c2VhbWxlc3N8c2VsZWN0ZWR8c2hhcGV8c2l6ZXxzaXplc3xzbG90fHNwYW58c3BlbGxDaGVja3xzcmN8c3JjRG9jfHNyY0xhbmd8c3JjU2V0fHN0YXJ0fHN0ZXB8c3R5bGV8c3VtbWFyeXx0YWJJbmRleHx0YXJnZXR8dGl0bGV8dHJhbnNsYXRlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aW5jcmVtZW50YWx8ZmFsbGJhY2t8aW5lcnR8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufG9wdGlvbnxyZXN1bHRzfHNlY3VyaXR5fHVuc2VsZWN0YWJsZXxhY2NlbnRIZWlnaHR8YWNjdW11bGF0ZXxhZGRpdGl2ZXxhbGlnbm1lbnRCYXNlbGluZXxhbGxvd1Jlb3JkZXJ8YWxwaGFiZXRpY3xhbXBsaXR1ZGV8YXJhYmljRm9ybXxhc2NlbnR8YXR0cmlidXRlTmFtZXxhdHRyaWJ1dGVUeXBlfGF1dG9SZXZlcnNlfGF6aW11dGh8YmFzZUZyZXF1ZW5jeXxiYXNlbGluZVNoaWZ0fGJhc2VQcm9maWxlfGJib3h8YmVnaW58Ymlhc3xieXxjYWxjTW9kZXxjYXBIZWlnaHR8Y2xpcHxjbGlwUGF0aFVuaXRzfGNsaXBQYXRofGNsaXBSdWxlfGNvbG9ySW50ZXJwb2xhdGlvbnxjb2xvckludGVycG9sYXRpb25GaWx0ZXJzfGNvbG9yUHJvZmlsZXxjb2xvclJlbmRlcmluZ3xjb250ZW50U2NyaXB0VHlwZXxjb250ZW50U3R5bGVUeXBlfGN1cnNvcnxjeHxjeXxkfGRlY2VsZXJhdGV8ZGVzY2VudHxkaWZmdXNlQ29uc3RhbnR8ZGlyZWN0aW9ufGRpc3BsYXl8ZGl2aXNvcnxkb21pbmFudEJhc2VsaW5lfGR1cnxkeHxkeXxlZGdlTW9kZXxlbGV2YXRpb258ZW5hYmxlQmFja2dyb3VuZHxlbmR8ZXhwb25lbnR8ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZHxmaWxsfGZpbGxPcGFjaXR5fGZpbGxSdWxlfGZpbHRlcnxmaWx0ZXJSZXN8ZmlsdGVyVW5pdHN8Zmxvb2RDb2xvcnxmbG9vZE9wYWNpdHl8Zm9jdXNhYmxlfGZvbnRGYW1pbHl8Zm9udFNpemV8Zm9udFNpemVBZGp1c3R8Zm9udFN0cmV0Y2h8Zm9udFN0eWxlfGZvbnRWYXJpYW50fGZvbnRXZWlnaHR8Zm9ybWF0fGZyb218ZnJ8Znh8Znl8ZzF8ZzJ8Z2x5cGhOYW1lfGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsfGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbHxnbHlwaFJlZnxncmFkaWVudFRyYW5zZm9ybXxncmFkaWVudFVuaXRzfGhhbmdpbmd8aG9yaXpBZHZYfGhvcml6T3JpZ2luWHxpZGVvZ3JhcGhpY3xpbWFnZVJlbmRlcmluZ3xpbnxpbjJ8aW50ZXJjZXB0fGt8azF8azJ8azN8azR8a2VybmVsTWF0cml4fGtlcm5lbFVuaXRMZW5ndGh8a2VybmluZ3xrZXlQb2ludHN8a2V5U3BsaW5lc3xrZXlUaW1lc3xsZW5ndGhBZGp1c3R8bGV0dGVyU3BhY2luZ3xsaWdodGluZ0NvbG9yfGxpbWl0aW5nQ29uZUFuZ2xlfGxvY2FsfG1hcmtlckVuZHxtYXJrZXJNaWR8bWFya2VyU3RhcnR8bWFya2VySGVpZ2h0fG1hcmtlclVuaXRzfG1hcmtlcldpZHRofG1hc2t8bWFza0NvbnRlbnRVbml0c3xtYXNrVW5pdHN8bWF0aGVtYXRpY2FsfG1vZGV8bnVtT2N0YXZlc3xvZmZzZXR8b3BhY2l0eXxvcGVyYXRvcnxvcmRlcnxvcmllbnR8b3JpZW50YXRpb258b3JpZ2lufG92ZXJmbG93fG92ZXJsaW5lUG9zaXRpb258b3ZlcmxpbmVUaGlja25lc3N8cGFub3NlMXxwYWludE9yZGVyfHBhdGhMZW5ndGh8cGF0dGVybkNvbnRlbnRVbml0c3xwYXR0ZXJuVHJhbnNmb3JtfHBhdHRlcm5Vbml0c3xwb2ludGVyRXZlbnRzfHBvaW50c3xwb2ludHNBdFh8cG9pbnRzQXRZfHBvaW50c0F0WnxwcmVzZXJ2ZUFscGhhfHByZXNlcnZlQXNwZWN0UmF0aW98cHJpbWl0aXZlVW5pdHN8cnxyYWRpdXN8cmVmWHxyZWZZfHJlbmRlcmluZ0ludGVudHxyZXBlYXRDb3VudHxyZXBlYXREdXJ8cmVxdWlyZWRFeHRlbnNpb25zfHJlcXVpcmVkRmVhdHVyZXN8cmVzdGFydHxyZXN1bHR8cm90YXRlfHJ4fHJ5fHNjYWxlfHNlZWR8c2hhcGVSZW5kZXJpbmd8c2xvcGV8c3BhY2luZ3xzcGVjdWxhckNvbnN0YW50fHNwZWN1bGFyRXhwb25lbnR8c3BlZWR8c3ByZWFkTWV0aG9kfHN0YXJ0T2Zmc2V0fHN0ZERldmlhdGlvbnxzdGVtaHxzdGVtdnxzdGl0Y2hUaWxlc3xzdG9wQ29sb3J8c3RvcE9wYWNpdHl8c3RyaWtldGhyb3VnaFBvc2l0aW9ufHN0cmlrZXRocm91Z2hUaGlja25lc3N8c3RyaW5nfHN0cm9rZXxzdHJva2VEYXNoYXJyYXl8c3Ryb2tlRGFzaG9mZnNldHxzdHJva2VMaW5lY2FwfHN0cm9rZUxpbmVqb2lufHN0cm9rZU1pdGVybGltaXR8c3Ryb2tlT3BhY2l0eXxzdHJva2VXaWR0aHxzdXJmYWNlU2NhbGV8c3lzdGVtTGFuZ3VhZ2V8dGFibGVWYWx1ZXN8dGFyZ2V0WHx0YXJnZXRZfHRleHRBbmNob3J8dGV4dERlY29yYXRpb258dGV4dFJlbmRlcmluZ3x0ZXh0TGVuZ3RofHRvfHRyYW5zZm9ybXx1MXx1Mnx1bmRlcmxpbmVQb3NpdGlvbnx1bmRlcmxpbmVUaGlja25lc3N8dW5pY29kZXx1bmljb2RlQmlkaXx1bmljb2RlUmFuZ2V8dW5pdHNQZXJFbXx2QWxwaGFiZXRpY3x2SGFuZ2luZ3x2SWRlb2dyYXBoaWN8dk1hdGhlbWF0aWNhbHx2YWx1ZXN8dmVjdG9yRWZmZWN0fHZlcnNpb258dmVydEFkdll8dmVydE9yaWdpblh8dmVydE9yaWdpbll8dmlld0JveHx2aWV3VGFyZ2V0fHZpc2liaWxpdHl8d2lkdGhzfHdvcmRTcGFjaW5nfHdyaXRpbmdNb2RlfHh8eEhlaWdodHx4MXx4Mnx4Q2hhbm5lbFNlbGVjdG9yfHhsaW5rQWN0dWF0ZXx4bGlua0FyY3JvbGV8eGxpbmtIcmVmfHhsaW5rUm9sZXx4bGlua1Nob3d8eGxpbmtUaXRsZXx4bGlua1R5cGV8eG1sQmFzZXx4bWxuc3x4bWxuc1hsaW5rfHhtbExhbmd8eG1sU3BhY2V8eXx5MXx5Mnx5Q2hhbm5lbFNlbGVjdG9yfHp8em9vbUFuZFBhbnxmb3J8Y2xhc3N8YXV0b2ZvY3VzKXwoKFtEZF1bQWFdW1R0XVtBYV18W0FhXVtScl1bSWldW0FhXXx4KS0uKikpJC8sIFFjID0gLyogQF9fUFVSRV9fICovIE9hKFxuICBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIEpjLnRlc3QoZSkgfHwgZS5jaGFyQ29kZUF0KDApID09PSAxMTEgJiYgZS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgZS5jaGFyQ29kZUF0KDIpIDwgOTE7XG4gIH1cbiAgLyogWisxICovXG4pLCBaYyA9IFFjLCBlbCA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQgIT09IFwidGhlbWVcIjtcbn0sIHhpID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAvLyA5NiBpcyBvbmUgbGVzcyB0aGFuIHRoZSBjaGFyIGNvZGVcbiAgLy8gZm9yIFwiYVwiIHNvIHRoaXMgaXMgY2hlY2tpbmcgdGhhdFxuICAvLyBpdCdzIGEgbG93ZXJjYXNlIGNoYXJhY3RlclxuICB0LmNoYXJDb2RlQXQoMCkgPiA5NiA/IFpjIDogZWw7XG59LCBTaSA9IGZ1bmN0aW9uKHQsIHIsIG4pIHtcbiAgdmFyIG87XG4gIGlmIChyKSB7XG4gICAgdmFyIGkgPSByLnNob3VsZEZvcndhcmRQcm9wO1xuICAgIG8gPSB0Ll9fZW1vdGlvbl9mb3J3YXJkUHJvcCAmJiBpID8gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHQuX19lbW90aW9uX2ZvcndhcmRQcm9wKHMpICYmIGkocyk7XG4gICAgfSA6IGk7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBvICE9IFwiZnVuY3Rpb25cIiAmJiBuICYmIChvID0gdC5fX2Vtb3Rpb25fZm9yd2FyZFByb3ApLCBvO1xufSwgdGwgPSBmdW5jdGlvbih0KSB7XG4gIHZhciByID0gdC5jYWNoZSwgbiA9IHQuc2VyaWFsaXplZCwgbyA9IHQuaXNTdHJpbmdUYWc7XG4gIHJldHVybiBUbyhyLCBuLCBvKSwgQWEoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHdvKHIsIG4sIG8pO1xuICB9KSwgbnVsbDtcbn0sIHJsID0gZnVuY3Rpb24gZSh0LCByKSB7XG4gIHZhciBuID0gdC5fX2Vtb3Rpb25fcmVhbCA9PT0gdCwgbyA9IG4gJiYgdC5fX2Vtb3Rpb25fYmFzZSB8fCB0LCBpLCBzO1xuICByICE9PSB2b2lkIDAgJiYgKGkgPSByLmxhYmVsLCBzID0gci50YXJnZXQpO1xuICB2YXIgYyA9IFNpKHQsIHIsIG4pLCBsID0gYyB8fCB4aShvKSwgdSA9ICFsKFwiYXNcIik7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcCA9IGFyZ3VtZW50cywgbSA9IG4gJiYgdC5fX2Vtb3Rpb25fc3R5bGVzICE9PSB2b2lkIDAgPyB0Ll9fZW1vdGlvbl9zdHlsZXMuc2xpY2UoMCkgOiBbXTtcbiAgICBpZiAoaSAhPT0gdm9pZCAwICYmIG0ucHVzaChcImxhYmVsOlwiICsgaSArIFwiO1wiKSwgcFswXSA9PSBudWxsIHx8IHBbMF0ucmF3ID09PSB2b2lkIDApXG4gICAgICBtLnB1c2guYXBwbHkobSwgcCk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgZyA9IHBbMF07XG4gICAgICBtLnB1c2goZ1swXSk7XG4gICAgICBmb3IgKHZhciB4ID0gcC5sZW5ndGgsIHkgPSAxOyB5IDwgeDsgeSsrKVxuICAgICAgICBtLnB1c2gocFt5XSwgZ1t5XSk7XG4gICAgfVxuICAgIHZhciBmID0gT28oZnVuY3Rpb24oUywgRSwgUCkge1xuICAgICAgdmFyIFQgPSB1ICYmIFMuYXMgfHwgbywgYiA9IFwiXCIsIGggPSBbXSwgdyA9IFM7XG4gICAgICBpZiAoUy50aGVtZSA9PSBudWxsKSB7XG4gICAgICAgIHcgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBTKVxuICAgICAgICAgIHdba10gPSBTW2tdO1xuICAgICAgICB3LnRoZW1lID0gQy51c2VDb250ZXh0KE1yKTtcbiAgICAgIH1cbiAgICAgIHR5cGVvZiBTLmNsYXNzTmFtZSA9PSBcInN0cmluZ1wiID8gYiA9ICRhKEUucmVnaXN0ZXJlZCwgaCwgUy5jbGFzc05hbWUpIDogUy5jbGFzc05hbWUgIT0gbnVsbCAmJiAoYiA9IFMuY2xhc3NOYW1lICsgXCIgXCIpO1xuICAgICAgdmFyIEwgPSBOcihtLmNvbmNhdChoKSwgRS5yZWdpc3RlcmVkLCB3KTtcbiAgICAgIGIgKz0gRS5rZXkgKyBcIi1cIiArIEwubmFtZSwgcyAhPT0gdm9pZCAwICYmIChiICs9IFwiIFwiICsgcyk7XG4gICAgICB2YXIgQiA9IHUgJiYgYyA9PT0gdm9pZCAwID8geGkoVCkgOiBsLCBkID0ge307XG4gICAgICBmb3IgKHZhciBBIGluIFMpXG4gICAgICAgIHUgJiYgQSA9PT0gXCJhc1wiIHx8IEIoQSkgJiYgKGRbQV0gPSBTW0FdKTtcbiAgICAgIHJldHVybiBkLmNsYXNzTmFtZSA9IGIsIFAgJiYgKGQucmVmID0gUCksIC8qIEBfX1BVUkVfXyAqLyBDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIEMuY3JlYXRlRWxlbWVudCh0bCwge1xuICAgICAgICBjYWNoZTogRSxcbiAgICAgICAgc2VyaWFsaXplZDogTCxcbiAgICAgICAgaXNTdHJpbmdUYWc6IHR5cGVvZiBUID09IFwic3RyaW5nXCJcbiAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gQy5jcmVhdGVFbGVtZW50KFQsIGQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZi5kaXNwbGF5TmFtZSA9IGkgIT09IHZvaWQgMCA/IGkgOiBcIlN0eWxlZChcIiArICh0eXBlb2YgbyA9PSBcInN0cmluZ1wiID8gbyA6IG8uZGlzcGxheU5hbWUgfHwgby5uYW1lIHx8IFwiQ29tcG9uZW50XCIpICsgXCIpXCIsIGYuZGVmYXVsdFByb3BzID0gdC5kZWZhdWx0UHJvcHMsIGYuX19lbW90aW9uX3JlYWwgPSBmLCBmLl9fZW1vdGlvbl9iYXNlID0gbywgZi5fX2Vtb3Rpb25fc3R5bGVzID0gbSwgZi5fX2Vtb3Rpb25fZm9yd2FyZFByb3AgPSBjLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJ0b1N0cmluZ1wiLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIi5cIiArIHM7XG4gICAgICB9XG4gICAgfSksIGYud2l0aENvbXBvbmVudCA9IGZ1bmN0aW9uKFMsIEUpIHtcbiAgICAgIHZhciBQID0gZShTLCBmbih7fSwgciwgRSwge1xuICAgICAgICBzaG91bGRGb3J3YXJkUHJvcDogU2koZiwgRSwgITApXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gUC5hcHBseSh2b2lkIDAsIG0pO1xuICAgIH0sIGY7XG4gIH07XG59LCBubCA9IFtcbiAgXCJhXCIsXG4gIFwiYWJiclwiLFxuICBcImFkZHJlc3NcIixcbiAgXCJhcmVhXCIsXG4gIFwiYXJ0aWNsZVwiLFxuICBcImFzaWRlXCIsXG4gIFwiYXVkaW9cIixcbiAgXCJiXCIsXG4gIFwiYmFzZVwiLFxuICBcImJkaVwiLFxuICBcImJkb1wiLFxuICBcImJpZ1wiLFxuICBcImJsb2NrcXVvdGVcIixcbiAgXCJib2R5XCIsXG4gIFwiYnJcIixcbiAgXCJidXR0b25cIixcbiAgXCJjYW52YXNcIixcbiAgXCJjYXB0aW9uXCIsXG4gIFwiY2l0ZVwiLFxuICBcImNvZGVcIixcbiAgXCJjb2xcIixcbiAgXCJjb2xncm91cFwiLFxuICBcImRhdGFcIixcbiAgXCJkYXRhbGlzdFwiLFxuICBcImRkXCIsXG4gIFwiZGVsXCIsXG4gIFwiZGV0YWlsc1wiLFxuICBcImRmblwiLFxuICBcImRpYWxvZ1wiLFxuICBcImRpdlwiLFxuICBcImRsXCIsXG4gIFwiZHRcIixcbiAgXCJlbVwiLFxuICBcImVtYmVkXCIsXG4gIFwiZmllbGRzZXRcIixcbiAgXCJmaWdjYXB0aW9uXCIsXG4gIFwiZmlndXJlXCIsXG4gIFwiZm9vdGVyXCIsXG4gIFwiZm9ybVwiLFxuICBcImgxXCIsXG4gIFwiaDJcIixcbiAgXCJoM1wiLFxuICBcImg0XCIsXG4gIFwiaDVcIixcbiAgXCJoNlwiLFxuICBcImhlYWRcIixcbiAgXCJoZWFkZXJcIixcbiAgXCJoZ3JvdXBcIixcbiAgXCJoclwiLFxuICBcImh0bWxcIixcbiAgXCJpXCIsXG4gIFwiaWZyYW1lXCIsXG4gIFwiaW1nXCIsXG4gIFwiaW5wdXRcIixcbiAgXCJpbnNcIixcbiAgXCJrYmRcIixcbiAgXCJrZXlnZW5cIixcbiAgXCJsYWJlbFwiLFxuICBcImxlZ2VuZFwiLFxuICBcImxpXCIsXG4gIFwibGlua1wiLFxuICBcIm1haW5cIixcbiAgXCJtYXBcIixcbiAgXCJtYXJrXCIsXG4gIFwibWFycXVlZVwiLFxuICBcIm1lbnVcIixcbiAgXCJtZW51aXRlbVwiLFxuICBcIm1ldGFcIixcbiAgXCJtZXRlclwiLFxuICBcIm5hdlwiLFxuICBcIm5vc2NyaXB0XCIsXG4gIFwib2JqZWN0XCIsXG4gIFwib2xcIixcbiAgXCJvcHRncm91cFwiLFxuICBcIm9wdGlvblwiLFxuICBcIm91dHB1dFwiLFxuICBcInBcIixcbiAgXCJwYXJhbVwiLFxuICBcInBpY3R1cmVcIixcbiAgXCJwcmVcIixcbiAgXCJwcm9ncmVzc1wiLFxuICBcInFcIixcbiAgXCJycFwiLFxuICBcInJ0XCIsXG4gIFwicnVieVwiLFxuICBcInNcIixcbiAgXCJzYW1wXCIsXG4gIFwic2NyaXB0XCIsXG4gIFwic2VjdGlvblwiLFxuICBcInNlbGVjdFwiLFxuICBcInNtYWxsXCIsXG4gIFwic291cmNlXCIsXG4gIFwic3BhblwiLFxuICBcInN0cm9uZ1wiLFxuICBcInN0eWxlXCIsXG4gIFwic3ViXCIsXG4gIFwic3VtbWFyeVwiLFxuICBcInN1cFwiLFxuICBcInRhYmxlXCIsXG4gIFwidGJvZHlcIixcbiAgXCJ0ZFwiLFxuICBcInRleHRhcmVhXCIsXG4gIFwidGZvb3RcIixcbiAgXCJ0aFwiLFxuICBcInRoZWFkXCIsXG4gIFwidGltZVwiLFxuICBcInRpdGxlXCIsXG4gIFwidHJcIixcbiAgXCJ0cmFja1wiLFxuICBcInVcIixcbiAgXCJ1bFwiLFxuICBcInZhclwiLFxuICBcInZpZGVvXCIsXG4gIFwid2JyXCIsXG4gIC8vIFNWR1xuICBcImNpcmNsZVwiLFxuICBcImNsaXBQYXRoXCIsXG4gIFwiZGVmc1wiLFxuICBcImVsbGlwc2VcIixcbiAgXCJmb3JlaWduT2JqZWN0XCIsXG4gIFwiZ1wiLFxuICBcImltYWdlXCIsXG4gIFwibGluZVwiLFxuICBcImxpbmVhckdyYWRpZW50XCIsXG4gIFwibWFza1wiLFxuICBcInBhdGhcIixcbiAgXCJwYXR0ZXJuXCIsXG4gIFwicG9seWdvblwiLFxuICBcInBvbHlsaW5lXCIsXG4gIFwicmFkaWFsR3JhZGllbnRcIixcbiAgXCJyZWN0XCIsXG4gIFwic3RvcFwiLFxuICBcInN2Z1wiLFxuICBcInRleHRcIixcbiAgXCJ0c3BhblwiXG5dLCBzbyA9IHJsLmJpbmQobnVsbCk7XG5ubC5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgc29bZV0gPSBzbyhlKTtcbn0pO1xudmFyIHFyID0geyBleHBvcnRzOiB7fSB9LCBHciA9IHsgZXhwb3J0czoge30gfSwgaGUgPSB7fTtcbi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIEVpO1xuZnVuY3Rpb24gb2woKSB7XG4gIGlmIChFaSkgcmV0dXJuIGhlO1xuICBFaSA9IDE7XG4gIHZhciBlID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmZvciwgdCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSA6IDYwMTAzLCByID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIikgOiA2MDEwNiwgbiA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIikgOiA2MDEwNywgbyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIikgOiA2MDEwOCwgaSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIikgOiA2MDExNCwgcyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIikgOiA2MDEwOSwgYyA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSA6IDYwMTEwLCBsID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5hc3luY19tb2RlXCIpIDogNjAxMTEsIHUgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKSA6IDYwMTExLCBwID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSA6IDYwMTEyLCBtID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSA6IDYwMTEzLCBnID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpIDogNjAxMjAsIHggPSBlID8gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIikgOiA2MDExNSwgeSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSA6IDYwMTE2LCBmID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5ibG9ja1wiKSA6IDYwMTIxLCBTID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mdW5kYW1lbnRhbFwiKSA6IDYwMTE3LCBFID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5yZXNwb25kZXJcIikgOiA2MDExOCwgUCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIikgOiA2MDExOTtcbiAgZnVuY3Rpb24gVChoKSB7XG4gICAgaWYgKHR5cGVvZiBoID09IFwib2JqZWN0XCIgJiYgaCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHcgPSBoLiQkdHlwZW9mO1xuICAgICAgc3dpdGNoICh3KSB7XG4gICAgICAgIGNhc2UgdDpcbiAgICAgICAgICBzd2l0Y2ggKGggPSBoLnR5cGUsIGgpIHtcbiAgICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgIGNhc2UgbjpcbiAgICAgICAgICAgIGNhc2UgaTpcbiAgICAgICAgICAgIGNhc2UgbzpcbiAgICAgICAgICAgIGNhc2UgbTpcbiAgICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzd2l0Y2ggKGggPSBoICYmIGguJCR0eXBlb2YsIGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICAgICAgY2FzZSBwOlxuICAgICAgICAgICAgICAgIGNhc2UgeTpcbiAgICAgICAgICAgICAgICBjYXNlIHg6XG4gICAgICAgICAgICAgICAgY2FzZSBzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgcmV0dXJuIHc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGIoaCkge1xuICAgIHJldHVybiBUKGgpID09PSB1O1xuICB9XG4gIHJldHVybiBoZS5Bc3luY01vZGUgPSBsLCBoZS5Db25jdXJyZW50TW9kZSA9IHUsIGhlLkNvbnRleHRDb25zdW1lciA9IGMsIGhlLkNvbnRleHRQcm92aWRlciA9IHMsIGhlLkVsZW1lbnQgPSB0LCBoZS5Gb3J3YXJkUmVmID0gcCwgaGUuRnJhZ21lbnQgPSBuLCBoZS5MYXp5ID0geSwgaGUuTWVtbyA9IHgsIGhlLlBvcnRhbCA9IHIsIGhlLlByb2ZpbGVyID0gaSwgaGUuU3RyaWN0TW9kZSA9IG8sIGhlLlN1c3BlbnNlID0gbSwgaGUuaXNBc3luY01vZGUgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIGIoaCkgfHwgVChoKSA9PT0gbDtcbiAgfSwgaGUuaXNDb25jdXJyZW50TW9kZSA9IGIsIGhlLmlzQ29udGV4dENvbnN1bWVyID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSBjO1xuICB9LCBoZS5pc0NvbnRleHRQcm92aWRlciA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0gcztcbiAgfSwgaGUuaXNFbGVtZW50ID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiB0eXBlb2YgaCA9PSBcIm9iamVjdFwiICYmIGggIT09IG51bGwgJiYgaC4kJHR5cGVvZiA9PT0gdDtcbiAgfSwgaGUuaXNGb3J3YXJkUmVmID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSBwO1xuICB9LCBoZS5pc0ZyYWdtZW50ID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiBUKGgpID09PSBuO1xuICB9LCBoZS5pc0xhenkgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IHk7XG4gIH0sIGhlLmlzTWVtbyA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0geDtcbiAgfSwgaGUuaXNQb3J0YWwgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IHI7XG4gIH0sIGhlLmlzUHJvZmlsZXIgPSBmdW5jdGlvbihoKSB7XG4gICAgcmV0dXJuIFQoaCkgPT09IGk7XG4gIH0sIGhlLmlzU3RyaWN0TW9kZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0gbztcbiAgfSwgaGUuaXNTdXNwZW5zZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICByZXR1cm4gVChoKSA9PT0gbTtcbiAgfSwgaGUuaXNWYWxpZEVsZW1lbnRUeXBlID0gZnVuY3Rpb24oaCkge1xuICAgIHJldHVybiB0eXBlb2YgaCA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBoID09IFwiZnVuY3Rpb25cIiB8fCBoID09PSBuIHx8IGggPT09IHUgfHwgaCA9PT0gaSB8fCBoID09PSBvIHx8IGggPT09IG0gfHwgaCA9PT0gZyB8fCB0eXBlb2YgaCA9PSBcIm9iamVjdFwiICYmIGggIT09IG51bGwgJiYgKGguJCR0eXBlb2YgPT09IHkgfHwgaC4kJHR5cGVvZiA9PT0geCB8fCBoLiQkdHlwZW9mID09PSBzIHx8IGguJCR0eXBlb2YgPT09IGMgfHwgaC4kJHR5cGVvZiA9PT0gcCB8fCBoLiQkdHlwZW9mID09PSBTIHx8IGguJCR0eXBlb2YgPT09IEUgfHwgaC4kJHR5cGVvZiA9PT0gUCB8fCBoLiQkdHlwZW9mID09PSBmKTtcbiAgfSwgaGUudHlwZU9mID0gVCwgaGU7XG59XG52YXIgZ2UgPSB7fTtcbi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIENpO1xuZnVuY3Rpb24gaWwoKSB7XG4gIHJldHVybiBDaSB8fCAoQ2kgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yLCB0ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpIDogNjAxMDMsIHIgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSA6IDYwMTA2LCBuID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSA6IDYwMTA3LCBvID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSA6IDYwMTA4LCBpID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSA6IDYwMTE0LCBzID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSA6IDYwMTA5LCBjID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpIDogNjAxMTAsIGwgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmFzeW5jX21vZGVcIikgOiA2MDExMSwgdSA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QuY29uY3VycmVudF9tb2RlXCIpIDogNjAxMTEsIHAgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpIDogNjAxMTIsIG0gPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpIDogNjAxMTMsIGcgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIikgOiA2MDEyMCwgeCA9IGUgPyBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSA6IDYwMTE1LCB5ID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpIDogNjAxMTYsIGYgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmJsb2NrXCIpIDogNjAxMjEsIFMgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LmZ1bmRhbWVudGFsXCIpIDogNjAxMTcsIEUgPSBlID8gU3ltYm9sLmZvcihcInJlYWN0LnJlc3BvbmRlclwiKSA6IDYwMTE4LCBQID0gZSA/IFN5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKSA6IDYwMTE5O1xuICAgIGZ1bmN0aW9uIFQoTykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBPID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIE8gPT0gXCJmdW5jdGlvblwiIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gICAgICBPID09PSBuIHx8IE8gPT09IHUgfHwgTyA9PT0gaSB8fCBPID09PSBvIHx8IE8gPT09IG0gfHwgTyA9PT0gZyB8fCB0eXBlb2YgTyA9PSBcIm9iamVjdFwiICYmIE8gIT09IG51bGwgJiYgKE8uJCR0eXBlb2YgPT09IHkgfHwgTy4kJHR5cGVvZiA9PT0geCB8fCBPLiQkdHlwZW9mID09PSBzIHx8IE8uJCR0eXBlb2YgPT09IGMgfHwgTy4kJHR5cGVvZiA9PT0gcCB8fCBPLiQkdHlwZW9mID09PSBTIHx8IE8uJCR0eXBlb2YgPT09IEUgfHwgTy4kJHR5cGVvZiA9PT0gUCB8fCBPLiQkdHlwZW9mID09PSBmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYihPKSB7XG4gICAgICBpZiAodHlwZW9mIE8gPT0gXCJvYmplY3RcIiAmJiBPICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB5ZSA9IE8uJCR0eXBlb2Y7XG4gICAgICAgIHN3aXRjaCAoeWUpIHtcbiAgICAgICAgICBjYXNlIHQ6XG4gICAgICAgICAgICB2YXIgRWUgPSBPLnR5cGU7XG4gICAgICAgICAgICBzd2l0Y2ggKEVlKSB7XG4gICAgICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgICBjYXNlIG46XG4gICAgICAgICAgICAgIGNhc2UgaTpcbiAgICAgICAgICAgICAgY2FzZSBvOlxuICAgICAgICAgICAgICBjYXNlIG06XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBNZSA9IEVlICYmIEVlLiQkdHlwZW9mO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoTWUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgYzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgcDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgeTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgeDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgczpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1lO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHllO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICByZXR1cm4geWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGggPSBsLCB3ID0gdSwgayA9IGMsIEwgPSBzLCBCID0gdCwgZCA9IHAsIEEgPSBuLCBEID0geSwgaiA9IHgsIFcgPSByLCB6ID0gaSwgVSA9IG8sIFYgPSBtLCB0ZSA9ICExO1xuICAgIGZ1bmN0aW9uIEYoTykge1xuICAgICAgcmV0dXJuIHRlIHx8ICh0ZSA9ICEwLCBjb25zb2xlLndhcm4oXCJUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSBSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLlwiKSksIFIoTykgfHwgYihPKSA9PT0gbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUihPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gdTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSShPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gSihPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gcztcbiAgICB9XG4gICAgZnVuY3Rpb24gUShPKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIE8gPT0gXCJvYmplY3RcIiAmJiBPICE9PSBudWxsICYmIE8uJCR0eXBlb2YgPT09IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEgoTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFgoTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIF8oTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHEoTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEcoTykge1xuICAgICAgcmV0dXJuIGIoTykgPT09IHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSBpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBaKE8pIHtcbiAgICAgIHJldHVybiBiKE8pID09PSBvO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZShPKSB7XG4gICAgICByZXR1cm4gYihPKSA9PT0gbTtcbiAgICB9XG4gICAgZ2UuQXN5bmNNb2RlID0gaCwgZ2UuQ29uY3VycmVudE1vZGUgPSB3LCBnZS5Db250ZXh0Q29uc3VtZXIgPSBrLCBnZS5Db250ZXh0UHJvdmlkZXIgPSBMLCBnZS5FbGVtZW50ID0gQiwgZ2UuRm9yd2FyZFJlZiA9IGQsIGdlLkZyYWdtZW50ID0gQSwgZ2UuTGF6eSA9IEQsIGdlLk1lbW8gPSBqLCBnZS5Qb3J0YWwgPSBXLCBnZS5Qcm9maWxlciA9IHosIGdlLlN0cmljdE1vZGUgPSBVLCBnZS5TdXNwZW5zZSA9IFYsIGdlLmlzQXN5bmNNb2RlID0gRiwgZ2UuaXNDb25jdXJyZW50TW9kZSA9IFIsIGdlLmlzQ29udGV4dENvbnN1bWVyID0gSSwgZ2UuaXNDb250ZXh0UHJvdmlkZXIgPSBKLCBnZS5pc0VsZW1lbnQgPSBRLCBnZS5pc0ZvcndhcmRSZWYgPSBILCBnZS5pc0ZyYWdtZW50ID0gWCwgZ2UuaXNMYXp5ID0gXywgZ2UuaXNNZW1vID0gcSwgZ2UuaXNQb3J0YWwgPSBHLCBnZS5pc1Byb2ZpbGVyID0gcmUsIGdlLmlzU3RyaWN0TW9kZSA9IFosIGdlLmlzU3VzcGVuc2UgPSBhZSwgZ2UuaXNWYWxpZEVsZW1lbnRUeXBlID0gVCwgZ2UudHlwZU9mID0gYjtcbiAgfSgpKSwgZ2U7XG59XG52YXIgVGk7XG5mdW5jdGlvbiBNYSgpIHtcbiAgcmV0dXJuIFRpIHx8IChUaSA9IDEsIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IEdyLmV4cG9ydHMgPSBvbCgpIDogR3IuZXhwb3J0cyA9IGlsKCkpLCBHci5leHBvcnRzO1xufVxuLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG52YXIgcW4sIHdpO1xuZnVuY3Rpb24gYWwoKSB7XG4gIGlmICh3aSkgcmV0dXJuIHFuO1xuICB3aSA9IDE7XG4gIHZhciBlID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIHIgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICBmdW5jdGlvbiBuKGkpIHtcbiAgICBpZiAoaSA9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuICAgIHJldHVybiBPYmplY3QoaSk7XG4gIH1cbiAgZnVuY3Rpb24gbygpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFPYmplY3QuYXNzaWduKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB2YXIgaSA9IG5ldyBTdHJpbmcoXCJhYmNcIik7XG4gICAgICBpZiAoaVs1XSA9IFwiZGVcIiwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaSlbMF0gPT09IFwiNVwiKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBmb3IgKHZhciBzID0ge30sIGMgPSAwOyBjIDwgMTA7IGMrKylcbiAgICAgICAgc1tcIl9cIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoYyldID0gYztcbiAgICAgIHZhciBsID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocykubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHNbcF07XG4gICAgICB9KTtcbiAgICAgIGlmIChsLmpvaW4oXCJcIikgIT09IFwiMDEyMzQ1Njc4OVwiKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB2YXIgdSA9IHt9O1xuICAgICAgcmV0dXJuIFwiYWJjZGVmZ2hpamtsbW5vcHFyc3RcIi5zcGxpdChcIlwiKS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdVtwXSA9IHA7XG4gICAgICB9KSwgT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdSkpLmpvaW4oXCJcIikgPT09IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3RcIjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHFuID0gbygpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uKGksIHMpIHtcbiAgICBmb3IgKHZhciBjLCBsID0gbihpKSwgdSwgcCA9IDE7IHAgPCBhcmd1bWVudHMubGVuZ3RoOyBwKyspIHtcbiAgICAgIGMgPSBPYmplY3QoYXJndW1lbnRzW3BdKTtcbiAgICAgIGZvciAodmFyIG0gaW4gYylcbiAgICAgICAgdC5jYWxsKGMsIG0pICYmIChsW21dID0gY1ttXSk7XG4gICAgICBpZiAoZSkge1xuICAgICAgICB1ID0gZShjKTtcbiAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCB1Lmxlbmd0aDsgZysrKVxuICAgICAgICAgIHIuY2FsbChjLCB1W2ddKSAmJiAobFt1W2ddXSA9IGNbdVtnXV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbDtcbiAgfSwgcW47XG59XG52YXIgR24sIE9pO1xuZnVuY3Rpb24gUG8oKSB7XG4gIGlmIChPaSkgcmV0dXJuIEduO1xuICBPaSA9IDE7XG4gIHZhciBlID0gXCJTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRFwiO1xuICByZXR1cm4gR24gPSBlLCBHbjtcbn1cbnZhciBLbiwgUmk7XG5mdW5jdGlvbiBJYSgpIHtcbiAgcmV0dXJuIFJpIHx8IChSaSA9IDEsIEtuID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpKSwgS247XG59XG52YXIgWG4sICRpO1xuZnVuY3Rpb24gc2woKSB7XG4gIGlmICgkaSkgcmV0dXJuIFhuO1xuICAkaSA9IDE7XG4gIHZhciBlID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgdCA9IC8qIEBfX1BVUkVfXyAqLyBQbygpLCByID0ge30sIG4gPSAvKiBAX19QVVJFX18gKi8gSWEoKTtcbiAgICBlID0gZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIHMgPSBcIldhcm5pbmc6IFwiICsgaTtcbiAgICAgIHR5cGVvZiBjb25zb2xlIDwgXCJ1XCIgJiYgY29uc29sZS5lcnJvcihzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihzKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbyhpLCBzLCBjLCBsLCB1KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgZm9yICh2YXIgcCBpbiBpKVxuICAgICAgICBpZiAobihpLCBwKSkge1xuICAgICAgICAgIHZhciBtO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlbcF0gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHZhciBnID0gRXJyb3IoXG4gICAgICAgICAgICAgICAgKGwgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIGMgKyBcIiB0eXBlIGBcIiArIHAgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIGlbcF0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGhyb3cgZy5uYW1lID0gXCJJbnZhcmlhbnQgVmlvbGF0aW9uXCIsIGc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtID0gaVtwXShzLCBwLCBsLCBjLCBudWxsLCB0KTtcbiAgICAgICAgICB9IGNhdGNoICh5KSB7XG4gICAgICAgICAgICBtID0geTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG0gJiYgIShtIGluc3RhbmNlb2YgRXJyb3IpICYmIGUoXG4gICAgICAgICAgICAobCB8fCBcIlJlYWN0IGNsYXNzXCIpICsgXCI6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiBcIiArIGMgKyBcIiBgXCIgKyBwICsgXCJgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgXCIgKyB0eXBlb2YgbSArIFwiLiBZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciBjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kIHNoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS5cIlxuICAgICAgICAgICksIG0gaW5zdGFuY2VvZiBFcnJvciAmJiAhKG0ubWVzc2FnZSBpbiByKSkge1xuICAgICAgICAgICAgclttLm1lc3NhZ2VdID0gITA7XG4gICAgICAgICAgICB2YXIgeCA9IHUgPyB1KCkgOiBcIlwiO1xuICAgICAgICAgICAgZShcbiAgICAgICAgICAgICAgXCJGYWlsZWQgXCIgKyBjICsgXCIgdHlwZTogXCIgKyBtLm1lc3NhZ2UgKyAoeCA/PyBcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG8ucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHIgPSB7fSk7XG4gIH0sIFhuID0gbywgWG47XG59XG52YXIgSm4sIFBpO1xuZnVuY3Rpb24gY2woKSB7XG4gIGlmIChQaSkgcmV0dXJuIEpuO1xuICBQaSA9IDE7XG4gIHZhciBlID0gTWEoKSwgdCA9IGFsKCksIHIgPSAvKiBAX19QVVJFX18gKi8gUG8oKSwgbiA9IC8qIEBfX1BVUkVfXyAqLyBJYSgpLCBvID0gLyogQF9fUFVSRV9fICovIHNsKCksIGkgPSBmdW5jdGlvbigpIHtcbiAgfTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChpID0gZnVuY3Rpb24oYykge1xuICAgIHZhciBsID0gXCJXYXJuaW5nOiBcIiArIGM7XG4gICAgdHlwZW9mIGNvbnNvbGUgPCBcInVcIiAmJiBjb25zb2xlLmVycm9yKGwpO1xuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobCk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gcygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gSm4gPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgdmFyIHUgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIHAgPSBcIkBAaXRlcmF0b3JcIjtcbiAgICBmdW5jdGlvbiBtKFIpIHtcbiAgICAgIHZhciBJID0gUiAmJiAodSAmJiBSW3VdIHx8IFJbcF0pO1xuICAgICAgaWYgKHR5cGVvZiBJID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIEk7XG4gICAgfVxuICAgIHZhciBnID0gXCI8PGFub255bW91cz4+XCIsIHggPSB7XG4gICAgICBhcnJheTogRShcImFycmF5XCIpLFxuICAgICAgYmlnaW50OiBFKFwiYmlnaW50XCIpLFxuICAgICAgYm9vbDogRShcImJvb2xlYW5cIiksXG4gICAgICBmdW5jOiBFKFwiZnVuY3Rpb25cIiksXG4gICAgICBudW1iZXI6IEUoXCJudW1iZXJcIiksXG4gICAgICBvYmplY3Q6IEUoXCJvYmplY3RcIiksXG4gICAgICBzdHJpbmc6IEUoXCJzdHJpbmdcIiksXG4gICAgICBzeW1ib2w6IEUoXCJzeW1ib2xcIiksXG4gICAgICBhbnk6IFAoKSxcbiAgICAgIGFycmF5T2Y6IFQsXG4gICAgICBlbGVtZW50OiBiKCksXG4gICAgICBlbGVtZW50VHlwZTogaCgpLFxuICAgICAgaW5zdGFuY2VPZjogdyxcbiAgICAgIG5vZGU6IGQoKSxcbiAgICAgIG9iamVjdE9mOiBMLFxuICAgICAgb25lT2Y6IGssXG4gICAgICBvbmVPZlR5cGU6IEIsXG4gICAgICBzaGFwZTogRCxcbiAgICAgIGV4YWN0OiBqXG4gICAgfTtcbiAgICBmdW5jdGlvbiB5KFIsIEkpIHtcbiAgICAgIHJldHVybiBSID09PSBJID8gUiAhPT0gMCB8fCAxIC8gUiA9PT0gMSAvIEkgOiBSICE9PSBSICYmIEkgIT09IEk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGYoUiwgSSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gUiwgdGhpcy5kYXRhID0gSSAmJiB0eXBlb2YgSSA9PSBcIm9iamVjdFwiID8gSSA6IHt9LCB0aGlzLnN0YWNrID0gXCJcIjtcbiAgICB9XG4gICAgZi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG4gICAgZnVuY3Rpb24gUyhSKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKVxuICAgICAgICB2YXIgSSA9IHt9LCBKID0gMDtcbiAgICAgIGZ1bmN0aW9uIFEoWCwgXywgcSwgRywgcmUsIFosIGFlKSB7XG4gICAgICAgIGlmIChHID0gRyB8fCBnLCBaID0gWiB8fCBxLCBhZSAhPT0gcikge1xuICAgICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgICB2YXIgTyA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiBVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uIFJlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXNcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRocm93IE8ubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBPO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiBjb25zb2xlIDwgXCJ1XCIpIHtcbiAgICAgICAgICAgIHZhciB5ZSA9IEcgKyBcIjpcIiArIHE7XG4gICAgICAgICAgICAhSVt5ZV0gJiYgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBKIDwgMyAmJiAoaShcbiAgICAgICAgICAgICAgXCJZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgdGhlIGBcIiArIFogKyBcImAgcHJvcCBvbiBgXCIgKyBHICsgXCJgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuIFlvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzIGZvciBkZXRhaWxzLlwiXG4gICAgICAgICAgICApLCBJW3llXSA9ICEwLCBKKyspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX1txXSA9PSBudWxsID8gWCA/IF9bcV0gPT09IG51bGwgPyBuZXcgZihcIlRoZSBcIiArIHJlICsgXCIgYFwiICsgWiArIFwiYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgXCIgKyAoXCJpbiBgXCIgKyBHICsgXCJgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC5cIikpIDogbmV3IGYoXCJUaGUgXCIgKyByZSArIFwiIGBcIiArIFogKyBcImAgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluIFwiICsgKFwiYFwiICsgRyArIFwiYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cIikpIDogbnVsbCA6IFIoXywgcSwgRywgcmUsIFopO1xuICAgICAgfVxuICAgICAgdmFyIEggPSBRLmJpbmQobnVsbCwgITEpO1xuICAgICAgcmV0dXJuIEguaXNSZXF1aXJlZCA9IFEuYmluZChudWxsLCAhMCksIEg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEUoUikge1xuICAgICAgZnVuY3Rpb24gSShKLCBRLCBILCBYLCBfLCBxKSB7XG4gICAgICAgIHZhciBHID0gSltRXSwgcmUgPSBVKEcpO1xuICAgICAgICBpZiAocmUgIT09IFIpIHtcbiAgICAgICAgICB2YXIgWiA9IFYoRyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBmKFxuICAgICAgICAgICAgXCJJbnZhbGlkIFwiICsgWCArIFwiIGBcIiArIF8gKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIFogKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgSCArIFwiYCwgZXhwZWN0ZWQgXCIpICsgKFwiYFwiICsgUiArIFwiYC5cIiksXG4gICAgICAgICAgICB7IGV4cGVjdGVkVHlwZTogUiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTKEkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQKCkge1xuICAgICAgcmV0dXJuIFMocyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFQoUikge1xuICAgICAgZnVuY3Rpb24gSShKLCBRLCBILCBYLCBfKSB7XG4gICAgICAgIGlmICh0eXBlb2YgUiAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIG5ldyBmKFwiUHJvcGVydHkgYFwiICsgXyArIFwiYCBvZiBjb21wb25lbnQgYFwiICsgSCArIFwiYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi5cIik7XG4gICAgICAgIHZhciBxID0gSltRXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHEpKSB7XG4gICAgICAgICAgdmFyIEcgPSBVKHEpO1xuICAgICAgICAgIHJldHVybiBuZXcgZihcIkludmFsaWQgXCIgKyBYICsgXCIgYFwiICsgXyArIFwiYCBvZiB0eXBlIFwiICsgKFwiYFwiICsgRyArIFwiYCBzdXBwbGllZCB0byBgXCIgKyBIICsgXCJgLCBleHBlY3RlZCBhbiBhcnJheS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHJlID0gMDsgcmUgPCBxLmxlbmd0aDsgcmUrKykge1xuICAgICAgICAgIHZhciBaID0gUihxLCByZSwgSCwgWCwgXyArIFwiW1wiICsgcmUgKyBcIl1cIiwgcik7XG4gICAgICAgICAgaWYgKFogaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgICAgIHJldHVybiBaO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFMoSSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICBmdW5jdGlvbiBSKEksIEosIFEsIEgsIFgpIHtcbiAgICAgICAgdmFyIF8gPSBJW0pdO1xuICAgICAgICBpZiAoIWMoXykpIHtcbiAgICAgICAgICB2YXIgcSA9IFUoXyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBmKFwiSW52YWxpZCBcIiArIEggKyBcIiBgXCIgKyBYICsgXCJgIG9mIHR5cGUgXCIgKyAoXCJgXCIgKyBxICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIFEgKyBcImAsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFMoUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGgoKSB7XG4gICAgICBmdW5jdGlvbiBSKEksIEosIFEsIEgsIFgpIHtcbiAgICAgICAgdmFyIF8gPSBJW0pdO1xuICAgICAgICBpZiAoIWUuaXNWYWxpZEVsZW1lbnRUeXBlKF8pKSB7XG4gICAgICAgICAgdmFyIHEgPSBVKF8pO1xuICAgICAgICAgIHJldHVybiBuZXcgZihcIkludmFsaWQgXCIgKyBIICsgXCIgYFwiICsgWCArIFwiYCBvZiB0eXBlIFwiICsgKFwiYFwiICsgcSArIFwiYCBzdXBwbGllZCB0byBgXCIgKyBRICsgXCJgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFMoUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHcoUikge1xuICAgICAgZnVuY3Rpb24gSShKLCBRLCBILCBYLCBfKSB7XG4gICAgICAgIGlmICghKEpbUV0gaW5zdGFuY2VvZiBSKSkge1xuICAgICAgICAgIHZhciBxID0gUi5uYW1lIHx8IGcsIEcgPSBGKEpbUV0pO1xuICAgICAgICAgIHJldHVybiBuZXcgZihcIkludmFsaWQgXCIgKyBYICsgXCIgYFwiICsgXyArIFwiYCBvZiB0eXBlIFwiICsgKFwiYFwiICsgRyArIFwiYCBzdXBwbGllZCB0byBgXCIgKyBIICsgXCJgLCBleHBlY3RlZCBcIikgKyAoXCJpbnN0YW5jZSBvZiBgXCIgKyBxICsgXCJgLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gUyhJKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gayhSKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoUikpXG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gaShcbiAgICAgICAgICBcIkludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290IFwiICsgYXJndW1lbnRzLmxlbmd0aCArIFwiIGFyZ3VtZW50cy4gQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuXCJcbiAgICAgICAgKSA6IGkoXCJJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS5cIikpLCBzO1xuICAgICAgZnVuY3Rpb24gSShKLCBRLCBILCBYLCBfKSB7XG4gICAgICAgIGZvciAodmFyIHEgPSBKW1FdLCBHID0gMDsgRyA8IFIubGVuZ3RoOyBHKyspXG4gICAgICAgICAgaWYgKHkocSwgUltHXSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHJlID0gSlNPTi5zdHJpbmdpZnkoUiwgZnVuY3Rpb24oYWUsIE8pIHtcbiAgICAgICAgICB2YXIgeWUgPSBWKE8pO1xuICAgICAgICAgIHJldHVybiB5ZSA9PT0gXCJzeW1ib2xcIiA/IFN0cmluZyhPKSA6IE87XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IGYoXCJJbnZhbGlkIFwiICsgWCArIFwiIGBcIiArIF8gKyBcImAgb2YgdmFsdWUgYFwiICsgU3RyaW5nKHEpICsgXCJgIFwiICsgKFwic3VwcGxpZWQgdG8gYFwiICsgSCArIFwiYCwgZXhwZWN0ZWQgb25lIG9mIFwiICsgcmUgKyBcIi5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFMoSSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEwoUikge1xuICAgICAgZnVuY3Rpb24gSShKLCBRLCBILCBYLCBfKSB7XG4gICAgICAgIGlmICh0eXBlb2YgUiAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIG5ldyBmKFwiUHJvcGVydHkgYFwiICsgXyArIFwiYCBvZiBjb21wb25lbnQgYFwiICsgSCArIFwiYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuXCIpO1xuICAgICAgICB2YXIgcSA9IEpbUV0sIEcgPSBVKHEpO1xuICAgICAgICBpZiAoRyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm4gbmV3IGYoXCJJbnZhbGlkIFwiICsgWCArIFwiIGBcIiArIF8gKyBcImAgb2YgdHlwZSBcIiArIChcImBcIiArIEcgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgSCArIFwiYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LlwiKSk7XG4gICAgICAgIGZvciAodmFyIHJlIGluIHEpXG4gICAgICAgICAgaWYgKG4ocSwgcmUpKSB7XG4gICAgICAgICAgICB2YXIgWiA9IFIocSwgcmUsIEgsIFgsIF8gKyBcIi5cIiArIHJlLCByKTtcbiAgICAgICAgICAgIGlmIChaIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgICAgICAgIHJldHVybiBaO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gUyhJKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQihSKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoUikpXG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaShcIkludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS5cIiksIHM7XG4gICAgICBmb3IgKHZhciBJID0gMDsgSSA8IFIubGVuZ3RoOyBJKyspIHtcbiAgICAgICAgdmFyIEogPSBSW0ldO1xuICAgICAgICBpZiAodHlwZW9mIEogIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBpKFxuICAgICAgICAgICAgXCJJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgcmVjZWl2ZWQgXCIgKyB0ZShKKSArIFwiIGF0IGluZGV4IFwiICsgSSArIFwiLlwiXG4gICAgICAgICAgKSwgcztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFEoSCwgWCwgXywgcSwgRykge1xuICAgICAgICBmb3IgKHZhciByZSA9IFtdLCBaID0gMDsgWiA8IFIubGVuZ3RoOyBaKyspIHtcbiAgICAgICAgICB2YXIgYWUgPSBSW1pdLCBPID0gYWUoSCwgWCwgXywgcSwgRywgcik7XG4gICAgICAgICAgaWYgKE8gPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIE8uZGF0YSAmJiBuKE8uZGF0YSwgXCJleHBlY3RlZFR5cGVcIikgJiYgcmUucHVzaChPLmRhdGEuZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeWUgPSByZS5sZW5ndGggPiAwID8gXCIsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFtcIiArIHJlLmpvaW4oXCIsIFwiKSArIFwiXVwiIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG5ldyBmKFwiSW52YWxpZCBcIiArIHEgKyBcIiBgXCIgKyBHICsgXCJgIHN1cHBsaWVkIHRvIFwiICsgKFwiYFwiICsgXyArIFwiYFwiICsgeWUgKyBcIi5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFMoUSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQoKSB7XG4gICAgICBmdW5jdGlvbiBSKEksIEosIFEsIEgsIFgpIHtcbiAgICAgICAgcmV0dXJuIFcoSVtKXSkgPyBudWxsIDogbmV3IGYoXCJJbnZhbGlkIFwiICsgSCArIFwiIGBcIiArIFggKyBcImAgc3VwcGxpZWQgdG8gXCIgKyAoXCJgXCIgKyBRICsgXCJgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFMoUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEEoUiwgSSwgSiwgUSwgSCkge1xuICAgICAgcmV0dXJuIG5ldyBmKFxuICAgICAgICAoUiB8fCBcIlJlYWN0IGNsYXNzXCIpICsgXCI6IFwiICsgSSArIFwiIHR5cGUgYFwiICsgSiArIFwiLlwiICsgUSArIFwiYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgXCIgKyBIICsgXCJgLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBEKFIpIHtcbiAgICAgIGZ1bmN0aW9uIEkoSiwgUSwgSCwgWCwgXykge1xuICAgICAgICB2YXIgcSA9IEpbUV0sIEcgPSBVKHEpO1xuICAgICAgICBpZiAoRyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm4gbmV3IGYoXCJJbnZhbGlkIFwiICsgWCArIFwiIGBcIiArIF8gKyBcImAgb2YgdHlwZSBgXCIgKyBHICsgXCJgIFwiICsgKFwic3VwcGxpZWQgdG8gYFwiICsgSCArIFwiYCwgZXhwZWN0ZWQgYG9iamVjdGAuXCIpKTtcbiAgICAgICAgZm9yICh2YXIgcmUgaW4gUikge1xuICAgICAgICAgIHZhciBaID0gUltyZV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBaICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHJldHVybiBBKEgsIFgsIF8sIHJlLCBWKFopKTtcbiAgICAgICAgICB2YXIgYWUgPSBaKHEsIHJlLCBILCBYLCBfICsgXCIuXCIgKyByZSwgcik7XG4gICAgICAgICAgaWYgKGFlKVxuICAgICAgICAgICAgcmV0dXJuIGFlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFMoSSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGooUikge1xuICAgICAgZnVuY3Rpb24gSShKLCBRLCBILCBYLCBfKSB7XG4gICAgICAgIHZhciBxID0gSltRXSwgRyA9IFUocSk7XG4gICAgICAgIGlmIChHICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgIHJldHVybiBuZXcgZihcIkludmFsaWQgXCIgKyBYICsgXCIgYFwiICsgXyArIFwiYCBvZiB0eXBlIGBcIiArIEcgKyBcImAgXCIgKyAoXCJzdXBwbGllZCB0byBgXCIgKyBIICsgXCJgLCBleHBlY3RlZCBgb2JqZWN0YC5cIikpO1xuICAgICAgICB2YXIgcmUgPSB0KHt9LCBKW1FdLCBSKTtcbiAgICAgICAgZm9yICh2YXIgWiBpbiByZSkge1xuICAgICAgICAgIHZhciBhZSA9IFJbWl07XG4gICAgICAgICAgaWYgKG4oUiwgWikgJiYgdHlwZW9mIGFlICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHJldHVybiBBKEgsIFgsIF8sIFosIFYoYWUpKTtcbiAgICAgICAgICBpZiAoIWFlKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBmKFxuICAgICAgICAgICAgICBcIkludmFsaWQgXCIgKyBYICsgXCIgYFwiICsgXyArIFwiYCBrZXkgYFwiICsgWiArIFwiYCBzdXBwbGllZCB0byBgXCIgKyBIICsgXCJgLlxcbkJhZCBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoSltRXSwgbnVsbCwgXCIgIFwiKSArIGBcblZhbGlkIGtleXM6IGAgKyBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhSKSwgbnVsbCwgXCIgIFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgTyA9IGFlKHEsIFosIEgsIFgsIF8gKyBcIi5cIiArIFosIHIpO1xuICAgICAgICAgIGlmIChPKVxuICAgICAgICAgICAgcmV0dXJuIE87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gUyhJKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVyhSKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBSKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIHJldHVybiAhUjtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KFIpKVxuICAgICAgICAgICAgcmV0dXJuIFIuZXZlcnkoVyk7XG4gICAgICAgICAgaWYgKFIgPT09IG51bGwgfHwgYyhSKSlcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICB2YXIgSSA9IG0oUik7XG4gICAgICAgICAgaWYgKEkpIHtcbiAgICAgICAgICAgIHZhciBKID0gSS5jYWxsKFIpLCBRO1xuICAgICAgICAgICAgaWYgKEkgIT09IFIuZW50cmllcykge1xuICAgICAgICAgICAgICBmb3IgKDsgIShRID0gSi5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgICAgICBpZiAoIVcoUS52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgZm9yICg7ICEoUSA9IEoubmV4dCgpKS5kb25lOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgSCA9IFEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKEggJiYgIVcoSFsxXSkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB6KFIsIEkpIHtcbiAgICAgIHJldHVybiBSID09PSBcInN5bWJvbFwiID8gITAgOiBJID8gSVtcIkBAdG9TdHJpbmdUYWdcIl0gPT09IFwiU3ltYm9sXCIgfHwgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgSSBpbnN0YW5jZW9mIFN5bWJvbCA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVKFIpIHtcbiAgICAgIHZhciBJID0gdHlwZW9mIFI7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShSKSA/IFwiYXJyYXlcIiA6IFIgaW5zdGFuY2VvZiBSZWdFeHAgPyBcIm9iamVjdFwiIDogeihJLCBSKSA/IFwic3ltYm9sXCIgOiBJO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWKFIpIHtcbiAgICAgIGlmICh0eXBlb2YgUiA+IFwidVwiIHx8IFIgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBcIlwiICsgUjtcbiAgICAgIHZhciBJID0gVShSKTtcbiAgICAgIGlmIChJID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChSIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICByZXR1cm4gXCJkYXRlXCI7XG4gICAgICAgIGlmIChSIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICAgIHJldHVybiBcInJlZ2V4cFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlKFIpIHtcbiAgICAgIHZhciBJID0gVihSKTtcbiAgICAgIHN3aXRjaCAoSSkge1xuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIHJldHVybiBcImFuIFwiICsgSTtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgY2FzZSBcInJlZ2V4cFwiOlxuICAgICAgICAgIHJldHVybiBcImEgXCIgKyBJO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBJO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBGKFIpIHtcbiAgICAgIHJldHVybiAhUi5jb25zdHJ1Y3RvciB8fCAhUi5jb25zdHJ1Y3Rvci5uYW1lID8gZyA6IFIuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHguY2hlY2tQcm9wVHlwZXMgPSBvLCB4LnJlc2V0V2FybmluZ0NhY2hlID0gby5yZXNldFdhcm5pbmdDYWNoZSwgeC5Qcm9wVHlwZXMgPSB4LCB4O1xuICB9LCBKbjtcbn1cbnZhciBRbiwga2k7XG5mdW5jdGlvbiBsbCgpIHtcbiAgaWYgKGtpKSByZXR1cm4gUW47XG4gIGtpID0gMTtcbiAgdmFyIGUgPSAvKiBAX19QVVJFX18gKi8gUG8oKTtcbiAgZnVuY3Rpb24gdCgpIHtcbiAgfVxuICBmdW5jdGlvbiByKCkge1xuICB9XG4gIHJldHVybiByLnJlc2V0V2FybmluZ0NhY2hlID0gdCwgUW4gPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBuKHMsIGMsIGwsIHUsIHAsIG0pIHtcbiAgICAgIGlmIChtICE9PSBlKSB7XG4gICAgICAgIHZhciBnID0gbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlc1wiXG4gICAgICAgICk7XG4gICAgICAgIHRocm93IGcubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBnO1xuICAgICAgfVxuICAgIH1cbiAgICBuLmlzUmVxdWlyZWQgPSBuO1xuICAgIGZ1bmN0aW9uIG8oKSB7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgdmFyIGkgPSB7XG4gICAgICBhcnJheTogbixcbiAgICAgIGJpZ2ludDogbixcbiAgICAgIGJvb2w6IG4sXG4gICAgICBmdW5jOiBuLFxuICAgICAgbnVtYmVyOiBuLFxuICAgICAgb2JqZWN0OiBuLFxuICAgICAgc3RyaW5nOiBuLFxuICAgICAgc3ltYm9sOiBuLFxuICAgICAgYW55OiBuLFxuICAgICAgYXJyYXlPZjogbyxcbiAgICAgIGVsZW1lbnQ6IG4sXG4gICAgICBlbGVtZW50VHlwZTogbixcbiAgICAgIGluc3RhbmNlT2Y6IG8sXG4gICAgICBub2RlOiBuLFxuICAgICAgb2JqZWN0T2Y6IG8sXG4gICAgICBvbmVPZjogbyxcbiAgICAgIG9uZU9mVHlwZTogbyxcbiAgICAgIHNoYXBlOiBvLFxuICAgICAgZXhhY3Q6IG8sXG4gICAgICBjaGVja1Byb3BUeXBlczogcixcbiAgICAgIHJlc2V0V2FybmluZ0NhY2hlOiB0XG4gICAgfTtcbiAgICByZXR1cm4gaS5Qcm9wVHlwZXMgPSBpLCBpO1xuICB9LCBRbjtcbn1cbnZhciBBaTtcbmZ1bmN0aW9uIHVsKCkge1xuICBpZiAoQWkpIHJldHVybiBxci5leHBvcnRzO1xuICBpZiAoQWkgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgZSA9IE1hKCksIHQgPSAhMDtcbiAgICBxci5leHBvcnRzID0gLyogQF9fUFVSRV9fICovIGNsKCkoZS5pc0VsZW1lbnQsIHQpO1xuICB9IGVsc2VcbiAgICBxci5leHBvcnRzID0gLyogQF9fUFVSRV9fICovIGxsKCkoKTtcbiAgcmV0dXJuIHFyLmV4cG9ydHM7XG59XG52YXIgZmwgPSAvKiBAX19QVVJFX18gKi8gdWwoKTtcbmNvbnN0IGEgPSAvKiBAX19QVVJFX18gKi8gZWMoZmwpO1xuZnVuY3Rpb24gZGwoZSkge1xuICByZXR1cm4gZSA9PSBudWxsIHx8IE9iamVjdC5rZXlzKGUpLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIF9hKGUpIHtcbiAgY29uc3Qge1xuICAgIHN0eWxlczogdCxcbiAgICBkZWZhdWx0VGhlbWU6IHIgPSB7fVxuICB9ID0gZSwgbiA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IChvKSA9PiB0KGRsKG8pID8gciA6IG8pIDogdDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChYYywge1xuICAgIHN0eWxlczogblxuICB9KTtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoX2EucHJvcFR5cGVzID0ge1xuICBkZWZhdWx0VGhlbWU6IGEub2JqZWN0LFxuICBzdHlsZXM6IGEub25lT2ZUeXBlKFthLmFycmF5LCBhLnN0cmluZywgYS5vYmplY3QsIGEuZnVuY10pXG59KTtcbi8qKlxuICogQG11aS9zdHlsZWQtZW5naW5lIHY2LjQuMFxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGphKGUsIHQpIHtcbiAgY29uc3QgciA9IHNvKGUsIHQpO1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gKC4uLm4pID0+IHtcbiAgICBjb25zdCBvID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGBcIiR7ZX1cImAgOiBcImNvbXBvbmVudFwiO1xuICAgIHJldHVybiBuLmxlbmd0aCA9PT0gMCA/IGNvbnNvbGUuZXJyb3IoW2BNVUk6IFNlZW1zIGxpa2UgeW91IGNhbGxlZCBcXGBzdHlsZWQoJHtvfSkoKVxcYCB3aXRob3V0IGEgXFxgc3R5bGVcXGAgYXJndW1lbnQuYCwgJ1lvdSBtdXN0IHByb3ZpZGUgYSBgc3R5bGVzYCBhcmd1bWVudDogYHN0eWxlZChcImRpdlwiKShzdHlsZVlvdUZvcmdvdFRvUGFzcylgLiddLmpvaW4oYFxuYCkpIDogbi5zb21lKChpKSA9PiBpID09PSB2b2lkIDApICYmIGNvbnNvbGUuZXJyb3IoYE1VSTogdGhlIHN0eWxlZCgke299KSguLi5hcmdzKSBBUEkgcmVxdWlyZXMgYWxsIGl0cyBhcmdzIHRvIGJlIGRlZmluZWQuYCksIHIoLi4ubik7XG4gIH0gOiByO1xufVxuZnVuY3Rpb24gcGwoZSwgdCkge1xuICBBcnJheS5pc0FycmF5KGUuX19lbW90aW9uX3N0eWxlcykgJiYgKGUuX19lbW90aW9uX3N0eWxlcyA9IHQoZS5fX2Vtb3Rpb25fc3R5bGVzKSk7XG59XG5jb25zdCBOaSA9IFtdO1xuZnVuY3Rpb24gTWkoZSkge1xuICByZXR1cm4gTmlbMF0gPSBlLCBOcihOaSk7XG59XG52YXIgS3IgPSB7IGV4cG9ydHM6IHt9IH0sIHhlID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIElpO1xuZnVuY3Rpb24gbWwoKSB7XG4gIGlmIChJaSkgcmV0dXJuIHhlO1xuICBJaSA9IDE7XG4gIHZhciBlID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLCB0ID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgciA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgbyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgaSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSwgcyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCBjID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCBsID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCB1ID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIHAgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLCBnID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSwgeCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpO1xuICBmdW5jdGlvbiB5KGYpIHtcbiAgICBpZiAodHlwZW9mIGYgPT0gXCJvYmplY3RcIiAmJiBmICE9PSBudWxsKSB7XG4gICAgICB2YXIgUyA9IGYuJCR0eXBlb2Y7XG4gICAgICBzd2l0Y2ggKFMpIHtcbiAgICAgICAgY2FzZSBlOlxuICAgICAgICAgIHN3aXRjaCAoZiA9IGYudHlwZSwgZikge1xuICAgICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgY2FzZSBvOlxuICAgICAgICAgICAgY2FzZSBuOlxuICAgICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHN3aXRjaCAoZiA9IGYgJiYgZi4kJHR5cGVvZiwgZikge1xuICAgICAgICAgICAgICAgIGNhc2UgczpcbiAgICAgICAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICAgICAgY2FzZSBtOlxuICAgICAgICAgICAgICAgIGNhc2UgcDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgICAgIGNhc2UgaTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gUztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSB0OlxuICAgICAgICAgIHJldHVybiBTO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4geGUuQ29udGV4dENvbnN1bWVyID0gaSwgeGUuQ29udGV4dFByb3ZpZGVyID0gcywgeGUuRWxlbWVudCA9IGUsIHhlLkZvcndhcmRSZWYgPSBjLCB4ZS5GcmFnbWVudCA9IHIsIHhlLkxhenkgPSBtLCB4ZS5NZW1vID0gcCwgeGUuUG9ydGFsID0gdCwgeGUuUHJvZmlsZXIgPSBvLCB4ZS5TdHJpY3RNb2RlID0gbiwgeGUuU3VzcGVuc2UgPSBsLCB4ZS5TdXNwZW5zZUxpc3QgPSB1LCB4ZS5pc0NvbnRleHRDb25zdW1lciA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4geShmKSA9PT0gaTtcbiAgfSwgeGUuaXNDb250ZXh0UHJvdmlkZXIgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHkoZikgPT09IHM7XG4gIH0sIHhlLmlzRWxlbWVudCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdHlwZW9mIGYgPT0gXCJvYmplY3RcIiAmJiBmICE9PSBudWxsICYmIGYuJCR0eXBlb2YgPT09IGU7XG4gIH0sIHhlLmlzRm9yd2FyZFJlZiA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4geShmKSA9PT0gYztcbiAgfSwgeGUuaXNGcmFnbWVudCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4geShmKSA9PT0gcjtcbiAgfSwgeGUuaXNMYXp5ID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB5KGYpID09PSBtO1xuICB9LCB4ZS5pc01lbW8gPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHkoZikgPT09IHA7XG4gIH0sIHhlLmlzUG9ydGFsID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB5KGYpID09PSB0O1xuICB9LCB4ZS5pc1Byb2ZpbGVyID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB5KGYpID09PSBvO1xuICB9LCB4ZS5pc1N0cmljdE1vZGUgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHkoZikgPT09IG47XG4gIH0sIHhlLmlzU3VzcGVuc2UgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHkoZikgPT09IGw7XG4gIH0sIHhlLmlzU3VzcGVuc2VMaXN0ID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB5KGYpID09PSB1O1xuICB9LCB4ZS5pc1ZhbGlkRWxlbWVudFR5cGUgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBmID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGYgPT0gXCJmdW5jdGlvblwiIHx8IGYgPT09IHIgfHwgZiA9PT0gbyB8fCBmID09PSBuIHx8IGYgPT09IGwgfHwgZiA9PT0gdSB8fCBmID09PSBnIHx8IHR5cGVvZiBmID09IFwib2JqZWN0XCIgJiYgZiAhPT0gbnVsbCAmJiAoZi4kJHR5cGVvZiA9PT0gbSB8fCBmLiQkdHlwZW9mID09PSBwIHx8IGYuJCR0eXBlb2YgPT09IHMgfHwgZi4kJHR5cGVvZiA9PT0gaSB8fCBmLiQkdHlwZW9mID09PSBjIHx8IGYuJCR0eXBlb2YgPT09IHggfHwgZi5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKTtcbiAgfSwgeGUudHlwZU9mID0geSwgeGU7XG59XG52YXIgU2UgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIF9pO1xuZnVuY3Rpb24gaGwoKSB7XG4gIHJldHVybiBfaSB8fCAoX2kgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZShmKSB7XG4gICAgICBpZiAodHlwZW9mIGYgPT0gXCJvYmplY3RcIiAmJiBmICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBTID0gZi4kJHR5cGVvZjtcbiAgICAgICAgc3dpdGNoIChTKSB7XG4gICAgICAgICAgY2FzZSB0OlxuICAgICAgICAgICAgc3dpdGNoIChmID0gZi50eXBlLCBmKSB7XG4gICAgICAgICAgICAgIGNhc2UgbjpcbiAgICAgICAgICAgICAgY2FzZSBpOlxuICAgICAgICAgICAgICBjYXNlIG86XG4gICAgICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgICAgY2FzZSBwOlxuICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZiA9IGYgJiYgZi4kJHR5cGVvZiwgZikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBjOlxuICAgICAgICAgICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgICAgICAgY2FzZSBnOlxuICAgICAgICAgICAgICAgICAgY2FzZSBtOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgICAgICAgIGNhc2UgczpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgcmV0dXJuIFM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHQgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksIHIgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCBuID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBvID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBpID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBzID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLCBjID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIGwgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIHUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIHAgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBnID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIHggPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCB5ID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIik7XG4gICAgU2UuQ29udGV4dENvbnN1bWVyID0gcywgU2UuQ29udGV4dFByb3ZpZGVyID0gYywgU2UuRWxlbWVudCA9IHQsIFNlLkZvcndhcmRSZWYgPSBsLCBTZS5GcmFnbWVudCA9IG4sIFNlLkxhenkgPSBnLCBTZS5NZW1vID0gbSwgU2UuUG9ydGFsID0gciwgU2UuUHJvZmlsZXIgPSBpLCBTZS5TdHJpY3RNb2RlID0gbywgU2UuU3VzcGVuc2UgPSB1LCBTZS5TdXNwZW5zZUxpc3QgPSBwLCBTZS5pc0NvbnRleHRDb25zdW1lciA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBlKGYpID09PSBzO1xuICAgIH0sIFNlLmlzQ29udGV4dFByb3ZpZGVyID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGUoZikgPT09IGM7XG4gICAgfSwgU2UuaXNFbGVtZW50ID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBmID09IFwib2JqZWN0XCIgJiYgZiAhPT0gbnVsbCAmJiBmLiQkdHlwZW9mID09PSB0O1xuICAgIH0sIFNlLmlzRm9yd2FyZFJlZiA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBlKGYpID09PSBsO1xuICAgIH0sIFNlLmlzRnJhZ21lbnQgPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZShmKSA9PT0gbjtcbiAgICB9LCBTZS5pc0xhenkgPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZShmKSA9PT0gZztcbiAgICB9LCBTZS5pc01lbW8gPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZShmKSA9PT0gbTtcbiAgICB9LCBTZS5pc1BvcnRhbCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBlKGYpID09PSByO1xuICAgIH0sIFNlLmlzUHJvZmlsZXIgPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZShmKSA9PT0gaTtcbiAgICB9LCBTZS5pc1N0cmljdE1vZGUgPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZShmKSA9PT0gbztcbiAgICB9LCBTZS5pc1N1c3BlbnNlID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGUoZikgPT09IHU7XG4gICAgfSwgU2UuaXNTdXNwZW5zZUxpc3QgPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZShmKSA9PT0gcDtcbiAgICB9LCBTZS5pc1ZhbGlkRWxlbWVudFR5cGUgPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGYgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZiA9PSBcImZ1bmN0aW9uXCIgfHwgZiA9PT0gbiB8fCBmID09PSBpIHx8IGYgPT09IG8gfHwgZiA9PT0gdSB8fCBmID09PSBwIHx8IGYgPT09IHggfHwgdHlwZW9mIGYgPT0gXCJvYmplY3RcIiAmJiBmICE9PSBudWxsICYmIChmLiQkdHlwZW9mID09PSBnIHx8IGYuJCR0eXBlb2YgPT09IG0gfHwgZi4kJHR5cGVvZiA9PT0gYyB8fCBmLiQkdHlwZW9mID09PSBzIHx8IGYuJCR0eXBlb2YgPT09IGwgfHwgZi4kJHR5cGVvZiA9PT0geSB8fCBmLmdldE1vZHVsZUlkICE9PSB2b2lkIDApO1xuICAgIH0sIFNlLnR5cGVPZiA9IGU7XG4gIH0oKSksIFNlO1xufVxudmFyIGppO1xuZnVuY3Rpb24gZ2woKSB7XG4gIHJldHVybiBqaSB8fCAoamkgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBLci5leHBvcnRzID0gLyogQF9fUFVSRV9fICovIG1sKCkgOiBLci5leHBvcnRzID0gLyogQF9fUFVSRV9fICovIGhsKCkpLCBLci5leHBvcnRzO1xufVxudmFyIHBuID0gLyogQF9fUFVSRV9fICovIGdsKCk7XG5mdW5jdGlvbiBndChlKSB7XG4gIGlmICh0eXBlb2YgZSAhPSBcIm9iamVjdFwiIHx8IGUgPT09IG51bGwpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCB0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO1xuICByZXR1cm4gKHQgPT09IG51bGwgfHwgdCA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkgPT09IG51bGwpICYmICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGUpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIGUpO1xufVxuZnVuY3Rpb24gRGEoZSkge1xuICBpZiAoLyogQF9fUFVSRV9fICovIEMuaXNWYWxpZEVsZW1lbnQoZSkgfHwgcG4uaXNWYWxpZEVsZW1lbnRUeXBlKGUpIHx8ICFndChlKSlcbiAgICByZXR1cm4gZTtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgocikgPT4ge1xuICAgIHRbcl0gPSBEYShlW3JdKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiB0dChlLCB0LCByID0ge1xuICBjbG9uZTogITBcbn0pIHtcbiAgY29uc3QgbiA9IHIuY2xvbmUgPyB7XG4gICAgLi4uZVxuICB9IDogZTtcbiAgcmV0dXJuIGd0KGUpICYmIGd0KHQpICYmIE9iamVjdC5rZXlzKHQpLmZvckVhY2goKG8pID0+IHtcbiAgICAvKiBAX19QVVJFX18gKi8gQy5pc1ZhbGlkRWxlbWVudCh0W29dKSB8fCBwbi5pc1ZhbGlkRWxlbWVudFR5cGUodFtvXSkgPyBuW29dID0gdFtvXSA6IGd0KHRbb10pICYmIC8vIEF2b2lkIHByb3RvdHlwZSBwb2xsdXRpb25cbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgbykgJiYgZ3QoZVtvXSkgPyBuW29dID0gdHQoZVtvXSwgdFtvXSwgcikgOiByLmNsb25lID8gbltvXSA9IGd0KHRbb10pID8gRGEodFtvXSkgOiB0W29dIDogbltvXSA9IHRbb107XG4gIH0pLCBuO1xufVxuY29uc3QgeWwgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gT2JqZWN0LmtleXMoZSkubWFwKChyKSA9PiAoe1xuICAgIGtleTogcixcbiAgICB2YWw6IGVbcl1cbiAgfSkpIHx8IFtdO1xuICByZXR1cm4gdC5zb3J0KChyLCBuKSA9PiByLnZhbCAtIG4udmFsKSwgdC5yZWR1Y2UoKHIsIG4pID0+ICh7XG4gICAgLi4ucixcbiAgICBbbi5rZXldOiBuLnZhbFxuICB9KSwge30pO1xufTtcbmZ1bmN0aW9uIGJsKGUpIHtcbiAgY29uc3Qge1xuICAgIC8vIFRoZSBicmVha3BvaW50ICoqc3RhcnQqKiBhdCB0aGlzIHZhbHVlLlxuICAgIC8vIEZvciBpbnN0YW5jZSB3aXRoIHRoZSBmaXJzdCBicmVha3BvaW50IHhzOiBbeHMsIHNtKS5cbiAgICB2YWx1ZXM6IHQgPSB7XG4gICAgICB4czogMCxcbiAgICAgIC8vIHBob25lXG4gICAgICBzbTogNjAwLFxuICAgICAgLy8gdGFibGV0XG4gICAgICBtZDogOTAwLFxuICAgICAgLy8gc21hbGwgbGFwdG9wXG4gICAgICBsZzogMTIwMCxcbiAgICAgIC8vIGRlc2t0b3BcbiAgICAgIHhsOiAxNTM2XG4gICAgICAvLyBsYXJnZSBzY3JlZW5cbiAgICB9LFxuICAgIHVuaXQ6IHIgPSBcInB4XCIsXG4gICAgc3RlcDogbiA9IDUsXG4gICAgLi4ub1xuICB9ID0gZSwgaSA9IHlsKHQpLCBzID0gT2JqZWN0LmtleXMoaSk7XG4gIGZ1bmN0aW9uIGMoZykge1xuICAgIHJldHVybiBgQG1lZGlhIChtaW4td2lkdGg6JHt0eXBlb2YgdFtnXSA9PSBcIm51bWJlclwiID8gdFtnXSA6IGd9JHtyfSlgO1xuICB9XG4gIGZ1bmN0aW9uIGwoZykge1xuICAgIHJldHVybiBgQG1lZGlhIChtYXgtd2lkdGg6JHsodHlwZW9mIHRbZ10gPT0gXCJudW1iZXJcIiA/IHRbZ10gOiBnKSAtIG4gLyAxMDB9JHtyfSlgO1xuICB9XG4gIGZ1bmN0aW9uIHUoZywgeCkge1xuICAgIGNvbnN0IHkgPSBzLmluZGV4T2YoeCk7XG4gICAgcmV0dXJuIGBAbWVkaWEgKG1pbi13aWR0aDoke3R5cGVvZiB0W2ddID09IFwibnVtYmVyXCIgPyB0W2ddIDogZ30ke3J9KSBhbmQgKG1heC13aWR0aDokeyh5ICE9PSAtMSAmJiB0eXBlb2YgdFtzW3ldXSA9PSBcIm51bWJlclwiID8gdFtzW3ldXSA6IHgpIC0gbiAvIDEwMH0ke3J9KWA7XG4gIH1cbiAgZnVuY3Rpb24gcChnKSB7XG4gICAgcmV0dXJuIHMuaW5kZXhPZihnKSArIDEgPCBzLmxlbmd0aCA/IHUoZywgc1tzLmluZGV4T2YoZykgKyAxXSkgOiBjKGcpO1xuICB9XG4gIGZ1bmN0aW9uIG0oZykge1xuICAgIGNvbnN0IHggPSBzLmluZGV4T2YoZyk7XG4gICAgcmV0dXJuIHggPT09IDAgPyBjKHNbMV0pIDogeCA9PT0gcy5sZW5ndGggLSAxID8gbChzW3hdKSA6IHUoZywgc1tzLmluZGV4T2YoZykgKyAxXSkucmVwbGFjZShcIkBtZWRpYVwiLCBcIkBtZWRpYSBub3QgYWxsIGFuZFwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGtleXM6IHMsXG4gICAgdmFsdWVzOiBpLFxuICAgIHVwOiBjLFxuICAgIGRvd246IGwsXG4gICAgYmV0d2VlbjogdSxcbiAgICBvbmx5OiBwLFxuICAgIG5vdDogbSxcbiAgICB1bml0OiByLFxuICAgIC4uLm9cbiAgfTtcbn1cbmZ1bmN0aW9uIHZsKGUsIHQpIHtcbiAgaWYgKCFlLmNvbnRhaW5lclF1ZXJpZXMpXG4gICAgcmV0dXJuIHQ7XG4gIGNvbnN0IHIgPSBPYmplY3Qua2V5cyh0KS5maWx0ZXIoKG4pID0+IG4uc3RhcnRzV2l0aChcIkBjb250YWluZXJcIikpLnNvcnQoKG4sIG8pID0+IHtcbiAgICB2YXIgcywgYztcbiAgICBjb25zdCBpID0gL21pbi13aWR0aDpcXHMqKFswLTkuXSspLztcbiAgICByZXR1cm4gKygoKHMgPSBuLm1hdGNoKGkpKSA9PSBudWxsID8gdm9pZCAwIDogc1sxXSkgfHwgMCkgLSArKCgoYyA9IG8ubWF0Y2goaSkpID09IG51bGwgPyB2b2lkIDAgOiBjWzFdKSB8fCAwKTtcbiAgfSk7XG4gIHJldHVybiByLmxlbmd0aCA/IHIucmVkdWNlKChuLCBvKSA9PiB7XG4gICAgY29uc3QgaSA9IHRbb107XG4gICAgcmV0dXJuIGRlbGV0ZSBuW29dLCBuW29dID0gaSwgbjtcbiAgfSwge1xuICAgIC4uLnRcbiAgfSkgOiB0O1xufVxuZnVuY3Rpb24geGwoZSwgdCkge1xuICByZXR1cm4gdCA9PT0gXCJAXCIgfHwgdC5zdGFydHNXaXRoKFwiQFwiKSAmJiAoZS5zb21lKChyKSA9PiB0LnN0YXJ0c1dpdGgoYEAke3J9YCkpIHx8ICEhdC5tYXRjaCgvXkBcXGQvKSk7XG59XG5mdW5jdGlvbiBTbChlLCB0KSB7XG4gIGNvbnN0IHIgPSB0Lm1hdGNoKC9eQChbXi9dKyk/XFwvPyguKyk/JC8pO1xuICBpZiAoIXIpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGBNVUk6IFRoZSBwcm92aWRlZCBzaG9ydGhhbmQgJHtgKCR7dH0pYH0gaXMgaW52YWxpZC4gVGhlIGZvcm1hdCBzaG91bGQgYmUgXFxgQDxicmVha3BvaW50IHwgbnVtYmVyPlxcYCBvciBcXGBAPGJyZWFrcG9pbnQgfCBudW1iZXI+Lzxjb250YWluZXI+XFxgLlxuRm9yIGV4YW1wbGUsIFxcYEBzbVxcYCBvciBcXGBANjAwXFxgIG9yIFxcYEA0MHJlbS9zaWRlYmFyXFxgLmAgOiBrdCgxOCwgYCgke3R9KWApKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBbLCBuLCBvXSA9IHIsIGkgPSBOdW1iZXIuaXNOYU4oK24pID8gbiB8fCAwIDogK247XG4gIHJldHVybiBlLmNvbnRhaW5lclF1ZXJpZXMobykudXAoaSk7XG59XG5mdW5jdGlvbiBFbChlKSB7XG4gIGNvbnN0IHQgPSAoaSwgcykgPT4gaS5yZXBsYWNlKFwiQG1lZGlhXCIsIHMgPyBgQGNvbnRhaW5lciAke3N9YCA6IFwiQGNvbnRhaW5lclwiKTtcbiAgZnVuY3Rpb24gcihpLCBzKSB7XG4gICAgaS51cCA9ICguLi5jKSA9PiB0KGUuYnJlYWtwb2ludHMudXAoLi4uYyksIHMpLCBpLmRvd24gPSAoLi4uYykgPT4gdChlLmJyZWFrcG9pbnRzLmRvd24oLi4uYyksIHMpLCBpLmJldHdlZW4gPSAoLi4uYykgPT4gdChlLmJyZWFrcG9pbnRzLmJldHdlZW4oLi4uYyksIHMpLCBpLm9ubHkgPSAoLi4uYykgPT4gdChlLmJyZWFrcG9pbnRzLm9ubHkoLi4uYyksIHMpLCBpLm5vdCA9ICguLi5jKSA9PiB7XG4gICAgICBjb25zdCBsID0gdChlLmJyZWFrcG9pbnRzLm5vdCguLi5jKSwgcyk7XG4gICAgICByZXR1cm4gbC5pbmNsdWRlcyhcIm5vdCBhbGwgYW5kXCIpID8gbC5yZXBsYWNlKFwibm90IGFsbCBhbmQgXCIsIFwiXCIpLnJlcGxhY2UoXCJtaW4td2lkdGg6XCIsIFwid2lkdGg8XCIpLnJlcGxhY2UoXCJtYXgtd2lkdGg6XCIsIFwid2lkdGg+XCIpLnJlcGxhY2UoXCJhbmRcIiwgXCJvclwiKSA6IGw7XG4gICAgfTtcbiAgfVxuICBjb25zdCBuID0ge30sIG8gPSAoaSkgPT4gKHIobiwgaSksIG4pO1xuICByZXR1cm4gcihvKSwge1xuICAgIC4uLmUsXG4gICAgY29udGFpbmVyUXVlcmllczogb1xuICB9O1xufVxuY29uc3QgQ2wgPSB7XG4gIGJvcmRlclJhZGl1czogNFxufSwgTXQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBhLm9uZU9mVHlwZShbYS5udW1iZXIsIGEuc3RyaW5nLCBhLm9iamVjdCwgYS5hcnJheV0pIDoge307XG5mdW5jdGlvbiB2cihlLCB0KSB7XG4gIHJldHVybiB0ID8gdHQoZSwgdCwge1xuICAgIGNsb25lOiAhMVxuICAgIC8vIE5vIG5lZWQgdG8gY2xvbmUgZGVlcCwgaXQncyB3YXkgZmFzdGVyLlxuICB9KSA6IGU7XG59XG5jb25zdCBrbiA9IHtcbiAgeHM6IDAsXG4gIC8vIHBob25lXG4gIHNtOiA2MDAsXG4gIC8vIHRhYmxldFxuICBtZDogOTAwLFxuICAvLyBzbWFsbCBsYXB0b3BcbiAgbGc6IDEyMDAsXG4gIC8vIGRlc2t0b3BcbiAgeGw6IDE1MzZcbiAgLy8gbGFyZ2Ugc2NyZWVuXG59LCBEaSA9IHtcbiAgLy8gU29ydGVkIEFTQyBieSBzaXplLiBUaGF0J3MgaW1wb3J0YW50LlxuICAvLyBJdCBjYW4ndCBiZSBjb25maWd1cmVkIGFzIGl0J3MgdXNlZCBzdGF0aWNhbGx5IGZvciBwcm9wVHlwZXMuXG4gIGtleXM6IFtcInhzXCIsIFwic21cIiwgXCJtZFwiLCBcImxnXCIsIFwieGxcIl0sXG4gIHVwOiAoZSkgPT4gYEBtZWRpYSAobWluLXdpZHRoOiR7a25bZV19cHgpYFxufSwgVGwgPSB7XG4gIGNvbnRhaW5lclF1ZXJpZXM6IChlKSA9PiAoe1xuICAgIHVwOiAodCkgPT4ge1xuICAgICAgbGV0IHIgPSB0eXBlb2YgdCA9PSBcIm51bWJlclwiID8gdCA6IGtuW3RdIHx8IHQ7XG4gICAgICByZXR1cm4gdHlwZW9mIHIgPT0gXCJudW1iZXJcIiAmJiAociA9IGAke3J9cHhgKSwgZSA/IGBAY29udGFpbmVyICR7ZX0gKG1pbi13aWR0aDoke3J9KWAgOiBgQGNvbnRhaW5lciAobWluLXdpZHRoOiR7cn0pYDtcbiAgICB9XG4gIH0pXG59O1xuZnVuY3Rpb24gT3QoZSwgdCwgcikge1xuICBjb25zdCBuID0gZS50aGVtZSB8fCB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICBjb25zdCBpID0gbi5icmVha3BvaW50cyB8fCBEaTtcbiAgICByZXR1cm4gdC5yZWR1Y2UoKHMsIGMsIGwpID0+IChzW2kudXAoaS5rZXlzW2xdKV0gPSByKHRbbF0pLCBzKSwge30pO1xuICB9XG4gIGlmICh0eXBlb2YgdCA9PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgaSA9IG4uYnJlYWtwb2ludHMgfHwgRGk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLnJlZHVjZSgocywgYykgPT4ge1xuICAgICAgaWYgKHhsKGkua2V5cywgYykpIHtcbiAgICAgICAgY29uc3QgbCA9IFNsKG4uY29udGFpbmVyUXVlcmllcyA/IG4gOiBUbCwgYyk7XG4gICAgICAgIGwgJiYgKHNbbF0gPSByKHRbY10sIGMpKTtcbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmtleXMoaS52YWx1ZXMgfHwga24pLmluY2x1ZGVzKGMpKSB7XG4gICAgICAgIGNvbnN0IGwgPSBpLnVwKGMpO1xuICAgICAgICBzW2xdID0gcih0W2NdLCBjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGwgPSBjO1xuICAgICAgICBzW2xdID0gdFtsXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH0sIHt9KTtcbiAgfVxuICByZXR1cm4gcih0KTtcbn1cbmZ1bmN0aW9uIHdsKGUgPSB7fSkge1xuICB2YXIgcjtcbiAgcmV0dXJuICgociA9IGUua2V5cykgPT0gbnVsbCA/IHZvaWQgMCA6IHIucmVkdWNlKChuLCBvKSA9PiB7XG4gICAgY29uc3QgaSA9IGUudXAobyk7XG4gICAgcmV0dXJuIG5baV0gPSB7fSwgbjtcbiAgfSwge30pKSB8fCB7fTtcbn1cbmZ1bmN0aW9uIE9sKGUsIHQpIHtcbiAgcmV0dXJuIGUucmVkdWNlKChyLCBuKSA9PiB7XG4gICAgY29uc3QgbyA9IHJbbl07XG4gICAgcmV0dXJuICghbyB8fCBPYmplY3Qua2V5cyhvKS5sZW5ndGggPT09IDApICYmIGRlbGV0ZSByW25dLCByO1xuICB9LCB0KTtcbn1cbmZ1bmN0aW9uIGVlKGUpIHtcbiAgaWYgKHR5cGVvZiBlICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiTVVJOiBgY2FwaXRhbGl6ZShzdHJpbmcpYCBleHBlY3RzIGEgc3RyaW5nIGFyZ3VtZW50LlwiIDoga3QoNykpO1xuICByZXR1cm4gZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGUuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBBbihlLCB0LCByID0gITApIHtcbiAgaWYgKCF0IHx8IHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChlICYmIGUudmFycyAmJiByKSB7XG4gICAgY29uc3QgbiA9IGB2YXJzLiR7dH1gLnNwbGl0KFwiLlwiKS5yZWR1Y2UoKG8sIGkpID0+IG8gJiYgb1tpXSA/IG9baV0gOiBudWxsLCBlKTtcbiAgICBpZiAobiAhPSBudWxsKVxuICAgICAgcmV0dXJuIG47XG4gIH1cbiAgcmV0dXJuIHQuc3BsaXQoXCIuXCIpLnJlZHVjZSgobiwgbykgPT4gbiAmJiBuW29dICE9IG51bGwgPyBuW29dIDogbnVsbCwgZSk7XG59XG5mdW5jdGlvbiBtbihlLCB0LCByLCBuID0gcikge1xuICBsZXQgbztcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IG8gPSBlKHIpIDogQXJyYXkuaXNBcnJheShlKSA/IG8gPSBlW3JdIHx8IG4gOiBvID0gQW4oZSwgcikgfHwgbiwgdCAmJiAobyA9IHQobywgbiwgZSkpLCBvO1xufVxuZnVuY3Rpb24gX2UoZSkge1xuICBjb25zdCB7XG4gICAgcHJvcDogdCxcbiAgICBjc3NQcm9wZXJ0eTogciA9IGUucHJvcCxcbiAgICB0aGVtZUtleTogbixcbiAgICB0cmFuc2Zvcm06IG9cbiAgfSA9IGUsIGkgPSAocykgPT4ge1xuICAgIGlmIChzW3RdID09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjID0gc1t0XSwgbCA9IHMudGhlbWUsIHUgPSBBbihsLCBuKSB8fCB7fTtcbiAgICByZXR1cm4gT3QocywgYywgKG0pID0+IHtcbiAgICAgIGxldCBnID0gbW4odSwgbywgbSk7XG4gICAgICByZXR1cm4gbSA9PT0gZyAmJiB0eXBlb2YgbSA9PSBcInN0cmluZ1wiICYmIChnID0gbW4odSwgbywgYCR7dH0ke20gPT09IFwiZGVmYXVsdFwiID8gXCJcIiA6IGVlKG0pfWAsIG0pKSwgciA9PT0gITEgPyBnIDoge1xuICAgICAgICBbcl06IGdcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBpLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgICBbdF06IE10XG4gIH0gOiB7fSwgaS5maWx0ZXJQcm9wcyA9IFt0XSwgaTtcbn1cbmZ1bmN0aW9uIFJsKGUpIHtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gKHIpID0+ICh0W3JdID09PSB2b2lkIDAgJiYgKHRbcl0gPSBlKHIpKSwgdFtyXSk7XG59XG5jb25zdCAkbCA9IHtcbiAgbTogXCJtYXJnaW5cIixcbiAgcDogXCJwYWRkaW5nXCJcbn0sIFBsID0ge1xuICB0OiBcIlRvcFwiLFxuICByOiBcIlJpZ2h0XCIsXG4gIGI6IFwiQm90dG9tXCIsXG4gIGw6IFwiTGVmdFwiLFxuICB4OiBbXCJMZWZ0XCIsIFwiUmlnaHRcIl0sXG4gIHk6IFtcIlRvcFwiLCBcIkJvdHRvbVwiXVxufSwgTGkgPSB7XG4gIG1hcmdpblg6IFwibXhcIixcbiAgbWFyZ2luWTogXCJteVwiLFxuICBwYWRkaW5nWDogXCJweFwiLFxuICBwYWRkaW5nWTogXCJweVwiXG59LCBrbCA9IFJsKChlKSA9PiB7XG4gIGlmIChlLmxlbmd0aCA+IDIpXG4gICAgaWYgKExpW2VdKVxuICAgICAgZSA9IExpW2VdO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBbZV07XG4gIGNvbnN0IFt0LCByXSA9IGUuc3BsaXQoXCJcIiksIG4gPSAkbFt0XSwgbyA9IFBsW3JdIHx8IFwiXCI7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG8pID8gby5tYXAoKGkpID0+IG4gKyBpKSA6IFtuICsgb107XG59KSwgTm4gPSBbXCJtXCIsIFwibXRcIiwgXCJtclwiLCBcIm1iXCIsIFwibWxcIiwgXCJteFwiLCBcIm15XCIsIFwibWFyZ2luXCIsIFwibWFyZ2luVG9wXCIsIFwibWFyZ2luUmlnaHRcIiwgXCJtYXJnaW5Cb3R0b21cIiwgXCJtYXJnaW5MZWZ0XCIsIFwibWFyZ2luWFwiLCBcIm1hcmdpbllcIiwgXCJtYXJnaW5JbmxpbmVcIiwgXCJtYXJnaW5JbmxpbmVTdGFydFwiLCBcIm1hcmdpbklubGluZUVuZFwiLCBcIm1hcmdpbkJsb2NrXCIsIFwibWFyZ2luQmxvY2tTdGFydFwiLCBcIm1hcmdpbkJsb2NrRW5kXCJdLCBNbiA9IFtcInBcIiwgXCJwdFwiLCBcInByXCIsIFwicGJcIiwgXCJwbFwiLCBcInB4XCIsIFwicHlcIiwgXCJwYWRkaW5nXCIsIFwicGFkZGluZ1RvcFwiLCBcInBhZGRpbmdSaWdodFwiLCBcInBhZGRpbmdCb3R0b21cIiwgXCJwYWRkaW5nTGVmdFwiLCBcInBhZGRpbmdYXCIsIFwicGFkZGluZ1lcIiwgXCJwYWRkaW5nSW5saW5lXCIsIFwicGFkZGluZ0lubGluZVN0YXJ0XCIsIFwicGFkZGluZ0lubGluZUVuZFwiLCBcInBhZGRpbmdCbG9ja1wiLCBcInBhZGRpbmdCbG9ja1N0YXJ0XCIsIFwicGFkZGluZ0Jsb2NrRW5kXCJdLCBBbCA9IFsuLi5ObiwgLi4uTW5dO1xuZnVuY3Rpb24gX3IoZSwgdCwgciwgbikge1xuICBjb25zdCBvID0gQW4oZSwgdCwgITApID8/IHI7XG4gIHJldHVybiB0eXBlb2YgbyA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyAoaSkgPT4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IGkgOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiBpICE9IFwibnVtYmVyXCIgJiYgY29uc29sZS5lcnJvcihgTVVJOiBFeHBlY3RlZCAke259IGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nLCBnb3QgJHtpfS5gKSwgdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IGBjYWxjKCR7aX0gKiAke299KWAgOiBvICogaSkgOiBBcnJheS5pc0FycmF5KG8pID8gKGkpID0+IHtcbiAgICBpZiAodHlwZW9mIGkgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBpO1xuICAgIGNvbnN0IHMgPSBNYXRoLmFicyhpKTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKE51bWJlci5pc0ludGVnZXIocykgPyBzID4gby5sZW5ndGggLSAxICYmIGNvbnNvbGUuZXJyb3IoW2BNVUk6IFRoZSB2YWx1ZSBwcm92aWRlZCAoJHtzfSkgb3ZlcmZsb3dzLmAsIGBUaGUgc3VwcG9ydGVkIHZhbHVlcyBhcmU6ICR7SlNPTi5zdHJpbmdpZnkobyl9LmAsIGAke3N9ID4gJHtvLmxlbmd0aCAtIDF9LCB5b3UgbmVlZCB0byBhZGQgdGhlIG1pc3NpbmcgdmFsdWVzLmBdLmpvaW4oYFxuYCkpIDogY29uc29sZS5lcnJvcihbYE1VSTogVGhlIFxcYHRoZW1lLiR7dH1cXGAgYXJyYXkgdHlwZSBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBub24gaW50ZWdlciB2YWx1ZXMuWW91IHNob3VsZCBlaXRoZXIgdXNlIGFuIGludGVnZXIgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCBhcyBpbmRleCwgb3IgZGVmaW5lIHRoZSBcXGB0aGVtZS4ke3R9XFxgIGFzIGEgbnVtYmVyLmBdLmpvaW4oYFxuYCkpKTtcbiAgICBjb25zdCBjID0gb1tzXTtcbiAgICByZXR1cm4gaSA+PSAwID8gYyA6IHR5cGVvZiBjID09IFwibnVtYmVyXCIgPyAtYyA6IGAtJHtjfWA7XG4gIH0gOiB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgPyBvIDogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFtgTVVJOiBUaGUgXFxgdGhlbWUuJHt0fVxcYCB2YWx1ZSAoJHtvfSkgaXMgaW52YWxpZC5gLCBcIkl0IHNob3VsZCBiZSBhIG51bWJlciwgYW4gYXJyYXkgb3IgYSBmdW5jdGlvbi5cIl0uam9pbihgXG5gKSksICgpID0+IHtcbiAgfSk7XG59XG5mdW5jdGlvbiBrbyhlKSB7XG4gIHJldHVybiBfcihlLCBcInNwYWNpbmdcIiwgOCwgXCJzcGFjaW5nXCIpO1xufVxuZnVuY3Rpb24ganIoZSwgdCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiB8fCB0ID09IG51bGwgPyB0IDogZSh0KTtcbn1cbmZ1bmN0aW9uIE5sKGUsIHQpIHtcbiAgcmV0dXJuIChyKSA9PiBlLnJlZHVjZSgobiwgbykgPT4gKG5bb10gPSBqcih0LCByKSwgbiksIHt9KTtcbn1cbmZ1bmN0aW9uIE1sKGUsIHQsIHIsIG4pIHtcbiAgaWYgKCF0LmluY2x1ZGVzKHIpKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBvID0ga2wociksIGkgPSBObChvLCBuKSwgcyA9IGVbcl07XG4gIHJldHVybiBPdChlLCBzLCBpKTtcbn1cbmZ1bmN0aW9uIExhKGUsIHQpIHtcbiAgY29uc3QgciA9IGtvKGUudGhlbWUpO1xuICByZXR1cm4gT2JqZWN0LmtleXMoZSkubWFwKChuKSA9PiBNbChlLCB0LCBuLCByKSkucmVkdWNlKHZyLCB7fSk7XG59XG5mdW5jdGlvbiBrZShlKSB7XG4gIHJldHVybiBMYShlLCBObik7XG59XG5rZS5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBObi5yZWR1Y2UoKGUsIHQpID0+IChlW3RdID0gTXQsIGUpLCB7fSkgOiB7fTtcbmtlLmZpbHRlclByb3BzID0gTm47XG5mdW5jdGlvbiBBZShlKSB7XG4gIHJldHVybiBMYShlLCBNbik7XG59XG5BZS5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBNbi5yZWR1Y2UoKGUsIHQpID0+IChlW3RdID0gTXQsIGUpLCB7fSkgOiB7fTtcbkFlLmZpbHRlclByb3BzID0gTW47XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgQWwucmVkdWNlKChlLCB0KSA9PiAoZVt0XSA9IE10LCBlKSwge30pO1xuZnVuY3Rpb24gQmEoZSA9IDgsIHQgPSBrbyh7XG4gIHNwYWNpbmc6IGVcbn0pKSB7XG4gIGlmIChlLm11aSlcbiAgICByZXR1cm4gZTtcbiAgY29uc3QgciA9ICguLi5uKSA9PiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChuLmxlbmd0aCA8PSA0IHx8IGNvbnNvbGUuZXJyb3IoYE1VSTogVG9vIG1hbnkgYXJndW1lbnRzIHByb3ZpZGVkLCBleHBlY3RlZCBiZXR3ZWVuIDAgYW5kIDQsIGdvdCAke24ubGVuZ3RofWApKSwgKG4ubGVuZ3RoID09PSAwID8gWzFdIDogbikubWFwKChpKSA9PiB7XG4gICAgY29uc3QgcyA9IHQoaSk7XG4gICAgcmV0dXJuIHR5cGVvZiBzID09IFwibnVtYmVyXCIgPyBgJHtzfXB4YCA6IHM7XG4gIH0pLmpvaW4oXCIgXCIpKTtcbiAgcmV0dXJuIHIubXVpID0gITAsIHI7XG59XG5mdW5jdGlvbiBJbiguLi5lKSB7XG4gIGNvbnN0IHQgPSBlLnJlZHVjZSgobiwgbykgPT4gKG8uZmlsdGVyUHJvcHMuZm9yRWFjaCgoaSkgPT4ge1xuICAgIG5baV0gPSBvO1xuICB9KSwgbiksIHt9KSwgciA9IChuKSA9PiBPYmplY3Qua2V5cyhuKS5yZWR1Y2UoKG8sIGkpID0+IHRbaV0gPyB2cihvLCB0W2ldKG4pKSA6IG8sIHt9KTtcbiAgcmV0dXJuIHIucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gZS5yZWR1Y2UoKG4sIG8pID0+IE9iamVjdC5hc3NpZ24obiwgby5wcm9wVHlwZXMpLCB7fSkgOiB7fSwgci5maWx0ZXJQcm9wcyA9IGUucmVkdWNlKChuLCBvKSA9PiBuLmNvbmNhdChvLmZpbHRlclByb3BzKSwgW10pLCByO1xufVxuZnVuY3Rpb24gb3QoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgIT0gXCJudW1iZXJcIiA/IGUgOiBgJHtlfXB4IHNvbGlkYDtcbn1cbmZ1bmN0aW9uIGx0KGUsIHQpIHtcbiAgcmV0dXJuIF9lKHtcbiAgICBwcm9wOiBlLFxuICAgIHRoZW1lS2V5OiBcImJvcmRlcnNcIixcbiAgICB0cmFuc2Zvcm06IHRcbiAgfSk7XG59XG5jb25zdCBJbCA9IGx0KFwiYm9yZGVyXCIsIG90KSwgX2wgPSBsdChcImJvcmRlclRvcFwiLCBvdCksIGpsID0gbHQoXCJib3JkZXJSaWdodFwiLCBvdCksIERsID0gbHQoXCJib3JkZXJCb3R0b21cIiwgb3QpLCBMbCA9IGx0KFwiYm9yZGVyTGVmdFwiLCBvdCksIEJsID0gbHQoXCJib3JkZXJDb2xvclwiKSwgVmwgPSBsdChcImJvcmRlclRvcENvbG9yXCIpLCBGbCA9IGx0KFwiYm9yZGVyUmlnaHRDb2xvclwiKSwgemwgPSBsdChcImJvcmRlckJvdHRvbUNvbG9yXCIpLCBXbCA9IGx0KFwiYm9yZGVyTGVmdENvbG9yXCIpLCBVbCA9IGx0KFwib3V0bGluZVwiLCBvdCksIFlsID0gbHQoXCJvdXRsaW5lQ29sb3JcIiksIF9uID0gKGUpID0+IHtcbiAgaWYgKGUuYm9yZGVyUmFkaXVzICE9PSB2b2lkIDAgJiYgZS5ib3JkZXJSYWRpdXMgIT09IG51bGwpIHtcbiAgICBjb25zdCB0ID0gX3IoZS50aGVtZSwgXCJzaGFwZS5ib3JkZXJSYWRpdXNcIiwgNCwgXCJib3JkZXJSYWRpdXNcIiksIHIgPSAobikgPT4gKHtcbiAgICAgIGJvcmRlclJhZGl1czoganIodCwgbilcbiAgICB9KTtcbiAgICByZXR1cm4gT3QoZSwgZS5ib3JkZXJSYWRpdXMsIHIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbl9uLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgYm9yZGVyUmFkaXVzOiBNdFxufSA6IHt9O1xuX24uZmlsdGVyUHJvcHMgPSBbXCJib3JkZXJSYWRpdXNcIl07XG5JbihJbCwgX2wsIGpsLCBEbCwgTGwsIEJsLCBWbCwgRmwsIHpsLCBXbCwgX24sIFVsLCBZbCk7XG5jb25zdCBqbiA9IChlKSA9PiB7XG4gIGlmIChlLmdhcCAhPT0gdm9pZCAwICYmIGUuZ2FwICE9PSBudWxsKSB7XG4gICAgY29uc3QgdCA9IF9yKGUudGhlbWUsIFwic3BhY2luZ1wiLCA4LCBcImdhcFwiKSwgciA9IChuKSA9PiAoe1xuICAgICAgZ2FwOiBqcih0LCBuKVxuICAgIH0pO1xuICAgIHJldHVybiBPdChlLCBlLmdhcCwgcik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuam4ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICBnYXA6IE10XG59IDoge307XG5qbi5maWx0ZXJQcm9wcyA9IFtcImdhcFwiXTtcbmNvbnN0IERuID0gKGUpID0+IHtcbiAgaWYgKGUuY29sdW1uR2FwICE9PSB2b2lkIDAgJiYgZS5jb2x1bW5HYXAgIT09IG51bGwpIHtcbiAgICBjb25zdCB0ID0gX3IoZS50aGVtZSwgXCJzcGFjaW5nXCIsIDgsIFwiY29sdW1uR2FwXCIpLCByID0gKG4pID0+ICh7XG4gICAgICBjb2x1bW5HYXA6IGpyKHQsIG4pXG4gICAgfSk7XG4gICAgcmV0dXJuIE90KGUsIGUuY29sdW1uR2FwLCByKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5Ebi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIGNvbHVtbkdhcDogTXRcbn0gOiB7fTtcbkRuLmZpbHRlclByb3BzID0gW1wiY29sdW1uR2FwXCJdO1xuY29uc3QgTG4gPSAoZSkgPT4ge1xuICBpZiAoZS5yb3dHYXAgIT09IHZvaWQgMCAmJiBlLnJvd0dhcCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHQgPSBfcihlLnRoZW1lLCBcInNwYWNpbmdcIiwgOCwgXCJyb3dHYXBcIiksIHIgPSAobikgPT4gKHtcbiAgICAgIHJvd0dhcDoganIodCwgbilcbiAgICB9KTtcbiAgICByZXR1cm4gT3QoZSwgZS5yb3dHYXAsIHIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbkxuLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgcm93R2FwOiBNdFxufSA6IHt9O1xuTG4uZmlsdGVyUHJvcHMgPSBbXCJyb3dHYXBcIl07XG5jb25zdCBIbCA9IF9lKHtcbiAgcHJvcDogXCJncmlkQ29sdW1uXCJcbn0pLCBxbCA9IF9lKHtcbiAgcHJvcDogXCJncmlkUm93XCJcbn0pLCBHbCA9IF9lKHtcbiAgcHJvcDogXCJncmlkQXV0b0Zsb3dcIlxufSksIEtsID0gX2Uoe1xuICBwcm9wOiBcImdyaWRBdXRvQ29sdW1uc1wiXG59KSwgWGwgPSBfZSh7XG4gIHByb3A6IFwiZ3JpZEF1dG9Sb3dzXCJcbn0pLCBKbCA9IF9lKHtcbiAgcHJvcDogXCJncmlkVGVtcGxhdGVDb2x1bW5zXCJcbn0pLCBRbCA9IF9lKHtcbiAgcHJvcDogXCJncmlkVGVtcGxhdGVSb3dzXCJcbn0pLCBabCA9IF9lKHtcbiAgcHJvcDogXCJncmlkVGVtcGxhdGVBcmVhc1wiXG59KSwgZXUgPSBfZSh7XG4gIHByb3A6IFwiZ3JpZEFyZWFcIlxufSk7XG5JbihqbiwgRG4sIExuLCBIbCwgcWwsIEdsLCBLbCwgWGwsIEpsLCBRbCwgWmwsIGV1KTtcbmZ1bmN0aW9uIEp0KGUsIHQpIHtcbiAgcmV0dXJuIHQgPT09IFwiZ3JleVwiID8gdCA6IGU7XG59XG5jb25zdCB0dSA9IF9lKHtcbiAgcHJvcDogXCJjb2xvclwiLFxuICB0aGVtZUtleTogXCJwYWxldHRlXCIsXG4gIHRyYW5zZm9ybTogSnRcbn0pLCBydSA9IF9lKHtcbiAgcHJvcDogXCJiZ2NvbG9yXCIsXG4gIGNzc1Byb3BlcnR5OiBcImJhY2tncm91bmRDb2xvclwiLFxuICB0aGVtZUtleTogXCJwYWxldHRlXCIsXG4gIHRyYW5zZm9ybTogSnRcbn0pLCBudSA9IF9lKHtcbiAgcHJvcDogXCJiYWNrZ3JvdW5kQ29sb3JcIixcbiAgdGhlbWVLZXk6IFwicGFsZXR0ZVwiLFxuICB0cmFuc2Zvcm06IEp0XG59KTtcbkluKHR1LCBydSwgbnUpO1xuZnVuY3Rpb24gWmUoZSkge1xuICByZXR1cm4gZSA8PSAxICYmIGUgIT09IDAgPyBgJHtlICogMTAwfSVgIDogZTtcbn1cbmNvbnN0IG91ID0gX2Uoe1xuICBwcm9wOiBcIndpZHRoXCIsXG4gIHRyYW5zZm9ybTogWmVcbn0pLCBBbyA9IChlKSA9PiB7XG4gIGlmIChlLm1heFdpZHRoICE9PSB2b2lkIDAgJiYgZS5tYXhXaWR0aCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHQgPSAocikgPT4ge1xuICAgICAgdmFyIG8sIGksIHMsIGMsIGw7XG4gICAgICBjb25zdCBuID0gKChzID0gKGkgPSAobyA9IGUudGhlbWUpID09IG51bGwgPyB2b2lkIDAgOiBvLmJyZWFrcG9pbnRzKSA9PSBudWxsID8gdm9pZCAwIDogaS52YWx1ZXMpID09IG51bGwgPyB2b2lkIDAgOiBzW3JdKSB8fCBrbltyXTtcbiAgICAgIHJldHVybiBuID8gKChsID0gKGMgPSBlLnRoZW1lKSA9PSBudWxsID8gdm9pZCAwIDogYy5icmVha3BvaW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IGwudW5pdCkgIT09IFwicHhcIiA/IHtcbiAgICAgICAgbWF4V2lkdGg6IGAke259JHtlLnRoZW1lLmJyZWFrcG9pbnRzLnVuaXR9YFxuICAgICAgfSA6IHtcbiAgICAgICAgbWF4V2lkdGg6IG5cbiAgICAgIH0gOiB7XG4gICAgICAgIG1heFdpZHRoOiBaZShyKVxuICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBPdChlLCBlLm1heFdpZHRoLCB0KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5Bby5maWx0ZXJQcm9wcyA9IFtcIm1heFdpZHRoXCJdO1xuY29uc3QgaXUgPSBfZSh7XG4gIHByb3A6IFwibWluV2lkdGhcIixcbiAgdHJhbnNmb3JtOiBaZVxufSksIGF1ID0gX2Uoe1xuICBwcm9wOiBcImhlaWdodFwiLFxuICB0cmFuc2Zvcm06IFplXG59KSwgc3UgPSBfZSh7XG4gIHByb3A6IFwibWF4SGVpZ2h0XCIsXG4gIHRyYW5zZm9ybTogWmVcbn0pLCBjdSA9IF9lKHtcbiAgcHJvcDogXCJtaW5IZWlnaHRcIixcbiAgdHJhbnNmb3JtOiBaZVxufSk7XG5fZSh7XG4gIHByb3A6IFwic2l6ZVwiLFxuICBjc3NQcm9wZXJ0eTogXCJ3aWR0aFwiLFxuICB0cmFuc2Zvcm06IFplXG59KTtcbl9lKHtcbiAgcHJvcDogXCJzaXplXCIsXG4gIGNzc1Byb3BlcnR5OiBcImhlaWdodFwiLFxuICB0cmFuc2Zvcm06IFplXG59KTtcbmNvbnN0IGx1ID0gX2Uoe1xuICBwcm9wOiBcImJveFNpemluZ1wiXG59KTtcbkluKG91LCBBbywgaXUsIGF1LCBzdSwgY3UsIGx1KTtcbmNvbnN0IERyID0ge1xuICAvLyBib3JkZXJzXG4gIGJvcmRlcjoge1xuICAgIHRoZW1lS2V5OiBcImJvcmRlcnNcIixcbiAgICB0cmFuc2Zvcm06IG90XG4gIH0sXG4gIGJvcmRlclRvcDoge1xuICAgIHRoZW1lS2V5OiBcImJvcmRlcnNcIixcbiAgICB0cmFuc2Zvcm06IG90XG4gIH0sXG4gIGJvcmRlclJpZ2h0OiB7XG4gICAgdGhlbWVLZXk6IFwiYm9yZGVyc1wiLFxuICAgIHRyYW5zZm9ybTogb3RcbiAgfSxcbiAgYm9yZGVyQm90dG9tOiB7XG4gICAgdGhlbWVLZXk6IFwiYm9yZGVyc1wiLFxuICAgIHRyYW5zZm9ybTogb3RcbiAgfSxcbiAgYm9yZGVyTGVmdDoge1xuICAgIHRoZW1lS2V5OiBcImJvcmRlcnNcIixcbiAgICB0cmFuc2Zvcm06IG90XG4gIH0sXG4gIGJvcmRlckNvbG9yOiB7XG4gICAgdGhlbWVLZXk6IFwicGFsZXR0ZVwiXG4gIH0sXG4gIGJvcmRlclRvcENvbG9yOiB7XG4gICAgdGhlbWVLZXk6IFwicGFsZXR0ZVwiXG4gIH0sXG4gIGJvcmRlclJpZ2h0Q29sb3I6IHtcbiAgICB0aGVtZUtleTogXCJwYWxldHRlXCJcbiAgfSxcbiAgYm9yZGVyQm90dG9tQ29sb3I6IHtcbiAgICB0aGVtZUtleTogXCJwYWxldHRlXCJcbiAgfSxcbiAgYm9yZGVyTGVmdENvbG9yOiB7XG4gICAgdGhlbWVLZXk6IFwicGFsZXR0ZVwiXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICB0aGVtZUtleTogXCJib3JkZXJzXCIsXG4gICAgdHJhbnNmb3JtOiBvdFxuICB9LFxuICBvdXRsaW5lQ29sb3I6IHtcbiAgICB0aGVtZUtleTogXCJwYWxldHRlXCJcbiAgfSxcbiAgYm9yZGVyUmFkaXVzOiB7XG4gICAgdGhlbWVLZXk6IFwic2hhcGUuYm9yZGVyUmFkaXVzXCIsXG4gICAgc3R5bGU6IF9uXG4gIH0sXG4gIC8vIHBhbGV0dGVcbiAgY29sb3I6IHtcbiAgICB0aGVtZUtleTogXCJwYWxldHRlXCIsXG4gICAgdHJhbnNmb3JtOiBKdFxuICB9LFxuICBiZ2NvbG9yOiB7XG4gICAgdGhlbWVLZXk6IFwicGFsZXR0ZVwiLFxuICAgIGNzc1Byb3BlcnR5OiBcImJhY2tncm91bmRDb2xvclwiLFxuICAgIHRyYW5zZm9ybTogSnRcbiAgfSxcbiAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgdGhlbWVLZXk6IFwicGFsZXR0ZVwiLFxuICAgIHRyYW5zZm9ybTogSnRcbiAgfSxcbiAgLy8gc3BhY2luZ1xuICBwOiB7XG4gICAgc3R5bGU6IEFlXG4gIH0sXG4gIHB0OiB7XG4gICAgc3R5bGU6IEFlXG4gIH0sXG4gIHByOiB7XG4gICAgc3R5bGU6IEFlXG4gIH0sXG4gIHBiOiB7XG4gICAgc3R5bGU6IEFlXG4gIH0sXG4gIHBsOiB7XG4gICAgc3R5bGU6IEFlXG4gIH0sXG4gIHB4OiB7XG4gICAgc3R5bGU6IEFlXG4gIH0sXG4gIHB5OiB7XG4gICAgc3R5bGU6IEFlXG4gIH0sXG4gIHBhZGRpbmc6IHtcbiAgICBzdHlsZTogQWVcbiAgfSxcbiAgcGFkZGluZ1RvcDoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwYWRkaW5nUmlnaHQ6IHtcbiAgICBzdHlsZTogQWVcbiAgfSxcbiAgcGFkZGluZ0JvdHRvbToge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwYWRkaW5nTGVmdDoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwYWRkaW5nWDoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwYWRkaW5nWToge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwYWRkaW5nSW5saW5lOiB7XG4gICAgc3R5bGU6IEFlXG4gIH0sXG4gIHBhZGRpbmdJbmxpbmVTdGFydDoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwYWRkaW5nSW5saW5lRW5kOiB7XG4gICAgc3R5bGU6IEFlXG4gIH0sXG4gIHBhZGRpbmdCbG9jazoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwYWRkaW5nQmxvY2tTdGFydDoge1xuICAgIHN0eWxlOiBBZVxuICB9LFxuICBwYWRkaW5nQmxvY2tFbmQ6IHtcbiAgICBzdHlsZTogQWVcbiAgfSxcbiAgbToge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBtdDoge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBtcjoge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBtYjoge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBtbDoge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBteDoge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBteToge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBtYXJnaW46IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbWFyZ2luVG9wOiB7XG4gICAgc3R5bGU6IGtlXG4gIH0sXG4gIG1hcmdpblJpZ2h0OiB7XG4gICAgc3R5bGU6IGtlXG4gIH0sXG4gIG1hcmdpbkJvdHRvbToge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBtYXJnaW5MZWZ0OiB7XG4gICAgc3R5bGU6IGtlXG4gIH0sXG4gIG1hcmdpblg6IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbWFyZ2luWToge1xuICAgIHN0eWxlOiBrZVxuICB9LFxuICBtYXJnaW5JbmxpbmU6IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbWFyZ2luSW5saW5lU3RhcnQ6IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbWFyZ2luSW5saW5lRW5kOiB7XG4gICAgc3R5bGU6IGtlXG4gIH0sXG4gIG1hcmdpbkJsb2NrOiB7XG4gICAgc3R5bGU6IGtlXG4gIH0sXG4gIG1hcmdpbkJsb2NrU3RhcnQ6IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgbWFyZ2luQmxvY2tFbmQ6IHtcbiAgICBzdHlsZToga2VcbiAgfSxcbiAgLy8gZGlzcGxheVxuICBkaXNwbGF5UHJpbnQ6IHtcbiAgICBjc3NQcm9wZXJ0eTogITEsXG4gICAgdHJhbnNmb3JtOiAoZSkgPT4gKHtcbiAgICAgIFwiQG1lZGlhIHByaW50XCI6IHtcbiAgICAgICAgZGlzcGxheTogZVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIGRpc3BsYXk6IHt9LFxuICBvdmVyZmxvdzoge30sXG4gIHRleHRPdmVyZmxvdzoge30sXG4gIHZpc2liaWxpdHk6IHt9LFxuICB3aGl0ZVNwYWNlOiB7fSxcbiAgLy8gZmxleGJveFxuICBmbGV4QmFzaXM6IHt9LFxuICBmbGV4RGlyZWN0aW9uOiB7fSxcbiAgZmxleFdyYXA6IHt9LFxuICBqdXN0aWZ5Q29udGVudDoge30sXG4gIGFsaWduSXRlbXM6IHt9LFxuICBhbGlnbkNvbnRlbnQ6IHt9LFxuICBvcmRlcjoge30sXG4gIGZsZXg6IHt9LFxuICBmbGV4R3Jvdzoge30sXG4gIGZsZXhTaHJpbms6IHt9LFxuICBhbGlnblNlbGY6IHt9LFxuICBqdXN0aWZ5SXRlbXM6IHt9LFxuICBqdXN0aWZ5U2VsZjoge30sXG4gIC8vIGdyaWRcbiAgZ2FwOiB7XG4gICAgc3R5bGU6IGpuXG4gIH0sXG4gIHJvd0dhcDoge1xuICAgIHN0eWxlOiBMblxuICB9LFxuICBjb2x1bW5HYXA6IHtcbiAgICBzdHlsZTogRG5cbiAgfSxcbiAgZ3JpZENvbHVtbjoge30sXG4gIGdyaWRSb3c6IHt9LFxuICBncmlkQXV0b0Zsb3c6IHt9LFxuICBncmlkQXV0b0NvbHVtbnM6IHt9LFxuICBncmlkQXV0b1Jvd3M6IHt9LFxuICBncmlkVGVtcGxhdGVDb2x1bW5zOiB7fSxcbiAgZ3JpZFRlbXBsYXRlUm93czoge30sXG4gIGdyaWRUZW1wbGF0ZUFyZWFzOiB7fSxcbiAgZ3JpZEFyZWE6IHt9LFxuICAvLyBwb3NpdGlvbnNcbiAgcG9zaXRpb246IHt9LFxuICB6SW5kZXg6IHtcbiAgICB0aGVtZUtleTogXCJ6SW5kZXhcIlxuICB9LFxuICB0b3A6IHt9LFxuICByaWdodDoge30sXG4gIGJvdHRvbToge30sXG4gIGxlZnQ6IHt9LFxuICAvLyBzaGFkb3dzXG4gIGJveFNoYWRvdzoge1xuICAgIHRoZW1lS2V5OiBcInNoYWRvd3NcIlxuICB9LFxuICAvLyBzaXppbmdcbiAgd2lkdGg6IHtcbiAgICB0cmFuc2Zvcm06IFplXG4gIH0sXG4gIG1heFdpZHRoOiB7XG4gICAgc3R5bGU6IEFvXG4gIH0sXG4gIG1pbldpZHRoOiB7XG4gICAgdHJhbnNmb3JtOiBaZVxuICB9LFxuICBoZWlnaHQ6IHtcbiAgICB0cmFuc2Zvcm06IFplXG4gIH0sXG4gIG1heEhlaWdodDoge1xuICAgIHRyYW5zZm9ybTogWmVcbiAgfSxcbiAgbWluSGVpZ2h0OiB7XG4gICAgdHJhbnNmb3JtOiBaZVxuICB9LFxuICBib3hTaXppbmc6IHt9LFxuICAvLyB0eXBvZ3JhcGh5XG4gIGZvbnQ6IHtcbiAgICB0aGVtZUtleTogXCJmb250XCJcbiAgfSxcbiAgZm9udEZhbWlseToge1xuICAgIHRoZW1lS2V5OiBcInR5cG9ncmFwaHlcIlxuICB9LFxuICBmb250U2l6ZToge1xuICAgIHRoZW1lS2V5OiBcInR5cG9ncmFwaHlcIlxuICB9LFxuICBmb250U3R5bGU6IHtcbiAgICB0aGVtZUtleTogXCJ0eXBvZ3JhcGh5XCJcbiAgfSxcbiAgZm9udFdlaWdodDoge1xuICAgIHRoZW1lS2V5OiBcInR5cG9ncmFwaHlcIlxuICB9LFxuICBsZXR0ZXJTcGFjaW5nOiB7fSxcbiAgdGV4dFRyYW5zZm9ybToge30sXG4gIGxpbmVIZWlnaHQ6IHt9LFxuICB0ZXh0QWxpZ246IHt9LFxuICB0eXBvZ3JhcGh5OiB7XG4gICAgY3NzUHJvcGVydHk6ICExLFxuICAgIHRoZW1lS2V5OiBcInR5cG9ncmFwaHlcIlxuICB9XG59O1xuZnVuY3Rpb24gdXUoLi4uZSkge1xuICBjb25zdCB0ID0gZS5yZWR1Y2UoKG4sIG8pID0+IG4uY29uY2F0KE9iamVjdC5rZXlzKG8pKSwgW10pLCByID0gbmV3IFNldCh0KTtcbiAgcmV0dXJuIGUuZXZlcnkoKG4pID0+IHIuc2l6ZSA9PT0gT2JqZWN0LmtleXMobikubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGZ1KGUsIHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUodCkgOiBlO1xufVxuZnVuY3Rpb24gZHUoKSB7XG4gIGZ1bmN0aW9uIGUociwgbiwgbywgaSkge1xuICAgIGNvbnN0IHMgPSB7XG4gICAgICBbcl06IG4sXG4gICAgICB0aGVtZTogb1xuICAgIH0sIGMgPSBpW3JdO1xuICAgIGlmICghYylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtyXTogblxuICAgICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBjc3NQcm9wZXJ0eTogbCA9IHIsXG4gICAgICB0aGVtZUtleTogdSxcbiAgICAgIHRyYW5zZm9ybTogcCxcbiAgICAgIHN0eWxlOiBtXG4gICAgfSA9IGM7XG4gICAgaWYgKG4gPT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh1ID09PSBcInR5cG9ncmFwaHlcIiAmJiBuID09PSBcImluaGVyaXRcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtyXTogblxuICAgICAgfTtcbiAgICBjb25zdCBnID0gQW4obywgdSkgfHwge307XG4gICAgcmV0dXJuIG0gPyBtKHMpIDogT3QocywgbiwgKHkpID0+IHtcbiAgICAgIGxldCBmID0gbW4oZywgcCwgeSk7XG4gICAgICByZXR1cm4geSA9PT0gZiAmJiB0eXBlb2YgeSA9PSBcInN0cmluZ1wiICYmIChmID0gbW4oZywgcCwgYCR7cn0ke3kgPT09IFwiZGVmYXVsdFwiID8gXCJcIiA6IGVlKHkpfWAsIHkpKSwgbCA9PT0gITEgPyBmIDoge1xuICAgICAgICBbbF06IGZcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdChyKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3g6IG4sXG4gICAgICB0aGVtZTogbyA9IHt9XG4gICAgfSA9IHIgfHwge307XG4gICAgaWYgKCFuKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaSA9IG8udW5zdGFibGVfc3hDb25maWcgPz8gRHI7XG4gICAgZnVuY3Rpb24gcyhjKSB7XG4gICAgICBsZXQgbCA9IGM7XG4gICAgICBpZiAodHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBsID0gYyhvKTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBjICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBjO1xuICAgICAgaWYgKCFsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IHUgPSB3bChvLmJyZWFrcG9pbnRzKSwgcCA9IE9iamVjdC5rZXlzKHUpO1xuICAgICAgbGV0IG0gPSB1O1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGwpLmZvckVhY2goKGcpID0+IHtcbiAgICAgICAgY29uc3QgeCA9IGZ1KGxbZ10sIG8pO1xuICAgICAgICBpZiAoeCAhPSBudWxsKVxuICAgICAgICAgIGlmICh0eXBlb2YgeCA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgaWYgKGlbZ10pXG4gICAgICAgICAgICAgIG0gPSB2cihtLCBlKGcsIHgsIG8sIGkpKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB5ID0gT3Qoe1xuICAgICAgICAgICAgICAgIHRoZW1lOiBvXG4gICAgICAgICAgICAgIH0sIHgsIChmKSA9PiAoe1xuICAgICAgICAgICAgICAgIFtnXTogZlxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHV1KHksIHgpID8gbVtnXSA9IHQoe1xuICAgICAgICAgICAgICAgIHN4OiB4LFxuICAgICAgICAgICAgICAgIHRoZW1lOiBvXG4gICAgICAgICAgICAgIH0pIDogbSA9IHZyKG0sIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG0gPSB2cihtLCBlKGcsIHgsIG8sIGkpKTtcbiAgICAgIH0pLCB2bChvLCBPbChwLCBtKSk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG4pID8gbi5tYXAocykgOiBzKG4pO1xuICB9XG4gIHJldHVybiB0O1xufVxuY29uc3QgQXQgPSBkdSgpO1xuQXQuZmlsdGVyUHJvcHMgPSBbXCJzeFwiXTtcbmZ1bmN0aW9uIHB1KGUsIHQpIHtcbiAgdmFyIG47XG4gIGNvbnN0IHIgPSB0aGlzO1xuICBpZiAoci52YXJzKSB7XG4gICAgaWYgKCEoKG4gPSByLmNvbG9yU2NoZW1lcykgIT0gbnVsbCAmJiBuW2VdKSB8fCB0eXBlb2Ygci5nZXRDb2xvclNjaGVtZVNlbGVjdG9yICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiB7fTtcbiAgICBsZXQgbyA9IHIuZ2V0Q29sb3JTY2hlbWVTZWxlY3RvcihlKTtcbiAgICByZXR1cm4gbyA9PT0gXCImXCIgPyB0IDogKChvLmluY2x1ZGVzKFwiZGF0YS1cIikgfHwgby5pbmNsdWRlcyhcIi5cIikpICYmIChvID0gYCo6d2hlcmUoJHtvLnJlcGxhY2UoL1xccyomJC8sIFwiXCIpfSkgJmApLCB7XG4gICAgICBbb106IHRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gci5wYWxldHRlLm1vZGUgPT09IGUgPyB0IDoge307XG59XG5mdW5jdGlvbiBObyhlID0ge30sIC4uLnQpIHtcbiAgY29uc3Qge1xuICAgIGJyZWFrcG9pbnRzOiByID0ge30sXG4gICAgcGFsZXR0ZTogbiA9IHt9LFxuICAgIHNwYWNpbmc6IG8sXG4gICAgc2hhcGU6IGkgPSB7fSxcbiAgICAuLi5zXG4gIH0gPSBlLCBjID0gYmwociksIGwgPSBCYShvKTtcbiAgbGV0IHUgPSB0dCh7XG4gICAgYnJlYWtwb2ludHM6IGMsXG4gICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIC8vIEluamVjdCBjb21wb25lbnQgZGVmaW5pdGlvbnMuXG4gICAgcGFsZXR0ZToge1xuICAgICAgbW9kZTogXCJsaWdodFwiLFxuICAgICAgLi4ublxuICAgIH0sXG4gICAgc3BhY2luZzogbCxcbiAgICBzaGFwZToge1xuICAgICAgLi4uQ2wsXG4gICAgICAuLi5pXG4gICAgfVxuICB9LCBzKTtcbiAgcmV0dXJuIHUgPSBFbCh1KSwgdS5hcHBseVN0eWxlcyA9IHB1LCB1ID0gdC5yZWR1Y2UoKHAsIG0pID0+IHR0KHAsIG0pLCB1KSwgdS51bnN0YWJsZV9zeENvbmZpZyA9IHtcbiAgICAuLi5EcixcbiAgICAuLi5zID09IG51bGwgPyB2b2lkIDAgOiBzLnVuc3RhYmxlX3N4Q29uZmlnXG4gIH0sIHUudW5zdGFibGVfc3ggPSBmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIEF0KHtcbiAgICAgIHN4OiBtLFxuICAgICAgdGhlbWU6IHRoaXNcbiAgICB9KTtcbiAgfSwgdTtcbn1cbmZ1bmN0aW9uIG11KGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIFZhKGUgPSBudWxsKSB7XG4gIGNvbnN0IHQgPSBDLnVzZUNvbnRleHQoTXIpO1xuICByZXR1cm4gIXQgfHwgbXUodCkgPyBlIDogdDtcbn1cbmNvbnN0IGh1ID0gTm8oKTtcbmZ1bmN0aW9uIEZhKGUgPSBodSkge1xuICByZXR1cm4gVmEoZSk7XG59XG5jb25zdCBndSA9IChlKSA9PiB7XG4gIHZhciBuO1xuICBjb25zdCB0ID0ge1xuICAgIHN5c3RlbVByb3BzOiB7fSxcbiAgICBvdGhlclByb3BzOiB7fVxuICB9LCByID0gKChuID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS50aGVtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4udW5zdGFibGVfc3hDb25maWcpID8/IERyO1xuICByZXR1cm4gT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgobykgPT4ge1xuICAgIHJbb10gPyB0LnN5c3RlbVByb3BzW29dID0gZVtvXSA6IHQub3RoZXJQcm9wc1tvXSA9IGVbb107XG4gIH0pLCB0O1xufTtcbmZ1bmN0aW9uIHphKGUpIHtcbiAgY29uc3Qge1xuICAgIHN4OiB0LFxuICAgIC4uLnJcbiAgfSA9IGUsIHtcbiAgICBzeXN0ZW1Qcm9wczogbixcbiAgICBvdGhlclByb3BzOiBvXG4gIH0gPSBndShyKTtcbiAgbGV0IGk7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHQpID8gaSA9IFtuLCAuLi50XSA6IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IGkgPSAoLi4ucykgPT4ge1xuICAgIGNvbnN0IGMgPSB0KC4uLnMpO1xuICAgIHJldHVybiBndChjKSA/IHtcbiAgICAgIC4uLm4sXG4gICAgICAuLi5jXG4gICAgfSA6IG47XG4gIH0gOiBpID0ge1xuICAgIC4uLm4sXG4gICAgLi4udFxuICB9LCB7XG4gICAgLi4ubyxcbiAgICBzeDogaVxuICB9O1xufVxuY29uc3QgQmkgPSAoZSkgPT4gZSwgeXUgPSAoKSA9PiB7XG4gIGxldCBlID0gQmk7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJlKHQpIHtcbiAgICAgIGUgPSB0O1xuICAgIH0sXG4gICAgZ2VuZXJhdGUodCkge1xuICAgICAgcmV0dXJuIGUodCk7XG4gICAgfSxcbiAgICByZXNldCgpIHtcbiAgICAgIGUgPSBCaTtcbiAgICB9XG4gIH07XG59LCBXYSA9IHl1KCk7XG5mdW5jdGlvbiBVYShlKSB7XG4gIHZhciB0LCByLCBuID0gXCJcIjtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGUgPT0gXCJudW1iZXJcIikgbiArPSBlO1xuICBlbHNlIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiKSBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgIHZhciBvID0gZS5sZW5ndGg7XG4gICAgZm9yICh0ID0gMDsgdCA8IG87IHQrKykgZVt0XSAmJiAociA9IFVhKGVbdF0pKSAmJiAobiAmJiAobiArPSBcIiBcIiksIG4gKz0gcik7XG4gIH0gZWxzZSBmb3IgKHIgaW4gZSkgZVtyXSAmJiAobiAmJiAobiArPSBcIiBcIiksIG4gKz0gcik7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gc2UoKSB7XG4gIGZvciAodmFyIGUsIHQsIHIgPSAwLCBuID0gXCJcIiwgbyA9IGFyZ3VtZW50cy5sZW5ndGg7IHIgPCBvOyByKyspIChlID0gYXJndW1lbnRzW3JdKSAmJiAodCA9IFVhKGUpKSAmJiAobiAmJiAobiArPSBcIiBcIiksIG4gKz0gdCk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gYnUoZSA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB0aGVtZUlkOiB0LFxuICAgIGRlZmF1bHRUaGVtZTogcixcbiAgICBkZWZhdWx0Q2xhc3NOYW1lOiBuID0gXCJNdWlCb3gtcm9vdFwiLFxuICAgIGdlbmVyYXRlQ2xhc3NOYW1lOiBvXG4gIH0gPSBlLCBpID0gamEoXCJkaXZcIiwge1xuICAgIHNob3VsZEZvcndhcmRQcm9wOiAoYykgPT4gYyAhPT0gXCJ0aGVtZVwiICYmIGMgIT09IFwic3hcIiAmJiBjICE9PSBcImFzXCJcbiAgfSkoQXQpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbihsLCB1KSB7XG4gICAgY29uc3QgcCA9IEZhKHIpLCB7XG4gICAgICBjbGFzc05hbWU6IG0sXG4gICAgICBjb21wb25lbnQ6IGcgPSBcImRpdlwiLFxuICAgICAgLi4ueFxuICAgIH0gPSB6YShsKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KGksIHtcbiAgICAgIGFzOiBnLFxuICAgICAgcmVmOiB1LFxuICAgICAgY2xhc3NOYW1lOiBzZShtLCBvID8gbyhuKSA6IG4pLFxuICAgICAgdGhlbWU6IHQgJiYgcFt0XSB8fCBwLFxuICAgICAgLi4ueFxuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IHZ1ID0ge1xuICBhY3RpdmU6IFwiYWN0aXZlXCIsXG4gIGNoZWNrZWQ6IFwiY2hlY2tlZFwiLFxuICBjb21wbGV0ZWQ6IFwiY29tcGxldGVkXCIsXG4gIGRpc2FibGVkOiBcImRpc2FibGVkXCIsXG4gIGVycm9yOiBcImVycm9yXCIsXG4gIGV4cGFuZGVkOiBcImV4cGFuZGVkXCIsXG4gIGZvY3VzZWQ6IFwiZm9jdXNlZFwiLFxuICBmb2N1c1Zpc2libGU6IFwiZm9jdXNWaXNpYmxlXCIsXG4gIG9wZW46IFwib3BlblwiLFxuICByZWFkT25seTogXCJyZWFkT25seVwiLFxuICByZXF1aXJlZDogXCJyZXF1aXJlZFwiLFxuICBzZWxlY3RlZDogXCJzZWxlY3RlZFwiXG59O1xuZnVuY3Rpb24gVmUoZSwgdCwgciA9IFwiTXVpXCIpIHtcbiAgY29uc3QgbiA9IHZ1W3RdO1xuICByZXR1cm4gbiA/IGAke3J9LSR7bn1gIDogYCR7V2EuZ2VuZXJhdGUoZSl9LSR7dH1gO1xufVxuZnVuY3Rpb24gRmUoZSwgdCwgciA9IFwiTXVpXCIpIHtcbiAgY29uc3QgbiA9IHt9O1xuICByZXR1cm4gdC5mb3JFYWNoKChvKSA9PiB7XG4gICAgbltvXSA9IFZlKGUsIG8sIHIpO1xuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIFlhKGUsIHQgPSBcIlwiKSB7XG4gIHJldHVybiBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSB8fCB0O1xufVxuZnVuY3Rpb24gVmkoZSwgdCwgcikge1xuICBjb25zdCBuID0gWWEodCk7XG4gIHJldHVybiBlLmRpc3BsYXlOYW1lIHx8IChuICE9PSBcIlwiID8gYCR7cn0oJHtufSlgIDogcik7XG59XG5mdW5jdGlvbiB4dShlKSB7XG4gIGlmIChlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBlO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4gWWEoZSwgXCJDb21wb25lbnRcIik7XG4gICAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgICBzd2l0Y2ggKGUuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBwbi5Gb3J3YXJkUmVmOlxuICAgICAgICAgIHJldHVybiBWaShlLCBlLnJlbmRlciwgXCJGb3J3YXJkUmVmXCIpO1xuICAgICAgICBjYXNlIHBuLk1lbW86XG4gICAgICAgICAgcmV0dXJuIFZpKGUsIGUudHlwZSwgXCJtZW1vXCIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gSGEoZSkge1xuICBjb25zdCB7XG4gICAgdmFyaWFudHM6IHQsXG4gICAgLi4uclxuICB9ID0gZSwgbiA9IHtcbiAgICB2YXJpYW50czogdCxcbiAgICBzdHlsZTogTWkociksXG4gICAgaXNQcm9jZXNzZWQ6ICEwXG4gIH07XG4gIHJldHVybiBuLnN0eWxlID09PSByIHx8IHQgJiYgdC5mb3JFYWNoKChvKSA9PiB7XG4gICAgdHlwZW9mIG8uc3R5bGUgIT0gXCJmdW5jdGlvblwiICYmIChvLnN0eWxlID0gTWkoby5zdHlsZSkpO1xuICB9KSwgbjtcbn1cbmNvbnN0IFN1ID0gTm8oKTtcbmZ1bmN0aW9uIFpuKGUpIHtcbiAgcmV0dXJuIGUgIT09IFwib3duZXJTdGF0ZVwiICYmIGUgIT09IFwidGhlbWVcIiAmJiBlICE9PSBcInN4XCIgJiYgZSAhPT0gXCJhc1wiO1xufVxuZnVuY3Rpb24gRXUoZSkge1xuICByZXR1cm4gZSA/ICh0LCByKSA9PiByW2VdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIEN1KGUsIHQsIHIpIHtcbiAgZS50aGVtZSA9IFJ1KGUudGhlbWUpID8gciA6IGUudGhlbWVbdF0gfHwgZS50aGVtZTtcbn1cbmZ1bmN0aW9uIGxuKGUsIHQpIHtcbiAgY29uc3QgciA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQoZSkgOiB0O1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSlcbiAgICByZXR1cm4gci5mbGF0TWFwKChuKSA9PiBsbihlLCBuKSk7XG4gIGlmIChBcnJheS5pc0FycmF5KHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIudmFyaWFudHMpKSB7XG4gICAgbGV0IG47XG4gICAgaWYgKHIuaXNQcm9jZXNzZWQpXG4gICAgICBuID0gci5zdHlsZTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdmFyaWFudHM6IG8sXG4gICAgICAgIC4uLmlcbiAgICAgIH0gPSByO1xuICAgICAgbiA9IGk7XG4gICAgfVxuICAgIHJldHVybiBxYShlLCByLnZhcmlhbnRzLCBbbl0pO1xuICB9XG4gIHJldHVybiByICE9IG51bGwgJiYgci5pc1Byb2Nlc3NlZCA/IHIuc3R5bGUgOiByO1xufVxuZnVuY3Rpb24gcWEoZSwgdCwgciA9IFtdKSB7XG4gIHZhciBvO1xuICBsZXQgbjtcbiAgZTogZm9yIChsZXQgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcyA9IHRbaV07XG4gICAgaWYgKHR5cGVvZiBzLnByb3BzID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKG4gPz8gKG4gPSB7XG4gICAgICAgIC4uLmUsXG4gICAgICAgIC4uLmUub3duZXJTdGF0ZSxcbiAgICAgICAgb3duZXJTdGF0ZTogZS5vd25lclN0YXRlXG4gICAgICB9KSwgIXMucHJvcHMobikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZVxuICAgICAgZm9yIChjb25zdCBjIGluIHMucHJvcHMpXG4gICAgICAgIGlmIChlW2NdICE9PSBzLnByb3BzW2NdICYmICgobyA9IGUub3duZXJTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG9bY10pICE9PSBzLnByb3BzW2NdKVxuICAgICAgICAgIGNvbnRpbnVlIGU7XG4gICAgdHlwZW9mIHMuc3R5bGUgPT0gXCJmdW5jdGlvblwiID8gKG4gPz8gKG4gPSB7XG4gICAgICAuLi5lLFxuICAgICAgLi4uZS5vd25lclN0YXRlLFxuICAgICAgb3duZXJTdGF0ZTogZS5vd25lclN0YXRlXG4gICAgfSksIHIucHVzaChzLnN0eWxlKG4pKSkgOiByLnB1c2gocy5zdHlsZSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBUdShlID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHRoZW1lSWQ6IHQsXG4gICAgZGVmYXVsdFRoZW1lOiByID0gU3UsXG4gICAgcm9vdFNob3VsZEZvcndhcmRQcm9wOiBuID0gWm4sXG4gICAgc2xvdFNob3VsZEZvcndhcmRQcm9wOiBvID0gWm5cbiAgfSA9IGU7XG4gIGZ1bmN0aW9uIGkoYykge1xuICAgIEN1KGMsIHQsIHIpO1xuICB9XG4gIHJldHVybiAoYywgbCA9IHt9KSA9PiB7XG4gICAgcGwoYywgKGgpID0+IGguZmlsdGVyKCh3KSA9PiB3ICE9PSBBdCkpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWU6IHUsXG4gICAgICBzbG90OiBwLFxuICAgICAgc2tpcFZhcmlhbnRzUmVzb2x2ZXI6IG0sXG4gICAgICBza2lwU3g6IGcsXG4gICAgICAvLyBUT0RPIHY2OiByZW1vdmUgYGxvd2VyY2FzZUZpcnN0TGV0dGVyKClgIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbiAgICAgIC8vIEZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS9tdWkvbWF0ZXJpYWwtdWkvcHVsbC8zNzkwOFxuICAgICAgb3ZlcnJpZGVzUmVzb2x2ZXI6IHggPSBFdShHYShwKSksXG4gICAgICAuLi55XG4gICAgfSA9IGwsIGYgPSBtICE9PSB2b2lkIDAgPyBtIDogKFxuICAgICAgLy8gVE9ETyB2NjogcmVtb3ZlIGBSb290YCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG4gICAgICAvLyBGb3IgbW9yZSBkZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vbXVpL21hdGVyaWFsLXVpL3B1bGwvMzc5MDhcbiAgICAgIHAgJiYgcCAhPT0gXCJSb290XCIgJiYgcCAhPT0gXCJyb290XCIgfHwgITFcbiAgICApLCBTID0gZyB8fCAhMTtcbiAgICBsZXQgRSA9IFpuO1xuICAgIHAgPT09IFwiUm9vdFwiIHx8IHAgPT09IFwicm9vdFwiID8gRSA9IG4gOiBwID8gRSA9IG8gOiAkdShjKSAmJiAoRSA9IHZvaWQgMCk7XG4gICAgY29uc3QgUCA9IGphKGMsIHtcbiAgICAgIHNob3VsZEZvcndhcmRQcm9wOiBFLFxuICAgICAgbGFiZWw6IE91KHUsIHApLFxuICAgICAgLi4ueVxuICAgIH0pLCBUID0gKGgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaCA9PSBcImZ1bmN0aW9uXCIgJiYgaC5fX2Vtb3Rpb25fcmVhbCAhPT0gaClcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICByZXR1cm4gbG4oaywgaCk7XG4gICAgICAgIH07XG4gICAgICBpZiAoZ3QoaCkpIHtcbiAgICAgICAgY29uc3QgdyA9IEhhKGgpO1xuICAgICAgICByZXR1cm4gdy52YXJpYW50cyA/IGZ1bmN0aW9uKEwpIHtcbiAgICAgICAgICByZXR1cm4gbG4oTCwgdyk7XG4gICAgICAgIH0gOiB3LnN0eWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGg7XG4gICAgfSwgYiA9ICguLi5oKSA9PiB7XG4gICAgICBjb25zdCB3ID0gW10sIGsgPSBoLm1hcChUKSwgTCA9IFtdO1xuICAgICAgaWYgKHcucHVzaChpKSwgdSAmJiB4ICYmIEwucHVzaChmdW5jdGlvbihEKSB7XG4gICAgICAgIHZhciBVLCBWO1xuICAgICAgICBjb25zdCBXID0gKFYgPSAoVSA9IEQudGhlbWUuY29tcG9uZW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IFVbdV0pID09IG51bGwgPyB2b2lkIDAgOiBWLnN0eWxlT3ZlcnJpZGVzO1xuICAgICAgICBpZiAoIVcpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHogPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0ZSBpbiBXKVxuICAgICAgICAgIHpbdGVdID0gbG4oRCwgV1t0ZV0pO1xuICAgICAgICByZXR1cm4geChELCB6KTtcbiAgICAgIH0pLCB1ICYmICFmICYmIEwucHVzaChmdW5jdGlvbihEKSB7XG4gICAgICAgIHZhciB6LCBVO1xuICAgICAgICBjb25zdCBqID0gRC50aGVtZSwgVyA9IChVID0gKHogPSBqID09IG51bGwgPyB2b2lkIDAgOiBqLmNvbXBvbmVudHMpID09IG51bGwgPyB2b2lkIDAgOiB6W3VdKSA9PSBudWxsID8gdm9pZCAwIDogVS52YXJpYW50cztcbiAgICAgICAgcmV0dXJuIFcgPyBxYShELCBXKSA6IG51bGw7XG4gICAgICB9KSwgUyB8fCBMLnB1c2goQXQpLCBBcnJheS5pc0FycmF5KGtbMF0pKSB7XG4gICAgICAgIGNvbnN0IEEgPSBrLnNoaWZ0KCksIEQgPSBuZXcgQXJyYXkody5sZW5ndGgpLmZpbGwoXCJcIiksIGogPSBuZXcgQXJyYXkoTC5sZW5ndGgpLmZpbGwoXCJcIik7XG4gICAgICAgIGxldCBXO1xuICAgICAgICBXID0gWy4uLkQsIC4uLkEsIC4uLmpdLCBXLnJhdyA9IFsuLi5ELCAuLi5BLnJhdywgLi4ual0sIHcudW5zaGlmdChXKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IEIgPSBbLi4udywgLi4uaywgLi4uTF0sIGQgPSBQKC4uLkIpO1xuICAgICAgcmV0dXJuIGMubXVpTmFtZSAmJiAoZC5tdWlOYW1lID0gYy5tdWlOYW1lKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChkLmRpc3BsYXlOYW1lID0gd3UodSwgcCwgYykpLCBkO1xuICAgIH07XG4gICAgcmV0dXJuIFAud2l0aENvbmZpZyAmJiAoYi53aXRoQ29uZmlnID0gUC53aXRoQ29uZmlnKSwgYjtcbiAgfTtcbn1cbmZ1bmN0aW9uIHd1KGUsIHQsIHIpIHtcbiAgcmV0dXJuIGUgPyBgJHtlfSR7ZWUodCB8fCBcIlwiKX1gIDogYFN0eWxlZCgke3h1KHIpfSlgO1xufVxuZnVuY3Rpb24gT3UoZSwgdCkge1xuICBsZXQgcjtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlICYmIChyID0gYCR7ZX0tJHtHYSh0IHx8IFwiUm9vdFwiKX1gKSwgcjtcbn1cbmZ1bmN0aW9uIFJ1KGUpIHtcbiAgZm9yIChjb25zdCB0IGluIGUpXG4gICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiAkdShlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiICYmIC8vIDk2IGlzIG9uZSBsZXNzIHRoYW4gdGhlIGNoYXIgY29kZVxuICAvLyBmb3IgXCJhXCIgc28gdGhpcyBpcyBjaGVja2luZyB0aGF0XG4gIC8vIGl0J3MgYSBsb3dlcmNhc2UgY2hhcmFjdGVyXG4gIGUuY2hhckNvZGVBdCgwKSA+IDk2O1xufVxuZnVuY3Rpb24gR2EoZSkge1xuICByZXR1cm4gZSAmJiBlLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgZS5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIGNvKGUsIHQpIHtcbiAgY29uc3QgciA9IHtcbiAgICAuLi50XG4gIH07XG4gIGZvciAoY29uc3QgbiBpbiBlKVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgbikpIHtcbiAgICAgIGNvbnN0IG8gPSBuO1xuICAgICAgaWYgKG8gPT09IFwiY29tcG9uZW50c1wiIHx8IG8gPT09IFwic2xvdHNcIilcbiAgICAgICAgcltvXSA9IHtcbiAgICAgICAgICAuLi5lW29dLFxuICAgICAgICAgIC4uLnJbb11cbiAgICAgICAgfTtcbiAgICAgIGVsc2UgaWYgKG8gPT09IFwiY29tcG9uZW50c1Byb3BzXCIgfHwgbyA9PT0gXCJzbG90UHJvcHNcIikge1xuICAgICAgICBjb25zdCBpID0gZVtvXSwgcyA9IHRbb107XG4gICAgICAgIGlmICghcylcbiAgICAgICAgICByW29dID0gaSB8fCB7fTtcbiAgICAgICAgZWxzZSBpZiAoIWkpXG4gICAgICAgICAgcltvXSA9IHM7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJbb10gPSB7XG4gICAgICAgICAgICAuLi5zXG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGMgaW4gaSlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSwgYykpIHtcbiAgICAgICAgICAgICAgY29uc3QgbCA9IGM7XG4gICAgICAgICAgICAgIHJbb11bbF0gPSBjbyhpW2xdLCBzW2xdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHJbb10gPT09IHZvaWQgMCAmJiAocltvXSA9IGVbb10pO1xuICAgIH1cbiAgcmV0dXJuIHI7XG59XG5jb25zdCBGdCA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IEMudXNlTGF5b3V0RWZmZWN0IDogQy51c2VFZmZlY3Q7XG5mdW5jdGlvbiBQdShlLCB0ID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsIHIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICByZXR1cm4gTWF0aC5tYXgodCwgTWF0aC5taW4oZSwgcikpO1xufVxuZnVuY3Rpb24gTW8oZSwgdCA9IDAsIHIgPSAxKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGUgPCB0IHx8IGUgPiByKSAmJiBjb25zb2xlLmVycm9yKGBNVUk6IFRoZSB2YWx1ZSBwcm92aWRlZCAke2V9IGlzIG91dCBvZiByYW5nZSBbJHt0fSwgJHtyfV0uYCksIFB1KGUsIHQsIHIpO1xufVxuZnVuY3Rpb24ga3UoZSkge1xuICBlID0gZS5zbGljZSgxKTtcbiAgY29uc3QgdCA9IG5ldyBSZWdFeHAoYC57MSwke2UubGVuZ3RoID49IDYgPyAyIDogMX19YCwgXCJnXCIpO1xuICBsZXQgciA9IGUubWF0Y2godCk7XG4gIHJldHVybiByICYmIHJbMF0ubGVuZ3RoID09PSAxICYmIChyID0gci5tYXAoKG4pID0+IG4gKyBuKSksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlLmxlbmd0aCAhPT0gZS50cmltKCkubGVuZ3RoICYmIGNvbnNvbGUuZXJyb3IoYE1VSTogVGhlIGNvbG9yOiBcIiR7ZX1cIiBpcyBpbnZhbGlkLiBNYWtlIHN1cmUgdGhlIGNvbG9yIGlucHV0IGRvZXNuJ3QgY29udGFpbiBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlLmApLCByID8gYHJnYiR7ci5sZW5ndGggPT09IDQgPyBcImFcIiA6IFwiXCJ9KCR7ci5tYXAoKG4sIG8pID0+IG8gPCAzID8gcGFyc2VJbnQobiwgMTYpIDogTWF0aC5yb3VuZChwYXJzZUludChuLCAxNikgLyAyNTUgKiAxZTMpIC8gMWUzKS5qb2luKFwiLCBcIil9KWAgOiBcIlwiO1xufVxuZnVuY3Rpb24gTnQoZSkge1xuICBpZiAoZS50eXBlKVxuICAgIHJldHVybiBlO1xuICBpZiAoZS5jaGFyQXQoMCkgPT09IFwiI1wiKVxuICAgIHJldHVybiBOdChrdShlKSk7XG4gIGNvbnN0IHQgPSBlLmluZGV4T2YoXCIoXCIpLCByID0gZS5zdWJzdHJpbmcoMCwgdCk7XG4gIGlmICghW1wicmdiXCIsIFwicmdiYVwiLCBcImhzbFwiLCBcImhzbGFcIiwgXCJjb2xvclwiXS5pbmNsdWRlcyhyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gYE1VSTogVW5zdXBwb3J0ZWQgXFxgJHtlfVxcYCBjb2xvci5cblRoZSBmb2xsb3dpbmcgZm9ybWF0cyBhcmUgc3VwcG9ydGVkOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpLCBjb2xvcigpLmAgOiBrdCg5LCBlKSk7XG4gIGxldCBuID0gZS5zdWJzdHJpbmcodCArIDEsIGUubGVuZ3RoIC0gMSksIG87XG4gIGlmIChyID09PSBcImNvbG9yXCIpIHtcbiAgICBpZiAobiA9IG4uc3BsaXQoXCIgXCIpLCBvID0gbi5zaGlmdCgpLCBuLmxlbmd0aCA9PT0gNCAmJiBuWzNdLmNoYXJBdCgwKSA9PT0gXCIvXCIgJiYgKG5bM10gPSBuWzNdLnNsaWNlKDEpKSwgIVtcInNyZ2JcIiwgXCJkaXNwbGF5LXAzXCIsIFwiYTk4LXJnYlwiLCBcInByb3Bob3RvLXJnYlwiLCBcInJlYy0yMDIwXCJdLmluY2x1ZGVzKG8pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGBNVUk6IHVuc3VwcG9ydGVkIFxcYCR7b31cXGAgY29sb3Igc3BhY2UuXG5UaGUgZm9sbG93aW5nIGNvbG9yIHNwYWNlcyBhcmUgc3VwcG9ydGVkOiBzcmdiLCBkaXNwbGF5LXAzLCBhOTgtcmdiLCBwcm9waG90by1yZ2IsIHJlYy0yMDIwLmAgOiBrdCgxMCwgbykpO1xuICB9IGVsc2VcbiAgICBuID0gbi5zcGxpdChcIixcIik7XG4gIHJldHVybiBuID0gbi5tYXAoKGkpID0+IHBhcnNlRmxvYXQoaSkpLCB7XG4gICAgdHlwZTogcixcbiAgICB2YWx1ZXM6IG4sXG4gICAgY29sb3JTcGFjZTogb1xuICB9O1xufVxuY29uc3QgQXUgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gTnQoZSk7XG4gIHJldHVybiB0LnZhbHVlcy5zbGljZSgwLCAzKS5tYXAoKHIsIG4pID0+IHQudHlwZS5pbmNsdWRlcyhcImhzbFwiKSAmJiBuICE9PSAwID8gYCR7cn0lYCA6IHIpLmpvaW4oXCIgXCIpO1xufSwgZ3IgPSAoZSwgdCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBBdShlKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHQgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNvbnNvbGUud2Fybih0KSwgZTtcbiAgfVxufTtcbmZ1bmN0aW9uIEJuKGUpIHtcbiAgY29uc3Qge1xuICAgIHR5cGU6IHQsXG4gICAgY29sb3JTcGFjZTogclxuICB9ID0gZTtcbiAgbGV0IHtcbiAgICB2YWx1ZXM6IG5cbiAgfSA9IGU7XG4gIHJldHVybiB0LmluY2x1ZGVzKFwicmdiXCIpID8gbiA9IG4ubWFwKChvLCBpKSA9PiBpIDwgMyA/IHBhcnNlSW50KG8sIDEwKSA6IG8pIDogdC5pbmNsdWRlcyhcImhzbFwiKSAmJiAoblsxXSA9IGAke25bMV19JWAsIG5bMl0gPSBgJHtuWzJdfSVgKSwgdC5pbmNsdWRlcyhcImNvbG9yXCIpID8gbiA9IGAke3J9ICR7bi5qb2luKFwiIFwiKX1gIDogbiA9IGAke24uam9pbihcIiwgXCIpfWAsIGAke3R9KCR7bn0pYDtcbn1cbmZ1bmN0aW9uIEthKGUpIHtcbiAgZSA9IE50KGUpO1xuICBjb25zdCB7XG4gICAgdmFsdWVzOiB0XG4gIH0gPSBlLCByID0gdFswXSwgbiA9IHRbMV0gLyAxMDAsIG8gPSB0WzJdIC8gMTAwLCBpID0gbiAqIE1hdGgubWluKG8sIDEgLSBvKSwgcyA9ICh1LCBwID0gKHUgKyByIC8gMzApICUgMTIpID0+IG8gLSBpICogTWF0aC5tYXgoTWF0aC5taW4ocCAtIDMsIDkgLSBwLCAxKSwgLTEpO1xuICBsZXQgYyA9IFwicmdiXCI7XG4gIGNvbnN0IGwgPSBbTWF0aC5yb3VuZChzKDApICogMjU1KSwgTWF0aC5yb3VuZChzKDgpICogMjU1KSwgTWF0aC5yb3VuZChzKDQpICogMjU1KV07XG4gIHJldHVybiBlLnR5cGUgPT09IFwiaHNsYVwiICYmIChjICs9IFwiYVwiLCBsLnB1c2godFszXSkpLCBCbih7XG4gICAgdHlwZTogYyxcbiAgICB2YWx1ZXM6IGxcbiAgfSk7XG59XG5mdW5jdGlvbiBsbyhlKSB7XG4gIGUgPSBOdChlKTtcbiAgbGV0IHQgPSBlLnR5cGUgPT09IFwiaHNsXCIgfHwgZS50eXBlID09PSBcImhzbGFcIiA/IE50KEthKGUpKS52YWx1ZXMgOiBlLnZhbHVlcztcbiAgcmV0dXJuIHQgPSB0Lm1hcCgocikgPT4gKGUudHlwZSAhPT0gXCJjb2xvclwiICYmIChyIC89IDI1NSksIHIgPD0gMC4wMzkyOCA/IHIgLyAxMi45MiA6ICgociArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQpKSwgTnVtYmVyKCgwLjIxMjYgKiB0WzBdICsgMC43MTUyICogdFsxXSArIDAuMDcyMiAqIHRbMl0pLnRvRml4ZWQoMykpO1xufVxuZnVuY3Rpb24gRmkoZSwgdCkge1xuICBjb25zdCByID0gbG8oZSksIG4gPSBsbyh0KTtcbiAgcmV0dXJuIChNYXRoLm1heChyLCBuKSArIDAuMDUpIC8gKE1hdGgubWluKHIsIG4pICsgMC4wNSk7XG59XG5mdW5jdGlvbiBEZShlLCB0KSB7XG4gIHJldHVybiBlID0gTnQoZSksIHQgPSBNbyh0KSwgKGUudHlwZSA9PT0gXCJyZ2JcIiB8fCBlLnR5cGUgPT09IFwiaHNsXCIpICYmIChlLnR5cGUgKz0gXCJhXCIpLCBlLnR5cGUgPT09IFwiY29sb3JcIiA/IGUudmFsdWVzWzNdID0gYC8ke3R9YCA6IGUudmFsdWVzWzNdID0gdCwgQm4oZSk7XG59XG5mdW5jdGlvbiBYcihlLCB0LCByKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIERlKGUsIHQpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuZnVuY3Rpb24gSW8oZSwgdCkge1xuICBpZiAoZSA9IE50KGUpLCB0ID0gTW8odCksIGUudHlwZS5pbmNsdWRlcyhcImhzbFwiKSlcbiAgICBlLnZhbHVlc1syXSAqPSAxIC0gdDtcbiAgZWxzZSBpZiAoZS50eXBlLmluY2x1ZGVzKFwicmdiXCIpIHx8IGUudHlwZS5pbmNsdWRlcyhcImNvbG9yXCIpKVxuICAgIGZvciAobGV0IHIgPSAwOyByIDwgMzsgciArPSAxKVxuICAgICAgZS52YWx1ZXNbcl0gKj0gMSAtIHQ7XG4gIHJldHVybiBCbihlKTtcbn1cbmZ1bmN0aW9uIENlKGUsIHQsIHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSW8oZSwgdCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5mdW5jdGlvbiBfbyhlLCB0KSB7XG4gIGlmIChlID0gTnQoZSksIHQgPSBNbyh0KSwgZS50eXBlLmluY2x1ZGVzKFwiaHNsXCIpKVxuICAgIGUudmFsdWVzWzJdICs9ICgxMDAgLSBlLnZhbHVlc1syXSkgKiB0O1xuICBlbHNlIGlmIChlLnR5cGUuaW5jbHVkZXMoXCJyZ2JcIikpXG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCAzOyByICs9IDEpXG4gICAgICBlLnZhbHVlc1tyXSArPSAoMjU1IC0gZS52YWx1ZXNbcl0pICogdDtcbiAgZWxzZSBpZiAoZS50eXBlLmluY2x1ZGVzKFwiY29sb3JcIikpXG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCAzOyByICs9IDEpXG4gICAgICBlLnZhbHVlc1tyXSArPSAoMSAtIGUudmFsdWVzW3JdKSAqIHQ7XG4gIHJldHVybiBCbihlKTtcbn1cbmZ1bmN0aW9uIFRlKGUsIHQsIHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gX28oZSwgdCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5mdW5jdGlvbiBOdShlLCB0ID0gMC4xNSkge1xuICByZXR1cm4gbG8oZSkgPiAwLjUgPyBJbyhlLCB0KSA6IF9vKGUsIHQpO1xufVxuZnVuY3Rpb24gSnIoZSwgdCwgcikge1xuICB0cnkge1xuICAgIHJldHVybiBOdShlLCB0KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGFyKGUsIHQpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/ICgpID0+IG51bGwgOiBmdW5jdGlvbiguLi5uKSB7XG4gICAgcmV0dXJuIGUoLi4ubikgfHwgdCguLi5uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIE11KGUpIHtcbiAgY29uc3Qge1xuICAgIHByb3RvdHlwZTogdCA9IHt9XG4gIH0gPSBlO1xuICByZXR1cm4gISF0LmlzUmVhY3RDb21wb25lbnQ7XG59XG5mdW5jdGlvbiBYYShlLCB0LCByLCBuLCBvKSB7XG4gIGNvbnN0IGkgPSBlW3RdLCBzID0gbyB8fCB0O1xuICBpZiAoaSA9PSBudWxsIHx8IC8vIFdoZW4gc2VydmVyLXNpZGUgcmVuZGVyaW5nIFJlYWN0IGRvZXNuJ3Qgd2FybiBlaXRoZXIuXG4gIC8vIFRoaXMgaXMgbm90IGFuIGFjY3VyYXRlIGNoZWNrIGZvciBTU1IuXG4gIC8vIFRoaXMgaXMgb25seSBpbiBwbGFjZSBmb3IgRW1vdGlvbiBjb21wYXQuXG4gIC8vIFRPRE86IFJldmlzaXQgb25jZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwMDQ3IGlzIHJlc29sdmVkLlxuICB0eXBlb2Ygd2luZG93ID4gXCJ1XCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBjO1xuICBjb25zdCBsID0gaS50eXBlO1xuICByZXR1cm4gdHlwZW9mIGwgPT0gXCJmdW5jdGlvblwiICYmICFNdShsKSAmJiAoYyA9IFwiRGlkIHlvdSBhY2NpZGVudGFsbHkgdXNlIGEgcGxhaW4gZnVuY3Rpb24gY29tcG9uZW50IGZvciBhbiBlbGVtZW50IGluc3RlYWQ/XCIpLCBjICE9PSB2b2lkIDAgPyBuZXcgRXJyb3IoYEludmFsaWQgJHtufSBcXGAke3N9XFxgIHN1cHBsaWVkIHRvIFxcYCR7cn1cXGAuIEV4cGVjdGVkIGFuIGVsZW1lbnQgdGhhdCBjYW4gaG9sZCBhIHJlZi4gJHtjfSBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9tdWkuY29tL3IvY2F2ZWF0LXdpdGgtcmVmcy1ndWlkZWApIDogbnVsbDtcbn1cbmNvbnN0IGpvID0gYXIoYS5lbGVtZW50LCBYYSk7XG5qby5pc1JlcXVpcmVkID0gYXIoYS5lbGVtZW50LmlzUmVxdWlyZWQsIFhhKTtcbmZ1bmN0aW9uIEl1KGUpIHtcbiAgY29uc3Qge1xuICAgIHByb3RvdHlwZTogdCA9IHt9XG4gIH0gPSBlO1xuICByZXR1cm4gISF0LmlzUmVhY3RDb21wb25lbnQ7XG59XG5mdW5jdGlvbiBfdShlLCB0LCByLCBuLCBvKSB7XG4gIGNvbnN0IGkgPSBlW3RdLCBzID0gbyB8fCB0O1xuICBpZiAoaSA9PSBudWxsIHx8IC8vIFdoZW4gc2VydmVyLXNpZGUgcmVuZGVyaW5nIFJlYWN0IGRvZXNuJ3Qgd2FybiBlaXRoZXIuXG4gIC8vIFRoaXMgaXMgbm90IGFuIGFjY3VyYXRlIGNoZWNrIGZvciBTU1IuXG4gIC8vIFRoaXMgaXMgb25seSBpbiBwbGFjZSBmb3IgZW1vdGlvbiBjb21wYXQuXG4gIC8vIFRPRE86IFJldmlzaXQgb25jZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwMDQ3IGlzIHJlc29sdmVkLlxuICB0eXBlb2Ygd2luZG93ID4gXCJ1XCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBjO1xuICByZXR1cm4gdHlwZW9mIGkgPT0gXCJmdW5jdGlvblwiICYmICFJdShpKSAmJiAoYyA9IFwiRGlkIHlvdSBhY2NpZGVudGFsbHkgcHJvdmlkZSBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCBpbnN0ZWFkP1wiKSwgYyAhPT0gdm9pZCAwID8gbmV3IEVycm9yKGBJbnZhbGlkICR7bn0gXFxgJHtzfVxcYCBzdXBwbGllZCB0byBcXGAke3J9XFxgLiBFeHBlY3RlZCBhbiBlbGVtZW50IHR5cGUgdGhhdCBjYW4gaG9sZCBhIHJlZi4gJHtjfSBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9tdWkuY29tL3IvY2F2ZWF0LXdpdGgtcmVmcy1ndWlkZWApIDogbnVsbDtcbn1cbmNvbnN0IEphID0gYXIoYS5lbGVtZW50VHlwZSwgX3UpLCBqdSA9IFwiZXhhY3QtcHJvcDog4oCLXCI7XG5mdW5jdGlvbiBEbyhlKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBlIDoge1xuICAgIC4uLmUsXG4gICAgW2p1XTogKHQpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBPYmplY3Qua2V5cyh0KS5maWx0ZXIoKG4pID0+ICFlLmhhc093blByb3BlcnR5KG4pKTtcbiAgICAgIHJldHVybiByLmxlbmd0aCA+IDAgPyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgcHJvcHMgYXJlIG5vdCBzdXBwb3J0ZWQ6ICR7ci5tYXAoKG4pID0+IGBcXGAke259XFxgYCkuam9pbihcIiwgXCIpfS4gUGxlYXNlIHJlbW92ZSB0aGVtLmApIDogbnVsbDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBPcihlLCB0LCByLCBuLCBvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGkgPSBlW3RdLCBzID0gbyB8fCB0O1xuICByZXR1cm4gaSA9PSBudWxsID8gbnVsbCA6IGkgJiYgaS5ub2RlVHlwZSAhPT0gMSA/IG5ldyBFcnJvcihgSW52YWxpZCAke259IFxcYCR7c31cXGAgc3VwcGxpZWQgdG8gXFxgJHtyfVxcYC4gRXhwZWN0ZWQgYW4gSFRNTEVsZW1lbnQuYCkgOiBudWxsO1xufVxuY29uc3QgTG8gPSBhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdF0pO1xuZnVuY3Rpb24gemkoZSkge1xuICByZXR1cm4gZSAmJiBlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiB1byhlLCB0KSB7XG4gIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUodCkgOiBlICYmIChlLmN1cnJlbnQgPSB0KTtcbn1cbmxldCBXaSA9IDA7XG5mdW5jdGlvbiBEdShlKSB7XG4gIGNvbnN0IFt0LCByXSA9IEMudXNlU3RhdGUoZSksIG4gPSBlIHx8IHQ7XG4gIHJldHVybiBDLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdCA9PSBudWxsICYmIChXaSArPSAxLCByKGBtdWktJHtXaX1gKSk7XG4gIH0sIFt0XSksIG47XG59XG5jb25zdCBMdSA9IHtcbiAgLi4uQ1xufSwgVWkgPSBMdS51c2VJZDtcbmZ1bmN0aW9uIFFhKGUpIHtcbiAgaWYgKFVpICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCB0ID0gVWkoKTtcbiAgICByZXR1cm4gZSA/PyB0O1xuICB9XG4gIHJldHVybiBEdShlKTtcbn1cbmZ1bmN0aW9uIEJ1KGUsIHQsIHIsIG4sIG8pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIilcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgaSA9IG8gfHwgdDtcbiAgcmV0dXJuIHR5cGVvZiBlW3RdIDwgXCJ1XCIgPyBuZXcgRXJyb3IoYFRoZSBwcm9wIFxcYCR7aX1cXGAgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHJlbW92ZSBpdC5gKSA6IG51bGw7XG59XG5mdW5jdGlvbiBWdSh7XG4gIGNvbnRyb2xsZWQ6IGUsXG4gIGRlZmF1bHQ6IHQsXG4gIG5hbWU6IHIsXG4gIHN0YXRlOiBuID0gXCJ2YWx1ZVwiXG59KSB7XG4gIGNvbnN0IHtcbiAgICBjdXJyZW50OiBvXG4gIH0gPSBDLnVzZVJlZihlICE9PSB2b2lkIDApLCBbaSwgc10gPSBDLnVzZVN0YXRlKHQpLCBjID0gbyA/IGUgOiBpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgQy51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgbyAhPT0gKGUgIT09IHZvaWQgMCkgJiYgY29uc29sZS5lcnJvcihbYE1VSTogQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgdGhlICR7byA/IFwiXCIgOiBcInVuXCJ9Y29udHJvbGxlZCAke259IHN0YXRlIG9mICR7cn0gdG8gYmUgJHtvID8gXCJ1blwiIDogXCJcIn1jb250cm9sbGVkLmAsIFwiRWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuXCIsIGBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICR7cn0gZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuYCwgXCJUaGUgbmF0dXJlIG9mIHRoZSBzdGF0ZSBpcyBkZXRlcm1pbmVkIGR1cmluZyB0aGUgZmlyc3QgcmVuZGVyLiBJdCdzIGNvbnNpZGVyZWQgY29udHJvbGxlZCBpZiB0aGUgdmFsdWUgaXMgbm90IGB1bmRlZmluZWRgLlwiLCBcIk1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHNcIl0uam9pbihgXG5gKSk7XG4gICAgfSwgW24sIHIsIGVdKTtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50OiB1XG4gICAgfSA9IEMudXNlUmVmKHQpO1xuICAgIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICFvICYmICFPYmplY3QuaXModSwgdCkgJiYgY29uc29sZS5lcnJvcihbYE1VSTogQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgdGhlIGRlZmF1bHQgJHtufSBzdGF0ZSBvZiBhbiB1bmNvbnRyb2xsZWQgJHtyfSBhZnRlciBiZWluZyBpbml0aWFsaXplZC4gVG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIG9wdCB0byB1c2UgYSBjb250cm9sbGVkICR7cn0uYF0uam9pbihgXG5gKSk7XG4gICAgfSwgW0pTT04uc3RyaW5naWZ5KHQpXSk7XG4gIH1cbiAgY29uc3QgbCA9IEMudXNlQ2FsbGJhY2soKHUpID0+IHtcbiAgICBvIHx8IHModSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFtjLCBsXTtcbn1cbmZ1bmN0aW9uIFF0KGUpIHtcbiAgY29uc3QgdCA9IEMudXNlUmVmKGUpO1xuICByZXR1cm4gRnQoKCkgPT4ge1xuICAgIHQuY3VycmVudCA9IGU7XG4gIH0pLCBDLnVzZVJlZigoLi4ucikgPT4gKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaGlkZSBgdGhpc2BcbiAgICAoMCwgdC5jdXJyZW50KSguLi5yKVxuICApKS5jdXJyZW50O1xufVxuZnVuY3Rpb24gYXQoLi4uZSkge1xuICByZXR1cm4gQy51c2VNZW1vKCgpID0+IGUuZXZlcnkoKHQpID0+IHQgPT0gbnVsbCkgPyBudWxsIDogKHQpID0+IHtcbiAgICBlLmZvckVhY2goKHIpID0+IHtcbiAgICAgIHVvKHIsIHQpO1xuICAgIH0pO1xuICB9LCBlKTtcbn1cbmNvbnN0IFlpID0ge307XG5mdW5jdGlvbiBaYShlLCB0KSB7XG4gIGNvbnN0IHIgPSBDLnVzZVJlZihZaSk7XG4gIHJldHVybiByLmN1cnJlbnQgPT09IFlpICYmIChyLmN1cnJlbnQgPSBlKHQpKSwgcjtcbn1cbmNvbnN0IEZ1ID0gW107XG5mdW5jdGlvbiB6dShlKSB7XG4gIEMudXNlRWZmZWN0KGUsIEZ1KTtcbn1cbmNsYXNzIFZuIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY3IodGhpcywgXCJjdXJyZW50SWRcIiwgbnVsbCk7XG4gICAgY3IodGhpcywgXCJjbGVhclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRJZCAhPT0gbnVsbCAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuY3VycmVudElkKSwgdGhpcy5jdXJyZW50SWQgPSBudWxsKTtcbiAgICB9KTtcbiAgICBjcih0aGlzLCBcImRpc3Bvc2VFZmZlY3RcIiwgKCkgPT4gdGhpcy5jbGVhcik7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IFZuKCk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGBmbmAgYWZ0ZXIgYGRlbGF5YCwgY2xlYXJpbmcgYW55IHByZXZpb3VzbHkgc2NoZWR1bGVkIGNhbGwuXG4gICAqL1xuICBzdGFydCh0LCByKSB7XG4gICAgdGhpcy5jbGVhcigpLCB0aGlzLmN1cnJlbnRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50SWQgPSBudWxsLCByKCk7XG4gICAgfSwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIER0KCkge1xuICBjb25zdCBlID0gWmEoVm4uY3JlYXRlKS5jdXJyZW50O1xuICByZXR1cm4genUoZS5kaXNwb3NlRWZmZWN0KSwgZTtcbn1cbmZ1bmN0aW9uIGhuKGUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZS5tYXRjaGVzKFwiOmZvY3VzLXZpc2libGVcIik7XG4gIH0gY2F0Y2gge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhL2pzZG9tLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSAmJiBjb25zb2xlLndhcm4oW1wiTVVJOiBUaGUgYDpmb2N1cy12aXNpYmxlYCBwc2V1ZG8gY2xhc3MgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuXCIsIFwiU29tZSBjb21wb25lbnRzIHJlbHkgb24gdGhpcyBmZWF0dXJlIHRvIHdvcmsgcHJvcGVybHkuXCJdLmpvaW4oYFxuYCkpO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIEdlKGUsIHQsIHIgPSB2b2lkIDApIHtcbiAgY29uc3QgbiA9IHt9O1xuICBmb3IgKGNvbnN0IG8gaW4gZSkge1xuICAgIGNvbnN0IGkgPSBlW29dO1xuICAgIGxldCBzID0gXCJcIiwgYyA9ICEwO1xuICAgIGZvciAobGV0IGwgPSAwOyBsIDwgaS5sZW5ndGg7IGwgKz0gMSkge1xuICAgICAgY29uc3QgdSA9IGlbbF07XG4gICAgICB1ICYmIChzICs9IChjID09PSAhMCA/IFwiXCIgOiBcIiBcIikgKyB0KHUpLCBjID0gITEsIHIgJiYgclt1XSAmJiAocyArPSBcIiBcIiArIHJbdV0pKTtcbiAgICB9XG4gICAgbltvXSA9IHM7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBXdShlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gZXMoZSwgdCwgcikge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwIHx8IFd1KGUpID8gdCA6IHtcbiAgICAuLi50LFxuICAgIG93bmVyU3RhdGU6IHtcbiAgICAgIC4uLnQub3duZXJTdGF0ZSxcbiAgICAgIC4uLnJcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBVdShlLCB0ID0gW10pIHtcbiAgaWYgKGUgPT09IHZvaWQgMClcbiAgICByZXR1cm4ge307XG4gIGNvbnN0IHIgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLmZpbHRlcigobikgPT4gbi5tYXRjaCgvXm9uW0EtWl0vKSAmJiB0eXBlb2YgZVtuXSA9PSBcImZ1bmN0aW9uXCIgJiYgIXQuaW5jbHVkZXMobikpLmZvckVhY2goKG4pID0+IHtcbiAgICByW25dID0gZVtuXTtcbiAgfSksIHI7XG59XG5mdW5jdGlvbiBIaShlKSB7XG4gIGlmIChlID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHt9O1xuICBjb25zdCB0ID0ge307XG4gIHJldHVybiBPYmplY3Qua2V5cyhlKS5maWx0ZXIoKHIpID0+ICEoci5tYXRjaCgvXm9uW0EtWl0vKSAmJiB0eXBlb2YgZVtyXSA9PSBcImZ1bmN0aW9uXCIpKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgdFtyXSA9IGVbcl07XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gdHMoZSkge1xuICBjb25zdCB7XG4gICAgZ2V0U2xvdFByb3BzOiB0LFxuICAgIGFkZGl0aW9uYWxQcm9wczogcixcbiAgICBleHRlcm5hbFNsb3RQcm9wczogbixcbiAgICBleHRlcm5hbEZvcndhcmRlZFByb3BzOiBvLFxuICAgIGNsYXNzTmFtZTogaVxuICB9ID0gZTtcbiAgaWYgKCF0KSB7XG4gICAgY29uc3QgeCA9IHNlKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuY2xhc3NOYW1lLCBpLCBvID09IG51bGwgPyB2b2lkIDAgOiBvLmNsYXNzTmFtZSwgbiA9PSBudWxsID8gdm9pZCAwIDogbi5jbGFzc05hbWUpLCB5ID0ge1xuICAgICAgLi4uciA9PSBudWxsID8gdm9pZCAwIDogci5zdHlsZSxcbiAgICAgIC4uLm8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uc3R5bGUsXG4gICAgICAuLi5uID09IG51bGwgPyB2b2lkIDAgOiBuLnN0eWxlXG4gICAgfSwgZiA9IHtcbiAgICAgIC4uLnIsXG4gICAgICAuLi5vLFxuICAgICAgLi4ublxuICAgIH07XG4gICAgcmV0dXJuIHgubGVuZ3RoID4gMCAmJiAoZi5jbGFzc05hbWUgPSB4KSwgT2JqZWN0LmtleXMoeSkubGVuZ3RoID4gMCAmJiAoZi5zdHlsZSA9IHkpLCB7XG4gICAgICBwcm9wczogZixcbiAgICAgIGludGVybmFsUmVmOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGNvbnN0IHMgPSBVdSh7XG4gICAgLi4ubyxcbiAgICAuLi5uXG4gIH0pLCBjID0gSGkobiksIGwgPSBIaShvKSwgdSA9IHQocyksIHAgPSBzZSh1ID09IG51bGwgPyB2b2lkIDAgOiB1LmNsYXNzTmFtZSwgciA9PSBudWxsID8gdm9pZCAwIDogci5jbGFzc05hbWUsIGksIG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uY2xhc3NOYW1lLCBuID09IG51bGwgPyB2b2lkIDAgOiBuLmNsYXNzTmFtZSksIG0gPSB7XG4gICAgLi4udSA9PSBudWxsID8gdm9pZCAwIDogdS5zdHlsZSxcbiAgICAuLi5yID09IG51bGwgPyB2b2lkIDAgOiByLnN0eWxlLFxuICAgIC4uLm8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uc3R5bGUsXG4gICAgLi4ubiA9PSBudWxsID8gdm9pZCAwIDogbi5zdHlsZVxuICB9LCBnID0ge1xuICAgIC4uLnUsXG4gICAgLi4ucixcbiAgICAuLi5sLFxuICAgIC4uLmNcbiAgfTtcbiAgcmV0dXJuIHAubGVuZ3RoID4gMCAmJiAoZy5jbGFzc05hbWUgPSBwKSwgT2JqZWN0LmtleXMobSkubGVuZ3RoID4gMCAmJiAoZy5zdHlsZSA9IG0pLCB7XG4gICAgcHJvcHM6IGcsXG4gICAgaW50ZXJuYWxSZWY6IHUucmVmXG4gIH07XG59XG5mdW5jdGlvbiBycyhlLCB0LCByKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKHQsIHIpIDogZTtcbn1cbmZ1bmN0aW9uIFl1KGUpIHtcbiAgdmFyIG07XG4gIGNvbnN0IHtcbiAgICBlbGVtZW50VHlwZTogdCxcbiAgICBleHRlcm5hbFNsb3RQcm9wczogcixcbiAgICBvd25lclN0YXRlOiBuLFxuICAgIHNraXBSZXNvbHZpbmdTbG90UHJvcHM6IG8gPSAhMSxcbiAgICAuLi5pXG4gIH0gPSBlLCBzID0gbyA/IHt9IDogcnMociwgbiksIHtcbiAgICBwcm9wczogYyxcbiAgICBpbnRlcm5hbFJlZjogbFxuICB9ID0gdHMoe1xuICAgIC4uLmksXG4gICAgZXh0ZXJuYWxTbG90UHJvcHM6IHNcbiAgfSksIHUgPSBhdChsLCBzID09IG51bGwgPyB2b2lkIDAgOiBzLnJlZiwgKG0gPSBlLmFkZGl0aW9uYWxQcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IG0ucmVmKTtcbiAgcmV0dXJuIGVzKHQsIHtcbiAgICAuLi5jLFxuICAgIHJlZjogdVxuICB9LCBuKTtcbn1cbmZ1bmN0aW9uIEJvKGUpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiBwYXJzZUludChDLnZlcnNpb24sIDEwKSA+PSAxOSA/ICgodCA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiB0LnJlZikgfHwgbnVsbCA6IChlID09IG51bGwgPyB2b2lkIDAgOiBlLnJlZikgfHwgbnVsbDtcbn1cbmNvbnN0IFZvID0gLyogQF9fUFVSRV9fICovIEMuY3JlYXRlQ29udGV4dChudWxsKTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoVm8uZGlzcGxheU5hbWUgPSBcIlRoZW1lQ29udGV4dFwiKTtcbmZ1bmN0aW9uIEZvKCkge1xuICBjb25zdCBlID0gQy51c2VDb250ZXh0KFZvKTtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBDLnVzZURlYnVnVmFsdWUoZSksIGU7XG59XG5jb25zdCBIdSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5mb3IsIHF1ID0gSHUgPyBTeW1ib2wuZm9yKFwibXVpLm5lc3RlZFwiKSA6IFwiX19USEVNRV9ORVNURURfX1wiO1xuZnVuY3Rpb24gR3UoZSwgdCkge1xuICBpZiAodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgciA9IHQoZSk7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAociB8fCBjb25zb2xlLmVycm9yKFtcIk1VSTogWW91IHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGZyb20geW91ciB0aGVtZSBmdW5jdGlvbiwgaS5lLlwiLCBcIjxUaGVtZVByb3ZpZGVyIHRoZW1lPXsoKSA9PiAoe30pfSAvPlwiXS5qb2luKGBcbmApKSksIHI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5lLFxuICAgIC4uLnRcbiAgfTtcbn1cbmZ1bmN0aW9uIGduKGUpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuOiB0LFxuICAgIHRoZW1lOiByXG4gIH0gPSBlLCBuID0gRm8oKTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG4gPT09IG51bGwgJiYgdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoW1wiTVVJOiBZb3UgYXJlIHByb3ZpZGluZyBhIHRoZW1lIGZ1bmN0aW9uIHByb3AgdG8gdGhlIFRoZW1lUHJvdmlkZXIgY29tcG9uZW50OlwiLCBcIjxUaGVtZVByb3ZpZGVyIHRoZW1lPXtvdXRlclRoZW1lID0+IG91dGVyVGhlbWV9IC8+XCIsIFwiXCIsIFwiSG93ZXZlciwgbm8gb3V0ZXIgdGhlbWUgaXMgcHJlc2VudC5cIiwgXCJNYWtlIHN1cmUgYSB0aGVtZSBpcyBhbHJlYWR5IGluamVjdGVkIGhpZ2hlciBpbiB0aGUgUmVhY3QgdHJlZSBvciBwcm92aWRlIGEgdGhlbWUgb2JqZWN0LlwiXS5qb2luKGBcbmApKTtcbiAgY29uc3QgbyA9IEMudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgaSA9IG4gPT09IG51bGwgPyB7XG4gICAgICAuLi5yXG4gICAgfSA6IEd1KG4sIHIpO1xuICAgIHJldHVybiBpICE9IG51bGwgJiYgKGlbcXVdID0gbiAhPT0gbnVsbCksIGk7XG4gIH0sIFtyLCBuXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goVm8uUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbyxcbiAgICBjaGlsZHJlbjogdFxuICB9KTtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoZ24ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogWW91ciBjb21wb25lbnQgdHJlZS5cbiAgICovXG4gIGNoaWxkcmVuOiBhLm5vZGUsXG4gIC8qKlxuICAgKiBBIHRoZW1lIG9iamVjdC4gWW91IGNhbiBwcm92aWRlIGEgZnVuY3Rpb24gdG8gZXh0ZW5kIHRoZSBvdXRlciB0aGVtZS5cbiAgICovXG4gIHRoZW1lOiBhLm9uZU9mVHlwZShbYS5vYmplY3QsIGEuZnVuY10pLmlzUmVxdWlyZWRcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoZ24ucHJvcFR5cGVzID0gRG8oZ24ucHJvcFR5cGVzKSk7XG5jb25zdCBucyA9IC8qIEBfX1BVUkVfXyAqLyBDLmNyZWF0ZUNvbnRleHQoKTtcbmZ1bmN0aW9uIG9zKHtcbiAgdmFsdWU6IGUsXG4gIC4uLnRcbn0pIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChucy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBlID8/ICEwLFxuICAgIC4uLnRcbiAgfSk7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKG9zLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgdmFsdWU6IGEuYm9vbFxufSk7XG5jb25zdCBpcyA9ICgpID0+IEMudXNlQ29udGV4dChucykgPz8gITEsIGFzID0gLyogQF9fUFVSRV9fICovIEMuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gc3Moe1xuICB2YWx1ZTogZSxcbiAgY2hpbGRyZW46IHRcbn0pIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChhcy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBlLFxuICAgIGNoaWxkcmVuOiB0XG4gIH0pO1xufVxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChzcy5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBUeXBlU2NyaXB0IHR5cGVzIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4g4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHZhbHVlOiBhLm9iamVjdFxufSk7XG5mdW5jdGlvbiBLdShlKSB7XG4gIGNvbnN0IHtcbiAgICB0aGVtZTogdCxcbiAgICBuYW1lOiByLFxuICAgIHByb3BzOiBuXG4gIH0gPSBlO1xuICBpZiAoIXQgfHwgIXQuY29tcG9uZW50cyB8fCAhdC5jb21wb25lbnRzW3JdKVxuICAgIHJldHVybiBuO1xuICBjb25zdCBvID0gdC5jb21wb25lbnRzW3JdO1xuICByZXR1cm4gby5kZWZhdWx0UHJvcHMgPyBjbyhvLmRlZmF1bHRQcm9wcywgbikgOiAhby5zdHlsZU92ZXJyaWRlcyAmJiAhby52YXJpYW50cyA/IGNvKG8sIG4pIDogbjtcbn1cbmZ1bmN0aW9uIFh1KHtcbiAgcHJvcHM6IGUsXG4gIG5hbWU6IHRcbn0pIHtcbiAgY29uc3QgciA9IEMudXNlQ29udGV4dChhcyk7XG4gIHJldHVybiBLdSh7XG4gICAgcHJvcHM6IGUsXG4gICAgbmFtZTogdCxcbiAgICB0aGVtZToge1xuICAgICAgY29tcG9uZW50czogclxuICAgIH1cbiAgfSk7XG59XG5jb25zdCBxaSA9IHt9O1xuZnVuY3Rpb24gR2koZSwgdCwgciwgbiA9ICExKSB7XG4gIHJldHVybiBDLnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IG8gPSBlICYmIHRbZV0gfHwgdDtcbiAgICBpZiAodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBpID0gcihvKSwgcyA9IGUgPyB7XG4gICAgICAgIC4uLnQsXG4gICAgICAgIFtlXTogaVxuICAgICAgfSA6IGk7XG4gICAgICByZXR1cm4gbiA/ICgpID0+IHMgOiBzO1xuICAgIH1cbiAgICByZXR1cm4gZSA/IHtcbiAgICAgIC4uLnQsXG4gICAgICBbZV06IHJcbiAgICB9IDoge1xuICAgICAgLi4udCxcbiAgICAgIC4uLnJcbiAgICB9O1xuICB9LCBbZSwgdCwgciwgbl0pO1xufVxuZnVuY3Rpb24gUnIoZSkge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW46IHQsXG4gICAgdGhlbWU6IHIsXG4gICAgdGhlbWVJZDogblxuICB9ID0gZSwgbyA9IFZhKHFpKSwgaSA9IEZvKCkgfHwgcWk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAobyA9PT0gbnVsbCAmJiB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgfHwgbiAmJiBvICYmICFvW25dICYmIHR5cGVvZiByID09IFwiZnVuY3Rpb25cIikgJiYgY29uc29sZS5lcnJvcihbXCJNVUk6IFlvdSBhcmUgcHJvdmlkaW5nIGEgdGhlbWUgZnVuY3Rpb24gcHJvcCB0byB0aGUgVGhlbWVQcm92aWRlciBjb21wb25lbnQ6XCIsIFwiPFRoZW1lUHJvdmlkZXIgdGhlbWU9e291dGVyVGhlbWUgPT4gb3V0ZXJUaGVtZX0gLz5cIiwgXCJcIiwgXCJIb3dldmVyLCBubyBvdXRlciB0aGVtZSBpcyBwcmVzZW50LlwiLCBcIk1ha2Ugc3VyZSBhIHRoZW1lIGlzIGFscmVhZHkgaW5qZWN0ZWQgaGlnaGVyIGluIHRoZSBSZWFjdCB0cmVlIG9yIHByb3ZpZGUgYSB0aGVtZSBvYmplY3QuXCJdLmpvaW4oYFxuYCkpO1xuICBjb25zdCBzID0gR2kobiwgbywgciksIGMgPSBHaShuLCBpLCByLCAhMCksIGwgPSAobiA/IHNbbl0gOiBzKS5kaXJlY3Rpb24gPT09IFwicnRsXCI7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goZ24sIHtcbiAgICB0aGVtZTogYyxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KE1yLlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogcyxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3gob3MsIHtcbiAgICAgICAgdmFsdWU6IGwsXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goc3MsIHtcbiAgICAgICAgICB2YWx1ZTogbiA/IHNbbl0uY29tcG9uZW50cyA6IHMuY29tcG9uZW50cyxcbiAgICAgICAgICBjaGlsZHJlbjogdFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoUnIucHJvcFR5cGVzID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiAgICBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4gICAgIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICAqIFlvdXIgY29tcG9uZW50IHRyZWUuXG4gICAqL1xuICBjaGlsZHJlbjogYS5ub2RlLFxuICAvKipcbiAgICogQSB0aGVtZSBvYmplY3QuIFlvdSBjYW4gcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIGV4dGVuZCB0aGUgb3V0ZXIgdGhlbWUuXG4gICAqL1xuICB0aGVtZTogYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3RdKS5pc1JlcXVpcmVkLFxuICAvKipcbiAgICogVGhlIGRlc2lnbiBzeXN0ZW0ncyB1bmlxdWUgaWQgZm9yIGdldHRpbmcgdGhlIGNvcnJlc3BvbmRlZCB0aGVtZSB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBkZXNpZ24gc3lzdGVtcy5cbiAgICovXG4gIHRoZW1lSWQ6IGEuc3RyaW5nXG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKFJyLnByb3BUeXBlcyA9IERvKFJyLnByb3BUeXBlcykpO1xuY29uc3QgS2kgPSB7XG4gIHRoZW1lOiB2b2lkIDBcbn07XG5mdW5jdGlvbiBKdShlKSB7XG4gIGxldCB0LCByO1xuICByZXR1cm4gZnVuY3Rpb24obykge1xuICAgIGxldCBpID0gdDtcbiAgICByZXR1cm4gKGkgPT09IHZvaWQgMCB8fCBvLnRoZW1lICE9PSByKSAmJiAoS2kudGhlbWUgPSBvLnRoZW1lLCBpID0gSGEoZShLaSkpLCB0ID0gaSwgciA9IG8udGhlbWUpLCBpO1xuICB9O1xufVxuY29uc3Qgem8gPSBcIm1vZGVcIiwgV28gPSBcImNvbG9yLXNjaGVtZVwiLCBRdSA9IFwiZGF0YS1jb2xvci1zY2hlbWVcIjtcbmZ1bmN0aW9uIFp1KGUpIHtcbiAgY29uc3Qge1xuICAgIGRlZmF1bHRNb2RlOiB0ID0gXCJzeXN0ZW1cIixcbiAgICBkZWZhdWx0TGlnaHRDb2xvclNjaGVtZTogciA9IFwibGlnaHRcIixcbiAgICBkZWZhdWx0RGFya0NvbG9yU2NoZW1lOiBuID0gXCJkYXJrXCIsXG4gICAgbW9kZVN0b3JhZ2VLZXk6IG8gPSB6byxcbiAgICBjb2xvclNjaGVtZVN0b3JhZ2VLZXk6IGkgPSBXbyxcbiAgICBhdHRyaWJ1dGU6IHMgPSBRdSxcbiAgICBjb2xvclNjaGVtZU5vZGU6IGMgPSBcImRvY3VtZW50LmRvY3VtZW50RWxlbWVudFwiLFxuICAgIG5vbmNlOiBsXG4gIH0gPSBlO1xuICBsZXQgdSA9IFwiXCIsIHAgPSBzO1xuICBpZiAocyA9PT0gXCJjbGFzc1wiICYmIChwID0gXCIuJXNcIiksIHMgPT09IFwiZGF0YVwiICYmIChwID0gXCJbZGF0YS0lc11cIiksIHAuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICBjb25zdCBnID0gcC5zdWJzdHJpbmcoMSk7XG4gICAgdSArPSBgJHtjfS5jbGFzc0xpc3QucmVtb3ZlKCcke2d9Jy5yZXBsYWNlKCclcycsIGxpZ2h0KSwgJyR7Z30nLnJlcGxhY2UoJyVzJywgZGFyaykpO1xuICAgICAgJHtjfS5jbGFzc0xpc3QuYWRkKCcke2d9Jy5yZXBsYWNlKCclcycsIGNvbG9yU2NoZW1lKSk7YDtcbiAgfVxuICBjb25zdCBtID0gcC5tYXRjaCgvXFxbKFteXFxdXSspXFxdLyk7XG4gIGlmIChtKSB7XG4gICAgY29uc3QgW2csIHhdID0gbVsxXS5zcGxpdChcIj1cIik7XG4gICAgeCB8fCAodSArPSBgJHtjfS5yZW1vdmVBdHRyaWJ1dGUoJyR7Z30nLnJlcGxhY2UoJyVzJywgbGlnaHQpKTtcbiAgICAgICR7Y30ucmVtb3ZlQXR0cmlidXRlKCcke2d9Jy5yZXBsYWNlKCclcycsIGRhcmspKTtgKSwgdSArPSBgXG4gICAgICAke2N9LnNldEF0dHJpYnV0ZSgnJHtnfScucmVwbGFjZSgnJXMnLCBjb2xvclNjaGVtZSksICR7eCA/IGAke3h9LnJlcGxhY2UoJyVzJywgY29sb3JTY2hlbWUpYCA6ICdcIlwiJ30pO2A7XG4gIH0gZWxzZVxuICAgIHUgKz0gYCR7Y30uc2V0QXR0cmlidXRlKCcke3B9JywgY29sb3JTY2hlbWUpO2A7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goXCJzY3JpcHRcIiwge1xuICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogITAsXG4gICAgbm9uY2U6IHR5cGVvZiB3aW5kb3cgPiBcInVcIiA/IGwgOiBcIlwiLFxuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGAoZnVuY3Rpb24oKSB7XG50cnkge1xuICBsZXQgY29sb3JTY2hlbWUgPSAnJztcbiAgY29uc3QgbW9kZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCcke299JykgfHwgJyR7dH0nO1xuICBjb25zdCBkYXJrID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJyR7aX0tZGFyaycpIHx8ICcke259JztcbiAgY29uc3QgbGlnaHQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnJHtpfS1saWdodCcpIHx8ICcke3J9JztcbiAgaWYgKG1vZGUgPT09ICdzeXN0ZW0nKSB7XG4gICAgLy8gaGFuZGxlIHN5c3RlbSBtb2RlXG4gICAgY29uc3QgbXFsID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKTtcbiAgICBpZiAobXFsLm1hdGNoZXMpIHtcbiAgICAgIGNvbG9yU2NoZW1lID0gZGFya1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvclNjaGVtZSA9IGxpZ2h0XG4gICAgfVxuICB9XG4gIGlmIChtb2RlID09PSAnbGlnaHQnKSB7XG4gICAgY29sb3JTY2hlbWUgPSBsaWdodDtcbiAgfVxuICBpZiAobW9kZSA9PT0gJ2RhcmsnKSB7XG4gICAgY29sb3JTY2hlbWUgPSBkYXJrO1xuICB9XG4gIGlmIChjb2xvclNjaGVtZSkge1xuICAgICR7dX1cbiAgfVxufSBjYXRjaChlKXt9fSkoKTtgXG4gICAgfVxuICB9LCBcIm11aS1jb2xvci1zY2hlbWUtaW5pdFwiKTtcbn1cbmZ1bmN0aW9uIFhpKGUpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB0eXBlb2Ygd2luZG93Lm1hdGNoTWVkaWEgPT0gXCJmdW5jdGlvblwiICYmIGUgPT09IFwic3lzdGVtXCIpXG4gICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzID8gXCJkYXJrXCIgOiBcImxpZ2h0XCI7XG59XG5mdW5jdGlvbiBjcyhlLCB0KSB7XG4gIGlmIChlLm1vZGUgPT09IFwibGlnaHRcIiB8fCBlLm1vZGUgPT09IFwic3lzdGVtXCIgJiYgZS5zeXN0ZW1Nb2RlID09PSBcImxpZ2h0XCIpXG4gICAgcmV0dXJuIHQoXCJsaWdodFwiKTtcbiAgaWYgKGUubW9kZSA9PT0gXCJkYXJrXCIgfHwgZS5tb2RlID09PSBcInN5c3RlbVwiICYmIGUuc3lzdGVtTW9kZSA9PT0gXCJkYXJrXCIpXG4gICAgcmV0dXJuIHQoXCJkYXJrXCIpO1xufVxuZnVuY3Rpb24gZWYoZSkge1xuICByZXR1cm4gY3MoZSwgKHQpID0+IHtcbiAgICBpZiAodCA9PT0gXCJsaWdodFwiKVxuICAgICAgcmV0dXJuIGUubGlnaHRDb2xvclNjaGVtZTtcbiAgICBpZiAodCA9PT0gXCJkYXJrXCIpXG4gICAgICByZXR1cm4gZS5kYXJrQ29sb3JTY2hlbWU7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW8oZSwgdCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA+IFwidVwiKVxuICAgIHJldHVybjtcbiAgbGV0IHI7XG4gIHRyeSB7XG4gICAgciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGUpIHx8IHZvaWQgMCwgciB8fCBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShlLCB0KTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIHIgfHwgdDtcbn1cbmZ1bmN0aW9uIHRmKGUpIHtcbiAgY29uc3Qge1xuICAgIGRlZmF1bHRNb2RlOiB0ID0gXCJsaWdodFwiLFxuICAgIGRlZmF1bHRMaWdodENvbG9yU2NoZW1lOiByLFxuICAgIGRlZmF1bHREYXJrQ29sb3JTY2hlbWU6IG4sXG4gICAgc3VwcG9ydGVkQ29sb3JTY2hlbWVzOiBvID0gW10sXG4gICAgbW9kZVN0b3JhZ2VLZXk6IGkgPSB6byxcbiAgICBjb2xvclNjaGVtZVN0b3JhZ2VLZXk6IHMgPSBXbyxcbiAgICBzdG9yYWdlV2luZG93OiBjID0gdHlwZW9mIHdpbmRvdyA+IFwidVwiID8gdm9pZCAwIDogd2luZG93LFxuICAgIG5vU3NyOiBsID0gITFcbiAgfSA9IGUsIHUgPSBvLmpvaW4oXCIsXCIpLCBwID0gby5sZW5ndGggPiAxLCBbbSwgZ10gPSBDLnVzZVN0YXRlKCgpID0+IHtcbiAgICBjb25zdCBiID0gZW8oaSwgdCksIGggPSBlbyhgJHtzfS1saWdodGAsIHIpLCB3ID0gZW8oYCR7c30tZGFya2AsIG4pO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RlOiBiLFxuICAgICAgc3lzdGVtTW9kZTogWGkoYiksXG4gICAgICBsaWdodENvbG9yU2NoZW1lOiBoLFxuICAgICAgZGFya0NvbG9yU2NoZW1lOiB3XG4gICAgfTtcbiAgfSksIFt4LCB5XSA9IEMudXNlU3RhdGUobCB8fCAhcCk7XG4gIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICB5KCEwKTtcbiAgfSwgW10pO1xuICBjb25zdCBmID0gZWYobSksIFMgPSBDLnVzZUNhbGxiYWNrKChiKSA9PiB7XG4gICAgZygoaCkgPT4ge1xuICAgICAgaWYgKGIgPT09IGgubW9kZSlcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICBjb25zdCB3ID0gYiA/PyB0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oaSwgdyk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmgsXG4gICAgICAgIG1vZGU6IHcsXG4gICAgICAgIHN5c3RlbU1vZGU6IFhpKHcpXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbaSwgdF0pLCBFID0gQy51c2VDYWxsYmFjaygoYikgPT4ge1xuICAgIGIgPyB0eXBlb2YgYiA9PSBcInN0cmluZ1wiID8gYiAmJiAhdS5pbmNsdWRlcyhiKSA/IGNvbnNvbGUuZXJyb3IoYFxcYCR7Yn1cXGAgZG9lcyBub3QgZXhpc3QgaW4gXFxgdGhlbWUuY29sb3JTY2hlbWVzXFxgLmApIDogZygoaCkgPT4ge1xuICAgICAgY29uc3QgdyA9IHtcbiAgICAgICAgLi4uaFxuICAgICAgfTtcbiAgICAgIHJldHVybiBjcyhoLCAoaykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGAke3N9LSR7a31gLCBiKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgICAgayA9PT0gXCJsaWdodFwiICYmICh3LmxpZ2h0Q29sb3JTY2hlbWUgPSBiKSwgayA9PT0gXCJkYXJrXCIgJiYgKHcuZGFya0NvbG9yU2NoZW1lID0gYik7XG4gICAgICB9KSwgdztcbiAgICB9KSA6IGcoKGgpID0+IHtcbiAgICAgIGNvbnN0IHcgPSB7XG4gICAgICAgIC4uLmhcbiAgICAgIH0sIGsgPSBiLmxpZ2h0ID09PSBudWxsID8gciA6IGIubGlnaHQsIEwgPSBiLmRhcmsgPT09IG51bGwgPyBuIDogYi5kYXJrO1xuICAgICAgaWYgKGspXG4gICAgICAgIGlmICghdS5pbmNsdWRlcyhrKSlcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBcXGAke2t9XFxgIGRvZXMgbm90IGV4aXN0IGluIFxcYHRoZW1lLmNvbG9yU2NoZW1lc1xcYC5gKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdy5saWdodENvbG9yU2NoZW1lID0gaztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYCR7c30tbGlnaHRgLCBrKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGlmIChMKVxuICAgICAgICBpZiAoIXUuaW5jbHVkZXMoTCkpXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgXFxgJHtMfVxcYCBkb2VzIG5vdCBleGlzdCBpbiBcXGB0aGVtZS5jb2xvclNjaGVtZXNcXGAuYCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHcuZGFya0NvbG9yU2NoZW1lID0gTDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYCR7c30tZGFya2AsIEwpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHc7XG4gICAgfSkgOiBnKChoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgJHtzfS1saWdodGAsIHIpLCBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgJHtzfS1kYXJrYCwgbik7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmgsXG4gICAgICAgIGxpZ2h0Q29sb3JTY2hlbWU6IHIsXG4gICAgICAgIGRhcmtDb2xvclNjaGVtZTogblxuICAgICAgfTtcbiAgICB9KTtcbiAgfSwgW3UsIHMsIHIsIG5dKSwgUCA9IEMudXNlQ2FsbGJhY2soKGIpID0+IHtcbiAgICBtLm1vZGUgPT09IFwic3lzdGVtXCIgJiYgZygoaCkgPT4ge1xuICAgICAgY29uc3QgdyA9IGIgIT0gbnVsbCAmJiBiLm1hdGNoZXMgPyBcImRhcmtcIiA6IFwibGlnaHRcIjtcbiAgICAgIHJldHVybiBoLnN5c3RlbU1vZGUgPT09IHcgPyBoIDoge1xuICAgICAgICAuLi5oLFxuICAgICAgICBzeXN0ZW1Nb2RlOiB3XG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbbS5tb2RlXSksIFQgPSBDLnVzZVJlZihQKTtcbiAgcmV0dXJuIFQuY3VycmVudCA9IFAsIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5tYXRjaE1lZGlhICE9IFwiZnVuY3Rpb25cIiB8fCAhcClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBiID0gKC4uLncpID0+IFQuY3VycmVudCguLi53KSwgaCA9IHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKTtcbiAgICByZXR1cm4gaC5hZGRMaXN0ZW5lcihiKSwgYihoKSwgKCkgPT4ge1xuICAgICAgaC5yZW1vdmVMaXN0ZW5lcihiKTtcbiAgICB9O1xuICB9LCBbcF0pLCBDLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGMgJiYgcCkge1xuICAgICAgY29uc3QgYiA9IChoKSA9PiB7XG4gICAgICAgIGNvbnN0IHcgPSBoLm5ld1ZhbHVlO1xuICAgICAgICB0eXBlb2YgaC5rZXkgPT0gXCJzdHJpbmdcIiAmJiBoLmtleS5zdGFydHNXaXRoKHMpICYmICghdyB8fCB1Lm1hdGNoKHcpKSAmJiAoaC5rZXkuZW5kc1dpdGgoXCJsaWdodFwiKSAmJiBFKHtcbiAgICAgICAgICBsaWdodDogd1xuICAgICAgICB9KSwgaC5rZXkuZW5kc1dpdGgoXCJkYXJrXCIpICYmIEUoe1xuICAgICAgICAgIGRhcms6IHdcbiAgICAgICAgfSkpLCBoLmtleSA9PT0gaSAmJiAoIXcgfHwgW1wibGlnaHRcIiwgXCJkYXJrXCIsIFwic3lzdGVtXCJdLmluY2x1ZGVzKHcpKSAmJiBTKHcgfHwgdCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGMuYWRkRXZlbnRMaXN0ZW5lcihcInN0b3JhZ2VcIiwgYiksICgpID0+IHtcbiAgICAgICAgYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RvcmFnZVwiLCBiKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbRSwgUywgaSwgcywgdSwgdCwgYywgcF0pLCB7XG4gICAgLi4ubSxcbiAgICBtb2RlOiB4ID8gbS5tb2RlIDogdm9pZCAwLFxuICAgIHN5c3RlbU1vZGU6IHggPyBtLnN5c3RlbU1vZGUgOiB2b2lkIDAsXG4gICAgY29sb3JTY2hlbWU6IHggPyBmIDogdm9pZCAwLFxuICAgIHNldE1vZGU6IFMsXG4gICAgc2V0Q29sb3JTY2hlbWU6IEVcbiAgfTtcbn1cbmNvbnN0IHJmID0gXCIqey13ZWJraXQtdHJhbnNpdGlvbjpub25lIWltcG9ydGFudDstbW96LXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7LW8tdHJhbnNpdGlvbjpub25lIWltcG9ydGFudDstbXMtdHJhbnNpdGlvbjpub25lIWltcG9ydGFudDt0cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50fVwiO1xuZnVuY3Rpb24gbmYoZSkge1xuICBjb25zdCB7XG4gICAgdGhlbWVJZDogdCxcbiAgICAvKipcbiAgICAgKiBUaGlzIGB0aGVtZWAgb2JqZWN0IG5lZWRzIHRvIGZvbGxvdyBhIGNlcnRhaW4gc3RydWN0dXJlIHRvXG4gICAgICogYmUgdXNlZCBjb3JyZWN0bHkgYnkgdGhlIGZpbmVsIGBDc3NWYXJzUHJvdmlkZXJgLiBJdCBzaG91bGQgaGF2ZSBhXG4gICAgICogYGNvbG9yU2NoZW1lc2Aga2V5IHdpdGggdGhlIGxpZ2h0IGFuZCBkYXJrIChhbmQgYW55IG90aGVyKSBwYWxldHRlLlxuICAgICAqIEl0IHNob3VsZCBhbHNvIGlkZWFsbHkgaGF2ZSBhIHZhcnMgb2JqZWN0IGNyZWF0ZWQgdXNpbmcgYHByZXBhcmVDc3NWYXJzYC5cbiAgICAgKi9cbiAgICB0aGVtZTogciA9IHt9LFxuICAgIG1vZGVTdG9yYWdlS2V5OiBuID0gem8sXG4gICAgY29sb3JTY2hlbWVTdG9yYWdlS2V5OiBvID0gV28sXG4gICAgZGlzYWJsZVRyYW5zaXRpb25PbkNoYW5nZTogaSA9ICExLFxuICAgIGRlZmF1bHRDb2xvclNjaGVtZTogcyxcbiAgICByZXNvbHZlVGhlbWU6IGNcbiAgfSA9IGUsIGwgPSB7XG4gICAgYWxsQ29sb3JTY2hlbWVzOiBbXSxcbiAgICBjb2xvclNjaGVtZTogdm9pZCAwLFxuICAgIGRhcmtDb2xvclNjaGVtZTogdm9pZCAwLFxuICAgIGxpZ2h0Q29sb3JTY2hlbWU6IHZvaWQgMCxcbiAgICBtb2RlOiB2b2lkIDAsXG4gICAgc2V0Q29sb3JTY2hlbWU6ICgpID0+IHtcbiAgICB9LFxuICAgIHNldE1vZGU6ICgpID0+IHtcbiAgICB9LFxuICAgIHN5c3RlbU1vZGU6IHZvaWQgMFxuICB9LCB1ID0gLyogQF9fUFVSRV9fICovIEMuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHUuZGlzcGxheU5hbWUgPSBcIkNvbG9yU2NoZW1lQ29udGV4dFwiKTtcbiAgY29uc3QgcCA9ICgpID0+IEMudXNlQ29udGV4dCh1KSB8fCBsLCBtID0ge30sIGcgPSB7fTtcbiAgZnVuY3Rpb24geChFKSB7XG4gICAgdmFyIFksIG9lLCBSZSwgdWU7XG4gICAgY29uc3Qge1xuICAgICAgY2hpbGRyZW46IFAsXG4gICAgICB0aGVtZTogVCxcbiAgICAgIG1vZGVTdG9yYWdlS2V5OiBiID0gbixcbiAgICAgIGNvbG9yU2NoZW1lU3RvcmFnZUtleTogaCA9IG8sXG4gICAgICBkaXNhYmxlVHJhbnNpdGlvbk9uQ2hhbmdlOiB3ID0gaSxcbiAgICAgIHN0b3JhZ2VXaW5kb3c6IGsgPSB0eXBlb2Ygd2luZG93ID4gXCJ1XCIgPyB2b2lkIDAgOiB3aW5kb3csXG4gICAgICBkb2N1bWVudE5vZGU6IEwgPSB0eXBlb2YgZG9jdW1lbnQgPiBcInVcIiA/IHZvaWQgMCA6IGRvY3VtZW50LFxuICAgICAgY29sb3JTY2hlbWVOb2RlOiBCID0gdHlwZW9mIGRvY3VtZW50ID4gXCJ1XCIgPyB2b2lkIDAgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBkaXNhYmxlTmVzdGVkQ29udGV4dDogZCA9ICExLFxuICAgICAgZGlzYWJsZVN0eWxlU2hlZXRHZW5lcmF0aW9uOiBBID0gITEsXG4gICAgICBkZWZhdWx0TW9kZTogRCA9IFwic3lzdGVtXCIsXG4gICAgICBub1NzcjogalxuICAgIH0gPSBFLCBXID0gQy51c2VSZWYoITEpLCB6ID0gRm8oKSwgVSA9IEMudXNlQ29udGV4dCh1KSwgViA9ICEhVSAmJiAhZCwgdGUgPSBDLnVzZU1lbW8oKCkgPT4gVCB8fCAodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gcigpIDogciksIFtUXSksIEYgPSB0ZVt0XSwgUiA9IEYgfHwgdGUsIHtcbiAgICAgIGNvbG9yU2NoZW1lczogSSA9IG0sXG4gICAgICBjb21wb25lbnRzOiBKID0gZyxcbiAgICAgIGNzc1ZhclByZWZpeDogUVxuICAgIH0gPSBSLCBIID0gT2JqZWN0LmtleXMoSSkuZmlsdGVyKChLKSA9PiAhIUlbS10pLmpvaW4oXCIsXCIpLCBYID0gQy51c2VNZW1vKCgpID0+IEguc3BsaXQoXCIsXCIpLCBbSF0pLCBfID0gdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/IHMgOiBzLmxpZ2h0LCBxID0gdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/IHMgOiBzLmRhcmssIEcgPSBJW19dICYmIElbcV0gPyBEIDogKChvZSA9IChZID0gSVtSLmRlZmF1bHRDb2xvclNjaGVtZV0pID09IG51bGwgPyB2b2lkIDAgOiBZLnBhbGV0dGUpID09IG51bGwgPyB2b2lkIDAgOiBvZS5tb2RlKSB8fCAoKFJlID0gUi5wYWxldHRlKSA9PSBudWxsID8gdm9pZCAwIDogUmUubW9kZSksIHtcbiAgICAgIG1vZGU6IHJlLFxuICAgICAgc2V0TW9kZTogWixcbiAgICAgIHN5c3RlbU1vZGU6IGFlLFxuICAgICAgbGlnaHRDb2xvclNjaGVtZTogTyxcbiAgICAgIGRhcmtDb2xvclNjaGVtZTogeWUsXG4gICAgICBjb2xvclNjaGVtZTogRWUsXG4gICAgICBzZXRDb2xvclNjaGVtZTogTWVcbiAgICB9ID0gdGYoe1xuICAgICAgc3VwcG9ydGVkQ29sb3JTY2hlbWVzOiBYLFxuICAgICAgZGVmYXVsdExpZ2h0Q29sb3JTY2hlbWU6IF8sXG4gICAgICBkZWZhdWx0RGFya0NvbG9yU2NoZW1lOiBxLFxuICAgICAgbW9kZVN0b3JhZ2VLZXk6IGIsXG4gICAgICBjb2xvclNjaGVtZVN0b3JhZ2VLZXk6IGgsXG4gICAgICBkZWZhdWx0TW9kZTogRyxcbiAgICAgIHN0b3JhZ2VXaW5kb3c6IGssXG4gICAgICBub1NzcjogalxuICAgIH0pO1xuICAgIGxldCBRZSA9IHJlLCB2ZSA9IEVlO1xuICAgIFYgJiYgKFFlID0gVS5tb2RlLCB2ZSA9IFUuY29sb3JTY2hlbWUpO1xuICAgIGNvbnN0IFBlID0gQy51c2VNZW1vKCgpID0+IHtcbiAgICAgIHZhciBPZTtcbiAgICAgIGNvbnN0IEsgPSB2ZSB8fCBSLmRlZmF1bHRDb2xvclNjaGVtZSwgYmUgPSAoKE9lID0gUi5nZW5lcmF0ZVRoZW1lVmFycykgPT0gbnVsbCA/IHZvaWQgMCA6IE9lLmNhbGwoUikpIHx8IFIudmFycywgd2UgPSB7XG4gICAgICAgIC4uLlIsXG4gICAgICAgIGNvbXBvbmVudHM6IEosXG4gICAgICAgIGNvbG9yU2NoZW1lczogSSxcbiAgICAgICAgY3NzVmFyUHJlZml4OiBRLFxuICAgICAgICB2YXJzOiBiZVxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2Ygd2UuZ2VuZXJhdGVTcGFjaW5nID09IFwiZnVuY3Rpb25cIiAmJiAod2Uuc3BhY2luZyA9IHdlLmdlbmVyYXRlU3BhY2luZygpKSwgSykge1xuICAgICAgICBjb25zdCBjZSA9IElbS107XG4gICAgICAgIGNlICYmIHR5cGVvZiBjZSA9PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKGNlKS5mb3JFYWNoKChJZSkgPT4ge1xuICAgICAgICAgIGNlW0llXSAmJiB0eXBlb2YgY2VbSWVdID09IFwib2JqZWN0XCIgPyB3ZVtJZV0gPSB7XG4gICAgICAgICAgICAuLi53ZVtJZV0sXG4gICAgICAgICAgICAuLi5jZVtJZV1cbiAgICAgICAgICB9IDogd2VbSWVdID0gY2VbSWVdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjID8gYyh3ZSkgOiB3ZTtcbiAgICB9LCBbUiwgdmUsIEosIEksIFFdKSwgemUgPSBSLmNvbG9yU2NoZW1lU2VsZWN0b3I7XG4gICAgRnQoKCkgPT4ge1xuICAgICAgaWYgKHZlICYmIEIgJiYgemUgJiYgemUgIT09IFwibWVkaWFcIikge1xuICAgICAgICBjb25zdCBLID0gemU7XG4gICAgICAgIGxldCBiZSA9IHplO1xuICAgICAgICBpZiAoSyA9PT0gXCJjbGFzc1wiICYmIChiZSA9IFwiLiVzXCIpLCBLID09PSBcImRhdGFcIiAmJiAoYmUgPSBcIltkYXRhLSVzXVwiKSwgSyAhPSBudWxsICYmIEsuc3RhcnRzV2l0aChcImRhdGEtXCIpICYmICFLLmluY2x1ZGVzKFwiJXNcIikgJiYgKGJlID0gYFske0t9PVwiJXNcIl1gKSwgYmUuc3RhcnRzV2l0aChcIi5cIikpXG4gICAgICAgICAgQi5jbGFzc0xpc3QucmVtb3ZlKC4uLlgubWFwKCh3ZSkgPT4gYmUuc3Vic3RyaW5nKDEpLnJlcGxhY2UoXCIlc1wiLCB3ZSkpKSwgQi5jbGFzc0xpc3QuYWRkKGJlLnN1YnN0cmluZygxKS5yZXBsYWNlKFwiJXNcIiwgdmUpKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3Qgd2UgPSBiZS5yZXBsYWNlKFwiJXNcIiwgdmUpLm1hdGNoKC9cXFsoW15cXF1dKylcXF0vKTtcbiAgICAgICAgICBpZiAod2UpIHtcbiAgICAgICAgICAgIGNvbnN0IFtPZSwgY2VdID0gd2VbMV0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAgICAgY2UgfHwgWC5mb3JFYWNoKChJZSkgPT4ge1xuICAgICAgICAgICAgICBCLnJlbW92ZUF0dHJpYnV0ZShPZS5yZXBsYWNlKHZlLCBJZSkpO1xuICAgICAgICAgICAgfSksIEIuc2V0QXR0cmlidXRlKE9lLCBjZSA/IGNlLnJlcGxhY2UoL1wifCcvZywgXCJcIikgOiBcIlwiKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEIuc2V0QXR0cmlidXRlKGJlLCB2ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbdmUsIHplLCBCLCBYXSksIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGxldCBLO1xuICAgICAgaWYgKHcgJiYgVy5jdXJyZW50ICYmIEwpIHtcbiAgICAgICAgY29uc3QgYmUgPSBMLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgYmUuYXBwZW5kQ2hpbGQoTC5jcmVhdGVUZXh0Tm9kZShyZikpLCBMLmhlYWQuYXBwZW5kQ2hpbGQoYmUpLCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShMLmJvZHkpLCBLID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgTC5oZWFkLnJlbW92ZUNoaWxkKGJlKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoSyk7XG4gICAgICB9O1xuICAgIH0sIFt2ZSwgdywgTF0pLCBDLnVzZUVmZmVjdCgoKSA9PiAoVy5jdXJyZW50ID0gITAsICgpID0+IHtcbiAgICAgIFcuY3VycmVudCA9ICExO1xuICAgIH0pLCBbXSk7XG4gICAgY29uc3QgTGUgPSBDLnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIGFsbENvbG9yU2NoZW1lczogWCxcbiAgICAgIGNvbG9yU2NoZW1lOiB2ZSxcbiAgICAgIGRhcmtDb2xvclNjaGVtZTogeWUsXG4gICAgICBsaWdodENvbG9yU2NoZW1lOiBPLFxuICAgICAgbW9kZTogUWUsXG4gICAgICBzZXRDb2xvclNjaGVtZTogTWUsXG4gICAgICBzZXRNb2RlOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBaIDogKEspID0+IHtcbiAgICAgICAgUGUuY29sb3JTY2hlbWVTZWxlY3RvciA9PT0gXCJtZWRpYVwiICYmIGNvbnNvbGUuZXJyb3IoW1wiTVVJOiBUaGUgYHNldE1vZGVgIGZ1bmN0aW9uIGhhcyBubyBlZmZlY3QgaWYgYGNvbG9yU2NoZW1lU2VsZWN0b3JgIGlzIGBtZWRpYWAgKGBtZWRpYWAgaXMgdGhlIGRlZmF1bHQgdmFsdWUpLlwiLCBcIlRvIHRvZ2dsZSB0aGUgbW9kZSBtYW51YWxseSwgcGxlYXNlIGNvbmZpZ3VyZSBgY29sb3JTY2hlbWVTZWxlY3RvcmAgdG8gdXNlIGEgY2xhc3Mgb3IgZGF0YSBhdHRyaWJ1dGUuXCIsIFwiVG8gbGVhcm4gbW9yZSwgdmlzaXQgaHR0cHM6Ly9tdWkuY29tL21hdGVyaWFsLXVpL2N1c3RvbWl6YXRpb24vY3NzLXRoZW1lLXZhcmlhYmxlcy9jb25maWd1cmF0aW9uLyN0b2dnbGluZy1kYXJrLW1vZGUtbWFudWFsbHlcIl0uam9pbihgXG5gKSksIFooSyk7XG4gICAgICB9LFxuICAgICAgc3lzdGVtTW9kZTogYWVcbiAgICB9KSwgW1gsIHZlLCB5ZSwgTywgUWUsIE1lLCBaLCBhZSwgUGUuY29sb3JTY2hlbWVTZWxlY3Rvcl0pO1xuICAgIGxldCB2ID0gITA7XG4gICAgKEEgfHwgUi5jc3NWYXJpYWJsZXMgPT09ICExIHx8IFYgJiYgKHogPT0gbnVsbCA/IHZvaWQgMCA6IHouY3NzVmFyUHJlZml4KSA9PT0gUSkgJiYgKHYgPSAhMSk7XG4gICAgY29uc3QgTSA9IC8qIEBfX1BVUkVfXyAqLyBOLmpzeHMoQy5GcmFnbWVudCwge1xuICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gTi5qc3goUnIsIHtcbiAgICAgICAgdGhlbWVJZDogRiA/IHQgOiB2b2lkIDAsXG4gICAgICAgIHRoZW1lOiBQZSxcbiAgICAgICAgY2hpbGRyZW46IFBcbiAgICAgIH0pLCB2ICYmIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChfYSwge1xuICAgICAgICBzdHlsZXM6ICgodWUgPSBQZS5nZW5lcmF0ZVN0eWxlU2hlZXRzKSA9PSBudWxsID8gdm9pZCAwIDogdWUuY2FsbChQZSkpIHx8IFtdXG4gICAgICB9KV1cbiAgICB9KTtcbiAgICByZXR1cm4gViA/IE0gOiAvKiBAX19QVVJFX18gKi8gTi5qc3godS5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IExlLFxuICAgICAgY2hpbGRyZW46IE1cbiAgICB9KTtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHgucHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb25lbnQgdHJlZS5cbiAgICAgKi9cbiAgICBjaGlsZHJlbjogYS5ub2RlLFxuICAgIC8qKlxuICAgICAqIFRoZSBub2RlIHVzZWQgdG8gYXR0YWNoIHRoZSBjb2xvci1zY2hlbWUgYXR0cmlidXRlXG4gICAgICovXG4gICAgY29sb3JTY2hlbWVOb2RlOiBhLmFueSxcbiAgICAvKipcbiAgICAgKiBsb2NhbFN0b3JhZ2Uga2V5IHVzZWQgdG8gc3RvcmUgYGNvbG9yU2NoZW1lYFxuICAgICAqL1xuICAgIGNvbG9yU2NoZW1lU3RvcmFnZUtleTogYS5zdHJpbmcsXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgbW9kZSB3aGVuIHRoZSBzdG9yYWdlIGlzIGVtcHR5LFxuICAgICAqIHJlcXVpcmUgdGhlIHRoZW1lIHRvIGhhdmUgYGNvbG9yU2NoZW1lc2Agd2l0aCBsaWdodCBhbmQgZGFyay5cbiAgICAgKi9cbiAgICBkZWZhdWx0TW9kZTogYS5zdHJpbmcsXG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB0aGUgcHJvdmlkZXIgY3JlYXRlcyBpdHMgb3duIGNvbnRleHQgYW5kIGdlbmVyYXRlIHN0eWxlc2hlZXQgYXMgaWYgaXQgaXMgYSByb290IGBDc3NWYXJzUHJvdmlkZXJgLlxuICAgICAqL1xuICAgIGRpc2FibGVOZXN0ZWRDb250ZXh0OiBhLmJvb2wsXG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB0aGUgc3R5bGUgc2hlZXQgd29uJ3QgYmUgZ2VuZXJhdGVkLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbnRyb2xsaW5nIG5lc3RlZCBDc3NWYXJzUHJvdmlkZXIgYmVoYXZpb3IuXG4gICAgICovXG4gICAgZGlzYWJsZVN0eWxlU2hlZXRHZW5lcmF0aW9uOiBhLmJvb2wsXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSBDU1MgdHJhbnNpdGlvbnMgd2hlbiBzd2l0Y2hpbmcgYmV0d2VlbiBtb2RlcyBvciBjb2xvciBzY2hlbWVzLlxuICAgICAqL1xuICAgIGRpc2FibGVUcmFuc2l0aW9uT25DaGFuZ2U6IGEuYm9vbCxcbiAgICAvKipcbiAgICAgKiBUaGUgZG9jdW1lbnQgdG8gYXR0YWNoIHRoZSBhdHRyaWJ1dGUgdG8uXG4gICAgICovXG4gICAgZG9jdW1lbnROb2RlOiBhLmFueSxcbiAgICAvKipcbiAgICAgKiBUaGUga2V5IGluIHRoZSBsb2NhbCBzdG9yYWdlIHVzZWQgdG8gc3RvcmUgY3VycmVudCBjb2xvciBzY2hlbWUuXG4gICAgICovXG4gICAgbW9kZVN0b3JhZ2VLZXk6IGEuc3RyaW5nLFxuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIG1vZGUgd2lsbCBiZSB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgc3RvcmFnZSB3aXRob3V0IGFuIGV4dHJhIHJlcmVuZGVyaW5nIGFmdGVyIHRoZSBoeWRyYXRpb24uXG4gICAgICogWW91IHNob3VsZCB1c2UgdGhpcyBvcHRpb24gaW4gY29uanVjdGlvbiB3aXRoIGBJbml0Q29sb3JTY2hlbWVTY3JpcHRgIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBub1NzcjogYS5ib29sLFxuICAgIC8qKlxuICAgICAqIFRoZSB3aW5kb3cgdGhhdCBhdHRhY2hlcyB0aGUgJ3N0b3JhZ2UnIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBkZWZhdWx0IHdpbmRvd1xuICAgICAqL1xuICAgIHN0b3JhZ2VXaW5kb3c6IGEuYW55LFxuICAgIC8qKlxuICAgICAqIFRoZSBjYWxjdWxhdGVkIHRoZW1lIG9iamVjdCB0aGF0IHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggY29udGV4dC5cbiAgICAgKi9cbiAgICB0aGVtZTogYS5vYmplY3RcbiAgfSk7XG4gIGNvbnN0IHkgPSB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gcyA6IHMubGlnaHQsIGYgPSB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gcyA6IHMuZGFyaztcbiAgcmV0dXJuIHtcbiAgICBDc3NWYXJzUHJvdmlkZXI6IHgsXG4gICAgdXNlQ29sb3JTY2hlbWU6IHAsXG4gICAgZ2V0SW5pdENvbG9yU2NoZW1lU2NyaXB0OiAoRSkgPT4gWnUoe1xuICAgICAgY29sb3JTY2hlbWVTdG9yYWdlS2V5OiBvLFxuICAgICAgZGVmYXVsdExpZ2h0Q29sb3JTY2hlbWU6IHksXG4gICAgICBkZWZhdWx0RGFya0NvbG9yU2NoZW1lOiBmLFxuICAgICAgbW9kZVN0b3JhZ2VLZXk6IG4sXG4gICAgICAuLi5FXG4gICAgfSlcbiAgfTtcbn1cbmZ1bmN0aW9uIG9mKGUgPSBcIlwiKSB7XG4gIGZ1bmN0aW9uIHQoLi4ubikge1xuICAgIGlmICghbi5sZW5ndGgpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBjb25zdCBvID0gblswXTtcbiAgICByZXR1cm4gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAhby5tYXRjaCgvKCN8XFwofFxcKXwoLT8oXFxkKlxcLik/XFxkKykocHh8ZW18JXxleHxjaHxyZW18dnd8dmh8dm1pbnx2bWF4fGNtfG1tfGlufHB0fHBjKSl8XigtPyhcXGQqXFwuKT9cXGQrKSR8KFxcZCsgXFxkKyBcXGQrKS8pID8gYCwgdmFyKC0tJHtlID8gYCR7ZX0tYCA6IFwiXCJ9JHtvfSR7dCguLi5uLnNsaWNlKDEpKX0pYCA6IGAsICR7b31gO1xuICB9XG4gIHJldHVybiAobiwgLi4ubykgPT4gYHZhcigtLSR7ZSA/IGAke2V9LWAgOiBcIlwifSR7bn0ke3QoLi4ubyl9KWA7XG59XG5jb25zdCBKaSA9IChlLCB0LCByLCBuID0gW10pID0+IHtcbiAgbGV0IG8gPSBlO1xuICB0LmZvckVhY2goKGksIHMpID0+IHtcbiAgICBzID09PSB0Lmxlbmd0aCAtIDEgPyBBcnJheS5pc0FycmF5KG8pID8gb1tOdW1iZXIoaSldID0gciA6IG8gJiYgdHlwZW9mIG8gPT0gXCJvYmplY3RcIiAmJiAob1tpXSA9IHIpIDogbyAmJiB0eXBlb2YgbyA9PSBcIm9iamVjdFwiICYmIChvW2ldIHx8IChvW2ldID0gbi5pbmNsdWRlcyhpKSA/IFtdIDoge30pLCBvID0gb1tpXSk7XG4gIH0pO1xufSwgYWYgPSAoZSwgdCwgcikgPT4ge1xuICBmdW5jdGlvbiBuKG8sIGkgPSBbXSwgcyA9IFtdKSB7XG4gICAgT2JqZWN0LmVudHJpZXMobykuZm9yRWFjaCgoW2MsIGxdKSA9PiB7XG4gICAgICAoIXIgfHwgIXIoWy4uLmksIGNdKSkgJiYgbCAhPSBudWxsICYmICh0eXBlb2YgbCA9PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKGwpLmxlbmd0aCA+IDAgPyBuKGwsIFsuLi5pLCBjXSwgQXJyYXkuaXNBcnJheShsKSA/IFsuLi5zLCBjXSA6IHMpIDogdChbLi4uaSwgY10sIGwsIHMpKTtcbiAgICB9KTtcbiAgfVxuICBuKGUpO1xufSwgc2YgPSAoZSwgdCkgPT4gdHlwZW9mIHQgPT0gXCJudW1iZXJcIiA/IFtcImxpbmVIZWlnaHRcIiwgXCJmb250V2VpZ2h0XCIsIFwib3BhY2l0eVwiLCBcInpJbmRleFwiXS5zb21lKChuKSA9PiBlLmluY2x1ZGVzKG4pKSB8fCBlW2UubGVuZ3RoIC0gMV0udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcIm9wYWNpdHlcIikgPyB0IDogYCR7dH1weGAgOiB0O1xuZnVuY3Rpb24gdG8oZSwgdCkge1xuICBjb25zdCB7XG4gICAgcHJlZml4OiByLFxuICAgIHNob3VsZFNraXBHZW5lcmF0aW5nVmFyOiBuXG4gIH0gPSB0IHx8IHt9LCBvID0ge30sIGkgPSB7fSwgcyA9IHt9O1xuICByZXR1cm4gYWYoXG4gICAgZSxcbiAgICAoYywgbCwgdSkgPT4ge1xuICAgICAgaWYgKCh0eXBlb2YgbCA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBsID09IFwibnVtYmVyXCIpICYmICghbiB8fCAhbihjLCBsKSkpIHtcbiAgICAgICAgY29uc3QgcCA9IGAtLSR7ciA/IGAke3J9LWAgOiBcIlwifSR7Yy5qb2luKFwiLVwiKX1gLCBtID0gc2YoYywgbCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obywge1xuICAgICAgICAgIFtwXTogbVxuICAgICAgICB9KSwgSmkoaSwgYywgYHZhcigke3B9KWAsIHUpLCBKaShzLCBjLCBgdmFyKCR7cH0sICR7bX0pYCwgdSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAoYykgPT4gY1swXSA9PT0gXCJ2YXJzXCJcbiAgICAvLyBza2lwICd2YXJzLyonIHBhdGhzXG4gICksIHtcbiAgICBjc3M6IG8sXG4gICAgdmFyczogaSxcbiAgICB2YXJzV2l0aERlZmF1bHRzOiBzXG4gIH07XG59XG5mdW5jdGlvbiBjZihlLCB0ID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGdldFNlbGVjdG9yOiByID0gUyxcbiAgICBkaXNhYmxlQ3NzQ29sb3JTY2hlbWU6IG4sXG4gICAgY29sb3JTY2hlbWVTZWxlY3Rvcjogb1xuICB9ID0gdCwge1xuICAgIGNvbG9yU2NoZW1lczogaSA9IHt9LFxuICAgIGNvbXBvbmVudHM6IHMsXG4gICAgZGVmYXVsdENvbG9yU2NoZW1lOiBjID0gXCJsaWdodFwiLFxuICAgIC4uLmxcbiAgfSA9IGUsIHtcbiAgICB2YXJzOiB1LFxuICAgIGNzczogcCxcbiAgICB2YXJzV2l0aERlZmF1bHRzOiBtXG4gIH0gPSB0byhsLCB0KTtcbiAgbGV0IGcgPSBtO1xuICBjb25zdCB4ID0ge30sIHtcbiAgICBbY106IHksXG4gICAgLi4uZlxuICB9ID0gaTtcbiAgaWYgKE9iamVjdC5lbnRyaWVzKGYgfHwge30pLmZvckVhY2goKFtULCBiXSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHZhcnM6IGgsXG4gICAgICBjc3M6IHcsXG4gICAgICB2YXJzV2l0aERlZmF1bHRzOiBrXG4gICAgfSA9IHRvKGIsIHQpO1xuICAgIGcgPSB0dChnLCBrKSwgeFtUXSA9IHtcbiAgICAgIGNzczogdyxcbiAgICAgIHZhcnM6IGhcbiAgICB9O1xuICB9KSwgeSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNzczogVCxcbiAgICAgIHZhcnM6IGIsXG4gICAgICB2YXJzV2l0aERlZmF1bHRzOiBoXG4gICAgfSA9IHRvKHksIHQpO1xuICAgIGcgPSB0dChnLCBoKSwgeFtjXSA9IHtcbiAgICAgIGNzczogVCxcbiAgICAgIHZhcnM6IGJcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIFMoVCwgYikge1xuICAgIHZhciB3LCBrO1xuICAgIGxldCBoID0gbztcbiAgICBpZiAobyA9PT0gXCJjbGFzc1wiICYmIChoID0gXCIuJXNcIiksIG8gPT09IFwiZGF0YVwiICYmIChoID0gXCJbZGF0YS0lc11cIiksIG8gIT0gbnVsbCAmJiBvLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSAmJiAhby5pbmNsdWRlcyhcIiVzXCIpICYmIChoID0gYFske299PVwiJXNcIl1gKSwgVCkge1xuICAgICAgaWYgKGggPT09IFwibWVkaWFcIilcbiAgICAgICAgcmV0dXJuIGUuZGVmYXVsdENvbG9yU2NoZW1lID09PSBUID8gXCI6cm9vdFwiIDoge1xuICAgICAgICAgIFtgQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogJHsoKGsgPSAodyA9IGlbVF0pID09IG51bGwgPyB2b2lkIDAgOiB3LnBhbGV0dGUpID09IG51bGwgPyB2b2lkIDAgOiBrLm1vZGUpIHx8IFR9KWBdOiB7XG4gICAgICAgICAgICBcIjpyb290XCI6IGJcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICBpZiAoaClcbiAgICAgICAgcmV0dXJuIGUuZGVmYXVsdENvbG9yU2NoZW1lID09PSBUID8gYDpyb290LCAke2gucmVwbGFjZShcIiVzXCIsIFN0cmluZyhUKSl9YCA6IGgucmVwbGFjZShcIiVzXCIsIFN0cmluZyhUKSk7XG4gICAgfVxuICAgIHJldHVybiBcIjpyb290XCI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YXJzOiBnLFxuICAgIGdlbmVyYXRlVGhlbWVWYXJzOiAoKSA9PiB7XG4gICAgICBsZXQgVCA9IHtcbiAgICAgICAgLi4udVxuICAgICAgfTtcbiAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyh4KS5mb3JFYWNoKChbLCB7XG4gICAgICAgIHZhcnM6IGJcbiAgICAgIH1dKSA9PiB7XG4gICAgICAgIFQgPSB0dChULCBiKTtcbiAgICAgIH0pLCBUO1xuICAgIH0sXG4gICAgZ2VuZXJhdGVTdHlsZVNoZWV0czogKCkgPT4ge1xuICAgICAgdmFyIEwsIEI7XG4gICAgICBjb25zdCBUID0gW10sIGIgPSBlLmRlZmF1bHRDb2xvclNjaGVtZSB8fCBcImxpZ2h0XCI7XG4gICAgICBmdW5jdGlvbiBoKGQsIEEpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoQSkubGVuZ3RoICYmIFQucHVzaCh0eXBlb2YgZCA9PSBcInN0cmluZ1wiID8ge1xuICAgICAgICAgIFtkXToge1xuICAgICAgICAgICAgLi4uQVxuICAgICAgICAgIH1cbiAgICAgICAgfSA6IGQpO1xuICAgICAgfVxuICAgICAgaChyKHZvaWQgMCwge1xuICAgICAgICAuLi5wXG4gICAgICB9KSwgcCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIFtiXTogdyxcbiAgICAgICAgLi4ua1xuICAgICAgfSA9IHg7XG4gICAgICBpZiAodykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY3NzOiBkXG4gICAgICAgIH0gPSB3LCBBID0gKEIgPSAoTCA9IGlbYl0pID09IG51bGwgPyB2b2lkIDAgOiBMLnBhbGV0dGUpID09IG51bGwgPyB2b2lkIDAgOiBCLm1vZGUsIEQgPSAhbiAmJiBBID8ge1xuICAgICAgICAgIGNvbG9yU2NoZW1lOiBBLFxuICAgICAgICAgIC4uLmRcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAuLi5kXG4gICAgICAgIH07XG4gICAgICAgIGgocihiLCB7XG4gICAgICAgICAgLi4uRFxuICAgICAgICB9KSwgRCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoaykuZm9yRWFjaCgoW2QsIHtcbiAgICAgICAgY3NzOiBBXG4gICAgICB9XSkgPT4ge1xuICAgICAgICB2YXIgVywgejtcbiAgICAgICAgY29uc3QgRCA9ICh6ID0gKFcgPSBpW2RdKSA9PSBudWxsID8gdm9pZCAwIDogVy5wYWxldHRlKSA9PSBudWxsID8gdm9pZCAwIDogei5tb2RlLCBqID0gIW4gJiYgRCA/IHtcbiAgICAgICAgICBjb2xvclNjaGVtZTogRCxcbiAgICAgICAgICAuLi5BXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgLi4uQVxuICAgICAgICB9O1xuICAgICAgICBoKHIoZCwge1xuICAgICAgICAgIC4uLmpcbiAgICAgICAgfSksIGopO1xuICAgICAgfSksIFQ7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbGYoZSkge1xuICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBlID09PSBcIm1lZGlhXCIgPyAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHIgIT09IFwibGlnaHRcIiAmJiByICE9PSBcImRhcmtcIiAmJiBjb25zb2xlLmVycm9yKGBNVUk6IEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWUpIHN1cHBvcnRzIG9ubHkgJ2xpZ2h0JyBvciAnZGFyaycsIGJ1dCByZWNlaXZlICcke3J9Jy5gKSwgYEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6ICR7cn0pYCkgOiBlID8gZS5zdGFydHNXaXRoKFwiZGF0YS1cIikgJiYgIWUuaW5jbHVkZXMoXCIlc1wiKSA/IGBbJHtlfT1cIiR7cn1cIl0gJmAgOiBlID09PSBcImNsYXNzXCIgPyBgLiR7cn0gJmAgOiBlID09PSBcImRhdGFcIiA/IGBbZGF0YS0ke3J9XSAmYCA6IGAke2UucmVwbGFjZShcIiVzXCIsIHIpfSAmYCA6IFwiJlwiO1xuICB9O1xufVxuZnVuY3Rpb24gbHMoKSB7XG4gIHJldHVybiB7XG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHN0eWxlIHRoZSB0ZXh0LlxuICAgIHRleHQ6IHtcbiAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCB0ZXh0LlxuICAgICAgcHJpbWFyeTogXCJyZ2JhKDAsIDAsIDAsIDAuODcpXCIsXG4gICAgICAvLyBTZWNvbmRhcnkgdGV4dC5cbiAgICAgIHNlY29uZGFyeTogXCJyZ2JhKDAsIDAsIDAsIDAuNilcIixcbiAgICAgIC8vIERpc2FibGVkIHRleHQgaGF2ZSBldmVuIGxvd2VyIHZpc3VhbCBwcm9taW5lbmNlLlxuICAgICAgZGlzYWJsZWQ6IFwicmdiYSgwLCAwLCAwLCAwLjM4KVwiXG4gICAgfSxcbiAgICAvLyBUaGUgY29sb3IgdXNlZCB0byBkaXZpZGUgZGlmZmVyZW50IGVsZW1lbnRzLlxuICAgIGRpdmlkZXI6IFwicmdiYSgwLCAwLCAwLCAwLjEyKVwiLFxuICAgIC8vIFRoZSBiYWNrZ3JvdW5kIGNvbG9ycyB1c2VkIHRvIHN0eWxlIHRoZSBzdXJmYWNlcy5cbiAgICAvLyBDb25zaXN0ZW5jeSBiZXR3ZWVuIHRoZXNlIHZhbHVlcyBpcyBpbXBvcnRhbnQuXG4gICAgYmFja2dyb3VuZDoge1xuICAgICAgcGFwZXI6IEVyLndoaXRlLFxuICAgICAgZGVmYXVsdDogRXIud2hpdGVcbiAgICB9LFxuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byBzdHlsZSB0aGUgYWN0aW9uIGVsZW1lbnRzLlxuICAgIGFjdGlvbjoge1xuICAgICAgLy8gVGhlIGNvbG9yIG9mIGFuIGFjdGl2ZSBhY3Rpb24gbGlrZSBhbiBpY29uIGJ1dHRvbi5cbiAgICAgIGFjdGl2ZTogXCJyZ2JhKDAsIDAsIDAsIDAuNTQpXCIsXG4gICAgICAvLyBUaGUgY29sb3Igb2YgYW4gaG92ZXJlZCBhY3Rpb24uXG4gICAgICBob3ZlcjogXCJyZ2JhKDAsIDAsIDAsIDAuMDQpXCIsXG4gICAgICBob3Zlck9wYWNpdHk6IDAuMDQsXG4gICAgICAvLyBUaGUgY29sb3Igb2YgYSBzZWxlY3RlZCBhY3Rpb24uXG4gICAgICBzZWxlY3RlZDogXCJyZ2JhKDAsIDAsIDAsIDAuMDgpXCIsXG4gICAgICBzZWxlY3RlZE9wYWNpdHk6IDAuMDgsXG4gICAgICAvLyBUaGUgY29sb3Igb2YgYSBkaXNhYmxlZCBhY3Rpb24uXG4gICAgICBkaXNhYmxlZDogXCJyZ2JhKDAsIDAsIDAsIDAuMjYpXCIsXG4gICAgICAvLyBUaGUgYmFja2dyb3VuZCBjb2xvciBvZiBhIGRpc2FibGVkIGFjdGlvbi5cbiAgICAgIGRpc2FibGVkQmFja2dyb3VuZDogXCJyZ2JhKDAsIDAsIDAsIDAuMTIpXCIsXG4gICAgICBkaXNhYmxlZE9wYWNpdHk6IDAuMzgsXG4gICAgICBmb2N1czogXCJyZ2JhKDAsIDAsIDAsIDAuMTIpXCIsXG4gICAgICBmb2N1c09wYWNpdHk6IDAuMTIsXG4gICAgICBhY3RpdmF0ZWRPcGFjaXR5OiAwLjEyXG4gICAgfVxuICB9O1xufVxuY29uc3QgdWYgPSBscygpO1xuZnVuY3Rpb24gdXMoKSB7XG4gIHJldHVybiB7XG4gICAgdGV4dDoge1xuICAgICAgcHJpbWFyeTogRXIud2hpdGUsXG4gICAgICBzZWNvbmRhcnk6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpXCIsXG4gICAgICBkaXNhYmxlZDogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSlcIixcbiAgICAgIGljb246IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpXCJcbiAgICB9LFxuICAgIGRpdmlkZXI6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKVwiLFxuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgIHBhcGVyOiBcIiMxMjEyMTJcIixcbiAgICAgIGRlZmF1bHQ6IFwiIzEyMTIxMlwiXG4gICAgfSxcbiAgICBhY3Rpb246IHtcbiAgICAgIGFjdGl2ZTogRXIud2hpdGUsXG4gICAgICBob3ZlcjogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDgpXCIsXG4gICAgICBob3Zlck9wYWNpdHk6IDAuMDgsXG4gICAgICBzZWxlY3RlZDogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTYpXCIsXG4gICAgICBzZWxlY3RlZE9wYWNpdHk6IDAuMTYsXG4gICAgICBkaXNhYmxlZDogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMylcIixcbiAgICAgIGRpc2FibGVkQmFja2dyb3VuZDogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpXCIsXG4gICAgICBkaXNhYmxlZE9wYWNpdHk6IDAuMzgsXG4gICAgICBmb2N1czogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpXCIsXG4gICAgICBmb2N1c09wYWNpdHk6IDAuMTIsXG4gICAgICBhY3RpdmF0ZWRPcGFjaXR5OiAwLjI0XG4gICAgfVxuICB9O1xufVxuY29uc3QgUWkgPSB1cygpO1xuZnVuY3Rpb24gWmkoZSwgdCwgciwgbikge1xuICBjb25zdCBvID0gbi5saWdodCB8fCBuLCBpID0gbi5kYXJrIHx8IG4gKiAxLjU7XG4gIGVbdF0gfHwgKGUuaGFzT3duUHJvcGVydHkocikgPyBlW3RdID0gZVtyXSA6IHQgPT09IFwibGlnaHRcIiA/IGUubGlnaHQgPSBfbyhlLm1haW4sIG8pIDogdCA9PT0gXCJkYXJrXCIgJiYgKGUuZGFyayA9IElvKGUubWFpbiwgaSkpKTtcbn1cbmZ1bmN0aW9uIGZmKGUgPSBcImxpZ2h0XCIpIHtcbiAgcmV0dXJuIGUgPT09IFwiZGFya1wiID8ge1xuICAgIG1haW46IFl0WzIwMF0sXG4gICAgbGlnaHQ6IFl0WzUwXSxcbiAgICBkYXJrOiBZdFs0MDBdXG4gIH0gOiB7XG4gICAgbWFpbjogWXRbNzAwXSxcbiAgICBsaWdodDogWXRbNDAwXSxcbiAgICBkYXJrOiBZdFs4MDBdXG4gIH07XG59XG5mdW5jdGlvbiBkZihlID0gXCJsaWdodFwiKSB7XG4gIHJldHVybiBlID09PSBcImRhcmtcIiA/IHtcbiAgICBtYWluOiBVdFsyMDBdLFxuICAgIGxpZ2h0OiBVdFs1MF0sXG4gICAgZGFyazogVXRbNDAwXVxuICB9IDoge1xuICAgIG1haW46IFV0WzUwMF0sXG4gICAgbGlnaHQ6IFV0WzMwMF0sXG4gICAgZGFyazogVXRbNzAwXVxuICB9O1xufVxuZnVuY3Rpb24gcGYoZSA9IFwibGlnaHRcIikge1xuICByZXR1cm4gZSA9PT0gXCJkYXJrXCIgPyB7XG4gICAgbWFpbjogV3RbNTAwXSxcbiAgICBsaWdodDogV3RbMzAwXSxcbiAgICBkYXJrOiBXdFs3MDBdXG4gIH0gOiB7XG4gICAgbWFpbjogV3RbNzAwXSxcbiAgICBsaWdodDogV3RbNDAwXSxcbiAgICBkYXJrOiBXdFs4MDBdXG4gIH07XG59XG5mdW5jdGlvbiBtZihlID0gXCJsaWdodFwiKSB7XG4gIHJldHVybiBlID09PSBcImRhcmtcIiA/IHtcbiAgICBtYWluOiBIdFs0MDBdLFxuICAgIGxpZ2h0OiBIdFszMDBdLFxuICAgIGRhcms6IEh0WzcwMF1cbiAgfSA6IHtcbiAgICBtYWluOiBIdFs3MDBdLFxuICAgIGxpZ2h0OiBIdFs1MDBdLFxuICAgIGRhcms6IEh0WzkwMF1cbiAgfTtcbn1cbmZ1bmN0aW9uIGhmKGUgPSBcImxpZ2h0XCIpIHtcbiAgcmV0dXJuIGUgPT09IFwiZGFya1wiID8ge1xuICAgIG1haW46IHF0WzQwMF0sXG4gICAgbGlnaHQ6IHF0WzMwMF0sXG4gICAgZGFyazogcXRbNzAwXVxuICB9IDoge1xuICAgIG1haW46IHF0WzgwMF0sXG4gICAgbGlnaHQ6IHF0WzUwMF0sXG4gICAgZGFyazogcXRbOTAwXVxuICB9O1xufVxuZnVuY3Rpb24gZ2YoZSA9IFwibGlnaHRcIikge1xuICByZXR1cm4gZSA9PT0gXCJkYXJrXCIgPyB7XG4gICAgbWFpbjogZnJbNDAwXSxcbiAgICBsaWdodDogZnJbMzAwXSxcbiAgICBkYXJrOiBmcls3MDBdXG4gIH0gOiB7XG4gICAgbWFpbjogXCIjZWQ2YzAyXCIsXG4gICAgLy8gY2xvc2VzdCB0byBvcmFuZ2VbODAwXSB0aGF0IHBhc3MgMzoxLlxuICAgIGxpZ2h0OiBmcls1MDBdLFxuICAgIGRhcms6IGZyWzkwMF1cbiAgfTtcbn1cbmZ1bmN0aW9uIFVvKGUpIHtcbiAgY29uc3Qge1xuICAgIG1vZGU6IHQgPSBcImxpZ2h0XCIsXG4gICAgY29udHJhc3RUaHJlc2hvbGQ6IHIgPSAzLFxuICAgIHRvbmFsT2Zmc2V0OiBuID0gMC4yLFxuICAgIC4uLm9cbiAgfSA9IGUsIGkgPSBlLnByaW1hcnkgfHwgZmYodCksIHMgPSBlLnNlY29uZGFyeSB8fCBkZih0KSwgYyA9IGUuZXJyb3IgfHwgcGYodCksIGwgPSBlLmluZm8gfHwgbWYodCksIHUgPSBlLnN1Y2Nlc3MgfHwgaGYodCksIHAgPSBlLndhcm5pbmcgfHwgZ2YodCk7XG4gIGZ1bmN0aW9uIG0oZikge1xuICAgIGNvbnN0IFMgPSBGaShmLCBRaS50ZXh0LnByaW1hcnkpID49IHIgPyBRaS50ZXh0LnByaW1hcnkgOiB1Zi50ZXh0LnByaW1hcnk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc3QgRSA9IEZpKGYsIFMpO1xuICAgICAgRSA8IDMgJiYgY29uc29sZS5lcnJvcihbYE1VSTogVGhlIGNvbnRyYXN0IHJhdGlvIG9mICR7RX06MSBmb3IgJHtTfSBvbiAke2Z9YCwgXCJmYWxscyBiZWxvdyB0aGUgV0NBRyByZWNvbW1lbmRlZCBhYnNvbHV0ZSBtaW5pbXVtIGNvbnRyYXN0IHJhdGlvIG9mIDM6MS5cIiwgXCJodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMtV0NBRzIwLTIwMDgxMjExLyN2aXN1YWwtYXVkaW8tY29udHJhc3QtY29udHJhc3RcIl0uam9pbihgXG5gKSk7XG4gICAgfVxuICAgIHJldHVybiBTO1xuICB9XG4gIGNvbnN0IGcgPSAoe1xuICAgIGNvbG9yOiBmLFxuICAgIG5hbWU6IFMsXG4gICAgbWFpblNoYWRlOiBFID0gNTAwLFxuICAgIGxpZ2h0U2hhZGU6IFAgPSAzMDAsXG4gICAgZGFya1NoYWRlOiBUID0gNzAwXG4gIH0pID0+IHtcbiAgICBpZiAoZiA9IHtcbiAgICAgIC4uLmZcbiAgICB9LCAhZi5tYWluICYmIGZbRV0gJiYgKGYubWFpbiA9IGZbRV0pLCAhZi5oYXNPd25Qcm9wZXJ0eShcIm1haW5cIikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gYE1VSTogVGhlIGNvbG9yJHtTID8gYCAoJHtTfSlgIDogXCJcIn0gcHJvdmlkZWQgdG8gYXVnbWVudENvbG9yKGNvbG9yKSBpcyBpbnZhbGlkLlxuVGhlIGNvbG9yIG9iamVjdCBuZWVkcyB0byBoYXZlIGEgXFxgbWFpblxcYCBwcm9wZXJ0eSBvciBhIFxcYCR7RX1cXGAgcHJvcGVydHkuYCA6IGt0KDExLCBTID8gYCAoJHtTfSlgIDogXCJcIiwgRSkpO1xuICAgIGlmICh0eXBlb2YgZi5tYWluICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gYE1VSTogVGhlIGNvbG9yJHtTID8gYCAoJHtTfSlgIDogXCJcIn0gcHJvdmlkZWQgdG8gYXVnbWVudENvbG9yKGNvbG9yKSBpcyBpbnZhbGlkLlxuXFxgY29sb3IubWFpblxcYCBzaG91bGQgYmUgYSBzdHJpbmcsIGJ1dCBcXGAke0pTT04uc3RyaW5naWZ5KGYubWFpbil9XFxgIHdhcyBwcm92aWRlZCBpbnN0ZWFkLlxuXG5EaWQgeW91IGludGVuZCB0byB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgYXBwcm9hY2hlcz9cblxuaW1wb3J0IHsgZ3JlZW4gfSBmcm9tIFwiQG11aS9tYXRlcmlhbC9jb2xvcnNcIjtcblxuY29uc3QgdGhlbWUxID0gY3JlYXRlVGhlbWUoeyBwYWxldHRlOiB7XG4gIHByaW1hcnk6IGdyZWVuLFxufSB9KTtcblxuY29uc3QgdGhlbWUyID0gY3JlYXRlVGhlbWUoeyBwYWxldHRlOiB7XG4gIHByaW1hcnk6IHsgbWFpbjogZ3JlZW5bNTAwXSB9LFxufSB9KTtgIDoga3QoMTIsIFMgPyBgICgke1N9KWAgOiBcIlwiLCBKU09OLnN0cmluZ2lmeShmLm1haW4pKSk7XG4gICAgcmV0dXJuIFppKGYsIFwibGlnaHRcIiwgUCwgbiksIFppKGYsIFwiZGFya1wiLCBULCBuKSwgZi5jb250cmFzdFRleHQgfHwgKGYuY29udHJhc3RUZXh0ID0gbShmLm1haW4pKSwgZjtcbiAgfTtcbiAgbGV0IHg7XG4gIHJldHVybiB0ID09PSBcImxpZ2h0XCIgPyB4ID0gbHMoKSA6IHQgPT09IFwiZGFya1wiICYmICh4ID0gdXMoKSksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoeCB8fCBjb25zb2xlLmVycm9yKGBNVUk6IFRoZSBwYWxldHRlIG1vZGUgXFxgJHt0fVxcYCBpcyBub3Qgc3VwcG9ydGVkLmApKSwgdHQoe1xuICAgIC8vIEEgY29sbGVjdGlvbiBvZiBjb21tb24gY29sb3JzLlxuICAgIGNvbW1vbjoge1xuICAgICAgLi4uRXJcbiAgICB9LFxuICAgIC8vIHByZXZlbnQgbXV0YWJsZSBvYmplY3QuXG4gICAgLy8gVGhlIHBhbGV0dGUgbW9kZSwgY2FuIGJlIGxpZ2h0IG9yIGRhcmsuXG4gICAgbW9kZTogdCxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gcmVwcmVzZW50IHByaW1hcnkgaW50ZXJmYWNlIGVsZW1lbnRzIGZvciBhIHVzZXIuXG4gICAgcHJpbWFyeTogZyh7XG4gICAgICBjb2xvcjogaSxcbiAgICAgIG5hbWU6IFwicHJpbWFyeVwiXG4gICAgfSksXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHJlcHJlc2VudCBzZWNvbmRhcnkgaW50ZXJmYWNlIGVsZW1lbnRzIGZvciBhIHVzZXIuXG4gICAgc2Vjb25kYXJ5OiBnKHtcbiAgICAgIGNvbG9yOiBzLFxuICAgICAgbmFtZTogXCJzZWNvbmRhcnlcIixcbiAgICAgIG1haW5TaGFkZTogXCJBNDAwXCIsXG4gICAgICBsaWdodFNoYWRlOiBcIkEyMDBcIixcbiAgICAgIGRhcmtTaGFkZTogXCJBNzAwXCJcbiAgICB9KSxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gcmVwcmVzZW50IGludGVyZmFjZSBlbGVtZW50cyB0aGF0IHRoZSB1c2VyIHNob3VsZCBiZSBtYWRlIGF3YXJlIG9mLlxuICAgIGVycm9yOiBnKHtcbiAgICAgIGNvbG9yOiBjLFxuICAgICAgbmFtZTogXCJlcnJvclwiXG4gICAgfSksXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHJlcHJlc2VudCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgYWN0aW9ucyBvciBpbXBvcnRhbnQgbWVzc2FnZXMuXG4gICAgd2FybmluZzogZyh7XG4gICAgICBjb2xvcjogcCxcbiAgICAgIG5hbWU6IFwid2FybmluZ1wiXG4gICAgfSksXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHByZXNlbnQgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIgdGhhdCBpcyBuZXV0cmFsIGFuZCBub3QgbmVjZXNzYXJpbHkgaW1wb3J0YW50LlxuICAgIGluZm86IGcoe1xuICAgICAgY29sb3I6IGwsXG4gICAgICBuYW1lOiBcImluZm9cIlxuICAgIH0pLFxuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgc3VjY2Vzc2Z1bCBjb21wbGV0aW9uIG9mIGFuIGFjdGlvbiB0aGF0IHVzZXIgdHJpZ2dlcmVkLlxuICAgIHN1Y2Nlc3M6IGcoe1xuICAgICAgY29sb3I6IHUsXG4gICAgICBuYW1lOiBcInN1Y2Nlc3NcIlxuICAgIH0pLFxuICAgIC8vIFRoZSBncmV5IGNvbG9ycy5cbiAgICBncmV5OiBvYyxcbiAgICAvLyBVc2VkIGJ5IGBnZXRDb250cmFzdFRleHQoKWAgdG8gbWF4aW1pemUgdGhlIGNvbnRyYXN0IGJldHdlZW5cbiAgICAvLyB0aGUgYmFja2dyb3VuZCBhbmQgdGhlIHRleHQuXG4gICAgY29udHJhc3RUaHJlc2hvbGQ6IHIsXG4gICAgLy8gVGFrZXMgYSBiYWNrZ3JvdW5kIGNvbG9yIGFuZCByZXR1cm5zIHRoZSB0ZXh0IGNvbG9yIHRoYXQgbWF4aW1pemVzIHRoZSBjb250cmFzdC5cbiAgICBnZXRDb250cmFzdFRleHQ6IG0sXG4gICAgLy8gR2VuZXJhdGUgYSByaWNoIGNvbG9yIG9iamVjdC5cbiAgICBhdWdtZW50Q29sb3I6IGcsXG4gICAgLy8gVXNlZCBieSB0aGUgZnVuY3Rpb25zIGJlbG93IHRvIHNoaWZ0IGEgY29sb3IncyBsdW1pbmFuY2UgYnkgYXBwcm94aW1hdGVseVxuICAgIC8vIHR3byBpbmRleGVzIHdpdGhpbiBpdHMgdG9uYWwgcGFsZXR0ZS5cbiAgICAvLyBFLmcuLCBzaGlmdCBmcm9tIFJlZCA1MDAgdG8gUmVkIDMwMCBvciBSZWQgNzAwLlxuICAgIHRvbmFsT2Zmc2V0OiBuLFxuICAgIC8vIFRoZSBsaWdodCBhbmQgZGFyayBtb2RlIG9iamVjdC5cbiAgICAuLi54XG4gIH0sIG8pO1xufVxuZnVuY3Rpb24geWYoZSkge1xuICBjb25zdCB0ID0ge307XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgY29uc3QgW28sIGldID0gbjtcbiAgICB0eXBlb2YgaSA9PSBcIm9iamVjdFwiICYmICh0W29dID0gYCR7aS5mb250U3R5bGUgPyBgJHtpLmZvbnRTdHlsZX0gYCA6IFwiXCJ9JHtpLmZvbnRWYXJpYW50ID8gYCR7aS5mb250VmFyaWFudH0gYCA6IFwiXCJ9JHtpLmZvbnRXZWlnaHQgPyBgJHtpLmZvbnRXZWlnaHR9IGAgOiBcIlwifSR7aS5mb250U3RyZXRjaCA/IGAke2kuZm9udFN0cmV0Y2h9IGAgOiBcIlwifSR7aS5mb250U2l6ZSB8fCBcIlwifSR7aS5saW5lSGVpZ2h0ID8gYC8ke2kubGluZUhlaWdodH0gYCA6IFwiXCJ9JHtpLmZvbnRGYW1pbHkgfHwgXCJcIn1gKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBiZihlLCB0KSB7XG4gIHJldHVybiB7XG4gICAgdG9vbGJhcjoge1xuICAgICAgbWluSGVpZ2h0OiA1NixcbiAgICAgIFtlLnVwKFwieHNcIildOiB7XG4gICAgICAgIFwiQG1lZGlhIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKVwiOiB7XG4gICAgICAgICAgbWluSGVpZ2h0OiA0OFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2UudXAoXCJzbVwiKV06IHtcbiAgICAgICAgbWluSGVpZ2h0OiA2NFxuICAgICAgfVxuICAgIH0sXG4gICAgLi4udFxuICB9O1xufVxuZnVuY3Rpb24gdmYoZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZChlICogMWU1KSAvIDFlNTtcbn1cbmNvbnN0IGVhID0ge1xuICB0ZXh0VHJhbnNmb3JtOiBcInVwcGVyY2FzZVwiXG59LCB0YSA9ICdcIlJvYm90b1wiLCBcIkhlbHZldGljYVwiLCBcIkFyaWFsXCIsIHNhbnMtc2VyaWYnO1xuZnVuY3Rpb24gZnMoZSwgdCkge1xuICBjb25zdCB7XG4gICAgZm9udEZhbWlseTogciA9IHRhLFxuICAgIC8vIFRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBvZiB0aGUgTWF0ZXJpYWwgU3BlY2lmaWNhdGlvbi5cbiAgICBmb250U2l6ZTogbiA9IDE0LFxuICAgIC8vIHB4XG4gICAgZm9udFdlaWdodExpZ2h0OiBvID0gMzAwLFxuICAgIGZvbnRXZWlnaHRSZWd1bGFyOiBpID0gNDAwLFxuICAgIGZvbnRXZWlnaHRNZWRpdW06IHMgPSA1MDAsXG4gICAgZm9udFdlaWdodEJvbGQ6IGMgPSA3MDAsXG4gICAgLy8gVGVsbCBNVUkgd2hhdCdzIHRoZSBmb250LXNpemUgb24gdGhlIGh0bWwgZWxlbWVudC5cbiAgICAvLyAxNnB4IGlzIHRoZSBkZWZhdWx0IGZvbnQtc2l6ZSB1c2VkIGJ5IGJyb3dzZXJzLlxuICAgIGh0bWxGb250U2l6ZTogbCA9IDE2LFxuICAgIC8vIEFwcGx5IHRoZSBDU1MgcHJvcGVydGllcyB0byBhbGwgdGhlIHZhcmlhbnRzLlxuICAgIGFsbFZhcmlhbnRzOiB1LFxuICAgIHB4VG9SZW06IHAsXG4gICAgLi4ubVxuICB9ID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdChlKSA6IHQ7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAodHlwZW9mIG4gIT0gXCJudW1iZXJcIiAmJiBjb25zb2xlLmVycm9yKFwiTVVJOiBgZm9udFNpemVgIGlzIHJlcXVpcmVkIHRvIGJlIGEgbnVtYmVyLlwiKSwgdHlwZW9mIGwgIT0gXCJudW1iZXJcIiAmJiBjb25zb2xlLmVycm9yKFwiTVVJOiBgaHRtbEZvbnRTaXplYCBpcyByZXF1aXJlZCB0byBiZSBhIG51bWJlci5cIikpO1xuICBjb25zdCBnID0gbiAvIDE0LCB4ID0gcCB8fCAoKFMpID0+IGAke1MgLyBsICogZ31yZW1gKSwgeSA9IChTLCBFLCBQLCBULCBiKSA9PiAoe1xuICAgIGZvbnRGYW1pbHk6IHIsXG4gICAgZm9udFdlaWdodDogUyxcbiAgICBmb250U2l6ZTogeChFKSxcbiAgICAvLyBVbml0bGVzcyBmb2xsb3dpbmcgaHR0cHM6Ly9tZXllcndlYi5jb20vZXJpYy90aG91Z2h0cy8yMDA2LzAyLzA4L3VuaXRsZXNzLWxpbmUtaGVpZ2h0cy9cbiAgICBsaW5lSGVpZ2h0OiBQLFxuICAgIC8vIFRoZSBsZXR0ZXIgc3BhY2luZyB3YXMgZGVzaWduZWQgZm9yIHRoZSBSb2JvdG8gZm9udC1mYW1pbHkuIFVzaW5nIHRoZSBzYW1lIGxldHRlci1zcGFjaW5nXG4gICAgLy8gYWNyb3NzIGZvbnQtZmFtaWxpZXMgY2FuIGNhdXNlIGlzc3VlcyB3aXRoIHRoZSBrZXJuaW5nLlxuICAgIC4uLnIgPT09IHRhID8ge1xuICAgICAgbGV0dGVyU3BhY2luZzogYCR7dmYoVCAvIEUpfWVtYFxuICAgIH0gOiB7fSxcbiAgICAuLi5iLFxuICAgIC4uLnVcbiAgfSksIGYgPSB7XG4gICAgaDE6IHkobywgOTYsIDEuMTY3LCAtMS41KSxcbiAgICBoMjogeShvLCA2MCwgMS4yLCAtMC41KSxcbiAgICBoMzogeShpLCA0OCwgMS4xNjcsIDApLFxuICAgIGg0OiB5KGksIDM0LCAxLjIzNSwgMC4yNSksXG4gICAgaDU6IHkoaSwgMjQsIDEuMzM0LCAwKSxcbiAgICBoNjogeShzLCAyMCwgMS42LCAwLjE1KSxcbiAgICBzdWJ0aXRsZTE6IHkoaSwgMTYsIDEuNzUsIDAuMTUpLFxuICAgIHN1YnRpdGxlMjogeShzLCAxNCwgMS41NywgMC4xKSxcbiAgICBib2R5MTogeShpLCAxNiwgMS41LCAwLjE1KSxcbiAgICBib2R5MjogeShpLCAxNCwgMS40MywgMC4xNSksXG4gICAgYnV0dG9uOiB5KHMsIDE0LCAxLjc1LCAwLjQsIGVhKSxcbiAgICBjYXB0aW9uOiB5KGksIDEyLCAxLjY2LCAwLjQpLFxuICAgIG92ZXJsaW5lOiB5KGksIDEyLCAyLjY2LCAxLCBlYSksXG4gICAgLy8gVE9ETyB2NjogUmVtb3ZlIGhhbmRsaW5nIG9mICdpbmhlcml0JyB2YXJpYW50IGZyb20gdGhlIHRoZW1lIGFzIGl0IGlzIGFscmVhZHkgaGFuZGxlZCBpbiBNYXRlcmlhbCBVSSdzIFR5cG9ncmFwaHkgY29tcG9uZW50LiBBbHNvLCByZW1lbWJlciB0byByZW1vdmUgdGhlIGFzc29jaWF0ZWQgdHlwZXMuXG4gICAgaW5oZXJpdDoge1xuICAgICAgZm9udEZhbWlseTogXCJpbmhlcml0XCIsXG4gICAgICBmb250V2VpZ2h0OiBcImluaGVyaXRcIixcbiAgICAgIGZvbnRTaXplOiBcImluaGVyaXRcIixcbiAgICAgIGxpbmVIZWlnaHQ6IFwiaW5oZXJpdFwiLFxuICAgICAgbGV0dGVyU3BhY2luZzogXCJpbmhlcml0XCJcbiAgICB9XG4gIH07XG4gIHJldHVybiB0dCh7XG4gICAgaHRtbEZvbnRTaXplOiBsLFxuICAgIHB4VG9SZW06IHgsXG4gICAgZm9udEZhbWlseTogcixcbiAgICBmb250U2l6ZTogbixcbiAgICBmb250V2VpZ2h0TGlnaHQ6IG8sXG4gICAgZm9udFdlaWdodFJlZ3VsYXI6IGksXG4gICAgZm9udFdlaWdodE1lZGl1bTogcyxcbiAgICBmb250V2VpZ2h0Qm9sZDogYyxcbiAgICAuLi5mXG4gIH0sIG0sIHtcbiAgICBjbG9uZTogITFcbiAgICAvLyBObyBuZWVkIHRvIGNsb25lIGRlZXBcbiAgfSk7XG59XG5jb25zdCB4ZiA9IDAuMiwgU2YgPSAwLjE0LCBFZiA9IDAuMTI7XG5mdW5jdGlvbiAkZSguLi5lKSB7XG4gIHJldHVybiBbYCR7ZVswXX1weCAke2VbMV19cHggJHtlWzJdfXB4ICR7ZVszXX1weCByZ2JhKDAsMCwwLCR7eGZ9KWAsIGAke2VbNF19cHggJHtlWzVdfXB4ICR7ZVs2XX1weCAke2VbN119cHggcmdiYSgwLDAsMCwke1NmfSlgLCBgJHtlWzhdfXB4ICR7ZVs5XX1weCAke2VbMTBdfXB4ICR7ZVsxMV19cHggcmdiYSgwLDAsMCwke0VmfSlgXS5qb2luKFwiLFwiKTtcbn1cbmNvbnN0IENmID0gW1wibm9uZVwiLCAkZSgwLCAyLCAxLCAtMSwgMCwgMSwgMSwgMCwgMCwgMSwgMywgMCksICRlKDAsIDMsIDEsIC0yLCAwLCAyLCAyLCAwLCAwLCAxLCA1LCAwKSwgJGUoMCwgMywgMywgLTIsIDAsIDMsIDQsIDAsIDAsIDEsIDgsIDApLCAkZSgwLCAyLCA0LCAtMSwgMCwgNCwgNSwgMCwgMCwgMSwgMTAsIDApLCAkZSgwLCAzLCA1LCAtMSwgMCwgNSwgOCwgMCwgMCwgMSwgMTQsIDApLCAkZSgwLCAzLCA1LCAtMSwgMCwgNiwgMTAsIDAsIDAsIDEsIDE4LCAwKSwgJGUoMCwgNCwgNSwgLTIsIDAsIDcsIDEwLCAxLCAwLCAyLCAxNiwgMSksICRlKDAsIDUsIDUsIC0zLCAwLCA4LCAxMCwgMSwgMCwgMywgMTQsIDIpLCAkZSgwLCA1LCA2LCAtMywgMCwgOSwgMTIsIDEsIDAsIDMsIDE2LCAyKSwgJGUoMCwgNiwgNiwgLTMsIDAsIDEwLCAxNCwgMSwgMCwgNCwgMTgsIDMpLCAkZSgwLCA2LCA3LCAtNCwgMCwgMTEsIDE1LCAxLCAwLCA0LCAyMCwgMyksICRlKDAsIDcsIDgsIC00LCAwLCAxMiwgMTcsIDIsIDAsIDUsIDIyLCA0KSwgJGUoMCwgNywgOCwgLTQsIDAsIDEzLCAxOSwgMiwgMCwgNSwgMjQsIDQpLCAkZSgwLCA3LCA5LCAtNCwgMCwgMTQsIDIxLCAyLCAwLCA1LCAyNiwgNCksICRlKDAsIDgsIDksIC01LCAwLCAxNSwgMjIsIDIsIDAsIDYsIDI4LCA1KSwgJGUoMCwgOCwgMTAsIC01LCAwLCAxNiwgMjQsIDIsIDAsIDYsIDMwLCA1KSwgJGUoMCwgOCwgMTEsIC01LCAwLCAxNywgMjYsIDIsIDAsIDYsIDMyLCA1KSwgJGUoMCwgOSwgMTEsIC01LCAwLCAxOCwgMjgsIDIsIDAsIDcsIDM0LCA2KSwgJGUoMCwgOSwgMTIsIC02LCAwLCAxOSwgMjksIDIsIDAsIDcsIDM2LCA2KSwgJGUoMCwgMTAsIDEzLCAtNiwgMCwgMjAsIDMxLCAzLCAwLCA4LCAzOCwgNyksICRlKDAsIDEwLCAxMywgLTYsIDAsIDIxLCAzMywgMywgMCwgOCwgNDAsIDcpLCAkZSgwLCAxMCwgMTQsIC02LCAwLCAyMiwgMzUsIDMsIDAsIDgsIDQyLCA3KSwgJGUoMCwgMTEsIDE0LCAtNywgMCwgMjMsIDM2LCAzLCAwLCA5LCA0NCwgOCksICRlKDAsIDExLCAxNSwgLTcsIDAsIDI0LCAzOCwgMywgMCwgOSwgNDYsIDgpXSwgVGYgPSB7XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uIGVhc2luZyBjdXJ2ZS5cbiAgZWFzZUluT3V0OiBcImN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSlcIixcbiAgLy8gT2JqZWN0cyBlbnRlciB0aGUgc2NyZWVuIGF0IGZ1bGwgdmVsb2NpdHkgZnJvbSBvZmYtc2NyZWVuIGFuZFxuICAvLyBzbG93bHkgZGVjZWxlcmF0ZSB0byBhIHJlc3RpbmcgcG9pbnQuXG4gIGVhc2VPdXQ6IFwiY3ViaWMtYmV6aWVyKDAuMCwgMCwgMC4yLCAxKVwiLFxuICAvLyBPYmplY3RzIGxlYXZlIHRoZSBzY3JlZW4gYXQgZnVsbCB2ZWxvY2l0eS4gVGhleSBkbyBub3QgZGVjZWxlcmF0ZSB3aGVuIG9mZi1zY3JlZW4uXG4gIGVhc2VJbjogXCJjdWJpYy1iZXppZXIoMC40LCAwLCAxLCAxKVwiLFxuICAvLyBUaGUgc2hhcnAgY3VydmUgaXMgdXNlZCBieSBvYmplY3RzIHRoYXQgbWF5IHJldHVybiB0byB0aGUgc2NyZWVuIGF0IGFueSB0aW1lLlxuICBzaGFycDogXCJjdWJpYy1iZXppZXIoMC40LCAwLCAwLjYsIDEpXCJcbn0sIGRzID0ge1xuICBzaG9ydGVzdDogMTUwLFxuICBzaG9ydGVyOiAyMDAsXG4gIHNob3J0OiAyNTAsXG4gIC8vIG1vc3QgYmFzaWMgcmVjb21tZW5kZWQgdGltaW5nXG4gIHN0YW5kYXJkOiAzMDAsXG4gIC8vIHRoaXMgaXMgdG8gYmUgdXNlZCBpbiBjb21wbGV4IGFuaW1hdGlvbnNcbiAgY29tcGxleDogMzc1LFxuICAvLyByZWNvbW1lbmRlZCB3aGVuIHNvbWV0aGluZyBpcyBlbnRlcmluZyBzY3JlZW5cbiAgZW50ZXJpbmdTY3JlZW46IDIyNSxcbiAgLy8gcmVjb21tZW5kZWQgd2hlbiBzb21ldGhpbmcgaXMgbGVhdmluZyBzY3JlZW5cbiAgbGVhdmluZ1NjcmVlbjogMTk1XG59O1xuZnVuY3Rpb24gcmEoZSkge1xuICByZXR1cm4gYCR7TWF0aC5yb3VuZChlKX1tc2A7XG59XG5mdW5jdGlvbiB3ZihlKSB7XG4gIGlmICghZSlcbiAgICByZXR1cm4gMDtcbiAgY29uc3QgdCA9IGUgLyAzNjtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgucm91bmQoKDQgKyAxNSAqIHQgKiogMC4yNSArIHQgLyA1KSAqIDEwKSwgM2UzKTtcbn1cbmZ1bmN0aW9uIE9mKGUpIHtcbiAgY29uc3QgdCA9IHtcbiAgICAuLi5UZixcbiAgICAuLi5lLmVhc2luZ1xuICB9LCByID0ge1xuICAgIC4uLmRzLFxuICAgIC4uLmUuZHVyYXRpb25cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBnZXRBdXRvSGVpZ2h0RHVyYXRpb246IHdmLFxuICAgIGNyZWF0ZTogKG8gPSBbXCJhbGxcIl0sIGkgPSB7fSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkdXJhdGlvbjogcyA9IHIuc3RhbmRhcmQsXG4gICAgICAgIGVhc2luZzogYyA9IHQuZWFzZUluT3V0LFxuICAgICAgICBkZWxheTogbCA9IDAsXG4gICAgICAgIC4uLnVcbiAgICAgIH0gPSBpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCBwID0gKGcpID0+IHR5cGVvZiBnID09IFwic3RyaW5nXCIsIG0gPSAoZykgPT4gIU51bWJlci5pc05hTihwYXJzZUZsb2F0KGcpKTtcbiAgICAgICAgIXAobykgJiYgIUFycmF5LmlzQXJyYXkobykgJiYgY29uc29sZS5lcnJvcignTVVJOiBBcmd1bWVudCBcInByb3BzXCIgbXVzdCBiZSBhIHN0cmluZyBvciBBcnJheS4nKSwgIW0ocykgJiYgIXAocykgJiYgY29uc29sZS5lcnJvcihgTVVJOiBBcmd1bWVudCBcImR1cmF0aW9uXCIgbXVzdCBiZSBhIG51bWJlciBvciBhIHN0cmluZyBidXQgZm91bmQgJHtzfS5gKSwgcChjKSB8fCBjb25zb2xlLmVycm9yKCdNVUk6IEFyZ3VtZW50IFwiZWFzaW5nXCIgbXVzdCBiZSBhIHN0cmluZy4nKSwgIW0obCkgJiYgIXAobCkgJiYgY29uc29sZS5lcnJvcignTVVJOiBBcmd1bWVudCBcImRlbGF5XCIgbXVzdCBiZSBhIG51bWJlciBvciBhIHN0cmluZy4nKSwgdHlwZW9mIGkgIT0gXCJvYmplY3RcIiAmJiBjb25zb2xlLmVycm9yKFtcIk1VSTogU2Vjb25nIGFyZ3VtZW50IG9mIHRyYW5zaXRpb24uY3JlYXRlIG11c3QgYmUgYW4gb2JqZWN0LlwiLCBcIkFyZ3VtZW50cyBzaG91bGQgYmUgZWl0aGVyIGBjcmVhdGUoJ3Byb3AxJywgb3B0aW9ucylgIG9yIGBjcmVhdGUoWydwcm9wMScsICdwcm9wMiddLCBvcHRpb25zKWBcIl0uam9pbihgXG5gKSksIE9iamVjdC5rZXlzKHUpLmxlbmd0aCAhPT0gMCAmJiBjb25zb2xlLmVycm9yKGBNVUk6IFVucmVjb2duaXplZCBhcmd1bWVudChzKSBbJHtPYmplY3Qua2V5cyh1KS5qb2luKFwiLFwiKX1dLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KG8pID8gbyA6IFtvXSkubWFwKChwKSA9PiBgJHtwfSAke3R5cGVvZiBzID09IFwic3RyaW5nXCIgPyBzIDogcmEocyl9ICR7Y30gJHt0eXBlb2YgbCA9PSBcInN0cmluZ1wiID8gbCA6IHJhKGwpfWApLmpvaW4oXCIsXCIpO1xuICAgIH0sXG4gICAgLi4uZSxcbiAgICBlYXNpbmc6IHQsXG4gICAgZHVyYXRpb246IHJcbiAgfTtcbn1cbmNvbnN0IFJmID0ge1xuICBtb2JpbGVTdGVwcGVyOiAxZTMsXG4gIGZhYjogMTA1MCxcbiAgc3BlZWREaWFsOiAxMDUwLFxuICBhcHBCYXI6IDExMDAsXG4gIGRyYXdlcjogMTIwMCxcbiAgbW9kYWw6IDEzMDAsXG4gIHNuYWNrYmFyOiAxNDAwLFxuICB0b29sdGlwOiAxNTAwXG59O1xuZnVuY3Rpb24gJGYoZSkge1xuICByZXR1cm4gZ3QoZSkgfHwgdHlwZW9mIGUgPiBcInVcIiB8fCB0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiBlID09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheShlKTtcbn1cbmZ1bmN0aW9uIHBzKGUgPSB7fSkge1xuICBjb25zdCB0ID0ge1xuICAgIC4uLmVcbiAgfTtcbiAgZnVuY3Rpb24gcihuKSB7XG4gICAgY29uc3QgbyA9IE9iamVjdC5lbnRyaWVzKG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgW3MsIGNdID0gb1tpXTtcbiAgICAgICEkZihjKSB8fCBzLnN0YXJ0c1dpdGgoXCJ1bnN0YWJsZV9cIikgPyBkZWxldGUgbltzXSA6IGd0KGMpICYmIChuW3NdID0ge1xuICAgICAgICAuLi5jXG4gICAgICB9LCByKG5bc10pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHIodCksIGBpbXBvcnQgeyB1bnN0YWJsZV9jcmVhdGVCcmVha3BvaW50cyBhcyBjcmVhdGVCcmVha3BvaW50cywgY3JlYXRlVHJhbnNpdGlvbnMgfSBmcm9tICdAbXVpL21hdGVyaWFsL3N0eWxlcyc7XG5cbmNvbnN0IHRoZW1lID0gJHtKU09OLnN0cmluZ2lmeSh0LCBudWxsLCAyKX07XG5cbnRoZW1lLmJyZWFrcG9pbnRzID0gY3JlYXRlQnJlYWtwb2ludHModGhlbWUuYnJlYWtwb2ludHMgfHwge30pO1xudGhlbWUudHJhbnNpdGlvbnMgPSBjcmVhdGVUcmFuc2l0aW9ucyh0aGVtZS50cmFuc2l0aW9ucyB8fCB7fSk7XG5cbmV4cG9ydCBkZWZhdWx0IHRoZW1lO2A7XG59XG5mdW5jdGlvbiBmbyhlID0ge30sIC4uLnQpIHtcbiAgY29uc3Qge1xuICAgIGJyZWFrcG9pbnRzOiByLFxuICAgIG1peGluczogbiA9IHt9LFxuICAgIHNwYWNpbmc6IG8sXG4gICAgcGFsZXR0ZTogaSA9IHt9LFxuICAgIHRyYW5zaXRpb25zOiBzID0ge30sXG4gICAgdHlwb2dyYXBoeTogYyA9IHt9LFxuICAgIHNoYXBlOiBsLFxuICAgIC4uLnVcbiAgfSA9IGU7XG4gIGlmIChlLnZhcnMpXG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiTVVJOiBgdmFyc2AgaXMgYSBwcml2YXRlIGZpZWxkIHVzZWQgZm9yIENTUyB2YXJpYWJsZXMgc3VwcG9ydC5cXG5QbGVhc2UgdXNlIGFub3RoZXIgbmFtZS5cIiA6IGt0KDIwKSk7XG4gIGNvbnN0IHAgPSBVbyhpKSwgbSA9IE5vKGUpO1xuICBsZXQgZyA9IHR0KG0sIHtcbiAgICBtaXhpbnM6IGJmKG0uYnJlYWtwb2ludHMsIG4pLFxuICAgIHBhbGV0dGU6IHAsXG4gICAgLy8gRG9uJ3QgdXNlIFsuLi5zaGFkb3dzXSB1bnRpbCB5b3UndmUgdmVyaWZpZWQgaXRzIHRyYW5zcGlsZWQgY29kZSBpcyBub3QgaW52b2tpbmcgdGhlIGl0ZXJhdG9yIHByb3RvY29sLlxuICAgIHNoYWRvd3M6IENmLnNsaWNlKCksXG4gICAgdHlwb2dyYXBoeTogZnMocCwgYyksXG4gICAgdHJhbnNpdGlvbnM6IE9mKHMpLFxuICAgIHpJbmRleDoge1xuICAgICAgLi4uUmZcbiAgICB9XG4gIH0pO1xuICBpZiAoZyA9IHR0KGcsIHUpLCBnID0gdC5yZWR1Y2UoKHgsIHkpID0+IHR0KHgsIHkpLCBnKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgeCA9IFtcImFjdGl2ZVwiLCBcImNoZWNrZWRcIiwgXCJjb21wbGV0ZWRcIiwgXCJkaXNhYmxlZFwiLCBcImVycm9yXCIsIFwiZXhwYW5kZWRcIiwgXCJmb2N1c2VkXCIsIFwiZm9jdXNWaXNpYmxlXCIsIFwicmVxdWlyZWRcIiwgXCJzZWxlY3RlZFwiXSwgeSA9IChmLCBTKSA9PiB7XG4gICAgICBsZXQgRTtcbiAgICAgIGZvciAoRSBpbiBmKSB7XG4gICAgICAgIGNvbnN0IFAgPSBmW0VdO1xuICAgICAgICBpZiAoeC5pbmNsdWRlcyhFKSAmJiBPYmplY3Qua2V5cyhQKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgVCA9IFZlKFwiXCIsIEUpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihbYE1VSTogVGhlIFxcYCR7U31cXGAgY29tcG9uZW50IGluY3JlYXNlcyB0aGUgQ1NTIHNwZWNpZmljaXR5IG9mIHRoZSBcXGAke0V9XFxgIGludGVybmFsIHN0YXRlLmAsIFwiWW91IGNhbiBub3Qgb3ZlcnJpZGUgaXQgbGlrZSB0aGlzOiBcIiwgSlNPTi5zdHJpbmdpZnkoZiwgbnVsbCwgMiksIFwiXCIsIGBJbnN0ZWFkLCB5b3UgbmVlZCB0byB1c2UgdGhlICcmLiR7VH0nIHN5bnRheDpgLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgICAgICBbYCYuJHtUfWBdOiBQXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG51bGwsIDIpLCBcIlwiLCBcImh0dHBzOi8vbXVpLmNvbS9yL3N0YXRlLWNsYXNzZXMtZ3VpZGVcIl0uam9pbihgXG5gKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZbRV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmtleXMoZy5jb21wb25lbnRzKS5mb3JFYWNoKChmKSA9PiB7XG4gICAgICBjb25zdCBTID0gZy5jb21wb25lbnRzW2ZdLnN0eWxlT3ZlcnJpZGVzO1xuICAgICAgUyAmJiBmLnN0YXJ0c1dpdGgoXCJNdWlcIikgJiYgeShTLCBmKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZy51bnN0YWJsZV9zeENvbmZpZyA9IHtcbiAgICAuLi5EcixcbiAgICAuLi51ID09IG51bGwgPyB2b2lkIDAgOiB1LnVuc3RhYmxlX3N4Q29uZmlnXG4gIH0sIGcudW5zdGFibGVfc3ggPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIEF0KHtcbiAgICAgIHN4OiB5LFxuICAgICAgdGhlbWU6IHRoaXNcbiAgICB9KTtcbiAgfSwgZy50b1J1bnRpbWVTb3VyY2UgPSBwcywgZztcbn1cbmZ1bmN0aW9uIFBmKGUpIHtcbiAgbGV0IHQ7XG4gIHJldHVybiBlIDwgMSA/IHQgPSA1LjExOTE2ICogZSAqKiAyIDogdCA9IDQuNSAqIE1hdGgubG9nKGUgKyAxKSArIDIsIE1hdGgucm91bmQodCAqIDEwKSAvIDFlMztcbn1cbmNvbnN0IGtmID0gWy4uLkFycmF5KDI1KV0ubWFwKChlLCB0KSA9PiB7XG4gIGlmICh0ID09PSAwKVxuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgY29uc3QgciA9IFBmKHQpO1xuICByZXR1cm4gYGxpbmVhci1ncmFkaWVudChyZ2JhKDI1NSAyNTUgMjU1IC8gJHtyfSksIHJnYmEoMjU1IDI1NSAyNTUgLyAke3J9KSlgO1xufSk7XG5mdW5jdGlvbiBtcyhlKSB7XG4gIHJldHVybiB7XG4gICAgaW5wdXRQbGFjZWhvbGRlcjogZSA9PT0gXCJkYXJrXCIgPyAwLjUgOiAwLjQyLFxuICAgIGlucHV0VW5kZXJsaW5lOiBlID09PSBcImRhcmtcIiA/IDAuNyA6IDAuNDIsXG4gICAgc3dpdGNoVHJhY2tEaXNhYmxlZDogZSA9PT0gXCJkYXJrXCIgPyAwLjIgOiAwLjEyLFxuICAgIHN3aXRjaFRyYWNrOiBlID09PSBcImRhcmtcIiA/IDAuMyA6IDAuMzhcbiAgfTtcbn1cbmZ1bmN0aW9uIGhzKGUpIHtcbiAgcmV0dXJuIGUgPT09IFwiZGFya1wiID8ga2YgOiBbXTtcbn1cbmZ1bmN0aW9uIEFmKGUpIHtcbiAgY29uc3Qge1xuICAgIHBhbGV0dGU6IHQgPSB7XG4gICAgICBtb2RlOiBcImxpZ2h0XCJcbiAgICB9LFxuICAgIC8vIG5lZWQgdG8gY2FzdCB0byBhdm9pZCBtb2R1bGUgYXVnbWVudGF0aW9uIHRlc3RcbiAgICBvcGFjaXR5OiByLFxuICAgIG92ZXJsYXlzOiBuLFxuICAgIC4uLm9cbiAgfSA9IGUsIGkgPSBVbyh0KTtcbiAgcmV0dXJuIHtcbiAgICBwYWxldHRlOiBpLFxuICAgIG9wYWNpdHk6IHtcbiAgICAgIC4uLm1zKGkubW9kZSksXG4gICAgICAuLi5yXG4gICAgfSxcbiAgICBvdmVybGF5czogbiB8fCBocyhpLm1vZGUpLFxuICAgIC4uLm9cbiAgfTtcbn1cbmZ1bmN0aW9uIE5mKGUpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiAhIWVbMF0ubWF0Y2goLyhjc3NWYXJQcmVmaXh8Y29sb3JTY2hlbWVTZWxlY3Rvcnxyb290U2VsZWN0b3J8dHlwb2dyYXBoeXxtaXhpbnN8YnJlYWtwb2ludHN8ZGlyZWN0aW9ufHRyYW5zaXRpb25zKS8pIHx8ICEhZVswXS5tYXRjaCgvc3hDb25maWckLykgfHwgLy8gZW5kcyB3aXRoIHN4Q29uZmlnXG4gIGVbMF0gPT09IFwicGFsZXR0ZVwiICYmICEhKCh0ID0gZVsxXSkgIT0gbnVsbCAmJiB0Lm1hdGNoKC8obW9kZXxjb250cmFzdFRocmVzaG9sZHx0b25hbE9mZnNldCkvKSk7XG59XG5jb25zdCBNZiA9IChlKSA9PiBbLi4uWy4uLkFycmF5KDI1KV0ubWFwKCh0LCByKSA9PiBgLS0ke2UgPyBgJHtlfS1gIDogXCJcIn1vdmVybGF5cy0ke3J9YCksIGAtLSR7ZSA/IGAke2V9LWAgOiBcIlwifXBhbGV0dGUtQXBwQmFyLWRhcmtCZ2AsIGAtLSR7ZSA/IGAke2V9LWAgOiBcIlwifXBhbGV0dGUtQXBwQmFyLWRhcmtDb2xvcmBdLCBJZiA9IChlKSA9PiAodCwgcikgPT4ge1xuICBjb25zdCBuID0gZS5yb290U2VsZWN0b3IgfHwgXCI6cm9vdFwiLCBvID0gZS5jb2xvclNjaGVtZVNlbGVjdG9yO1xuICBsZXQgaSA9IG87XG4gIGlmIChvID09PSBcImNsYXNzXCIgJiYgKGkgPSBcIi4lc1wiKSwgbyA9PT0gXCJkYXRhXCIgJiYgKGkgPSBcIltkYXRhLSVzXVwiKSwgbyAhPSBudWxsICYmIG8uc3RhcnRzV2l0aChcImRhdGEtXCIpICYmICFvLmluY2x1ZGVzKFwiJXNcIikgJiYgKGkgPSBgWyR7b309XCIlc1wiXWApLCBlLmRlZmF1bHRDb2xvclNjaGVtZSA9PT0gdCkge1xuICAgIGlmICh0ID09PSBcImRhcmtcIikge1xuICAgICAgY29uc3QgcyA9IHt9O1xuICAgICAgcmV0dXJuIE1mKGUuY3NzVmFyUHJlZml4KS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgIHNbY10gPSByW2NdLCBkZWxldGUgcltjXTtcbiAgICAgIH0pLCBpID09PSBcIm1lZGlhXCIgPyB7XG4gICAgICAgIFtuXTogcixcbiAgICAgICAgXCJAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiOiB7XG4gICAgICAgICAgW25dOiBzXG4gICAgICAgIH1cbiAgICAgIH0gOiBpID8ge1xuICAgICAgICBbaS5yZXBsYWNlKFwiJXNcIiwgdCldOiBzLFxuICAgICAgICBbYCR7bn0sICR7aS5yZXBsYWNlKFwiJXNcIiwgdCl9YF06IHJcbiAgICAgIH0gOiB7XG4gICAgICAgIFtuXToge1xuICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgLi4uc1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaSAmJiBpICE9PSBcIm1lZGlhXCIpXG4gICAgICByZXR1cm4gYCR7bn0sICR7aS5yZXBsYWNlKFwiJXNcIiwgU3RyaW5nKHQpKX1gO1xuICB9IGVsc2UgaWYgKHQpIHtcbiAgICBpZiAoaSA9PT0gXCJtZWRpYVwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2BAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiAke1N0cmluZyh0KX0pYF06IHtcbiAgICAgICAgICBbbl06IHJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBpZiAoaSlcbiAgICAgIHJldHVybiBpLnJlcGxhY2UoXCIlc1wiLCBTdHJpbmcodCkpO1xuICB9XG4gIHJldHVybiBuO1xufTtcbmZ1bmN0aW9uIF9mKGUsIHQpIHtcbiAgdC5mb3JFYWNoKChyKSA9PiB7XG4gICAgZVtyXSB8fCAoZVtyXSA9IHt9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiAkKGUsIHQsIHIpIHtcbiAgIWVbdF0gJiYgciAmJiAoZVt0XSA9IHIpO1xufVxuZnVuY3Rpb24geXIoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgIT0gXCJzdHJpbmdcIiB8fCAhZS5zdGFydHNXaXRoKFwiaHNsXCIpID8gZSA6IEthKGUpO1xufVxuZnVuY3Rpb24gQ3QoZSwgdCkge1xuICBgJHt0fUNoYW5uZWxgIGluIGUgfHwgKGVbYCR7dH1DaGFubmVsYF0gPSBncih5cihlW3RdKSwgYE1VSTogQ2FuJ3QgY3JlYXRlIFxcYHBhbGV0dGUuJHt0fUNoYW5uZWxcXGAgYmVjYXVzZSBcXGBwYWxldHRlLiR7dH1cXGAgaXMgbm90IG9uZSBvZiB0aGVzZSBmb3JtYXRzOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpLCBjb2xvcigpLlxuVG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nLCB5b3UgbmVlZCB0byBleHBsaWNpdGx5IHByb3ZpZGUgdGhlIFxcYHBhbGV0dGUuJHt0fUNoYW5uZWxcXGAgYXMgYSBzdHJpbmcgKGluIHJnYiBmb3JtYXQsIGZvciBleGFtcGxlIFwiMTIgMTIgMTJcIikgb3IgdW5kZWZpbmVkIGlmIHlvdSB3YW50IHRvIHJlbW92ZSB0aGUgY2hhbm5lbCB0b2tlbi5gKSk7XG59XG5mdW5jdGlvbiBqZihlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcIm51bWJlclwiID8gYCR7ZX1weGAgOiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiB8fCBBcnJheS5pc0FycmF5KGUpID8gZSA6IFwiOHB4XCI7XG59XG5jb25zdCBwdCA9IChlKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGUoKTtcbiAgfSBjYXRjaCB7XG4gIH1cbn0sIERmID0gKGUgPSBcIm11aVwiKSA9PiBvZihlKTtcbmZ1bmN0aW9uIHJvKGUsIHQsIHIsIG4pIHtcbiAgaWYgKCF0KVxuICAgIHJldHVybjtcbiAgdCA9IHQgPT09ICEwID8ge30gOiB0O1xuICBjb25zdCBvID0gbiA9PT0gXCJkYXJrXCIgPyBcImRhcmtcIiA6IFwibGlnaHRcIjtcbiAgaWYgKCFyKSB7XG4gICAgZVtuXSA9IEFmKHtcbiAgICAgIC4uLnQsXG4gICAgICBwYWxldHRlOiB7XG4gICAgICAgIG1vZGU6IG8sXG4gICAgICAgIC4uLnQgPT0gbnVsbCA/IHZvaWQgMCA6IHQucGFsZXR0ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7XG4gICAgcGFsZXR0ZTogaSxcbiAgICAuLi5zXG4gIH0gPSBmbyh7XG4gICAgLi4ucixcbiAgICBwYWxldHRlOiB7XG4gICAgICBtb2RlOiBvLFxuICAgICAgLi4udCA9PSBudWxsID8gdm9pZCAwIDogdC5wYWxldHRlXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVbbl0gPSB7XG4gICAgLi4udCxcbiAgICBwYWxldHRlOiBpLFxuICAgIG9wYWNpdHk6IHtcbiAgICAgIC4uLm1zKG8pLFxuICAgICAgLi4udCA9PSBudWxsID8gdm9pZCAwIDogdC5vcGFjaXR5XG4gICAgfSxcbiAgICBvdmVybGF5czogKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub3ZlcmxheXMpIHx8IGhzKG8pXG4gIH0sIHM7XG59XG5mdW5jdGlvbiBMZihlID0ge30sIC4uLnQpIHtcbiAgY29uc3Qge1xuICAgIGNvbG9yU2NoZW1lczogciA9IHtcbiAgICAgIGxpZ2h0OiAhMFxuICAgIH0sXG4gICAgZGVmYXVsdENvbG9yU2NoZW1lOiBuLFxuICAgIGRpc2FibGVDc3NDb2xvclNjaGVtZTogbyA9ICExLFxuICAgIGNzc1ZhclByZWZpeDogaSA9IFwibXVpXCIsXG4gICAgc2hvdWxkU2tpcEdlbmVyYXRpbmdWYXI6IHMgPSBOZixcbiAgICBjb2xvclNjaGVtZVNlbGVjdG9yOiBjID0gci5saWdodCAmJiByLmRhcmsgPyBcIm1lZGlhXCIgOiB2b2lkIDAsXG4gICAgcm9vdFNlbGVjdG9yOiBsID0gXCI6cm9vdFwiLFxuICAgIC4uLnVcbiAgfSA9IGUsIHAgPSBPYmplY3Qua2V5cyhyKVswXSwgbSA9IG4gfHwgKHIubGlnaHQgJiYgcCAhPT0gXCJsaWdodFwiID8gXCJsaWdodFwiIDogcCksIGcgPSBEZihpKSwge1xuICAgIFttXTogeCxcbiAgICBsaWdodDogeSxcbiAgICBkYXJrOiBmLFxuICAgIC4uLlNcbiAgfSA9IHIsIEUgPSB7XG4gICAgLi4uU1xuICB9O1xuICBsZXQgUCA9IHg7XG4gIGlmICgobSA9PT0gXCJkYXJrXCIgJiYgIShcImRhcmtcIiBpbiByKSB8fCBtID09PSBcImxpZ2h0XCIgJiYgIShcImxpZ2h0XCIgaW4gcikpICYmIChQID0gITApLCAhUClcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gYE1VSTogVGhlIFxcYGNvbG9yU2NoZW1lcy4ke219XFxgIG9wdGlvbiBpcyBlaXRoZXIgbWlzc2luZyBvciBpbnZhbGlkLmAgOiBrdCgyMSwgbSkpO1xuICBjb25zdCBUID0gcm8oRSwgUCwgdSwgbSk7XG4gIHkgJiYgIUUubGlnaHQgJiYgcm8oRSwgeSwgdm9pZCAwLCBcImxpZ2h0XCIpLCBmICYmICFFLmRhcmsgJiYgcm8oRSwgZiwgdm9pZCAwLCBcImRhcmtcIik7XG4gIGxldCBiID0ge1xuICAgIGRlZmF1bHRDb2xvclNjaGVtZTogbSxcbiAgICAuLi5ULFxuICAgIGNzc1ZhclByZWZpeDogaSxcbiAgICBjb2xvclNjaGVtZVNlbGVjdG9yOiBjLFxuICAgIHJvb3RTZWxlY3RvcjogbCxcbiAgICBnZXRDc3NWYXI6IGcsXG4gICAgY29sb3JTY2hlbWVzOiBFLFxuICAgIGZvbnQ6IHtcbiAgICAgIC4uLnlmKFQudHlwb2dyYXBoeSksXG4gICAgICAuLi5ULmZvbnRcbiAgICB9LFxuICAgIHNwYWNpbmc6IGpmKHUuc3BhY2luZylcbiAgfTtcbiAgT2JqZWN0LmtleXMoYi5jb2xvclNjaGVtZXMpLmZvckVhY2goKEIpID0+IHtcbiAgICBjb25zdCBkID0gYi5jb2xvclNjaGVtZXNbQl0ucGFsZXR0ZSwgQSA9IChEKSA9PiB7XG4gICAgICBjb25zdCBqID0gRC5zcGxpdChcIi1cIiksIFcgPSBqWzFdLCB6ID0galsyXTtcbiAgICAgIHJldHVybiBnKEQsIGRbV11bel0pO1xuICAgIH07XG4gICAgaWYgKGQubW9kZSA9PT0gXCJsaWdodFwiICYmICgkKGQuY29tbW9uLCBcImJhY2tncm91bmRcIiwgXCIjZmZmXCIpLCAkKGQuY29tbW9uLCBcIm9uQmFja2dyb3VuZFwiLCBcIiMwMDBcIikpLCBkLm1vZGUgPT09IFwiZGFya1wiICYmICgkKGQuY29tbW9uLCBcImJhY2tncm91bmRcIiwgXCIjMDAwXCIpLCAkKGQuY29tbW9uLCBcIm9uQmFja2dyb3VuZFwiLCBcIiNmZmZcIikpLCBfZihkLCBbXCJBbGVydFwiLCBcIkFwcEJhclwiLCBcIkF2YXRhclwiLCBcIkJ1dHRvblwiLCBcIkNoaXBcIiwgXCJGaWxsZWRJbnB1dFwiLCBcIkxpbmVhclByb2dyZXNzXCIsIFwiU2tlbGV0b25cIiwgXCJTbGlkZXJcIiwgXCJTbmFja2JhckNvbnRlbnRcIiwgXCJTcGVlZERpYWxBY3Rpb25cIiwgXCJTdGVwQ29ubmVjdG9yXCIsIFwiU3RlcENvbnRlbnRcIiwgXCJTd2l0Y2hcIiwgXCJUYWJsZUNlbGxcIiwgXCJUb29sdGlwXCJdKSwgZC5tb2RlID09PSBcImxpZ2h0XCIpIHtcbiAgICAgICQoZC5BbGVydCwgXCJlcnJvckNvbG9yXCIsIENlKGQuZXJyb3IubGlnaHQsIDAuNikpLCAkKGQuQWxlcnQsIFwiaW5mb0NvbG9yXCIsIENlKGQuaW5mby5saWdodCwgMC42KSksICQoZC5BbGVydCwgXCJzdWNjZXNzQ29sb3JcIiwgQ2UoZC5zdWNjZXNzLmxpZ2h0LCAwLjYpKSwgJChkLkFsZXJ0LCBcIndhcm5pbmdDb2xvclwiLCBDZShkLndhcm5pbmcubGlnaHQsIDAuNikpLCAkKGQuQWxlcnQsIFwiZXJyb3JGaWxsZWRCZ1wiLCBBKFwicGFsZXR0ZS1lcnJvci1tYWluXCIpKSwgJChkLkFsZXJ0LCBcImluZm9GaWxsZWRCZ1wiLCBBKFwicGFsZXR0ZS1pbmZvLW1haW5cIikpLCAkKGQuQWxlcnQsIFwic3VjY2Vzc0ZpbGxlZEJnXCIsIEEoXCJwYWxldHRlLXN1Y2Nlc3MtbWFpblwiKSksICQoZC5BbGVydCwgXCJ3YXJuaW5nRmlsbGVkQmdcIiwgQShcInBhbGV0dGUtd2FybmluZy1tYWluXCIpKSwgJChkLkFsZXJ0LCBcImVycm9yRmlsbGVkQ29sb3JcIiwgcHQoKCkgPT4gZC5nZXRDb250cmFzdFRleHQoZC5lcnJvci5tYWluKSkpLCAkKGQuQWxlcnQsIFwiaW5mb0ZpbGxlZENvbG9yXCIsIHB0KCgpID0+IGQuZ2V0Q29udHJhc3RUZXh0KGQuaW5mby5tYWluKSkpLCAkKGQuQWxlcnQsIFwic3VjY2Vzc0ZpbGxlZENvbG9yXCIsIHB0KCgpID0+IGQuZ2V0Q29udHJhc3RUZXh0KGQuc3VjY2Vzcy5tYWluKSkpLCAkKGQuQWxlcnQsIFwid2FybmluZ0ZpbGxlZENvbG9yXCIsIHB0KCgpID0+IGQuZ2V0Q29udHJhc3RUZXh0KGQud2FybmluZy5tYWluKSkpLCAkKGQuQWxlcnQsIFwiZXJyb3JTdGFuZGFyZEJnXCIsIFRlKGQuZXJyb3IubGlnaHQsIDAuOSkpLCAkKGQuQWxlcnQsIFwiaW5mb1N0YW5kYXJkQmdcIiwgVGUoZC5pbmZvLmxpZ2h0LCAwLjkpKSwgJChkLkFsZXJ0LCBcInN1Y2Nlc3NTdGFuZGFyZEJnXCIsIFRlKGQuc3VjY2Vzcy5saWdodCwgMC45KSksICQoZC5BbGVydCwgXCJ3YXJuaW5nU3RhbmRhcmRCZ1wiLCBUZShkLndhcm5pbmcubGlnaHQsIDAuOSkpLCAkKGQuQWxlcnQsIFwiZXJyb3JJY29uQ29sb3JcIiwgQShcInBhbGV0dGUtZXJyb3ItbWFpblwiKSksICQoZC5BbGVydCwgXCJpbmZvSWNvbkNvbG9yXCIsIEEoXCJwYWxldHRlLWluZm8tbWFpblwiKSksICQoZC5BbGVydCwgXCJzdWNjZXNzSWNvbkNvbG9yXCIsIEEoXCJwYWxldHRlLXN1Y2Nlc3MtbWFpblwiKSksICQoZC5BbGVydCwgXCJ3YXJuaW5nSWNvbkNvbG9yXCIsIEEoXCJwYWxldHRlLXdhcm5pbmctbWFpblwiKSksICQoZC5BcHBCYXIsIFwiZGVmYXVsdEJnXCIsIEEoXCJwYWxldHRlLWdyZXktMTAwXCIpKSwgJChkLkF2YXRhciwgXCJkZWZhdWx0QmdcIiwgQShcInBhbGV0dGUtZ3JleS00MDBcIikpLCAkKGQuQnV0dG9uLCBcImluaGVyaXRDb250YWluZWRCZ1wiLCBBKFwicGFsZXR0ZS1ncmV5LTMwMFwiKSksICQoZC5CdXR0b24sIFwiaW5oZXJpdENvbnRhaW5lZEhvdmVyQmdcIiwgQShcInBhbGV0dGUtZ3JleS1BMTAwXCIpKSwgJChkLkNoaXAsIFwiZGVmYXVsdEJvcmRlclwiLCBBKFwicGFsZXR0ZS1ncmV5LTQwMFwiKSksICQoZC5DaGlwLCBcImRlZmF1bHRBdmF0YXJDb2xvclwiLCBBKFwicGFsZXR0ZS1ncmV5LTcwMFwiKSksICQoZC5DaGlwLCBcImRlZmF1bHRJY29uQ29sb3JcIiwgQShcInBhbGV0dGUtZ3JleS03MDBcIikpLCAkKGQuRmlsbGVkSW5wdXQsIFwiYmdcIiwgXCJyZ2JhKDAsIDAsIDAsIDAuMDYpXCIpLCAkKGQuRmlsbGVkSW5wdXQsIFwiaG92ZXJCZ1wiLCBcInJnYmEoMCwgMCwgMCwgMC4wOSlcIiksICQoZC5GaWxsZWRJbnB1dCwgXCJkaXNhYmxlZEJnXCIsIFwicmdiYSgwLCAwLCAwLCAwLjEyKVwiKSwgJChkLkxpbmVhclByb2dyZXNzLCBcInByaW1hcnlCZ1wiLCBUZShkLnByaW1hcnkubWFpbiwgMC42MikpLCAkKGQuTGluZWFyUHJvZ3Jlc3MsIFwic2Vjb25kYXJ5QmdcIiwgVGUoZC5zZWNvbmRhcnkubWFpbiwgMC42MikpLCAkKGQuTGluZWFyUHJvZ3Jlc3MsIFwiZXJyb3JCZ1wiLCBUZShkLmVycm9yLm1haW4sIDAuNjIpKSwgJChkLkxpbmVhclByb2dyZXNzLCBcImluZm9CZ1wiLCBUZShkLmluZm8ubWFpbiwgMC42MikpLCAkKGQuTGluZWFyUHJvZ3Jlc3MsIFwic3VjY2Vzc0JnXCIsIFRlKGQuc3VjY2Vzcy5tYWluLCAwLjYyKSksICQoZC5MaW5lYXJQcm9ncmVzcywgXCJ3YXJuaW5nQmdcIiwgVGUoZC53YXJuaW5nLm1haW4sIDAuNjIpKSwgJChkLlNrZWxldG9uLCBcImJnXCIsIGByZ2JhKCR7QShcInBhbGV0dGUtdGV4dC1wcmltYXJ5Q2hhbm5lbFwiKX0gLyAwLjExKWApLCAkKGQuU2xpZGVyLCBcInByaW1hcnlUcmFja1wiLCBUZShkLnByaW1hcnkubWFpbiwgMC42MikpLCAkKGQuU2xpZGVyLCBcInNlY29uZGFyeVRyYWNrXCIsIFRlKGQuc2Vjb25kYXJ5Lm1haW4sIDAuNjIpKSwgJChkLlNsaWRlciwgXCJlcnJvclRyYWNrXCIsIFRlKGQuZXJyb3IubWFpbiwgMC42MikpLCAkKGQuU2xpZGVyLCBcImluZm9UcmFja1wiLCBUZShkLmluZm8ubWFpbiwgMC42MikpLCAkKGQuU2xpZGVyLCBcInN1Y2Nlc3NUcmFja1wiLCBUZShkLnN1Y2Nlc3MubWFpbiwgMC42MikpLCAkKGQuU2xpZGVyLCBcIndhcm5pbmdUcmFja1wiLCBUZShkLndhcm5pbmcubWFpbiwgMC42MikpO1xuICAgICAgY29uc3QgRCA9IEpyKGQuYmFja2dyb3VuZC5kZWZhdWx0LCAwLjgpO1xuICAgICAgJChkLlNuYWNrYmFyQ29udGVudCwgXCJiZ1wiLCBEKSwgJChkLlNuYWNrYmFyQ29udGVudCwgXCJjb2xvclwiLCBwdCgoKSA9PiBkLmdldENvbnRyYXN0VGV4dChEKSkpLCAkKGQuU3BlZWREaWFsQWN0aW9uLCBcImZhYkhvdmVyQmdcIiwgSnIoZC5iYWNrZ3JvdW5kLnBhcGVyLCAwLjE1KSksICQoZC5TdGVwQ29ubmVjdG9yLCBcImJvcmRlclwiLCBBKFwicGFsZXR0ZS1ncmV5LTQwMFwiKSksICQoZC5TdGVwQ29udGVudCwgXCJib3JkZXJcIiwgQShcInBhbGV0dGUtZ3JleS00MDBcIikpLCAkKGQuU3dpdGNoLCBcImRlZmF1bHRDb2xvclwiLCBBKFwicGFsZXR0ZS1jb21tb24td2hpdGVcIikpLCAkKGQuU3dpdGNoLCBcImRlZmF1bHREaXNhYmxlZENvbG9yXCIsIEEoXCJwYWxldHRlLWdyZXktMTAwXCIpKSwgJChkLlN3aXRjaCwgXCJwcmltYXJ5RGlzYWJsZWRDb2xvclwiLCBUZShkLnByaW1hcnkubWFpbiwgMC42MikpLCAkKGQuU3dpdGNoLCBcInNlY29uZGFyeURpc2FibGVkQ29sb3JcIiwgVGUoZC5zZWNvbmRhcnkubWFpbiwgMC42MikpLCAkKGQuU3dpdGNoLCBcImVycm9yRGlzYWJsZWRDb2xvclwiLCBUZShkLmVycm9yLm1haW4sIDAuNjIpKSwgJChkLlN3aXRjaCwgXCJpbmZvRGlzYWJsZWRDb2xvclwiLCBUZShkLmluZm8ubWFpbiwgMC42MikpLCAkKGQuU3dpdGNoLCBcInN1Y2Nlc3NEaXNhYmxlZENvbG9yXCIsIFRlKGQuc3VjY2Vzcy5tYWluLCAwLjYyKSksICQoZC5Td2l0Y2gsIFwid2FybmluZ0Rpc2FibGVkQ29sb3JcIiwgVGUoZC53YXJuaW5nLm1haW4sIDAuNjIpKSwgJChkLlRhYmxlQ2VsbCwgXCJib3JkZXJcIiwgVGUoWHIoZC5kaXZpZGVyLCAxKSwgMC44OCkpLCAkKGQuVG9vbHRpcCwgXCJiZ1wiLCBYcihkLmdyZXlbNzAwXSwgMC45MikpO1xuICAgIH1cbiAgICBpZiAoZC5tb2RlID09PSBcImRhcmtcIikge1xuICAgICAgJChkLkFsZXJ0LCBcImVycm9yQ29sb3JcIiwgVGUoZC5lcnJvci5saWdodCwgMC42KSksICQoZC5BbGVydCwgXCJpbmZvQ29sb3JcIiwgVGUoZC5pbmZvLmxpZ2h0LCAwLjYpKSwgJChkLkFsZXJ0LCBcInN1Y2Nlc3NDb2xvclwiLCBUZShkLnN1Y2Nlc3MubGlnaHQsIDAuNikpLCAkKGQuQWxlcnQsIFwid2FybmluZ0NvbG9yXCIsIFRlKGQud2FybmluZy5saWdodCwgMC42KSksICQoZC5BbGVydCwgXCJlcnJvckZpbGxlZEJnXCIsIEEoXCJwYWxldHRlLWVycm9yLWRhcmtcIikpLCAkKGQuQWxlcnQsIFwiaW5mb0ZpbGxlZEJnXCIsIEEoXCJwYWxldHRlLWluZm8tZGFya1wiKSksICQoZC5BbGVydCwgXCJzdWNjZXNzRmlsbGVkQmdcIiwgQShcInBhbGV0dGUtc3VjY2Vzcy1kYXJrXCIpKSwgJChkLkFsZXJ0LCBcIndhcm5pbmdGaWxsZWRCZ1wiLCBBKFwicGFsZXR0ZS13YXJuaW5nLWRhcmtcIikpLCAkKGQuQWxlcnQsIFwiZXJyb3JGaWxsZWRDb2xvclwiLCBwdCgoKSA9PiBkLmdldENvbnRyYXN0VGV4dChkLmVycm9yLmRhcmspKSksICQoZC5BbGVydCwgXCJpbmZvRmlsbGVkQ29sb3JcIiwgcHQoKCkgPT4gZC5nZXRDb250cmFzdFRleHQoZC5pbmZvLmRhcmspKSksICQoZC5BbGVydCwgXCJzdWNjZXNzRmlsbGVkQ29sb3JcIiwgcHQoKCkgPT4gZC5nZXRDb250cmFzdFRleHQoZC5zdWNjZXNzLmRhcmspKSksICQoZC5BbGVydCwgXCJ3YXJuaW5nRmlsbGVkQ29sb3JcIiwgcHQoKCkgPT4gZC5nZXRDb250cmFzdFRleHQoZC53YXJuaW5nLmRhcmspKSksICQoZC5BbGVydCwgXCJlcnJvclN0YW5kYXJkQmdcIiwgQ2UoZC5lcnJvci5saWdodCwgMC45KSksICQoZC5BbGVydCwgXCJpbmZvU3RhbmRhcmRCZ1wiLCBDZShkLmluZm8ubGlnaHQsIDAuOSkpLCAkKGQuQWxlcnQsIFwic3VjY2Vzc1N0YW5kYXJkQmdcIiwgQ2UoZC5zdWNjZXNzLmxpZ2h0LCAwLjkpKSwgJChkLkFsZXJ0LCBcIndhcm5pbmdTdGFuZGFyZEJnXCIsIENlKGQud2FybmluZy5saWdodCwgMC45KSksICQoZC5BbGVydCwgXCJlcnJvckljb25Db2xvclwiLCBBKFwicGFsZXR0ZS1lcnJvci1tYWluXCIpKSwgJChkLkFsZXJ0LCBcImluZm9JY29uQ29sb3JcIiwgQShcInBhbGV0dGUtaW5mby1tYWluXCIpKSwgJChkLkFsZXJ0LCBcInN1Y2Nlc3NJY29uQ29sb3JcIiwgQShcInBhbGV0dGUtc3VjY2Vzcy1tYWluXCIpKSwgJChkLkFsZXJ0LCBcIndhcm5pbmdJY29uQ29sb3JcIiwgQShcInBhbGV0dGUtd2FybmluZy1tYWluXCIpKSwgJChkLkFwcEJhciwgXCJkZWZhdWx0QmdcIiwgQShcInBhbGV0dGUtZ3JleS05MDBcIikpLCAkKGQuQXBwQmFyLCBcImRhcmtCZ1wiLCBBKFwicGFsZXR0ZS1iYWNrZ3JvdW5kLXBhcGVyXCIpKSwgJChkLkFwcEJhciwgXCJkYXJrQ29sb3JcIiwgQShcInBhbGV0dGUtdGV4dC1wcmltYXJ5XCIpKSwgJChkLkF2YXRhciwgXCJkZWZhdWx0QmdcIiwgQShcInBhbGV0dGUtZ3JleS02MDBcIikpLCAkKGQuQnV0dG9uLCBcImluaGVyaXRDb250YWluZWRCZ1wiLCBBKFwicGFsZXR0ZS1ncmV5LTgwMFwiKSksICQoZC5CdXR0b24sIFwiaW5oZXJpdENvbnRhaW5lZEhvdmVyQmdcIiwgQShcInBhbGV0dGUtZ3JleS03MDBcIikpLCAkKGQuQ2hpcCwgXCJkZWZhdWx0Qm9yZGVyXCIsIEEoXCJwYWxldHRlLWdyZXktNzAwXCIpKSwgJChkLkNoaXAsIFwiZGVmYXVsdEF2YXRhckNvbG9yXCIsIEEoXCJwYWxldHRlLWdyZXktMzAwXCIpKSwgJChkLkNoaXAsIFwiZGVmYXVsdEljb25Db2xvclwiLCBBKFwicGFsZXR0ZS1ncmV5LTMwMFwiKSksICQoZC5GaWxsZWRJbnB1dCwgXCJiZ1wiLCBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wOSlcIiksICQoZC5GaWxsZWRJbnB1dCwgXCJob3ZlckJnXCIsIFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEzKVwiKSwgJChkLkZpbGxlZElucHV0LCBcImRpc2FibGVkQmdcIiwgXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpXCIpLCAkKGQuTGluZWFyUHJvZ3Jlc3MsIFwicHJpbWFyeUJnXCIsIENlKGQucHJpbWFyeS5tYWluLCAwLjUpKSwgJChkLkxpbmVhclByb2dyZXNzLCBcInNlY29uZGFyeUJnXCIsIENlKGQuc2Vjb25kYXJ5Lm1haW4sIDAuNSkpLCAkKGQuTGluZWFyUHJvZ3Jlc3MsIFwiZXJyb3JCZ1wiLCBDZShkLmVycm9yLm1haW4sIDAuNSkpLCAkKGQuTGluZWFyUHJvZ3Jlc3MsIFwiaW5mb0JnXCIsIENlKGQuaW5mby5tYWluLCAwLjUpKSwgJChkLkxpbmVhclByb2dyZXNzLCBcInN1Y2Nlc3NCZ1wiLCBDZShkLnN1Y2Nlc3MubWFpbiwgMC41KSksICQoZC5MaW5lYXJQcm9ncmVzcywgXCJ3YXJuaW5nQmdcIiwgQ2UoZC53YXJuaW5nLm1haW4sIDAuNSkpLCAkKGQuU2tlbGV0b24sIFwiYmdcIiwgYHJnYmEoJHtBKFwicGFsZXR0ZS10ZXh0LXByaW1hcnlDaGFubmVsXCIpfSAvIDAuMTMpYCksICQoZC5TbGlkZXIsIFwicHJpbWFyeVRyYWNrXCIsIENlKGQucHJpbWFyeS5tYWluLCAwLjUpKSwgJChkLlNsaWRlciwgXCJzZWNvbmRhcnlUcmFja1wiLCBDZShkLnNlY29uZGFyeS5tYWluLCAwLjUpKSwgJChkLlNsaWRlciwgXCJlcnJvclRyYWNrXCIsIENlKGQuZXJyb3IubWFpbiwgMC41KSksICQoZC5TbGlkZXIsIFwiaW5mb1RyYWNrXCIsIENlKGQuaW5mby5tYWluLCAwLjUpKSwgJChkLlNsaWRlciwgXCJzdWNjZXNzVHJhY2tcIiwgQ2UoZC5zdWNjZXNzLm1haW4sIDAuNSkpLCAkKGQuU2xpZGVyLCBcIndhcm5pbmdUcmFja1wiLCBDZShkLndhcm5pbmcubWFpbiwgMC41KSk7XG4gICAgICBjb25zdCBEID0gSnIoZC5iYWNrZ3JvdW5kLmRlZmF1bHQsIDAuOTgpO1xuICAgICAgJChkLlNuYWNrYmFyQ29udGVudCwgXCJiZ1wiLCBEKSwgJChkLlNuYWNrYmFyQ29udGVudCwgXCJjb2xvclwiLCBwdCgoKSA9PiBkLmdldENvbnRyYXN0VGV4dChEKSkpLCAkKGQuU3BlZWREaWFsQWN0aW9uLCBcImZhYkhvdmVyQmdcIiwgSnIoZC5iYWNrZ3JvdW5kLnBhcGVyLCAwLjE1KSksICQoZC5TdGVwQ29ubmVjdG9yLCBcImJvcmRlclwiLCBBKFwicGFsZXR0ZS1ncmV5LTYwMFwiKSksICQoZC5TdGVwQ29udGVudCwgXCJib3JkZXJcIiwgQShcInBhbGV0dGUtZ3JleS02MDBcIikpLCAkKGQuU3dpdGNoLCBcImRlZmF1bHRDb2xvclwiLCBBKFwicGFsZXR0ZS1ncmV5LTMwMFwiKSksICQoZC5Td2l0Y2gsIFwiZGVmYXVsdERpc2FibGVkQ29sb3JcIiwgQShcInBhbGV0dGUtZ3JleS02MDBcIikpLCAkKGQuU3dpdGNoLCBcInByaW1hcnlEaXNhYmxlZENvbG9yXCIsIENlKGQucHJpbWFyeS5tYWluLCAwLjU1KSksICQoZC5Td2l0Y2gsIFwic2Vjb25kYXJ5RGlzYWJsZWRDb2xvclwiLCBDZShkLnNlY29uZGFyeS5tYWluLCAwLjU1KSksICQoZC5Td2l0Y2gsIFwiZXJyb3JEaXNhYmxlZENvbG9yXCIsIENlKGQuZXJyb3IubWFpbiwgMC41NSkpLCAkKGQuU3dpdGNoLCBcImluZm9EaXNhYmxlZENvbG9yXCIsIENlKGQuaW5mby5tYWluLCAwLjU1KSksICQoZC5Td2l0Y2gsIFwic3VjY2Vzc0Rpc2FibGVkQ29sb3JcIiwgQ2UoZC5zdWNjZXNzLm1haW4sIDAuNTUpKSwgJChkLlN3aXRjaCwgXCJ3YXJuaW5nRGlzYWJsZWRDb2xvclwiLCBDZShkLndhcm5pbmcubWFpbiwgMC41NSkpLCAkKGQuVGFibGVDZWxsLCBcImJvcmRlclwiLCBDZShYcihkLmRpdmlkZXIsIDEpLCAwLjY4KSksICQoZC5Ub29sdGlwLCBcImJnXCIsIFhyKGQuZ3JleVs3MDBdLCAwLjkyKSk7XG4gICAgfVxuICAgIEN0KGQuYmFja2dyb3VuZCwgXCJkZWZhdWx0XCIpLCBDdChkLmJhY2tncm91bmQsIFwicGFwZXJcIiksIEN0KGQuY29tbW9uLCBcImJhY2tncm91bmRcIiksIEN0KGQuY29tbW9uLCBcIm9uQmFja2dyb3VuZFwiKSwgQ3QoZCwgXCJkaXZpZGVyXCIpLCBPYmplY3Qua2V5cyhkKS5mb3JFYWNoKChEKSA9PiB7XG4gICAgICBjb25zdCBqID0gZFtEXTtcbiAgICAgIEQgIT09IFwidG9uYWxPZmZzZXRcIiAmJiBqICYmIHR5cGVvZiBqID09IFwib2JqZWN0XCIgJiYgKGoubWFpbiAmJiAkKGRbRF0sIFwibWFpbkNoYW5uZWxcIiwgZ3IoeXIoai5tYWluKSkpLCBqLmxpZ2h0ICYmICQoZFtEXSwgXCJsaWdodENoYW5uZWxcIiwgZ3IoeXIoai5saWdodCkpKSwgai5kYXJrICYmICQoZFtEXSwgXCJkYXJrQ2hhbm5lbFwiLCBncih5cihqLmRhcmspKSksIGouY29udHJhc3RUZXh0ICYmICQoZFtEXSwgXCJjb250cmFzdFRleHRDaGFubmVsXCIsIGdyKHlyKGouY29udHJhc3RUZXh0KSkpLCBEID09PSBcInRleHRcIiAmJiAoQ3QoZFtEXSwgXCJwcmltYXJ5XCIpLCBDdChkW0RdLCBcInNlY29uZGFyeVwiKSksIEQgPT09IFwiYWN0aW9uXCIgJiYgKGouYWN0aXZlICYmIEN0KGRbRF0sIFwiYWN0aXZlXCIpLCBqLnNlbGVjdGVkICYmIEN0KGRbRF0sIFwic2VsZWN0ZWRcIikpKTtcbiAgICB9KTtcbiAgfSksIGIgPSB0LnJlZHVjZSgoQiwgZCkgPT4gdHQoQiwgZCksIGIpO1xuICBjb25zdCBoID0ge1xuICAgIHByZWZpeDogaSxcbiAgICBkaXNhYmxlQ3NzQ29sb3JTY2hlbWU6IG8sXG4gICAgc2hvdWxkU2tpcEdlbmVyYXRpbmdWYXI6IHMsXG4gICAgZ2V0U2VsZWN0b3I6IElmKGIpXG4gIH0sIHtcbiAgICB2YXJzOiB3LFxuICAgIGdlbmVyYXRlVGhlbWVWYXJzOiBrLFxuICAgIGdlbmVyYXRlU3R5bGVTaGVldHM6IExcbiAgfSA9IGNmKGIsIGgpO1xuICByZXR1cm4gYi52YXJzID0gdywgT2JqZWN0LmVudHJpZXMoYi5jb2xvclNjaGVtZXNbYi5kZWZhdWx0Q29sb3JTY2hlbWVdKS5mb3JFYWNoKChbQiwgZF0pID0+IHtcbiAgICBiW0JdID0gZDtcbiAgfSksIGIuZ2VuZXJhdGVUaGVtZVZhcnMgPSBrLCBiLmdlbmVyYXRlU3R5bGVTaGVldHMgPSBMLCBiLmdlbmVyYXRlU3BhY2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCYSh1LnNwYWNpbmcsIGtvKHRoaXMpKTtcbiAgfSwgYi5nZXRDb2xvclNjaGVtZVNlbGVjdG9yID0gbGYoYyksIGIuc3BhY2luZyA9IGIuZ2VuZXJhdGVTcGFjaW5nKCksIGIuc2hvdWxkU2tpcEdlbmVyYXRpbmdWYXIgPSBzLCBiLnVuc3RhYmxlX3N4Q29uZmlnID0ge1xuICAgIC4uLkRyLFxuICAgIC4uLnUgPT0gbnVsbCA/IHZvaWQgMCA6IHUudW5zdGFibGVfc3hDb25maWdcbiAgfSwgYi51bnN0YWJsZV9zeCA9IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gQXQoe1xuICAgICAgc3g6IGQsXG4gICAgICB0aGVtZTogdGhpc1xuICAgIH0pO1xuICB9LCBiLnRvUnVudGltZVNvdXJjZSA9IHBzLCBiO1xufVxuZnVuY3Rpb24gbmEoZSwgdCwgcikge1xuICBlLmNvbG9yU2NoZW1lcyAmJiByICYmIChlLmNvbG9yU2NoZW1lc1t0XSA9IHtcbiAgICAuLi5yICE9PSAhMCAmJiByLFxuICAgIHBhbGV0dGU6IFVvKHtcbiAgICAgIC4uLnIgPT09ICEwID8ge30gOiByLnBhbGV0dGUsXG4gICAgICBtb2RlOiB0XG4gICAgfSlcbiAgICAvLyBjYXN0IHR5cGUgdG8gc2tpcCBtb2R1bGUgYXVnbWVudGF0aW9uIHRlc3RcbiAgfSk7XG59XG5mdW5jdGlvbiBGbihlID0ge30sIC4uLnQpIHtcbiAgY29uc3Qge1xuICAgIHBhbGV0dGU6IHIsXG4gICAgY3NzVmFyaWFibGVzOiBuID0gITEsXG4gICAgY29sb3JTY2hlbWVzOiBvID0gciA/IHZvaWQgMCA6IHtcbiAgICAgIGxpZ2h0OiAhMFxuICAgIH0sXG4gICAgZGVmYXVsdENvbG9yU2NoZW1lOiBpID0gciA9PSBudWxsID8gdm9pZCAwIDogci5tb2RlLFxuICAgIC4uLnNcbiAgfSA9IGUsIGMgPSBpIHx8IFwibGlnaHRcIiwgbCA9IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG9bY10sIHUgPSB7XG4gICAgLi4ubyxcbiAgICAuLi5yID8ge1xuICAgICAgW2NdOiB7XG4gICAgICAgIC4uLnR5cGVvZiBsICE9IFwiYm9vbGVhblwiICYmIGwsXG4gICAgICAgIHBhbGV0dGU6IHJcbiAgICAgIH1cbiAgICB9IDogdm9pZCAwXG4gIH07XG4gIGlmIChuID09PSAhMSkge1xuICAgIGlmICghKFwiY29sb3JTY2hlbWVzXCIgaW4gZSkpXG4gICAgICByZXR1cm4gZm8oZSwgLi4udCk7XG4gICAgbGV0IHAgPSByO1xuICAgIFwicGFsZXR0ZVwiIGluIGUgfHwgdVtjXSAmJiAodVtjXSAhPT0gITAgPyBwID0gdVtjXS5wYWxldHRlIDogYyA9PT0gXCJkYXJrXCIgJiYgKHAgPSB7XG4gICAgICBtb2RlOiBcImRhcmtcIlxuICAgIH0pKTtcbiAgICBjb25zdCBtID0gZm8oe1xuICAgICAgLi4uZSxcbiAgICAgIHBhbGV0dGU6IHBcbiAgICB9LCAuLi50KTtcbiAgICByZXR1cm4gbS5kZWZhdWx0Q29sb3JTY2hlbWUgPSBjLCBtLmNvbG9yU2NoZW1lcyA9IHUsIG0ucGFsZXR0ZS5tb2RlID09PSBcImxpZ2h0XCIgJiYgKG0uY29sb3JTY2hlbWVzLmxpZ2h0ID0ge1xuICAgICAgLi4udS5saWdodCAhPT0gITAgJiYgdS5saWdodCxcbiAgICAgIHBhbGV0dGU6IG0ucGFsZXR0ZVxuICAgIH0sIG5hKG0sIFwiZGFya1wiLCB1LmRhcmspKSwgbS5wYWxldHRlLm1vZGUgPT09IFwiZGFya1wiICYmIChtLmNvbG9yU2NoZW1lcy5kYXJrID0ge1xuICAgICAgLi4udS5kYXJrICE9PSAhMCAmJiB1LmRhcmssXG4gICAgICBwYWxldHRlOiBtLnBhbGV0dGVcbiAgICB9LCBuYShtLCBcImxpZ2h0XCIsIHUubGlnaHQpKSwgbTtcbiAgfVxuICByZXR1cm4gIXIgJiYgIShcImxpZ2h0XCIgaW4gdSkgJiYgYyA9PT0gXCJsaWdodFwiICYmICh1LmxpZ2h0ID0gITApLCBMZih7XG4gICAgLi4ucyxcbiAgICBjb2xvclNjaGVtZXM6IHUsXG4gICAgZGVmYXVsdENvbG9yU2NoZW1lOiBjLFxuICAgIC4uLnR5cGVvZiBuICE9IFwiYm9vbGVhblwiICYmIG5cbiAgfSwgLi4udCk7XG59XG5jb25zdCBncyA9IEZuKCk7XG5mdW5jdGlvbiBMcigpIHtcbiAgY29uc3QgZSA9IEZhKGdzKTtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBDLnVzZURlYnVnVmFsdWUoZSksIGVbd3RdIHx8IGU7XG59XG5mdW5jdGlvbiBCZihlKSB7XG4gIHJldHVybiBlICE9PSBcIm93bmVyU3RhdGVcIiAmJiBlICE9PSBcInRoZW1lXCIgJiYgZSAhPT0gXCJzeFwiICYmIGUgIT09IFwiYXNcIjtcbn1cbmNvbnN0IHlzID0gKGUpID0+IEJmKGUpICYmIGUgIT09IFwiY2xhc3Nlc1wiLCBsZSA9IFR1KHtcbiAgdGhlbWVJZDogd3QsXG4gIGRlZmF1bHRUaGVtZTogZ3MsXG4gIHJvb3RTaG91bGRGb3J3YXJkUHJvcDogeXNcbn0pO1xuZnVuY3Rpb24gb2Eoe1xuICB0aGVtZTogZSxcbiAgLi4udFxufSkge1xuICBjb25zdCByID0gd3QgaW4gZSA/IGVbd3RdIDogdm9pZCAwO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KFJyLCB7XG4gICAgLi4udCxcbiAgICB0aGVtZUlkOiByID8gd3QgOiB2b2lkIDAsXG4gICAgdGhlbWU6IHIgfHwgZVxuICB9KTtcbn1cbmNvbnN0IFFyID0ge1xuICBhdHRyaWJ1dGU6IFwiZGF0YS1tdWktY29sb3Itc2NoZW1lXCIsXG4gIGNvbG9yU2NoZW1lU3RvcmFnZUtleTogXCJtdWktY29sb3Itc2NoZW1lXCIsXG4gIGRlZmF1bHRMaWdodENvbG9yU2NoZW1lOiBcImxpZ2h0XCIsXG4gIGRlZmF1bHREYXJrQ29sb3JTY2hlbWU6IFwiZGFya1wiLFxuICBtb2RlU3RvcmFnZUtleTogXCJtdWktbW9kZVwiXG59LCB7XG4gIENzc1ZhcnNQcm92aWRlcjogVmYsXG4gIHVzZUNvbG9yU2NoZW1lOiB6bSxcbiAgZ2V0SW5pdENvbG9yU2NoZW1lU2NyaXB0OiBXbVxufSA9IG5mKHtcbiAgdGhlbWVJZDogd3QsXG4gIC8vIEB0cy1pZ25vcmUgaWdub3JlIG1vZHVsZSBhdWdtZW50YXRpb24gdGVzdHNcbiAgdGhlbWU6ICgpID0+IEZuKHtcbiAgICBjc3NWYXJpYWJsZXM6ICEwXG4gIH0pLFxuICBjb2xvclNjaGVtZVN0b3JhZ2VLZXk6IFFyLmNvbG9yU2NoZW1lU3RvcmFnZUtleSxcbiAgbW9kZVN0b3JhZ2VLZXk6IFFyLm1vZGVTdG9yYWdlS2V5LFxuICBkZWZhdWx0Q29sb3JTY2hlbWU6IHtcbiAgICBsaWdodDogUXIuZGVmYXVsdExpZ2h0Q29sb3JTY2hlbWUsXG4gICAgZGFyazogUXIuZGVmYXVsdERhcmtDb2xvclNjaGVtZVxuICB9LFxuICByZXNvbHZlVGhlbWU6IChlKSA9PiB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLmUsXG4gICAgICB0eXBvZ3JhcGh5OiBmcyhlLnBhbGV0dGUsIGUudHlwb2dyYXBoeSlcbiAgICB9O1xuICAgIHJldHVybiB0LnVuc3RhYmxlX3N4ID0gZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIEF0KHtcbiAgICAgICAgc3g6IG4sXG4gICAgICAgIHRoZW1lOiB0aGlzXG4gICAgICB9KTtcbiAgICB9LCB0O1xuICB9XG59KSwgRmYgPSBWZjtcbmZ1bmN0aW9uIHpmKHtcbiAgdGhlbWU6IGUsXG4gIC4uLnRcbn0pIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChvYSwge1xuICAgIHRoZW1lOiBlLFxuICAgIC4uLnRcbiAgfSkgOiBcImNvbG9yU2NoZW1lc1wiIGluICh3dCBpbiBlID8gZVt3dF0gOiBlKSA/IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChGZiwge1xuICAgIHRoZW1lOiBlLFxuICAgIC4uLnRcbiAgfSkgOiAvKiBAX19QVVJFX18gKi8gTi5qc3gob2EsIHtcbiAgICB0aGVtZTogZSxcbiAgICAuLi50XG4gIH0pO1xufVxuZnVuY3Rpb24gV2YoKSB7XG4gIHJldHVybiB6YTtcbn1cbmNvbnN0IHFlID0gSnU7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGEubm9kZSwgYS5vYmplY3QuaXNSZXF1aXJlZCk7XG5mdW5jdGlvbiBIZShlKSB7XG4gIHJldHVybiBYdShlKTtcbn1cbmZ1bmN0aW9uIFVmKGUpIHtcbiAgcmV0dXJuIFZlKFwiTXVpU3ZnSWNvblwiLCBlKTtcbn1cbkZlKFwiTXVpU3ZnSWNvblwiLCBbXCJyb290XCIsIFwiY29sb3JQcmltYXJ5XCIsIFwiY29sb3JTZWNvbmRhcnlcIiwgXCJjb2xvckFjdGlvblwiLCBcImNvbG9yRXJyb3JcIiwgXCJjb2xvckRpc2FibGVkXCIsIFwiZm9udFNpemVJbmhlcml0XCIsIFwiZm9udFNpemVTbWFsbFwiLCBcImZvbnRTaXplTWVkaXVtXCIsIFwiZm9udFNpemVMYXJnZVwiXSk7XG5jb25zdCBZZiA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb2xvcjogdCxcbiAgICBmb250U2l6ZTogcixcbiAgICBjbGFzc2VzOiBuXG4gIH0gPSBlLCBvID0ge1xuICAgIHJvb3Q6IFtcInJvb3RcIiwgdCAhPT0gXCJpbmhlcml0XCIgJiYgYGNvbG9yJHtlZSh0KX1gLCBgZm9udFNpemUke2VlKHIpfWBdXG4gIH07XG4gIHJldHVybiBHZShvLCBVZiwgbik7XG59LCBIZiA9IGxlKFwic3ZnXCIsIHtcbiAgbmFtZTogXCJNdWlTdmdJY29uXCIsXG4gIHNsb3Q6IFwiUm9vdFwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lclN0YXRlOiByXG4gICAgfSA9IGU7XG4gICAgcmV0dXJuIFt0LnJvb3QsIHIuY29sb3IgIT09IFwiaW5oZXJpdFwiICYmIHRbYGNvbG9yJHtlZShyLmNvbG9yKX1gXSwgdFtgZm9udFNpemUke2VlKHIuZm9udFNpemUpfWBdXTtcbiAgfVxufSkocWUoKHtcbiAgdGhlbWU6IGVcbn0pID0+IHtcbiAgdmFyIHQsIHIsIG4sIG8sIGksIHMsIGMsIGwsIHUsIHAsIG0sIGcsIHgsIHk7XG4gIHJldHVybiB7XG4gICAgdXNlclNlbGVjdDogXCJub25lXCIsXG4gICAgd2lkdGg6IFwiMWVtXCIsXG4gICAgaGVpZ2h0OiBcIjFlbVwiLFxuICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgZmxleFNocmluazogMCxcbiAgICB0cmFuc2l0aW9uOiAobyA9ICh0ID0gZS50cmFuc2l0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IHQuY3JlYXRlKSA9PSBudWxsID8gdm9pZCAwIDogby5jYWxsKHQsIFwiZmlsbFwiLCB7XG4gICAgICBkdXJhdGlvbjogKG4gPSAociA9IChlLnZhcnMgPz8gZSkudHJhbnNpdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiByLmR1cmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogbi5zaG9ydGVyXG4gICAgfSksXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgcHJvcHM6IChmKSA9PiAhZi5oYXNTdmdBc0NoaWxkLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIC8vIHRoZSA8c3ZnPiB3aWxsIGRlZmluZSB0aGUgcHJvcGVydHkgdGhhdCBoYXMgYGN1cnJlbnRDb2xvcmBcbiAgICAgICAgICAvLyBmb3IgZXhhbXBsZSBoZXJvaWNvbnMgdXNlcyBmaWxsPVwibm9uZVwiIGFuZCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBmb250U2l6ZTogXCJpbmhlcml0XCJcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBmb250U2l6ZTogXCJpbmhlcml0XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBmb250U2l6ZTogXCJzbWFsbFwiXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZm9udFNpemU6ICgocyA9IChpID0gZS50eXBvZ3JhcGh5KSA9PSBudWxsID8gdm9pZCAwIDogaS5weFRvUmVtKSA9PSBudWxsID8gdm9pZCAwIDogcy5jYWxsKGksIDIwKSkgfHwgXCIxLjI1cmVtXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBmb250U2l6ZTogXCJtZWRpdW1cIlxuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGZvbnRTaXplOiAoKGwgPSAoYyA9IGUudHlwb2dyYXBoeSkgPT0gbnVsbCA/IHZvaWQgMCA6IGMucHhUb1JlbSkgPT0gbnVsbCA/IHZvaWQgMCA6IGwuY2FsbChjLCAyNCkpIHx8IFwiMS41cmVtXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBmb250U2l6ZTogXCJsYXJnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZm9udFNpemU6ICgocCA9ICh1ID0gZS50eXBvZ3JhcGh5KSA9PSBudWxsID8gdm9pZCAwIDogdS5weFRvUmVtKSA9PSBudWxsID8gdm9pZCAwIDogcC5jYWxsKHUsIDM1KSkgfHwgXCIyLjE4NzVyZW1cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVE9ETyB2NSBkZXByZWNhdGUgY29sb3IgcHJvcCwgdjYgcmVtb3ZlIGZvciBzeFxuICAgICAgLi4uT2JqZWN0LmVudHJpZXMoKGUudmFycyA/PyBlKS5wYWxldHRlKS5maWx0ZXIoKFssIGZdKSA9PiBmICYmIGYubWFpbikubWFwKChbZl0pID0+IHtcbiAgICAgICAgdmFyIFMsIEU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGNvbG9yOiBmXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3I6IChFID0gKFMgPSAoZS52YXJzID8/IGUpLnBhbGV0dGUpID09IG51bGwgPyB2b2lkIDAgOiBTW2ZdKSA9PSBudWxsID8gdm9pZCAwIDogRS5tYWluXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgY29sb3I6IFwiYWN0aW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBjb2xvcjogKGcgPSAobSA9IChlLnZhcnMgPz8gZSkucGFsZXR0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG0uYWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogZy5hY3RpdmVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBjb2xvcjogXCJkaXNhYmxlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6ICh5ID0gKHggPSAoZS52YXJzID8/IGUpLnBhbGV0dGUpID09IG51bGwgPyB2b2lkIDAgOiB4LmFjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IHkuZGlzYWJsZWRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBjb2xvcjogXCJpbmhlcml0XCJcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBjb2xvcjogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59KSksIHluID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IG4gPSBIZSh7XG4gICAgcHJvcHM6IHQsXG4gICAgbmFtZTogXCJNdWlTdmdJY29uXCJcbiAgfSksIHtcbiAgICBjaGlsZHJlbjogbyxcbiAgICBjbGFzc05hbWU6IGksXG4gICAgY29sb3I6IHMgPSBcImluaGVyaXRcIixcbiAgICBjb21wb25lbnQ6IGMgPSBcInN2Z1wiLFxuICAgIGZvbnRTaXplOiBsID0gXCJtZWRpdW1cIixcbiAgICBodG1sQ29sb3I6IHUsXG4gICAgaW5oZXJpdFZpZXdCb3g6IHAgPSAhMSxcbiAgICB0aXRsZUFjY2VzczogbSxcbiAgICB2aWV3Qm94OiBnID0gXCIwIDAgMjQgMjRcIixcbiAgICAuLi54XG4gIH0gPSBuLCB5ID0gLyogQF9fUFVSRV9fICovIEMuaXNWYWxpZEVsZW1lbnQobykgJiYgby50eXBlID09PSBcInN2Z1wiLCBmID0ge1xuICAgIC4uLm4sXG4gICAgY29sb3I6IHMsXG4gICAgY29tcG9uZW50OiBjLFxuICAgIGZvbnRTaXplOiBsLFxuICAgIGluc3RhbmNlRm9udFNpemU6IHQuZm9udFNpemUsXG4gICAgaW5oZXJpdFZpZXdCb3g6IHAsXG4gICAgdmlld0JveDogZyxcbiAgICBoYXNTdmdBc0NoaWxkOiB5XG4gIH0sIFMgPSB7fTtcbiAgcCB8fCAoUy52aWV3Qm94ID0gZyk7XG4gIGNvbnN0IEUgPSBZZihmKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeHMoSGYsIHtcbiAgICBhczogYyxcbiAgICBjbGFzc05hbWU6IHNlKEUucm9vdCwgaSksXG4gICAgZm9jdXNhYmxlOiBcImZhbHNlXCIsXG4gICAgY29sb3I6IHUsXG4gICAgXCJhcmlhLWhpZGRlblwiOiBtID8gdm9pZCAwIDogITAsXG4gICAgcm9sZTogbSA/IFwiaW1nXCIgOiB2b2lkIDAsXG4gICAgcmVmOiByLFxuICAgIC4uLlMsXG4gICAgLi4ueCxcbiAgICAuLi55ICYmIG8ucHJvcHMsXG4gICAgb3duZXJTdGF0ZTogZixcbiAgICBjaGlsZHJlbjogW3kgPyBvLnByb3BzLmNoaWxkcmVuIDogbywgbSA/IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChcInRpdGxlXCIsIHtcbiAgICAgIGNoaWxkcmVuOiBtXG4gICAgfSkgOiBudWxsXVxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICh5bi5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCICAgIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiAgICAg4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogTm9kZSBwYXNzZWQgaW50byB0aGUgU1ZHIGVsZW1lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogYS5ub2RlLFxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIEl0IHN1cHBvcnRzIGJvdGggZGVmYXVsdCBhbmQgY3VzdG9tIHRoZW1lIGNvbG9ycywgd2hpY2ggY2FuIGJlIGFkZGVkIGFzIHNob3duIGluIHRoZVxuICAgKiBbcGFsZXR0ZSBjdXN0b21pemF0aW9uIGd1aWRlXShodHRwczovL211aS5jb20vbWF0ZXJpYWwtdWkvY3VzdG9taXphdGlvbi9wYWxldHRlLyNjdXN0b20tY29sb3JzKS5cbiAgICogWW91IGNhbiB1c2UgdGhlIGBodG1sQ29sb3JgIHByb3AgdG8gYXBwbHkgYSBjb2xvciBhdHRyaWJ1dGUgdG8gdGhlIFNWRyBlbGVtZW50LlxuICAgKiBAZGVmYXVsdCAnaW5oZXJpdCdcbiAgICovXG4gIGNvbG9yOiBhLm9uZU9mVHlwZShbYS5vbmVPZihbXCJpbmhlcml0XCIsIFwiYWN0aW9uXCIsIFwiZGlzYWJsZWRcIiwgXCJwcmltYXJ5XCIsIFwic2Vjb25kYXJ5XCIsIFwiZXJyb3JcIiwgXCJpbmZvXCIsIFwic3VjY2Vzc1wiLCBcIndhcm5pbmdcIl0pLCBhLnN0cmluZ10pLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgY29tcG9uZW50OiBhLmVsZW1lbnRUeXBlLFxuICAvKipcbiAgICogVGhlIGZvbnRTaXplIGFwcGxpZWQgdG8gdGhlIGljb24uIERlZmF1bHRzIHRvIDI0cHgsIGJ1dCBjYW4gYmUgY29uZmlndXJlIHRvIGluaGVyaXQgZm9udCBzaXplLlxuICAgKiBAZGVmYXVsdCAnbWVkaXVtJ1xuICAgKi9cbiAgZm9udFNpemU6IGEub25lT2ZUeXBlKFthLm9uZU9mKFtcImluaGVyaXRcIiwgXCJsYXJnZVwiLCBcIm1lZGl1bVwiLCBcInNtYWxsXCJdKSwgYS5zdHJpbmddKSxcbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBjb2xvciBhdHRyaWJ1dGUgdG8gdGhlIFNWRyBlbGVtZW50LlxuICAgKi9cbiAgaHRtbENvbG9yOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHJvb3Qgbm9kZSB3aWxsIGluaGVyaXQgdGhlIGN1c3RvbSBgY29tcG9uZW50YCdzIHZpZXdCb3ggYW5kIHRoZSBgdmlld0JveGBcbiAgICogcHJvcCB3aWxsIGJlIGlnbm9yZWQuXG4gICAqIFVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHJlZmVyZW5jZSBhIGN1c3RvbSBgY29tcG9uZW50YCBhbmQgaGF2ZSBgU3ZnSWNvbmAgcGFzcyB0aGF0XG4gICAqIGBjb21wb25lbnRgJ3Mgdmlld0JveCB0byB0aGUgcm9vdCBub2RlLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaW5oZXJpdFZpZXdCb3g6IGEuYm9vbCxcbiAgLyoqXG4gICAqIFRoZSBzaGFwZS1yZW5kZXJpbmcgYXR0cmlidXRlLiBUaGUgYmVoYXZpb3Igb2YgdGhlIGRpZmZlcmVudCBvcHRpb25zIGlzIGRlc2NyaWJlZCBvbiB0aGVcbiAgICogW01ETiBXZWIgRG9jc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zaGFwZS1yZW5kZXJpbmcpLlxuICAgKiBJZiB5b3UgYXJlIGhhdmluZyBpc3N1ZXMgd2l0aCBibHVycnkgaWNvbnMgeW91IHNob3VsZCBpbnZlc3RpZ2F0ZSB0aGlzIHByb3AuXG4gICAqL1xuICBzaGFwZVJlbmRlcmluZzogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHByb3AgdGhhdCBhbGxvd3MgZGVmaW5pbmcgc3lzdGVtIG92ZXJyaWRlcyBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHN4OiBhLm9uZU9mVHlwZShbYS5hcnJheU9mKGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0LCBhLmJvb2xdKSksIGEuZnVuYywgYS5vYmplY3RdKSxcbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgaHVtYW4tcmVhZGFibGUgdGl0bGUgZm9yIHRoZSBlbGVtZW50IHRoYXQgY29udGFpbnMgaXQuXG4gICAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkctYWNjZXNzLyNFcXVpdmFsZW50XG4gICAqL1xuICB0aXRsZUFjY2VzczogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBBbGxvd3MgeW91IHRvIHJlZGVmaW5lIHdoYXQgdGhlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdW5pdHMgbWVhbiBpbnNpZGUgYW4gU1ZHIGVsZW1lbnQuXG4gICAqIEZvciBleGFtcGxlLCBpZiB0aGUgU1ZHIGVsZW1lbnQgaXMgNTAwICh3aWR0aCkgYnkgMjAwIChoZWlnaHQpLFxuICAgKiBhbmQgeW91IHBhc3Mgdmlld0JveD1cIjAgMCA1MCAyMFwiLFxuICAgKiB0aGlzIG1lYW5zIHRoYXQgdGhlIGNvb3JkaW5hdGVzIGluc2lkZSB0aGUgU1ZHIHdpbGwgZ28gZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyICgwLDApXG4gICAqIHRvIGJvdHRvbSByaWdodCAoNTAsMjApIGFuZCBlYWNoIHVuaXQgd2lsbCBiZSB3b3J0aCAxMHB4LlxuICAgKiBAZGVmYXVsdCAnMCAwIDI0IDI0J1xuICAgKi9cbiAgdmlld0JveDogYS5zdHJpbmdcbn0pO1xueW4ubXVpTmFtZSA9IFwiU3ZnSWNvblwiO1xuZnVuY3Rpb24gc3IoZSwgdCkge1xuICBmdW5jdGlvbiByKG4sIG8pIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KHluLCB7XG4gICAgICBcImRhdGEtdGVzdGlkXCI6IGAke3R9SWNvbmAsXG4gICAgICByZWY6IG8sXG4gICAgICAuLi5uLFxuICAgICAgY2hpbGRyZW46IGVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChyLmRpc3BsYXlOYW1lID0gYCR7dH1JY29uYCksIHIubXVpTmFtZSA9IHluLm11aU5hbWUsIC8qIEBfX1BVUkVfXyAqLyBDLm1lbW8oLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihyKSk7XG59XG5mdW5jdGlvbiBicyhlLCB0KSB7XG4gIGlmIChlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHIgPSB7fTtcbiAgZm9yICh2YXIgbiBpbiBlKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChlLCBuKSkge1xuICAgIGlmICh0LmluY2x1ZGVzKG4pKSBjb250aW51ZTtcbiAgICByW25dID0gZVtuXTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHBvKGUsIHQpIHtcbiAgcmV0dXJuIHBvID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uKHIsIG4pIHtcbiAgICByZXR1cm4gci5fX3Byb3RvX18gPSBuLCByO1xuICB9LCBwbyhlLCB0KTtcbn1cbmZ1bmN0aW9uIHZzKGUsIHQpIHtcbiAgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQucHJvdG90eXBlKSwgZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBlLCBwbyhlLCB0KTtcbn1cbmNvbnN0IGlhID0ge1xuICBkaXNhYmxlZDogITFcbn07XG52YXIgcWYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBhLm9uZU9mVHlwZShbYS5udW1iZXIsIGEuc2hhcGUoe1xuICBlbnRlcjogYS5udW1iZXIsXG4gIGV4aXQ6IGEubnVtYmVyLFxuICBhcHBlYXI6IGEubnVtYmVyXG59KS5pc1JlcXVpcmVkXSkgOiBudWxsO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGEub25lT2ZUeXBlKFthLnN0cmluZywgYS5zaGFwZSh7XG4gIGVudGVyOiBhLnN0cmluZyxcbiAgZXhpdDogYS5zdHJpbmcsXG4gIGFjdGl2ZTogYS5zdHJpbmdcbn0pLCBhLnNoYXBlKHtcbiAgZW50ZXI6IGEuc3RyaW5nLFxuICBlbnRlckRvbmU6IGEuc3RyaW5nLFxuICBlbnRlckFjdGl2ZTogYS5zdHJpbmcsXG4gIGV4aXQ6IGEuc3RyaW5nLFxuICBleGl0RG9uZTogYS5zdHJpbmcsXG4gIGV4aXRBY3RpdmU6IGEuc3RyaW5nXG59KV0pO1xuY29uc3QgYm4gPSB5dC5jcmVhdGVDb250ZXh0KG51bGwpO1xudmFyIEdmID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gdC5zY3JvbGxUb3A7XG59LCBiciA9IFwidW5tb3VudGVkXCIsIF90ID0gXCJleGl0ZWRcIiwganQgPSBcImVudGVyaW5nXCIsIEt0ID0gXCJlbnRlcmVkXCIsIG1vID0gXCJleGl0aW5nXCIsIEV0ID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKGUpIHtcbiAgdnModCwgZSk7XG4gIGZ1bmN0aW9uIHQobiwgbykge1xuICAgIHZhciBpO1xuICAgIGkgPSBlLmNhbGwodGhpcywgbiwgbykgfHwgdGhpcztcbiAgICB2YXIgcyA9IG8sIGMgPSBzICYmICFzLmlzTW91bnRpbmcgPyBuLmVudGVyIDogbi5hcHBlYXIsIGw7XG4gICAgcmV0dXJuIGkuYXBwZWFyU3RhdHVzID0gbnVsbCwgbi5pbiA/IGMgPyAobCA9IF90LCBpLmFwcGVhclN0YXR1cyA9IGp0KSA6IGwgPSBLdCA6IG4udW5tb3VudE9uRXhpdCB8fCBuLm1vdW50T25FbnRlciA/IGwgPSBiciA6IGwgPSBfdCwgaS5zdGF0ZSA9IHtcbiAgICAgIHN0YXR1czogbFxuICAgIH0sIGkubmV4dENhbGxiYWNrID0gbnVsbCwgaTtcbiAgfVxuICB0LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uKG8sIGkpIHtcbiAgICB2YXIgcyA9IG8uaW47XG4gICAgcmV0dXJuIHMgJiYgaS5zdGF0dXMgPT09IGJyID8ge1xuICAgICAgc3RhdHVzOiBfdFxuICAgIH0gOiBudWxsO1xuICB9O1xuICB2YXIgciA9IHQucHJvdG90eXBlO1xuICByZXR1cm4gci5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudXBkYXRlU3RhdHVzKCEwLCB0aGlzLmFwcGVhclN0YXR1cyk7XG4gIH0sIHIuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24obykge1xuICAgIHZhciBpID0gbnVsbDtcbiAgICBpZiAobyAhPT0gdGhpcy5wcm9wcykge1xuICAgICAgdmFyIHMgPSB0aGlzLnN0YXRlLnN0YXR1cztcbiAgICAgIHRoaXMucHJvcHMuaW4gPyBzICE9PSBqdCAmJiBzICE9PSBLdCAmJiAoaSA9IGp0KSA6IChzID09PSBqdCB8fCBzID09PSBLdCkgJiYgKGkgPSBtbyk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU3RhdHVzKCExLCBpKTtcbiAgfSwgci5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FuY2VsTmV4dENhbGxiYWNrKCk7XG4gIH0sIHIuZ2V0VGltZW91dHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbyA9IHRoaXMucHJvcHMudGltZW91dCwgaSwgcywgYztcbiAgICByZXR1cm4gaSA9IHMgPSBjID0gbywgbyAhPSBudWxsICYmIHR5cGVvZiBvICE9IFwibnVtYmVyXCIgJiYgKGkgPSBvLmV4aXQsIHMgPSBvLmVudGVyLCBjID0gby5hcHBlYXIgIT09IHZvaWQgMCA/IG8uYXBwZWFyIDogcyksIHtcbiAgICAgIGV4aXQ6IGksXG4gICAgICBlbnRlcjogcyxcbiAgICAgIGFwcGVhcjogY1xuICAgIH07XG4gIH0sIHIudXBkYXRlU3RhdHVzID0gZnVuY3Rpb24obywgaSkge1xuICAgIGlmIChvID09PSB2b2lkIDAgJiYgKG8gPSAhMSksIGkgIT09IG51bGwpXG4gICAgICBpZiAodGhpcy5jYW5jZWxOZXh0Q2FsbGJhY2soKSwgaSA9PT0ganQpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudW5tb3VudE9uRXhpdCB8fCB0aGlzLnByb3BzLm1vdW50T25FbnRlcikge1xuICAgICAgICAgIHZhciBzID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gdGhpcy5wcm9wcy5ub2RlUmVmLmN1cnJlbnQgOiBXci5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgICBzICYmIEdmKHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyZm9ybUVudGVyKG8pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRoaXMucGVyZm9ybUV4aXQoKTtcbiAgICBlbHNlIHRoaXMucHJvcHMudW5tb3VudE9uRXhpdCAmJiB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gX3QgJiYgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdGF0dXM6IGJyXG4gICAgfSk7XG4gIH0sIHIucGVyZm9ybUVudGVyID0gZnVuY3Rpb24obykge1xuICAgIHZhciBpID0gdGhpcywgcyA9IHRoaXMucHJvcHMuZW50ZXIsIGMgPSB0aGlzLmNvbnRleHQgPyB0aGlzLmNvbnRleHQuaXNNb3VudGluZyA6IG8sIGwgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyBbY10gOiBbV3IuZmluZERPTU5vZGUodGhpcyksIGNdLCB1ID0gbFswXSwgcCA9IGxbMV0sIG0gPSB0aGlzLmdldFRpbWVvdXRzKCksIGcgPSBjID8gbS5hcHBlYXIgOiBtLmVudGVyO1xuICAgIGlmICghbyAmJiAhcyB8fCBpYS5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IEt0XG4gICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgaS5wcm9wcy5vbkVudGVyZWQodSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbkVudGVyKHUsIHApLCB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICBzdGF0dXM6IGp0XG4gICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICBpLnByb3BzLm9uRW50ZXJpbmcodSwgcCksIGkub25UcmFuc2l0aW9uRW5kKGcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBLdFxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpLnByb3BzLm9uRW50ZXJlZCh1LCBwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgci5wZXJmb3JtRXhpdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvID0gdGhpcywgaSA9IHRoaXMucHJvcHMuZXhpdCwgcyA9IHRoaXMuZ2V0VGltZW91dHMoKSwgYyA9IHRoaXMucHJvcHMubm9kZVJlZiA/IHZvaWQgMCA6IFdyLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgIGlmICghaSB8fCBpYS5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IF90XG4gICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgby5wcm9wcy5vbkV4aXRlZChjKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb3BzLm9uRXhpdChjKSwgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgc3RhdHVzOiBtb1xuICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgby5wcm9wcy5vbkV4aXRpbmcoYyksIG8ub25UcmFuc2l0aW9uRW5kKHMuZXhpdCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIG8uc2FmZVNldFN0YXRlKHtcbiAgICAgICAgICBzdGF0dXM6IF90XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG8ucHJvcHMub25FeGl0ZWQoYyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIHIuY2FuY2VsTmV4dENhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5uZXh0Q2FsbGJhY2sgIT09IG51bGwgJiYgKHRoaXMubmV4dENhbGxiYWNrLmNhbmNlbCgpLCB0aGlzLm5leHRDYWxsYmFjayA9IG51bGwpO1xuICB9LCByLnNhZmVTZXRTdGF0ZSA9IGZ1bmN0aW9uKG8sIGkpIHtcbiAgICBpID0gdGhpcy5zZXROZXh0Q2FsbGJhY2soaSksIHRoaXMuc2V0U3RhdGUobywgaSk7XG4gIH0sIHIuc2V0TmV4dENhbGxiYWNrID0gZnVuY3Rpb24obykge1xuICAgIHZhciBpID0gdGhpcywgcyA9ICEwO1xuICAgIHJldHVybiB0aGlzLm5leHRDYWxsYmFjayA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHMgJiYgKHMgPSAhMSwgaS5uZXh0Q2FsbGJhY2sgPSBudWxsLCBvKGMpKTtcbiAgICB9LCB0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHMgPSAhMTtcbiAgICB9LCB0aGlzLm5leHRDYWxsYmFjaztcbiAgfSwgci5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihvLCBpKSB7XG4gICAgdGhpcy5zZXROZXh0Q2FsbGJhY2soaSk7XG4gICAgdmFyIHMgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyB0aGlzLnByb3BzLm5vZGVSZWYuY3VycmVudCA6IFdyLmZpbmRET01Ob2RlKHRoaXMpLCBjID0gbyA9PSBudWxsICYmICF0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyO1xuICAgIGlmICghcyB8fCBjKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMubmV4dENhbGxiYWNrLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXIpIHtcbiAgICAgIHZhciBsID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gW3RoaXMubmV4dENhbGxiYWNrXSA6IFtzLCB0aGlzLm5leHRDYWxsYmFja10sIHUgPSBsWzBdLCBwID0gbFsxXTtcbiAgICAgIHRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXIodSwgcCk7XG4gICAgfVxuICAgIG8gIT0gbnVsbCAmJiBzZXRUaW1lb3V0KHRoaXMubmV4dENhbGxiYWNrLCBvKTtcbiAgfSwgci5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbyA9IHRoaXMuc3RhdGUuc3RhdHVzO1xuICAgIGlmIChvID09PSBicilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBpID0gdGhpcy5wcm9wcywgcyA9IGkuY2hpbGRyZW47XG4gICAgaS5pbiwgaS5tb3VudE9uRW50ZXIsIGkudW5tb3VudE9uRXhpdCwgaS5hcHBlYXIsIGkuZW50ZXIsIGkuZXhpdCwgaS50aW1lb3V0LCBpLmFkZEVuZExpc3RlbmVyLCBpLm9uRW50ZXIsIGkub25FbnRlcmluZywgaS5vbkVudGVyZWQsIGkub25FeGl0LCBpLm9uRXhpdGluZywgaS5vbkV4aXRlZCwgaS5ub2RlUmVmO1xuICAgIHZhciBjID0gYnMoaSwgW1wiY2hpbGRyZW5cIiwgXCJpblwiLCBcIm1vdW50T25FbnRlclwiLCBcInVubW91bnRPbkV4aXRcIiwgXCJhcHBlYXJcIiwgXCJlbnRlclwiLCBcImV4aXRcIiwgXCJ0aW1lb3V0XCIsIFwiYWRkRW5kTGlzdGVuZXJcIiwgXCJvbkVudGVyXCIsIFwib25FbnRlcmluZ1wiLCBcIm9uRW50ZXJlZFwiLCBcIm9uRXhpdFwiLCBcIm9uRXhpdGluZ1wiLCBcIm9uRXhpdGVkXCIsIFwibm9kZVJlZlwiXSk7XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGFsbG93cyBmb3IgbmVzdGVkIFRyYW5zaXRpb25zXG4gICAgICAvKiBAX19QVVJFX18gKi8geXQuY3JlYXRlRWxlbWVudChibi5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSwgdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiID8gcyhvLCBjKSA6IHl0LmNsb25lRWxlbWVudCh5dC5DaGlsZHJlbi5vbmx5KHMpLCBjKSlcbiAgICApO1xuICB9LCB0O1xufSh5dC5Db21wb25lbnQpO1xuRXQuY29udGV4dFR5cGUgPSBibjtcbkV0LnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgLyoqXG4gICAqIEEgUmVhY3QgcmVmZXJlbmNlIHRvIERPTSBlbGVtZW50IHRoYXQgbmVlZCB0byB0cmFuc2l0aW9uOlxuICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTExMjcxMzAvNDY3MTkzMlxuICAgKlxuICAgKiAgIC0gV2hlbiBgbm9kZVJlZmAgcHJvcCBpcyB1c2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZCB0byBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICogICAgICAoZS5nLiBgb25FbnRlcmApIGJlY2F1c2UgdXNlciBhbHJlYWR5IGhhcyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBub2RlLlxuICAgKiAgIC0gV2hlbiBjaGFuZ2luZyBga2V5YCBwcm9wIG9mIGBUcmFuc2l0aW9uYCBpbiBhIGBUcmFuc2l0aW9uR3JvdXBgIGEgbmV3XG4gICAqICAgICBgbm9kZVJlZmAgbmVlZCB0byBiZSBwcm92aWRlZCB0byBgVHJhbnNpdGlvbmAgd2l0aCBjaGFuZ2VkIGBrZXlgIHByb3BcbiAgICogICAgIChzZWVcbiAgICogICAgIFt0ZXN0L0NTU1RyYW5zaXRpb24tdGVzdC5qc10oaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9ibG9iLzEzNDM1Zjg5N2IzYWI3MWY2ZTE5ZDcyNGYxNDU1OTZmNTkxMDU4MWMvdGVzdC9DU1NUcmFuc2l0aW9uLXRlc3QuanMjTDM2Mi1MNDM3KSkuXG4gICAqL1xuICBub2RlUmVmOiBhLnNoYXBlKHtcbiAgICBjdXJyZW50OiB0eXBlb2YgRWxlbWVudCA+IFwidVwiID8gYS5hbnkgOiBmdW5jdGlvbihlLCB0LCByLCBuLCBvLCBpKSB7XG4gICAgICB2YXIgcyA9IGVbdF07XG4gICAgICByZXR1cm4gYS5pbnN0YW5jZU9mKHMgJiYgXCJvd25lckRvY3VtZW50XCIgaW4gcyA/IHMub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5FbGVtZW50IDogRWxlbWVudCkoZSwgdCwgciwgbiwgbywgaSk7XG4gICAgfVxuICB9KSxcbiAgLyoqXG4gICAqIEEgYGZ1bmN0aW9uYCBjaGlsZCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGEgUmVhY3QgZWxlbWVudC4gVGhpcyBmdW5jdGlvbiBpc1xuICAgKiBjYWxsZWQgd2l0aCB0aGUgY3VycmVudCB0cmFuc2l0aW9uIHN0YXR1cyAoYCdlbnRlcmluZydgLCBgJ2VudGVyZWQnYCxcbiAgICogYCdleGl0aW5nJ2AsIGAnZXhpdGVkJ2ApLCB3aGljaCBjYW4gYmUgdXNlZCB0byBhcHBseSBjb250ZXh0XG4gICAqIHNwZWNpZmljIHByb3BzIHRvIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogPFRyYW5zaXRpb24gaW49e3RoaXMuc3RhdGUuaW59IHRpbWVvdXQ9ezE1MH0+XG4gICAqICAge3N0YXRlID0+IChcbiAgICogICAgIDxNeUNvbXBvbmVudCBjbGFzc05hbWU9e2BmYWRlIGZhZGUtJHtzdGF0ZX1gfSAvPlxuICAgKiAgICl9XG4gICAqIDwvVHJhbnNpdGlvbj5cbiAgICogYGBgXG4gICAqL1xuICBjaGlsZHJlbjogYS5vbmVPZlR5cGUoW2EuZnVuYy5pc1JlcXVpcmVkLCBhLmVsZW1lbnQuaXNSZXF1aXJlZF0pLmlzUmVxdWlyZWQsXG4gIC8qKlxuICAgKiBTaG93IHRoZSBjb21wb25lbnQ7IHRyaWdnZXJzIHRoZSBlbnRlciBvciBleGl0IHN0YXRlc1xuICAgKi9cbiAgaW46IGEuYm9vbCxcbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBtb3VudGVkIGltbWVkaWF0ZWx5IGFsb25nIHdpdGhcbiAgICogdGhlIHBhcmVudCBgVHJhbnNpdGlvbmAgY29tcG9uZW50LiBJZiB5b3Ugd2FudCB0byBcImxhenkgbW91bnRcIiB0aGUgY29tcG9uZW50IG9uIHRoZVxuICAgKiBmaXJzdCBgaW49e3RydWV9YCB5b3UgY2FuIHNldCBgbW91bnRPbkVudGVyYC4gQWZ0ZXIgdGhlIGZpcnN0IGVudGVyIHRyYW5zaXRpb24gdGhlIGNvbXBvbmVudCB3aWxsIHN0YXlcbiAgICogbW91bnRlZCwgZXZlbiBvbiBcImV4aXRlZFwiLCB1bmxlc3MgeW91IGFsc28gc3BlY2lmeSBgdW5tb3VudE9uRXhpdGAuXG4gICAqL1xuICBtb3VudE9uRW50ZXI6IGEuYm9vbCxcbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGNoaWxkIGNvbXBvbmVudCBzdGF5cyBtb3VudGVkIGFmdGVyIGl0IHJlYWNoZXMgdGhlIGAnZXhpdGVkJ2Agc3RhdGUuXG4gICAqIFNldCBgdW5tb3VudE9uRXhpdGAgaWYgeW91J2QgcHJlZmVyIHRvIHVubW91bnQgdGhlIGNvbXBvbmVudCBhZnRlciBpdCBmaW5pc2hlcyBleGl0aW5nLlxuICAgKi9cbiAgdW5tb3VudE9uRXhpdDogYS5ib29sLFxuICAvKipcbiAgICogQnkgZGVmYXVsdCB0aGUgY2hpbGQgY29tcG9uZW50IGRvZXMgbm90IHBlcmZvcm0gdGhlIGVudGVyIHRyYW5zaXRpb24gd2hlblxuICAgKiBpdCBmaXJzdCBtb3VudHMsIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBpbmAuIElmIHlvdSB3YW50IHRoaXNcbiAgICogYmVoYXZpb3IsIHNldCBib3RoIGBhcHBlYXJgIGFuZCBgaW5gIHRvIGB0cnVlYC5cbiAgICpcbiAgICogPiAqKk5vdGUqKjogdGhlcmUgYXJlIG5vIHNwZWNpYWwgYXBwZWFyIHN0YXRlcyBsaWtlIGBhcHBlYXJpbmdgL2BhcHBlYXJlZGAsIHRoaXMgcHJvcFxuICAgKiA+IG9ubHkgYWRkcyBhbiBhZGRpdGlvbmFsIGVudGVyIHRyYW5zaXRpb24uIEhvd2V2ZXIsIGluIHRoZVxuICAgKiA+IGA8Q1NTVHJhbnNpdGlvbj5gIGNvbXBvbmVudCB0aGF0IGZpcnN0IGVudGVyIHRyYW5zaXRpb24gZG9lcyByZXN1bHQgaW5cbiAgICogPiBhZGRpdGlvbmFsIGAuYXBwZWFyLSpgIGNsYXNzZXMsIHRoYXQgd2F5IHlvdSBjYW4gY2hvb3NlIHRvIHN0eWxlIGl0XG4gICAqID4gZGlmZmVyZW50bHkuXG4gICAqL1xuICBhcHBlYXI6IGEuYm9vbCxcbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGVudGVyIHRyYW5zaXRpb25zLlxuICAgKi9cbiAgZW50ZXI6IGEuYm9vbCxcbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGV4aXQgdHJhbnNpdGlvbnMuXG4gICAqL1xuICBleGl0OiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24sIGluIG1pbGxpc2Vjb25kcy5cbiAgICogUmVxdWlyZWQgdW5sZXNzIGBhZGRFbmRMaXN0ZW5lcmAgaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIFlvdSBtYXkgc3BlY2lmeSBhIHNpbmdsZSB0aW1lb3V0IGZvciBhbGwgdHJhbnNpdGlvbnM6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiB0aW1lb3V0PXs1MDB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBvciBpbmRpdmlkdWFsbHk6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiB0aW1lb3V0PXt7XG4gICAqICBhcHBlYXI6IDUwMCxcbiAgICogIGVudGVyOiAzMDAsXG4gICAqICBleGl0OiA1MDAsXG4gICAqIH19XG4gICAqIGBgYFxuICAgKlxuICAgKiAtIGBhcHBlYXJgIGRlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiBgZW50ZXJgXG4gICAqIC0gYGVudGVyYCBkZWZhdWx0cyB0byBgMGBcbiAgICogLSBgZXhpdGAgZGVmYXVsdHMgdG8gYDBgXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXIgfCB7IGVudGVyPzogbnVtYmVyLCBleGl0PzogbnVtYmVyLCBhcHBlYXI/OiBudW1iZXIgfX1cbiAgICovXG4gIHRpbWVvdXQ6IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgciA9IHFmO1xuICAgIHQuYWRkRW5kTGlzdGVuZXIgfHwgKHIgPSByLmlzUmVxdWlyZWQpO1xuICAgIGZvciAodmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBvID0gbmV3IEFycmF5KG4gPiAxID8gbiAtIDEgOiAwKSwgaSA9IDE7IGkgPCBuOyBpKyspXG4gICAgICBvW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gci5hcHBseSh2b2lkIDAsIFt0XS5jb25jYXQobykpO1xuICB9LFxuICAvKipcbiAgICogQWRkIGEgY3VzdG9tIHRyYW5zaXRpb24gZW5kIHRyaWdnZXIuIENhbGxlZCB3aXRoIHRoZSB0cmFuc2l0aW9uaW5nXG4gICAqIERPTSBub2RlIGFuZCBhIGBkb25lYCBjYWxsYmFjay4gQWxsb3dzIGZvciBtb3JlIGZpbmUgZ3JhaW5lZCB0cmFuc2l0aW9uIGVuZFxuICAgKiBsb2dpYy4gVGltZW91dHMgYXJlIHN0aWxsIHVzZWQgYXMgYSBmYWxsYmFjayBpZiBwcm92aWRlZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogYGBganN4XG4gICAqIGFkZEVuZExpc3RlbmVyPXsobm9kZSwgZG9uZSkgPT4ge1xuICAgKiAgIC8vIHVzZSB0aGUgY3NzIHRyYW5zaXRpb25lbmQgZXZlbnQgdG8gbWFyayB0aGUgZmluaXNoIG9mIGEgdHJhbnNpdGlvblxuICAgKiAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGRvbmUsIGZhbHNlKTtcbiAgICogfX1cbiAgICogYGBgXG4gICAqL1xuICBhZGRFbmRMaXN0ZW5lcjogYS5mdW5jLFxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHRoZSBcImVudGVyaW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKSAtPiB2b2lkXG4gICAqL1xuICBvbkVudGVyOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJlbnRlcmluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbClcbiAgICovXG4gIG9uRW50ZXJpbmc6IGEuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImVudGVyZWRcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpIC0+IHZvaWRcbiAgICovXG4gIG9uRW50ZXJlZDogYS5mdW5jLFxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHRoZSBcImV4aXRpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdDogYS5mdW5jLFxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZXhpdGluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCkgLT4gdm9pZFxuICAgKi9cbiAgb25FeGl0aW5nOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJleGl0ZWRcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZFxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCkgLT4gdm9pZFxuICAgKi9cbiAgb25FeGl0ZWQ6IGEuZnVuY1xufSA6IHt9O1xuZnVuY3Rpb24gR3QoKSB7XG59XG5FdC5kZWZhdWx0UHJvcHMgPSB7XG4gIGluOiAhMSxcbiAgbW91bnRPbkVudGVyOiAhMSxcbiAgdW5tb3VudE9uRXhpdDogITEsXG4gIGFwcGVhcjogITEsXG4gIGVudGVyOiAhMCxcbiAgZXhpdDogITAsXG4gIG9uRW50ZXI6IEd0LFxuICBvbkVudGVyaW5nOiBHdCxcbiAgb25FbnRlcmVkOiBHdCxcbiAgb25FeGl0OiBHdCxcbiAgb25FeGl0aW5nOiBHdCxcbiAgb25FeGl0ZWQ6IEd0XG59O1xuRXQuVU5NT1VOVEVEID0gYnI7XG5FdC5FWElURUQgPSBfdDtcbkV0LkVOVEVSSU5HID0ganQ7XG5FdC5FTlRFUkVEID0gS3Q7XG5FdC5FWElUSU5HID0gbW87XG5mdW5jdGlvbiBLZihlKSB7XG4gIGlmIChlID09PSB2b2lkIDApIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBZbyhlLCB0KSB7XG4gIHZhciByID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0ICYmIG5uKGkpID8gdChpKSA6IGk7XG4gIH0sIG4gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIGUgJiYgUXMubWFwKGUsIGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gbztcbiAgfSkuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgbltvLmtleV0gPSByKG8pO1xuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIFhmKGUsIHQpIHtcbiAgZSA9IGUgfHwge30sIHQgPSB0IHx8IHt9O1xuICBmdW5jdGlvbiByKHApIHtcbiAgICByZXR1cm4gcCBpbiB0ID8gdFtwXSA6IGVbcF07XG4gIH1cbiAgdmFyIG4gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgbyA9IFtdO1xuICBmb3IgKHZhciBpIGluIGUpXG4gICAgaSBpbiB0ID8gby5sZW5ndGggJiYgKG5baV0gPSBvLCBvID0gW10pIDogby5wdXNoKGkpO1xuICB2YXIgcywgYyA9IHt9O1xuICBmb3IgKHZhciBsIGluIHQpIHtcbiAgICBpZiAobltsXSlcbiAgICAgIGZvciAocyA9IDA7IHMgPCBuW2xdLmxlbmd0aDsgcysrKSB7XG4gICAgICAgIHZhciB1ID0gbltsXVtzXTtcbiAgICAgICAgY1tuW2xdW3NdXSA9IHIodSk7XG4gICAgICB9XG4gICAgY1tsXSA9IHIobCk7XG4gIH1cbiAgZm9yIChzID0gMDsgcyA8IG8ubGVuZ3RoOyBzKyspXG4gICAgY1tvW3NdXSA9IHIob1tzXSk7XG4gIHJldHVybiBjO1xufVxuZnVuY3Rpb24gTHQoZSwgdCwgcikge1xuICByZXR1cm4gclt0XSAhPSBudWxsID8gclt0XSA6IGUucHJvcHNbdF07XG59XG5mdW5jdGlvbiBKZihlLCB0KSB7XG4gIHJldHVybiBZbyhlLmNoaWxkcmVuLCBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIG9uKHIsIHtcbiAgICAgIG9uRXhpdGVkOiB0LmJpbmQobnVsbCwgciksXG4gICAgICBpbjogITAsXG4gICAgICBhcHBlYXI6IEx0KHIsIFwiYXBwZWFyXCIsIGUpLFxuICAgICAgZW50ZXI6IEx0KHIsIFwiZW50ZXJcIiwgZSksXG4gICAgICBleGl0OiBMdChyLCBcImV4aXRcIiwgZSlcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBRZihlLCB0LCByKSB7XG4gIHZhciBuID0gWW8oZS5jaGlsZHJlbiksIG8gPSBYZih0LCBuKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgIHZhciBzID0gb1tpXTtcbiAgICBpZiAobm4ocykpIHtcbiAgICAgIHZhciBjID0gaSBpbiB0LCBsID0gaSBpbiBuLCB1ID0gdFtpXSwgcCA9IG5uKHUpICYmICF1LnByb3BzLmluO1xuICAgICAgbCAmJiAoIWMgfHwgcCkgPyBvW2ldID0gb24ocywge1xuICAgICAgICBvbkV4aXRlZDogci5iaW5kKG51bGwsIHMpLFxuICAgICAgICBpbjogITAsXG4gICAgICAgIGV4aXQ6IEx0KHMsIFwiZXhpdFwiLCBlKSxcbiAgICAgICAgZW50ZXI6IEx0KHMsIFwiZW50ZXJcIiwgZSlcbiAgICAgIH0pIDogIWwgJiYgYyAmJiAhcCA/IG9baV0gPSBvbihzLCB7XG4gICAgICAgIGluOiAhMVxuICAgICAgfSkgOiBsICYmIGMgJiYgbm4odSkgJiYgKG9baV0gPSBvbihzLCB7XG4gICAgICAgIG9uRXhpdGVkOiByLmJpbmQobnVsbCwgcyksXG4gICAgICAgIGluOiB1LnByb3BzLmluLFxuICAgICAgICBleGl0OiBMdChzLCBcImV4aXRcIiwgZSksXG4gICAgICAgIGVudGVyOiBMdChzLCBcImVudGVyXCIsIGUpXG4gICAgICB9KSk7XG4gICAgfVxuICB9KSwgbztcbn1cbnZhciBaZiA9IE9iamVjdC52YWx1ZXMgfHwgZnVuY3Rpb24oZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZSkubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gZVt0XTtcbiAgfSk7XG59LCBlZCA9IHtcbiAgY29tcG9uZW50OiBcImRpdlwiLFxuICBjaGlsZEZhY3Rvcnk6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfVxufSwgSG8gPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oZSkge1xuICB2cyh0LCBlKTtcbiAgZnVuY3Rpb24gdChuLCBvKSB7XG4gICAgdmFyIGk7XG4gICAgaSA9IGUuY2FsbCh0aGlzLCBuLCBvKSB8fCB0aGlzO1xuICAgIHZhciBzID0gaS5oYW5kbGVFeGl0ZWQuYmluZChLZihpKSk7XG4gICAgcmV0dXJuIGkuc3RhdGUgPSB7XG4gICAgICBjb250ZXh0VmFsdWU6IHtcbiAgICAgICAgaXNNb3VudGluZzogITBcbiAgICAgIH0sXG4gICAgICBoYW5kbGVFeGl0ZWQ6IHMsXG4gICAgICBmaXJzdFJlbmRlcjogITBcbiAgICB9LCBpO1xuICB9XG4gIHZhciByID0gdC5wcm90b3R5cGU7XG4gIHJldHVybiByLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb3VudGVkID0gITAsIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY29udGV4dFZhbHVlOiB7XG4gICAgICAgIGlzTW91bnRpbmc6ICExXG4gICAgICB9XG4gICAgfSk7XG4gIH0sIHIuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSAhMTtcbiAgfSwgdC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbihvLCBpKSB7XG4gICAgdmFyIHMgPSBpLmNoaWxkcmVuLCBjID0gaS5oYW5kbGVFeGl0ZWQsIGwgPSBpLmZpcnN0UmVuZGVyO1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogbCA/IEpmKG8sIGMpIDogUWYobywgcywgYyksXG4gICAgICBmaXJzdFJlbmRlcjogITFcbiAgICB9O1xuICB9LCByLmhhbmRsZUV4aXRlZCA9IGZ1bmN0aW9uKG8sIGkpIHtcbiAgICB2YXIgcyA9IFlvKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgIG8ua2V5IGluIHMgfHwgKG8ucHJvcHMub25FeGl0ZWQgJiYgby5wcm9wcy5vbkV4aXRlZChpKSwgdGhpcy5tb3VudGVkICYmIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGwgPSBmbih7fSwgYy5jaGlsZHJlbik7XG4gICAgICByZXR1cm4gZGVsZXRlIGxbby5rZXldLCB7XG4gICAgICAgIGNoaWxkcmVuOiBsXG4gICAgICB9O1xuICAgIH0pKTtcbiAgfSwgci5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbyA9IHRoaXMucHJvcHMsIGkgPSBvLmNvbXBvbmVudCwgcyA9IG8uY2hpbGRGYWN0b3J5LCBjID0gYnMobywgW1wiY29tcG9uZW50XCIsIFwiY2hpbGRGYWN0b3J5XCJdKSwgbCA9IHRoaXMuc3RhdGUuY29udGV4dFZhbHVlLCB1ID0gWmYodGhpcy5zdGF0ZS5jaGlsZHJlbikubWFwKHMpO1xuICAgIHJldHVybiBkZWxldGUgYy5hcHBlYXIsIGRlbGV0ZSBjLmVudGVyLCBkZWxldGUgYy5leGl0LCBpID09PSBudWxsID8gLyogQF9fUFVSRV9fICovIHl0LmNyZWF0ZUVsZW1lbnQoYm4uUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBsXG4gICAgfSwgdSkgOiAvKiBAX19QVVJFX18gKi8geXQuY3JlYXRlRWxlbWVudChibi5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGxcbiAgICB9LCAvKiBAX19QVVJFX18gKi8geXQuY3JlYXRlRWxlbWVudChpLCBjLCB1KSk7XG4gIH0sIHQ7XG59KHl0LkNvbXBvbmVudCk7XG5Iby5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIC8qKlxuICAgKiBgPFRyYW5zaXRpb25Hcm91cD5gIHJlbmRlcnMgYSBgPGRpdj5gIGJ5IGRlZmF1bHQuIFlvdSBjYW4gY2hhbmdlIHRoaXNcbiAgICogYmVoYXZpb3IgYnkgcHJvdmlkaW5nIGEgYGNvbXBvbmVudGAgcHJvcC5cbiAgICogSWYgeW91IHVzZSBSZWFjdCB2MTYrIGFuZCB3b3VsZCBsaWtlIHRvIGF2b2lkIGEgd3JhcHBpbmcgYDxkaXY+YCBlbGVtZW50XG4gICAqIHlvdSBjYW4gcGFzcyBpbiBgY29tcG9uZW50PXtudWxsfWAuIFRoaXMgaXMgdXNlZnVsIGlmIHRoZSB3cmFwcGluZyBkaXZcbiAgICogYm9ya3MgeW91ciBjc3Mgc3R5bGVzLlxuICAgKi9cbiAgY29tcG9uZW50OiBhLmFueSxcbiAgLyoqXG4gICAqIEEgc2V0IG9mIGA8VHJhbnNpdGlvbj5gIGNvbXBvbmVudHMsIHRoYXQgYXJlIHRvZ2dsZWQgYGluYCBhbmQgb3V0IGFzIHRoZXlcbiAgICogbGVhdmUuIHRoZSBgPFRyYW5zaXRpb25Hcm91cD5gIHdpbGwgaW5qZWN0IHNwZWNpZmljIHRyYW5zaXRpb24gcHJvcHMsIHNvXG4gICAqIHJlbWVtYmVyIHRvIHNwcmVhZCB0aGVtIHRocm91Z2ggaWYgeW91IGFyZSB3cmFwcGluZyB0aGUgYDxUcmFuc2l0aW9uPmAgYXNcbiAgICogd2l0aCBvdXIgYDxGYWRlPmAgZXhhbXBsZS5cbiAgICpcbiAgICogV2hpbGUgdGhpcyBjb21wb25lbnQgaXMgbWVhbnQgZm9yIG11bHRpcGxlIGBUcmFuc2l0aW9uYCBvciBgQ1NTVHJhbnNpdGlvbmBcbiAgICogY2hpbGRyZW4sIHNvbWV0aW1lcyB5b3UgbWF5IHdhbnQgdG8gaGF2ZSBhIHNpbmdsZSB0cmFuc2l0aW9uIGNoaWxkIHdpdGhcbiAgICogY29udGVudCB0aGF0IHlvdSB3YW50IHRvIGJlIHRyYW5zaXRpb25lZCBvdXQgYW5kIGluIHdoZW4geW91IGNoYW5nZSBpdFxuICAgKiAoZS5nLiByb3V0ZXMsIGltYWdlcyBldGMuKSBJbiB0aGF0IGNhc2UgeW91IGNhbiBjaGFuZ2UgdGhlIGBrZXlgIHByb3Agb2ZcbiAgICogdGhlIHRyYW5zaXRpb24gY2hpbGQgYXMgeW91IGNoYW5nZSBpdHMgY29udGVudCwgdGhpcyB3aWxsIGNhdXNlXG4gICAqIGBUcmFuc2l0aW9uR3JvdXBgIHRvIHRyYW5zaXRpb24gdGhlIGNoaWxkIG91dCBhbmQgYmFjayBpbi5cbiAgICovXG4gIGNoaWxkcmVuOiBhLm5vZGUsXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIHByb3AgdGhhdCBlbmFibGVzIG9yIGRpc2FibGVzIGFwcGVhciBhbmltYXRpb25zXG4gICAqIGZvciBhbGwgY2hpbGRyZW4uIE5vdGUgdGhhdCBzcGVjaWZ5aW5nIHRoaXMgd2lsbCBvdmVycmlkZSBhbnkgZGVmYXVsdHMgc2V0XG4gICAqIG9uIGluZGl2aWR1YWwgY2hpbGRyZW4gVHJhbnNpdGlvbnMuXG4gICAqL1xuICBhcHBlYXI6IGEuYm9vbCxcbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgZW50ZXIgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgZW50ZXI6IGEuYm9vbCxcbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgZXhpdCBhbmltYXRpb25zXG4gICAqIGZvciBhbGwgY2hpbGRyZW4uIE5vdGUgdGhhdCBzcGVjaWZ5aW5nIHRoaXMgd2lsbCBvdmVycmlkZSBhbnkgZGVmYXVsdHMgc2V0XG4gICAqIG9uIGluZGl2aWR1YWwgY2hpbGRyZW4gVHJhbnNpdGlvbnMuXG4gICAqL1xuICBleGl0OiBhLmJvb2wsXG4gIC8qKlxuICAgKiBZb3UgbWF5IG5lZWQgdG8gYXBwbHkgcmVhY3RpdmUgdXBkYXRlcyB0byBhIGNoaWxkIGFzIGl0IGlzIGV4aXRpbmcuXG4gICAqIFRoaXMgaXMgZ2VuZXJhbGx5IGRvbmUgYnkgdXNpbmcgYGNsb25lRWxlbWVudGAgaG93ZXZlciBpbiB0aGUgY2FzZSBvZiBhbiBleGl0aW5nXG4gICAqIGNoaWxkIHRoZSBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBhbmQgbm90IGFjY2Vzc2libGUgdG8gdGhlIGNvbnN1bWVyLlxuICAgKlxuICAgKiBJZiB5b3UgZG8gbmVlZCB0byB1cGRhdGUgYSBjaGlsZCBhcyBpdCBsZWF2ZXMgeW91IGNhbiBwcm92aWRlIGEgYGNoaWxkRmFjdG9yeWBcbiAgICogdG8gd3JhcCBldmVyeSBjaGlsZCwgZXZlbiB0aGUgb25lcyB0aGF0IGFyZSBsZWF2aW5nLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihjaGlsZDogUmVhY3RFbGVtZW50KSAtPiBSZWFjdEVsZW1lbnRcbiAgICovXG4gIGNoaWxkRmFjdG9yeTogYS5mdW5jXG59IDoge307XG5Iby5kZWZhdWx0UHJvcHMgPSBlZDtcbmNvbnN0IHRkID0gKGUpID0+IGUuc2Nyb2xsVG9wO1xuZnVuY3Rpb24gdm4oZSwgdCkge1xuICBjb25zdCB7XG4gICAgdGltZW91dDogcixcbiAgICBlYXNpbmc6IG4sXG4gICAgc3R5bGU6IG8gPSB7fVxuICB9ID0gZTtcbiAgcmV0dXJuIHtcbiAgICBkdXJhdGlvbjogby50cmFuc2l0aW9uRHVyYXRpb24gPz8gKHR5cGVvZiByID09IFwibnVtYmVyXCIgPyByIDogclt0Lm1vZGVdIHx8IDApLFxuICAgIGVhc2luZzogby50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPz8gKHR5cGVvZiBuID09IFwib2JqZWN0XCIgPyBuW3QubW9kZV0gOiBuKSxcbiAgICBkZWxheTogby50cmFuc2l0aW9uRGVsYXlcbiAgfTtcbn1cbmZ1bmN0aW9uIHJkKGUpIHtcbiAgcmV0dXJuIFZlKFwiTXVpQ29sbGFwc2VcIiwgZSk7XG59XG5GZShcIk11aUNvbGxhcHNlXCIsIFtcInJvb3RcIiwgXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIiwgXCJlbnRlcmVkXCIsIFwiaGlkZGVuXCIsIFwid3JhcHBlclwiLCBcIndyYXBwZXJJbm5lclwiXSk7XG5jb25zdCBuZCA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvcmllbnRhdGlvbjogdCxcbiAgICBjbGFzc2VzOiByXG4gIH0gPSBlLCBuID0ge1xuICAgIHJvb3Q6IFtcInJvb3RcIiwgYCR7dH1gXSxcbiAgICBlbnRlcmVkOiBbXCJlbnRlcmVkXCJdLFxuICAgIGhpZGRlbjogW1wiaGlkZGVuXCJdLFxuICAgIHdyYXBwZXI6IFtcIndyYXBwZXJcIiwgYCR7dH1gXSxcbiAgICB3cmFwcGVySW5uZXI6IFtcIndyYXBwZXJJbm5lclwiLCBgJHt0fWBdXG4gIH07XG4gIHJldHVybiBHZShuLCByZCwgcik7XG59LCBvZCA9IGxlKFwiZGl2XCIsIHtcbiAgbmFtZTogXCJNdWlDb2xsYXBzZVwiLFxuICBzbG90OiBcIlJvb3RcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJTdGF0ZTogclxuICAgIH0gPSBlO1xuICAgIHJldHVybiBbdC5yb290LCB0W3Iub3JpZW50YXRpb25dLCByLnN0YXRlID09PSBcImVudGVyZWRcIiAmJiB0LmVudGVyZWQsIHIuc3RhdGUgPT09IFwiZXhpdGVkXCIgJiYgIXIuaW4gJiYgci5jb2xsYXBzZWRTaXplID09PSBcIjBweFwiICYmIHQuaGlkZGVuXTtcbiAgfVxufSkocWUoKHtcbiAgdGhlbWU6IGVcbn0pID0+ICh7XG4gIGhlaWdodDogMCxcbiAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gIHRyYW5zaXRpb246IGUudHJhbnNpdGlvbnMuY3JlYXRlKFwiaGVpZ2h0XCIpLFxuICB2YXJpYW50czogW3tcbiAgICBwcm9wczoge1xuICAgICAgb3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgdHJhbnNpdGlvbjogZS50cmFuc2l0aW9ucy5jcmVhdGUoXCJ3aWR0aFwiKVxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiB7XG4gICAgICBzdGF0ZTogXCJlbnRlcmVkXCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgb3ZlcmZsb3c6IFwidmlzaWJsZVwiXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHN0YXRlOiBcImVudGVyZWRcIixcbiAgICAgIG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiBcImF1dG9cIlxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+IHQuc3RhdGUgPT09IFwiZXhpdGVkXCIgJiYgIXQuaW4gJiYgdC5jb2xsYXBzZWRTaXplID09PSBcIjBweFwiLFxuICAgIHN0eWxlOiB7XG4gICAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiXG4gICAgfVxuICB9XVxufSkpKSwgaWQgPSBsZShcImRpdlwiLCB7XG4gIG5hbWU6IFwiTXVpQ29sbGFwc2VcIixcbiAgc2xvdDogXCJXcmFwcGVyXCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4gdC53cmFwcGVyXG59KSh7XG4gIC8vIEhhY2sgdG8gZ2V0IGNoaWxkcmVuIHdpdGggYSBuZWdhdGl2ZSBtYXJnaW4gdG8gbm90IGZhbHNpZnkgdGhlIGhlaWdodCBjb21wdXRhdGlvbi5cbiAgZGlzcGxheTogXCJmbGV4XCIsXG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6IHtcbiAgICAgIG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiBcImF1dG9cIixcbiAgICAgIGhlaWdodDogXCIxMDAlXCJcbiAgICB9XG4gIH1dXG59KSwgYWQgPSBsZShcImRpdlwiLCB7XG4gIG5hbWU6IFwiTXVpQ29sbGFwc2VcIixcbiAgc2xvdDogXCJXcmFwcGVySW5uZXJcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB0LndyYXBwZXJJbm5lclxufSkoe1xuICB3aWR0aDogXCIxMDAlXCIsXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiB7XG4gICAgICBvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogXCJhdXRvXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiXG4gICAgfVxuICB9XVxufSksIHhuID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IG4gPSBIZSh7XG4gICAgcHJvcHM6IHQsXG4gICAgbmFtZTogXCJNdWlDb2xsYXBzZVwiXG4gIH0pLCB7XG4gICAgYWRkRW5kTGlzdGVuZXI6IG8sXG4gICAgY2hpbGRyZW46IGksXG4gICAgY2xhc3NOYW1lOiBzLFxuICAgIGNvbGxhcHNlZFNpemU6IGMgPSBcIjBweFwiLFxuICAgIGNvbXBvbmVudDogbCxcbiAgICBlYXNpbmc6IHUsXG4gICAgaW46IHAsXG4gICAgb25FbnRlcjogbSxcbiAgICBvbkVudGVyZWQ6IGcsXG4gICAgb25FbnRlcmluZzogeCxcbiAgICBvbkV4aXQ6IHksXG4gICAgb25FeGl0ZWQ6IGYsXG4gICAgb25FeGl0aW5nOiBTLFxuICAgIG9yaWVudGF0aW9uOiBFID0gXCJ2ZXJ0aWNhbFwiLFxuICAgIHN0eWxlOiBQLFxuICAgIHRpbWVvdXQ6IFQgPSBkcy5zdGFuZGFyZCxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvcHJvcC10eXBlc1xuICAgIFRyYW5zaXRpb25Db21wb25lbnQ6IGIgPSBFdCxcbiAgICAuLi5oXG4gIH0gPSBuLCB3ID0ge1xuICAgIC4uLm4sXG4gICAgb3JpZW50YXRpb246IEUsXG4gICAgY29sbGFwc2VkU2l6ZTogY1xuICB9LCBrID0gbmQodyksIEwgPSBMcigpLCBCID0gRHQoKSwgZCA9IEMudXNlUmVmKG51bGwpLCBBID0gQy51c2VSZWYoKSwgRCA9IHR5cGVvZiBjID09IFwibnVtYmVyXCIgPyBgJHtjfXB4YCA6IGMsIGogPSBFID09PSBcImhvcml6b250YWxcIiwgVyA9IGogPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCB6ID0gQy51c2VSZWYobnVsbCksIFUgPSBhdChyLCB6KSwgViA9IChfKSA9PiAocSkgPT4ge1xuICAgIGlmIChfKSB7XG4gICAgICBjb25zdCBHID0gei5jdXJyZW50O1xuICAgICAgcSA9PT0gdm9pZCAwID8gXyhHKSA6IF8oRywgcSk7XG4gICAgfVxuICB9LCB0ZSA9ICgpID0+IGQuY3VycmVudCA/IGQuY3VycmVudFtqID8gXCJjbGllbnRXaWR0aFwiIDogXCJjbGllbnRIZWlnaHRcIl0gOiAwLCBGID0gVigoXywgcSkgPT4ge1xuICAgIGQuY3VycmVudCAmJiBqICYmIChkLmN1cnJlbnQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIpLCBfLnN0eWxlW1ddID0gRCwgbSAmJiBtKF8sIHEpO1xuICB9KSwgUiA9IFYoKF8sIHEpID0+IHtcbiAgICBjb25zdCBHID0gdGUoKTtcbiAgICBkLmN1cnJlbnQgJiYgaiAmJiAoZC5jdXJyZW50LnN0eWxlLnBvc2l0aW9uID0gXCJcIik7XG4gICAgY29uc3Qge1xuICAgICAgZHVyYXRpb246IHJlLFxuICAgICAgZWFzaW5nOiBaXG4gICAgfSA9IHZuKHtcbiAgICAgIHN0eWxlOiBQLFxuICAgICAgdGltZW91dDogVCxcbiAgICAgIGVhc2luZzogdVxuICAgIH0sIHtcbiAgICAgIG1vZGU6IFwiZW50ZXJcIlxuICAgIH0pO1xuICAgIGlmIChUID09PSBcImF1dG9cIikge1xuICAgICAgY29uc3QgYWUgPSBMLnRyYW5zaXRpb25zLmdldEF1dG9IZWlnaHREdXJhdGlvbihHKTtcbiAgICAgIF8uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7YWV9bXNgLCBBLmN1cnJlbnQgPSBhZTtcbiAgICB9IGVsc2VcbiAgICAgIF8uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdHlwZW9mIHJlID09IFwic3RyaW5nXCIgPyByZSA6IGAke3JlfW1zYDtcbiAgICBfLnN0eWxlW1ddID0gYCR7R31weGAsIF8uc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uID0gWiwgeCAmJiB4KF8sIHEpO1xuICB9KSwgSSA9IFYoKF8sIHEpID0+IHtcbiAgICBfLnN0eWxlW1ddID0gXCJhdXRvXCIsIGcgJiYgZyhfLCBxKTtcbiAgfSksIEogPSBWKChfKSA9PiB7XG4gICAgXy5zdHlsZVtXXSA9IGAke3RlKCl9cHhgLCB5ICYmIHkoXyk7XG4gIH0pLCBRID0gVihmKSwgSCA9IFYoKF8pID0+IHtcbiAgICBjb25zdCBxID0gdGUoKSwge1xuICAgICAgZHVyYXRpb246IEcsXG4gICAgICBlYXNpbmc6IHJlXG4gICAgfSA9IHZuKHtcbiAgICAgIHN0eWxlOiBQLFxuICAgICAgdGltZW91dDogVCxcbiAgICAgIGVhc2luZzogdVxuICAgIH0sIHtcbiAgICAgIG1vZGU6IFwiZXhpdFwiXG4gICAgfSk7XG4gICAgaWYgKFQgPT09IFwiYXV0b1wiKSB7XG4gICAgICBjb25zdCBaID0gTC50cmFuc2l0aW9ucy5nZXRBdXRvSGVpZ2h0RHVyYXRpb24ocSk7XG4gICAgICBfLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke1p9bXNgLCBBLmN1cnJlbnQgPSBaO1xuICAgIH0gZWxzZVxuICAgICAgXy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB0eXBlb2YgRyA9PSBcInN0cmluZ1wiID8gRyA6IGAke0d9bXNgO1xuICAgIF8uc3R5bGVbV10gPSBELCBfLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9IHJlLCBTICYmIFMoXyk7XG4gIH0pLCBYID0gKF8pID0+IHtcbiAgICBUID09PSBcImF1dG9cIiAmJiBCLnN0YXJ0KEEuY3VycmVudCB8fCAwLCBfKSwgbyAmJiBvKHouY3VycmVudCwgXyk7XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goYiwge1xuICAgIGluOiBwLFxuICAgIG9uRW50ZXI6IEYsXG4gICAgb25FbnRlcmVkOiBJLFxuICAgIG9uRW50ZXJpbmc6IFIsXG4gICAgb25FeGl0OiBKLFxuICAgIG9uRXhpdGVkOiBRLFxuICAgIG9uRXhpdGluZzogSCxcbiAgICBhZGRFbmRMaXN0ZW5lcjogWCxcbiAgICBub2RlUmVmOiB6LFxuICAgIHRpbWVvdXQ6IFQgPT09IFwiYXV0b1wiID8gbnVsbCA6IFQsXG4gICAgLi4uaCxcbiAgICBjaGlsZHJlbjogKF8sIHtcbiAgICAgIG93bmVyU3RhdGU6IHEsXG4gICAgICAuLi5HXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovIE4uanN4KG9kLCB7XG4gICAgICBhczogbCxcbiAgICAgIGNsYXNzTmFtZTogc2Uoay5yb290LCBzLCB7XG4gICAgICAgIGVudGVyZWQ6IGsuZW50ZXJlZCxcbiAgICAgICAgZXhpdGVkOiAhcCAmJiBEID09PSBcIjBweFwiICYmIGsuaGlkZGVuXG4gICAgICB9W19dKSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIFtqID8gXCJtaW5XaWR0aFwiIDogXCJtaW5IZWlnaHRcIl06IEQsXG4gICAgICAgIC4uLlBcbiAgICAgIH0sXG4gICAgICByZWY6IFUsXG4gICAgICBvd25lclN0YXRlOiB7XG4gICAgICAgIC4uLncsXG4gICAgICAgIHN0YXRlOiBfXG4gICAgICB9LFxuICAgICAgLi4uRyxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goaWQsIHtcbiAgICAgICAgb3duZXJTdGF0ZToge1xuICAgICAgICAgIC4uLncsXG4gICAgICAgICAgc3RhdGU6IF9cbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NOYW1lOiBrLndyYXBwZXIsXG4gICAgICAgIHJlZjogZCxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChhZCwge1xuICAgICAgICAgIG93bmVyU3RhdGU6IHtcbiAgICAgICAgICAgIC4uLncsXG4gICAgICAgICAgICBzdGF0ZTogX1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xhc3NOYW1lOiBrLndyYXBwZXJJbm5lcixcbiAgICAgICAgICBjaGlsZHJlbjogaVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICh4bi5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCICAgIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiAgICAg4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogQWRkIGEgY3VzdG9tIHRyYW5zaXRpb24gZW5kIHRyaWdnZXIuIENhbGxlZCB3aXRoIHRoZSB0cmFuc2l0aW9uaW5nIERPTVxuICAgKiBub2RlIGFuZCBhIGRvbmUgY2FsbGJhY2suIEFsbG93cyBmb3IgbW9yZSBmaW5lIGdyYWluZWQgdHJhbnNpdGlvbiBlbmRcbiAgICogbG9naWMuIE5vdGU6IFRpbWVvdXRzIGFyZSBzdGlsbCB1c2VkIGFzIGEgZmFsbGJhY2sgaWYgcHJvdmlkZWQuXG4gICAqL1xuICBhZGRFbmRMaXN0ZW5lcjogYS5mdW5jLFxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgbm9kZSB0byBiZSBjb2xsYXBzZWQuXG4gICAqL1xuICBjaGlsZHJlbjogYS5ub2RlLFxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVGhlIHdpZHRoIChob3Jpem9udGFsKSBvciBoZWlnaHQgKHZlcnRpY2FsKSBvZiB0aGUgY29udGFpbmVyIHdoZW4gY29sbGFwc2VkLlxuICAgKiBAZGVmYXVsdCAnMHB4J1xuICAgKi9cbiAgY29sbGFwc2VkU2l6ZTogYS5vbmVPZlR5cGUoW2EubnVtYmVyLCBhLnN0cmluZ10pLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgY29tcG9uZW50OiBKYSxcbiAgLyoqXG4gICAqIFRoZSB0cmFuc2l0aW9uIHRpbWluZyBmdW5jdGlvbi5cbiAgICogWW91IG1heSBzcGVjaWZ5IGEgc2luZ2xlIGVhc2luZyBvciBhIG9iamVjdCBjb250YWluaW5nIGVudGVyIGFuZCBleGl0IHZhbHVlcy5cbiAgICovXG4gIGVhc2luZzogYS5vbmVPZlR5cGUoW2Euc2hhcGUoe1xuICAgIGVudGVyOiBhLnN0cmluZyxcbiAgICBleGl0OiBhLnN0cmluZ1xuICB9KSwgYS5zdHJpbmddKSxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCB3aWxsIHRyYW5zaXRpb24gaW4uXG4gICAqL1xuICBpbjogYS5ib29sLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FbnRlcjogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FbnRlcmVkOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkVudGVyaW5nOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkV4aXQ6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRXhpdGVkOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkV4aXRpbmc6IGEuZnVuYyxcbiAgLyoqXG4gICAqIFRoZSB0cmFuc2l0aW9uIG9yaWVudGF0aW9uLlxuICAgKiBAZGVmYXVsdCAndmVydGljYWwnXG4gICAqL1xuICBvcmllbnRhdGlvbjogYS5vbmVPZihbXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIl0pLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3R5bGU6IGEub2JqZWN0LFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSksXG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gZm9yIHRoZSB0cmFuc2l0aW9uLCBpbiBtaWxsaXNlY29uZHMuXG4gICAqIFlvdSBtYXkgc3BlY2lmeSBhIHNpbmdsZSB0aW1lb3V0IGZvciBhbGwgdHJhbnNpdGlvbnMsIG9yIGluZGl2aWR1YWxseSB3aXRoIGFuIG9iamVjdC5cbiAgICpcbiAgICogU2V0IHRvICdhdXRvJyB0byBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSB0cmFuc2l0aW9uIHRpbWUgYmFzZWQgb24gaGVpZ2h0LlxuICAgKiBAZGVmYXVsdCBkdXJhdGlvbi5zdGFuZGFyZFxuICAgKi9cbiAgdGltZW91dDogYS5vbmVPZlR5cGUoW2Eub25lT2YoW1wiYXV0b1wiXSksIGEubnVtYmVyLCBhLnNoYXBlKHtcbiAgICBhcHBlYXI6IGEubnVtYmVyLFxuICAgIGVudGVyOiBhLm51bWJlcixcbiAgICBleGl0OiBhLm51bWJlclxuICB9KV0pXG59KTtcbnhuICYmICh4bi5tdWlTdXBwb3J0QXV0byA9ICEwKTtcbmZ1bmN0aW9uIEJ0KGUsIHQpIHtcbiAgY29uc3Qge1xuICAgIGNsYXNzTmFtZTogcixcbiAgICBlbGVtZW50VHlwZTogbixcbiAgICBvd25lclN0YXRlOiBvLFxuICAgIGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6IGksXG4gICAgaW50ZXJuYWxGb3J3YXJkZWRQcm9wczogcyxcbiAgICBzaG91bGRGb3J3YXJkQ29tcG9uZW50UHJvcDogYyA9ICExLFxuICAgIC4uLmxcbiAgfSA9IHQsIHtcbiAgICBjb21wb25lbnQ6IHUsXG4gICAgc2xvdHM6IHAgPSB7XG4gICAgICBbZV06IHZvaWQgMFxuICAgIH0sXG4gICAgc2xvdFByb3BzOiBtID0ge1xuICAgICAgW2VdOiB2b2lkIDBcbiAgICB9LFxuICAgIC4uLmdcbiAgfSA9IGksIHggPSBwW2VdIHx8IG4sIHkgPSBycyhtW2VdLCBvKSwge1xuICAgIHByb3BzOiB7XG4gICAgICBjb21wb25lbnQ6IGYsXG4gICAgICAuLi5TXG4gICAgfSxcbiAgICBpbnRlcm5hbFJlZjogRVxuICB9ID0gdHMoe1xuICAgIGNsYXNzTmFtZTogcixcbiAgICAuLi5sLFxuICAgIGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6IGUgPT09IFwicm9vdFwiID8gZyA6IHZvaWQgMCxcbiAgICBleHRlcm5hbFNsb3RQcm9wczogeVxuICB9KSwgUCA9IGF0KEUsIHkgPT0gbnVsbCA/IHZvaWQgMCA6IHkucmVmLCB0LnJlZiksIFQgPSBlID09PSBcInJvb3RcIiA/IGYgfHwgdSA6IGYsIGIgPSBlcyh4LCB7XG4gICAgLi4uZSA9PT0gXCJyb290XCIgJiYgIXUgJiYgIXBbZV0gJiYgcyxcbiAgICAuLi5lICE9PSBcInJvb3RcIiAmJiAhcFtlXSAmJiBzLFxuICAgIC4uLlMsXG4gICAgLi4uVCAmJiAhYyAmJiB7XG4gICAgICBhczogVFxuICAgIH0sXG4gICAgLi4uVCAmJiBjICYmIHtcbiAgICAgIGNvbXBvbmVudDogVFxuICAgIH0sXG4gICAgcmVmOiBQXG4gIH0sIG8pO1xuICByZXR1cm4gW3gsIGJdO1xufVxuY2xhc3MgU24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjcih0aGlzLCBcIm1vdW50RWZmZWN0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuc2hvdWxkTW91bnQgJiYgIXRoaXMuZGlkTW91bnQgJiYgdGhpcy5yZWYuY3VycmVudCAhPT0gbnVsbCAmJiAodGhpcy5kaWRNb3VudCA9ICEwLCB0aGlzLm1vdW50ZWQucmVzb2x2ZSgpKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IG51bGxcbiAgICB9LCB0aGlzLm1vdW50ZWQgPSBudWxsLCB0aGlzLmRpZE1vdW50ID0gITEsIHRoaXMuc2hvdWxkTW91bnQgPSAhMSwgdGhpcy5zZXRTaG91bGRNb3VudCA9IG51bGw7XG4gIH1cbiAgLyoqIFJlYWN0IHJlZiB0byB0aGUgcmlwcGxlIGluc3RhbmNlICovXG4gIC8qKiBJZiB0aGUgcmlwcGxlIGNvbXBvbmVudCBzaG91bGQgYmUgbW91bnRlZCAqL1xuICAvKiogUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHJpcHBsZSBjb21wb25lbnQgaXMgbW91bnRlZCAqL1xuICAvKiogSWYgdGhlIHJpcHBsZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCAqL1xuICAvKiogUmVhY3Qgc3RhdGUgaG9vayBzZXR0ZXIgKi9cbiAgc3RhdGljIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IFNuKCk7XG4gIH1cbiAgc3RhdGljIHVzZSgpIHtcbiAgICBjb25zdCB0ID0gWmEoU24uY3JlYXRlKS5jdXJyZW50LCBbciwgbl0gPSBDLnVzZVN0YXRlKCExKTtcbiAgICByZXR1cm4gdC5zaG91bGRNb3VudCA9IHIsIHQuc2V0U2hvdWxkTW91bnQgPSBuLCBDLnVzZUVmZmVjdCh0Lm1vdW50RWZmZWN0LCBbcl0pLCB0O1xuICB9XG4gIG1vdW50KCkge1xuICAgIHJldHVybiB0aGlzLm1vdW50ZWQgfHwgKHRoaXMubW91bnRlZCA9IGNkKCksIHRoaXMuc2hvdWxkTW91bnQgPSAhMCwgdGhpcy5zZXRTaG91bGRNb3VudCh0aGlzLnNob3VsZE1vdW50KSksIHRoaXMubW91bnRlZDtcbiAgfVxuICAvKiBSaXBwbGUgQVBJICovXG4gIHN0YXJ0KC4uLnQpIHtcbiAgICB0aGlzLm1vdW50KCkudGhlbigoKSA9PiB7XG4gICAgICB2YXIgcjtcbiAgICAgIHJldHVybiAociA9IHRoaXMucmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiByLnN0YXJ0KC4uLnQpO1xuICAgIH0pO1xuICB9XG4gIHN0b3AoLi4udCkge1xuICAgIHRoaXMubW91bnQoKS50aGVuKCgpID0+IHtcbiAgICAgIHZhciByO1xuICAgICAgcmV0dXJuIChyID0gdGhpcy5yZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuc3RvcCguLi50KTtcbiAgICB9KTtcbiAgfVxuICBwdWxzYXRlKC4uLnQpIHtcbiAgICB0aGlzLm1vdW50KCkudGhlbigoKSA9PiB7XG4gICAgICB2YXIgcjtcbiAgICAgIHJldHVybiAociA9IHRoaXMucmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiByLnB1bHNhdGUoLi4udCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNkKCkge1xuICByZXR1cm4gU24udXNlKCk7XG59XG5mdW5jdGlvbiBjZCgpIHtcbiAgbGV0IGUsIHQ7XG4gIGNvbnN0IHIgPSBuZXcgUHJvbWlzZSgobiwgbykgPT4ge1xuICAgIGUgPSBuLCB0ID0gbztcbiAgfSk7XG4gIHJldHVybiByLnJlc29sdmUgPSBlLCByLnJlamVjdCA9IHQsIHI7XG59XG5mdW5jdGlvbiB4cyhlKSB7XG4gIGNvbnN0IHtcbiAgICBjbGFzc05hbWU6IHQsXG4gICAgY2xhc3NlczogcixcbiAgICBwdWxzYXRlOiBuID0gITEsXG4gICAgcmlwcGxlWDogbyxcbiAgICByaXBwbGVZOiBpLFxuICAgIHJpcHBsZVNpemU6IHMsXG4gICAgaW46IGMsXG4gICAgb25FeGl0ZWQ6IGwsXG4gICAgdGltZW91dDogdVxuICB9ID0gZSwgW3AsIG1dID0gQy51c2VTdGF0ZSghMSksIGcgPSBzZSh0LCByLnJpcHBsZSwgci5yaXBwbGVWaXNpYmxlLCBuICYmIHIucmlwcGxlUHVsc2F0ZSksIHggPSB7XG4gICAgd2lkdGg6IHMsXG4gICAgaGVpZ2h0OiBzLFxuICAgIHRvcDogLShzIC8gMikgKyBpLFxuICAgIGxlZnQ6IC0ocyAvIDIpICsgb1xuICB9LCB5ID0gc2Uoci5jaGlsZCwgcCAmJiByLmNoaWxkTGVhdmluZywgbiAmJiByLmNoaWxkUHVsc2F0ZSk7XG4gIHJldHVybiAhYyAmJiAhcCAmJiBtKCEwKSwgQy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghYyAmJiBsICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGYgPSBzZXRUaW1lb3V0KGwsIHUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGYpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtsLCBjLCB1XSksIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogZyxcbiAgICBzdHlsZTogeCxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KFwic3BhblwiLCB7XG4gICAgICBjbGFzc05hbWU6IHlcbiAgICB9KVxuICB9KTtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoeHMucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogYS5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIEBpZ25vcmUgLSBpbmplY3RlZCBmcm9tIFRyYW5zaXRpb25Hcm91cFxuICAgKi9cbiAgaW46IGEuYm9vbCxcbiAgLyoqXG4gICAqIEBpZ25vcmUgLSBpbmplY3RlZCBmcm9tIFRyYW5zaXRpb25Hcm91cFxuICAgKi9cbiAgb25FeGl0ZWQ6IGEuZnVuYyxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHJpcHBsZSBwdWxzYXRlcywgdHlwaWNhbGx5IGluZGljYXRpbmcgdGhlIGtleWJvYXJkIGZvY3VzIHN0YXRlIG9mIGFuIGVsZW1lbnQuXG4gICAqL1xuICBwdWxzYXRlOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBEaWFtZXRlciBvZiB0aGUgcmlwcGxlLlxuICAgKi9cbiAgcmlwcGxlU2l6ZTogYS5udW1iZXIsXG4gIC8qKlxuICAgKiBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSByaXBwbGUgY2VudGVyLlxuICAgKi9cbiAgcmlwcGxlWDogYS5udW1iZXIsXG4gIC8qKlxuICAgKiBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgcmlwcGxlIGNlbnRlci5cbiAgICovXG4gIHJpcHBsZVk6IGEubnVtYmVyLFxuICAvKipcbiAgICogZXhpdCBkZWxheVxuICAgKi9cbiAgdGltZW91dDogYS5udW1iZXIuaXNSZXF1aXJlZFxufSk7XG5jb25zdCBudCA9IEZlKFwiTXVpVG91Y2hSaXBwbGVcIiwgW1wicm9vdFwiLCBcInJpcHBsZVwiLCBcInJpcHBsZVZpc2libGVcIiwgXCJyaXBwbGVQdWxzYXRlXCIsIFwiY2hpbGRcIiwgXCJjaGlsZExlYXZpbmdcIiwgXCJjaGlsZFB1bHNhdGVcIl0pLCBobyA9IDU1MCwgbGQgPSA4MCwgdWQgPSBJcmBcbiAgMCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XG4gICAgb3BhY2l0eTogMC4xO1xuICB9XG5cbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcbiAgICBvcGFjaXR5OiAwLjM7XG4gIH1cbmAsIGZkID0gSXJgXG4gIDAlIHtcbiAgICBvcGFjaXR5OiAxO1xuICB9XG5cbiAgMTAwJSB7XG4gICAgb3BhY2l0eTogMDtcbiAgfVxuYCwgZGQgPSBJcmBcbiAgMCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gIH1cblxuICA1MCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMC45Mik7XG4gIH1cblxuICAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xuICB9XG5gLCBwZCA9IGxlKFwic3BhblwiLCB7XG4gIG5hbWU6IFwiTXVpVG91Y2hSaXBwbGVcIixcbiAgc2xvdDogXCJSb290XCJcbn0pKHtcbiAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICB6SW5kZXg6IDAsXG4gIHRvcDogMCxcbiAgcmlnaHQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgbGVmdDogMCxcbiAgYm9yZGVyUmFkaXVzOiBcImluaGVyaXRcIlxufSksIG1kID0gbGUoeHMsIHtcbiAgbmFtZTogXCJNdWlUb3VjaFJpcHBsZVwiLFxuICBzbG90OiBcIlJpcHBsZVwiXG59KWBcbiAgb3BhY2l0eTogMDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuXG4gICYuJHtudC5yaXBwbGVWaXNpYmxlfSB7XG4gICAgb3BhY2l0eTogMC4zO1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gICAgYW5pbWF0aW9uLW5hbWU6ICR7dWR9O1xuICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogJHtob31tcztcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiAkeyh7XG4gIHRoZW1lOiBlXG59KSA9PiBlLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlSW5PdXR9O1xuICB9XG5cbiAgJi4ke250LnJpcHBsZVB1bHNhdGV9IHtcbiAgICBhbmltYXRpb24tZHVyYXRpb246ICR7KHtcbiAgdGhlbWU6IGVcbn0pID0+IGUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlcn1tcztcbiAgfVxuXG4gICYgLiR7bnQuY2hpbGR9IHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogY3VycmVudENvbG9yO1xuICB9XG5cbiAgJiAuJHtudC5jaGlsZExlYXZpbmd9IHtcbiAgICBvcGFjaXR5OiAwO1xuICAgIGFuaW1hdGlvbi1uYW1lOiAke2ZkfTtcbiAgICBhbmltYXRpb24tZHVyYXRpb246ICR7aG99bXM7XG4gICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogJHsoe1xuICB0aGVtZTogZVxufSkgPT4gZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZUluT3V0fTtcbiAgfVxuXG4gICYgLiR7bnQuY2hpbGRQdWxzYXRlfSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIC8qIEBub2ZsaXAgKi9cbiAgICBsZWZ0OiAwcHg7XG4gICAgdG9wOiAwO1xuICAgIGFuaW1hdGlvbi1uYW1lOiAke2RkfTtcbiAgICBhbmltYXRpb24tZHVyYXRpb246IDI1MDBtcztcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiAkeyh7XG4gIHRoZW1lOiBlXG59KSA9PiBlLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlSW5PdXR9O1xuICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xuICAgIGFuaW1hdGlvbi1kZWxheTogMjAwbXM7XG4gIH1cbmAsIFNzID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IG4gPSBIZSh7XG4gICAgcHJvcHM6IHQsXG4gICAgbmFtZTogXCJNdWlUb3VjaFJpcHBsZVwiXG4gIH0pLCB7XG4gICAgY2VudGVyOiBvID0gITEsXG4gICAgY2xhc3NlczogaSA9IHt9LFxuICAgIGNsYXNzTmFtZTogcyxcbiAgICAuLi5jXG4gIH0gPSBuLCBbbCwgdV0gPSBDLnVzZVN0YXRlKFtdKSwgcCA9IEMudXNlUmVmKDApLCBtID0gQy51c2VSZWYobnVsbCk7XG4gIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBtLmN1cnJlbnQgJiYgKG0uY3VycmVudCgpLCBtLmN1cnJlbnQgPSBudWxsKTtcbiAgfSwgW2xdKTtcbiAgY29uc3QgZyA9IEMudXNlUmVmKCExKSwgeCA9IER0KCksIHkgPSBDLnVzZVJlZihudWxsKSwgZiA9IEMudXNlUmVmKG51bGwpLCBTID0gQy51c2VDYWxsYmFjaygoYikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHB1bHNhdGU6IGgsXG4gICAgICByaXBwbGVYOiB3LFxuICAgICAgcmlwcGxlWTogayxcbiAgICAgIHJpcHBsZVNpemU6IEwsXG4gICAgICBjYjogQlxuICAgIH0gPSBiO1xuICAgIHUoKGQpID0+IFsuLi5kLCAvKiBAX19QVVJFX18gKi8gTi5qc3gobWQsIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgcmlwcGxlOiBzZShpLnJpcHBsZSwgbnQucmlwcGxlKSxcbiAgICAgICAgcmlwcGxlVmlzaWJsZTogc2UoaS5yaXBwbGVWaXNpYmxlLCBudC5yaXBwbGVWaXNpYmxlKSxcbiAgICAgICAgcmlwcGxlUHVsc2F0ZTogc2UoaS5yaXBwbGVQdWxzYXRlLCBudC5yaXBwbGVQdWxzYXRlKSxcbiAgICAgICAgY2hpbGQ6IHNlKGkuY2hpbGQsIG50LmNoaWxkKSxcbiAgICAgICAgY2hpbGRMZWF2aW5nOiBzZShpLmNoaWxkTGVhdmluZywgbnQuY2hpbGRMZWF2aW5nKSxcbiAgICAgICAgY2hpbGRQdWxzYXRlOiBzZShpLmNoaWxkUHVsc2F0ZSwgbnQuY2hpbGRQdWxzYXRlKVxuICAgICAgfSxcbiAgICAgIHRpbWVvdXQ6IGhvLFxuICAgICAgcHVsc2F0ZTogaCxcbiAgICAgIHJpcHBsZVg6IHcsXG4gICAgICByaXBwbGVZOiBrLFxuICAgICAgcmlwcGxlU2l6ZTogTFxuICAgIH0sIHAuY3VycmVudCldKSwgcC5jdXJyZW50ICs9IDEsIG0uY3VycmVudCA9IEI7XG4gIH0sIFtpXSksIEUgPSBDLnVzZUNhbGxiYWNrKChiID0ge30sIGggPSB7fSwgdyA9ICgpID0+IHtcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHB1bHNhdGU6IGsgPSAhMSxcbiAgICAgIGNlbnRlcjogTCA9IG8gfHwgaC5wdWxzYXRlLFxuICAgICAgZmFrZUVsZW1lbnQ6IEIgPSAhMVxuICAgICAgLy8gRm9yIHRlc3QgcHVycG9zZXNcbiAgICB9ID0gaDtcbiAgICBpZiAoKGIgPT0gbnVsbCA/IHZvaWQgMCA6IGIudHlwZSkgPT09IFwibW91c2Vkb3duXCIgJiYgZy5jdXJyZW50KSB7XG4gICAgICBnLmN1cnJlbnQgPSAhMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKGIgPT0gbnVsbCA/IHZvaWQgMCA6IGIudHlwZSkgPT09IFwidG91Y2hzdGFydFwiICYmIChnLmN1cnJlbnQgPSAhMCk7XG4gICAgY29uc3QgZCA9IEIgPyBudWxsIDogZi5jdXJyZW50LCBBID0gZCA/IGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIGxldCBELCBqLCBXO1xuICAgIGlmIChMIHx8IGIgPT09IHZvaWQgMCB8fCBiLmNsaWVudFggPT09IDAgJiYgYi5jbGllbnRZID09PSAwIHx8ICFiLmNsaWVudFggJiYgIWIudG91Y2hlcylcbiAgICAgIEQgPSBNYXRoLnJvdW5kKEEud2lkdGggLyAyKSwgaiA9IE1hdGgucm91bmQoQS5oZWlnaHQgLyAyKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WDogeixcbiAgICAgICAgY2xpZW50WTogVVxuICAgICAgfSA9IGIudG91Y2hlcyAmJiBiLnRvdWNoZXMubGVuZ3RoID4gMCA/IGIudG91Y2hlc1swXSA6IGI7XG4gICAgICBEID0gTWF0aC5yb3VuZCh6IC0gQS5sZWZ0KSwgaiA9IE1hdGgucm91bmQoVSAtIEEudG9wKTtcbiAgICB9XG4gICAgaWYgKEwpXG4gICAgICBXID0gTWF0aC5zcXJ0KCgyICogQS53aWR0aCAqKiAyICsgQS5oZWlnaHQgKiogMikgLyAzKSwgVyAlIDIgPT09IDAgJiYgKFcgKz0gMSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB6ID0gTWF0aC5tYXgoTWF0aC5hYnMoKGQgPyBkLmNsaWVudFdpZHRoIDogMCkgLSBEKSwgRCkgKiAyICsgMiwgVSA9IE1hdGgubWF4KE1hdGguYWJzKChkID8gZC5jbGllbnRIZWlnaHQgOiAwKSAtIGopLCBqKSAqIDIgKyAyO1xuICAgICAgVyA9IE1hdGguc3FydCh6ICoqIDIgKyBVICoqIDIpO1xuICAgIH1cbiAgICBiICE9IG51bGwgJiYgYi50b3VjaGVzID8geS5jdXJyZW50ID09PSBudWxsICYmICh5LmN1cnJlbnQgPSAoKSA9PiB7XG4gICAgICBTKHtcbiAgICAgICAgcHVsc2F0ZTogayxcbiAgICAgICAgcmlwcGxlWDogRCxcbiAgICAgICAgcmlwcGxlWTogaixcbiAgICAgICAgcmlwcGxlU2l6ZTogVyxcbiAgICAgICAgY2I6IHdcbiAgICAgIH0pO1xuICAgIH0sIHguc3RhcnQobGQsICgpID0+IHtcbiAgICAgIHkuY3VycmVudCAmJiAoeS5jdXJyZW50KCksIHkuY3VycmVudCA9IG51bGwpO1xuICAgIH0pKSA6IFMoe1xuICAgICAgcHVsc2F0ZTogayxcbiAgICAgIHJpcHBsZVg6IEQsXG4gICAgICByaXBwbGVZOiBqLFxuICAgICAgcmlwcGxlU2l6ZTogVyxcbiAgICAgIGNiOiB3XG4gICAgfSk7XG4gIH0sIFtvLCBTLCB4XSksIFAgPSBDLnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBFKHt9LCB7XG4gICAgICBwdWxzYXRlOiAhMFxuICAgIH0pO1xuICB9LCBbRV0pLCBUID0gQy51c2VDYWxsYmFjaygoYiwgaCkgPT4ge1xuICAgIGlmICh4LmNsZWFyKCksIChiID09IG51bGwgPyB2b2lkIDAgOiBiLnR5cGUpID09PSBcInRvdWNoZW5kXCIgJiYgeS5jdXJyZW50KSB7XG4gICAgICB5LmN1cnJlbnQoKSwgeS5jdXJyZW50ID0gbnVsbCwgeC5zdGFydCgwLCAoKSA9PiB7XG4gICAgICAgIFQoYiwgaCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgeS5jdXJyZW50ID0gbnVsbCwgdSgodykgPT4gdy5sZW5ndGggPiAwID8gdy5zbGljZSgxKSA6IHcpLCBtLmN1cnJlbnQgPSBoO1xuICB9LCBbeF0pO1xuICByZXR1cm4gQy51c2VJbXBlcmF0aXZlSGFuZGxlKHIsICgpID0+ICh7XG4gICAgcHVsc2F0ZTogUCxcbiAgICBzdGFydDogRSxcbiAgICBzdG9wOiBUXG4gIH0pLCBbUCwgRSwgVF0pLCAvKiBAX19QVVJFX18gKi8gTi5qc3gocGQsIHtcbiAgICBjbGFzc05hbWU6IHNlKG50LnJvb3QsIGkucm9vdCwgcyksXG4gICAgcmVmOiBmLFxuICAgIC4uLmMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChIbywge1xuICAgICAgY29tcG9uZW50OiBudWxsLFxuICAgICAgZXhpdDogITAsXG4gICAgICBjaGlsZHJlbjogbFxuICAgIH0pXG4gIH0pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKFNzLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHJpcHBsZSBzdGFydHMgYXQgdGhlIGNlbnRlciBvZiB0aGUgY29tcG9uZW50XG4gICAqIHJhdGhlciB0aGFuIGF0IHRoZSBwb2ludCBvZiBpbnRlcmFjdGlvbi5cbiAgICovXG4gIGNlbnRlcjogYS5ib29sLFxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IGEuc3RyaW5nXG59KTtcbmZ1bmN0aW9uIGhkKGUpIHtcbiAgcmV0dXJuIFZlKFwiTXVpQnV0dG9uQmFzZVwiLCBlKTtcbn1cbmNvbnN0IGdkID0gRmUoXCJNdWlCdXR0b25CYXNlXCIsIFtcInJvb3RcIiwgXCJkaXNhYmxlZFwiLCBcImZvY3VzVmlzaWJsZVwiXSksIHlkID0gKGUpID0+IHtcbiAgY29uc3Qge1xuICAgIGRpc2FibGVkOiB0LFxuICAgIGZvY3VzVmlzaWJsZTogcixcbiAgICBmb2N1c1Zpc2libGVDbGFzc05hbWU6IG4sXG4gICAgY2xhc3Nlczogb1xuICB9ID0gZSwgcyA9IEdlKHtcbiAgICByb290OiBbXCJyb290XCIsIHQgJiYgXCJkaXNhYmxlZFwiLCByICYmIFwiZm9jdXNWaXNpYmxlXCJdXG4gIH0sIGhkLCBvKTtcbiAgcmV0dXJuIHIgJiYgbiAmJiAocy5yb290ICs9IGAgJHtufWApLCBzO1xufSwgYmQgPSBsZShcImJ1dHRvblwiLCB7XG4gIG5hbWU6IFwiTXVpQnV0dG9uQmFzZVwiLFxuICBzbG90OiBcIlJvb3RcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB0LnJvb3Rcbn0pKHtcbiAgZGlzcGxheTogXCJpbmxpbmUtZmxleFwiLFxuICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gIC8vIFJlc2V0IGRlZmF1bHQgdmFsdWVcbiAgLy8gV2UgZGlzYWJsZSB0aGUgZm9jdXMgcmluZyBmb3IgbW91c2UsIHRvdWNoIGFuZCBrZXlib2FyZCB1c2Vycy5cbiAgb3V0bGluZTogMCxcbiAgYm9yZGVyOiAwLFxuICBtYXJnaW46IDAsXG4gIC8vIFJlbW92ZSB0aGUgbWFyZ2luIGluIFNhZmFyaVxuICBib3JkZXJSYWRpdXM6IDAsXG4gIHBhZGRpbmc6IDAsXG4gIC8vIFJlbW92ZSB0aGUgcGFkZGluZyBpbiBGaXJlZm94XG4gIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICBNb3pBcHBlYXJhbmNlOiBcIm5vbmVcIixcbiAgLy8gUmVzZXRcbiAgV2Via2l0QXBwZWFyYW5jZTogXCJub25lXCIsXG4gIC8vIFJlc2V0XG4gIHRleHREZWNvcmF0aW9uOiBcIm5vbmVcIixcbiAgLy8gU28gd2UgdGFrZSBwcmVjZWRlbnQgb3ZlciB0aGUgc3R5bGUgb2YgYSBuYXRpdmUgPGEgLz4gZWxlbWVudC5cbiAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICBcIiY6Oi1tb3otZm9jdXMtaW5uZXJcIjoge1xuICAgIGJvcmRlclN0eWxlOiBcIm5vbmVcIlxuICAgIC8vIFJlbW92ZSBGaXJlZm94IGRvdHRlZCBvdXRsaW5lLlxuICB9LFxuICBbYCYuJHtnZC5kaXNhYmxlZH1gXToge1xuICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgIC8vIERpc2FibGUgbGluayBpbnRlcmFjdGlvbnNcbiAgICBjdXJzb3I6IFwiZGVmYXVsdFwiXG4gIH0sXG4gIFwiQG1lZGlhIHByaW50XCI6IHtcbiAgICBjb2xvckFkanVzdDogXCJleGFjdFwiXG4gIH1cbn0pLCAkciA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCBuID0gSGUoe1xuICAgIHByb3BzOiB0LFxuICAgIG5hbWU6IFwiTXVpQnV0dG9uQmFzZVwiXG4gIH0pLCB7XG4gICAgYWN0aW9uOiBvLFxuICAgIGNlbnRlclJpcHBsZTogaSA9ICExLFxuICAgIGNoaWxkcmVuOiBzLFxuICAgIGNsYXNzTmFtZTogYyxcbiAgICBjb21wb25lbnQ6IGwgPSBcImJ1dHRvblwiLFxuICAgIGRpc2FibGVkOiB1ID0gITEsXG4gICAgZGlzYWJsZVJpcHBsZTogcCA9ICExLFxuICAgIGRpc2FibGVUb3VjaFJpcHBsZTogbSA9ICExLFxuICAgIGZvY3VzUmlwcGxlOiBnID0gITEsXG4gICAgZm9jdXNWaXNpYmxlQ2xhc3NOYW1lOiB4LFxuICAgIExpbmtDb21wb25lbnQ6IHkgPSBcImFcIixcbiAgICBvbkJsdXI6IGYsXG4gICAgb25DbGljazogUyxcbiAgICBvbkNvbnRleHRNZW51OiBFLFxuICAgIG9uRHJhZ0xlYXZlOiBQLFxuICAgIG9uRm9jdXM6IFQsXG4gICAgb25Gb2N1c1Zpc2libGU6IGIsXG4gICAgb25LZXlEb3duOiBoLFxuICAgIG9uS2V5VXA6IHcsXG4gICAgb25Nb3VzZURvd246IGssXG4gICAgb25Nb3VzZUxlYXZlOiBMLFxuICAgIG9uTW91c2VVcDogQixcbiAgICBvblRvdWNoRW5kOiBkLFxuICAgIG9uVG91Y2hNb3ZlOiBBLFxuICAgIG9uVG91Y2hTdGFydDogRCxcbiAgICB0YWJJbmRleDogaiA9IDAsXG4gICAgVG91Y2hSaXBwbGVQcm9wczogVyxcbiAgICB0b3VjaFJpcHBsZVJlZjogeixcbiAgICB0eXBlOiBVLFxuICAgIC4uLlZcbiAgfSA9IG4sIHRlID0gQy51c2VSZWYobnVsbCksIEYgPSBzZCgpLCBSID0gYXQoRi5yZWYsIHopLCBbSSwgSl0gPSBDLnVzZVN0YXRlKCExKTtcbiAgdSAmJiBJICYmIEooITEpLCBDLnVzZUltcGVyYXRpdmVIYW5kbGUobywgKCkgPT4gKHtcbiAgICBmb2N1c1Zpc2libGU6ICgpID0+IHtcbiAgICAgIEooITApLCB0ZS5jdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuICB9KSwgW10pO1xuICBjb25zdCBRID0gRi5zaG91bGRNb3VudCAmJiAhcCAmJiAhdTtcbiAgQy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIEkgJiYgZyAmJiAhcCAmJiBGLnB1bHNhdGUoKTtcbiAgfSwgW3AsIGcsIEksIEZdKTtcbiAgY29uc3QgSCA9IFR0KEYsIFwic3RhcnRcIiwgaywgbSksIFggPSBUdChGLCBcInN0b3BcIiwgRSwgbSksIF8gPSBUdChGLCBcInN0b3BcIiwgUCwgbSksIHEgPSBUdChGLCBcInN0b3BcIiwgQiwgbSksIEcgPSBUdChGLCBcInN0b3BcIiwgKE0pID0+IHtcbiAgICBJICYmIE0ucHJldmVudERlZmF1bHQoKSwgTCAmJiBMKE0pO1xuICB9LCBtKSwgcmUgPSBUdChGLCBcInN0YXJ0XCIsIEQsIG0pLCBaID0gVHQoRiwgXCJzdG9wXCIsIGQsIG0pLCBhZSA9IFR0KEYsIFwic3RvcFwiLCBBLCBtKSwgTyA9IFR0KEYsIFwic3RvcFwiLCAoTSkgPT4ge1xuICAgIGhuKE0udGFyZ2V0KSB8fCBKKCExKSwgZiAmJiBmKE0pO1xuICB9LCAhMSksIHllID0gUXQoKE0pID0+IHtcbiAgICB0ZS5jdXJyZW50IHx8ICh0ZS5jdXJyZW50ID0gTS5jdXJyZW50VGFyZ2V0KSwgaG4oTS50YXJnZXQpICYmIChKKCEwKSwgYiAmJiBiKE0pKSwgVCAmJiBUKE0pO1xuICB9KSwgRWUgPSAoKSA9PiB7XG4gICAgY29uc3QgTSA9IHRlLmN1cnJlbnQ7XG4gICAgcmV0dXJuIGwgJiYgbCAhPT0gXCJidXR0b25cIiAmJiAhKE0udGFnTmFtZSA9PT0gXCJBXCIgJiYgTS5ocmVmKTtcbiAgfSwgTWUgPSBRdCgoTSkgPT4ge1xuICAgIGcgJiYgIU0ucmVwZWF0ICYmIEkgJiYgTS5rZXkgPT09IFwiIFwiICYmIEYuc3RvcChNLCAoKSA9PiB7XG4gICAgICBGLnN0YXJ0KE0pO1xuICAgIH0pLCBNLnRhcmdldCA9PT0gTS5jdXJyZW50VGFyZ2V0ICYmIEVlKCkgJiYgTS5rZXkgPT09IFwiIFwiICYmIE0ucHJldmVudERlZmF1bHQoKSwgaCAmJiBoKE0pLCBNLnRhcmdldCA9PT0gTS5jdXJyZW50VGFyZ2V0ICYmIEVlKCkgJiYgTS5rZXkgPT09IFwiRW50ZXJcIiAmJiAhdSAmJiAoTS5wcmV2ZW50RGVmYXVsdCgpLCBTICYmIFMoTSkpO1xuICB9KSwgUWUgPSBRdCgoTSkgPT4ge1xuICAgIGcgJiYgTS5rZXkgPT09IFwiIFwiICYmIEkgJiYgIU0uZGVmYXVsdFByZXZlbnRlZCAmJiBGLnN0b3AoTSwgKCkgPT4ge1xuICAgICAgRi5wdWxzYXRlKE0pO1xuICAgIH0pLCB3ICYmIHcoTSksIFMgJiYgTS50YXJnZXQgPT09IE0uY3VycmVudFRhcmdldCAmJiBFZSgpICYmIE0ua2V5ID09PSBcIiBcIiAmJiAhTS5kZWZhdWx0UHJldmVudGVkICYmIFMoTSk7XG4gIH0pO1xuICBsZXQgdmUgPSBsO1xuICB2ZSA9PT0gXCJidXR0b25cIiAmJiAoVi5ocmVmIHx8IFYudG8pICYmICh2ZSA9IHkpO1xuICBjb25zdCBQZSA9IHt9O1xuICB2ZSA9PT0gXCJidXR0b25cIiA/IChQZS50eXBlID0gVSA9PT0gdm9pZCAwID8gXCJidXR0b25cIiA6IFUsIFBlLmRpc2FibGVkID0gdSkgOiAoIVYuaHJlZiAmJiAhVi50byAmJiAoUGUucm9sZSA9IFwiYnV0dG9uXCIpLCB1ICYmIChQZVtcImFyaWEtZGlzYWJsZWRcIl0gPSB1KSk7XG4gIGNvbnN0IHplID0gYXQociwgdGUpLCBMZSA9IHtcbiAgICAuLi5uLFxuICAgIGNlbnRlclJpcHBsZTogaSxcbiAgICBjb21wb25lbnQ6IGwsXG4gICAgZGlzYWJsZWQ6IHUsXG4gICAgZGlzYWJsZVJpcHBsZTogcCxcbiAgICBkaXNhYmxlVG91Y2hSaXBwbGU6IG0sXG4gICAgZm9jdXNSaXBwbGU6IGcsXG4gICAgdGFiSW5kZXg6IGosXG4gICAgZm9jdXNWaXNpYmxlOiBJXG4gIH0sIHYgPSB5ZChMZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3hzKGJkLCB7XG4gICAgYXM6IHZlLFxuICAgIGNsYXNzTmFtZTogc2Uodi5yb290LCBjKSxcbiAgICBvd25lclN0YXRlOiBMZSxcbiAgICBvbkJsdXI6IE8sXG4gICAgb25DbGljazogUyxcbiAgICBvbkNvbnRleHRNZW51OiBYLFxuICAgIG9uRm9jdXM6IHllLFxuICAgIG9uS2V5RG93bjogTWUsXG4gICAgb25LZXlVcDogUWUsXG4gICAgb25Nb3VzZURvd246IEgsXG4gICAgb25Nb3VzZUxlYXZlOiBHLFxuICAgIG9uTW91c2VVcDogcSxcbiAgICBvbkRyYWdMZWF2ZTogXyxcbiAgICBvblRvdWNoRW5kOiBaLFxuICAgIG9uVG91Y2hNb3ZlOiBhZSxcbiAgICBvblRvdWNoU3RhcnQ6IHJlLFxuICAgIHJlZjogemUsXG4gICAgdGFiSW5kZXg6IHUgPyAtMSA6IGosXG4gICAgdHlwZTogVSxcbiAgICAuLi5QZSxcbiAgICAuLi5WLFxuICAgIGNoaWxkcmVuOiBbcywgUSA/IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChTcywge1xuICAgICAgcmVmOiBSLFxuICAgICAgY2VudGVyOiBpLFxuICAgICAgLi4uV1xuICAgIH0pIDogbnVsbF1cbiAgfSk7XG59KTtcbmZ1bmN0aW9uIFR0KGUsIHQsIHIsIG4gPSAhMSkge1xuICByZXR1cm4gUXQoKG8pID0+IChyICYmIHIobyksIG4gfHwgZVt0XShvKSwgITApKTtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoJHIucHJvcFR5cGVzID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiAgICBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4gICAgIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICAqIEEgcmVmIGZvciBpbXBlcmF0aXZlIGFjdGlvbnMuXG4gICAqIEl0IGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIGBmb2N1c1Zpc2libGUoKWAgYWN0aW9uLlxuICAgKi9cbiAgYWN0aW9uOiBMbyxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHJpcHBsZXMgYXJlIGNlbnRlcmVkLlxuICAgKiBUaGV5IHdvbid0IHN0YXJ0IGF0IHRoZSBjdXJzb3IgaW50ZXJhY3Rpb24gcG9zaXRpb24uXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBjZW50ZXJSaXBwbGU6IGEuYm9vbCxcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogYS5ub2RlLFxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgY29tcG9uZW50OiBKYSxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVkOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByaXBwbGUgZWZmZWN0IGlzIGRpc2FibGVkLlxuICAgKlxuICAgKiDimqDvuI8gV2l0aG91dCBhIHJpcHBsZSB0aGVyZSBpcyBubyBzdHlsaW5nIGZvciA6Zm9jdXMtdmlzaWJsZSBieSBkZWZhdWx0LiBCZSBzdXJlXG4gICAqIHRvIGhpZ2hsaWdodCB0aGUgZWxlbWVudCBieSBhcHBseWluZyBzZXBhcmF0ZSBzdHlsZXMgd2l0aCB0aGUgYC5NdWktZm9jdXNWaXNpYmxlYCBjbGFzcy5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVSaXBwbGU6IGEuYm9vbCxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHRvdWNoIHJpcHBsZSBlZmZlY3QgaXMgZGlzYWJsZWQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlVG91Y2hSaXBwbGU6IGEuYm9vbCxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGJhc2UgYnV0dG9uIHdpbGwgaGF2ZSBhIGtleWJvYXJkIGZvY3VzIHJpcHBsZS5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGZvY3VzUmlwcGxlOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUaGlzIHByb3AgY2FuIGhlbHAgaWRlbnRpZnkgd2hpY2ggZWxlbWVudCBoYXMga2V5Ym9hcmQgZm9jdXMuXG4gICAqIFRoZSBjbGFzcyBuYW1lIHdpbGwgYmUgYXBwbGllZCB3aGVuIHRoZSBlbGVtZW50IGdhaW5zIHRoZSBmb2N1cyB0aHJvdWdoIGtleWJvYXJkIGludGVyYWN0aW9uLlxuICAgKiBJdCdzIGEgcG9seWZpbGwgZm9yIHRoZSBbQ1NTIDpmb2N1cy12aXNpYmxlIHNlbGVjdG9yXShodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvc2VsZWN0b3JzLTQvI3RoZS1mb2N1cy12aXNpYmxlLXBzZXVkbykuXG4gICAqIFRoZSByYXRpb25hbGUgZm9yIHVzaW5nIHRoaXMgZmVhdHVyZSBbaXMgZXhwbGFpbmVkIGhlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2ZvY3VzLXZpc2libGUvYmxvYi9IRUFEL2V4cGxhaW5lci5tZCkuXG4gICAqIEEgW3BvbHlmaWxsIGNhbiBiZSB1c2VkXShodHRwczovL2dpdGh1Yi5jb20vV0lDRy9mb2N1cy12aXNpYmxlKSB0byBhcHBseSBhIGBmb2N1cy12aXNpYmxlYCBjbGFzcyB0byBvdGhlciBjb21wb25lbnRzXG4gICAqIGlmIG5lZWRlZC5cbiAgICovXG4gIGZvY3VzVmlzaWJsZUNsYXNzTmFtZTogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBocmVmOiBhLmFueSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCB0byByZW5kZXIgYSBsaW5rIHdoZW4gdGhlIGBocmVmYCBwcm9wIGlzIHByb3ZpZGVkLlxuICAgKiBAZGVmYXVsdCAnYSdcbiAgICovXG4gIExpbmtDb21wb25lbnQ6IGEuZWxlbWVudFR5cGUsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkJsdXI6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uQ2xpY2s6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uQ29udGV4dE1lbnU6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRHJhZ0xlYXZlOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkZvY3VzOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZm9jdXNlZCB3aXRoIGEga2V5Ym9hcmQuXG4gICAqIFdlIHRyaWdnZXIgYSBgb25Gb2N1c2AgY2FsbGJhY2sgdG9vLlxuICAgKi9cbiAgb25Gb2N1c1Zpc2libGU6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uS2V5RG93bjogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25LZXlVcDogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Nb3VzZURvd246IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uTW91c2VMZWF2ZTogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Nb3VzZVVwOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvblRvdWNoRW5kOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvblRvdWNoTW92ZTogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Ub3VjaFN0YXJ0OiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHByb3AgdGhhdCBhbGxvd3MgZGVmaW5pbmcgc3lzdGVtIG92ZXJyaWRlcyBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHN4OiBhLm9uZU9mVHlwZShbYS5hcnJheU9mKGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0LCBhLmJvb2xdKSksIGEuZnVuYywgYS5vYmplY3RdKSxcbiAgLyoqXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHRhYkluZGV4OiBhLm51bWJlcixcbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIGBUb3VjaFJpcHBsZWAgZWxlbWVudC5cbiAgICovXG4gIFRvdWNoUmlwcGxlUHJvcHM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQSByZWYgdGhhdCBwb2ludHMgdG8gdGhlIGBUb3VjaFJpcHBsZWAgZWxlbWVudC5cbiAgICovXG4gIHRvdWNoUmlwcGxlUmVmOiBhLm9uZU9mVHlwZShbYS5mdW5jLCBhLnNoYXBlKHtcbiAgICBjdXJyZW50OiBhLnNoYXBlKHtcbiAgICAgIHB1bHNhdGU6IGEuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgc3RhcnQ6IGEuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgc3RvcDogYS5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KVxuICB9KV0pLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdHlwZTogYS5vbmVPZlR5cGUoW2Eub25lT2YoW1wiYnV0dG9uXCIsIFwicmVzZXRcIiwgXCJzdWJtaXRcIl0pLCBhLnN0cmluZ10pXG59KTtcbmZ1bmN0aW9uIHZkKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlLm1haW4gPT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIHhkKGUsIHQgPSBbXSkge1xuICBpZiAoIXZkKGUpKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChjb25zdCByIG9mIHQpXG4gICAgaWYgKCFlLmhhc093blByb3BlcnR5KHIpIHx8IHR5cGVvZiBlW3JdICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIFB0KGUgPSBbXSkge1xuICByZXR1cm4gKFssIHRdKSA9PiB0ICYmIHhkKHQsIGUpO1xufVxuZnVuY3Rpb24gU2QoZSkge1xuICByZXR1cm4gVmUoXCJNdWlDaXJjdWxhclByb2dyZXNzXCIsIGUpO1xufVxuRmUoXCJNdWlDaXJjdWxhclByb2dyZXNzXCIsIFtcInJvb3RcIiwgXCJkZXRlcm1pbmF0ZVwiLCBcImluZGV0ZXJtaW5hdGVcIiwgXCJjb2xvclByaW1hcnlcIiwgXCJjb2xvclNlY29uZGFyeVwiLCBcInN2Z1wiLCBcImNpcmNsZVwiLCBcImNpcmNsZURldGVybWluYXRlXCIsIFwiY2lyY2xlSW5kZXRlcm1pbmF0ZVwiLCBcImNpcmNsZURpc2FibGVTaHJpbmtcIl0pO1xuY29uc3QgJHQgPSA0NCwgZ28gPSBJcmBcbiAgMCUge1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICB9XG5cbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgfVxuYCwgeW8gPSBJcmBcbiAgMCUge1xuICAgIHN0cm9rZS1kYXNoYXJyYXk6IDFweCwgMjAwcHg7XG4gICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IDA7XG4gIH1cblxuICA1MCUge1xuICAgIHN0cm9rZS1kYXNoYXJyYXk6IDEwMHB4LCAyMDBweDtcbiAgICBzdHJva2UtZGFzaG9mZnNldDogLTE1cHg7XG4gIH1cblxuICAxMDAlIHtcbiAgICBzdHJva2UtZGFzaGFycmF5OiAxcHgsIDIwMHB4O1xuICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAtMTI2cHg7XG4gIH1cbmAsIEVkID0gdHlwZW9mIGdvICE9IFwic3RyaW5nXCIgPyAkb2BcbiAgICAgICAgYW5pbWF0aW9uOiAke2dvfSAxLjRzIGxpbmVhciBpbmZpbml0ZTtcbiAgICAgIGAgOiBudWxsLCBDZCA9IHR5cGVvZiB5byAhPSBcInN0cmluZ1wiID8gJG9gXG4gICAgICAgIGFuaW1hdGlvbjogJHt5b30gMS40cyBlYXNlLWluLW91dCBpbmZpbml0ZTtcbiAgICAgIGAgOiBudWxsLCBUZCA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjbGFzc2VzOiB0LFxuICAgIHZhcmlhbnQ6IHIsXG4gICAgY29sb3I6IG4sXG4gICAgZGlzYWJsZVNocmluazogb1xuICB9ID0gZSwgaSA9IHtcbiAgICByb290OiBbXCJyb290XCIsIHIsIGBjb2xvciR7ZWUobil9YF0sXG4gICAgc3ZnOiBbXCJzdmdcIl0sXG4gICAgY2lyY2xlOiBbXCJjaXJjbGVcIiwgYGNpcmNsZSR7ZWUocil9YCwgbyAmJiBcImNpcmNsZURpc2FibGVTaHJpbmtcIl1cbiAgfTtcbiAgcmV0dXJuIEdlKGksIFNkLCB0KTtcbn0sIHdkID0gbGUoXCJzcGFuXCIsIHtcbiAgbmFtZTogXCJNdWlDaXJjdWxhclByb2dyZXNzXCIsXG4gIHNsb3Q6IFwiUm9vdFwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lclN0YXRlOiByXG4gICAgfSA9IGU7XG4gICAgcmV0dXJuIFt0LnJvb3QsIHRbci52YXJpYW50XSwgdFtgY29sb3Ike2VlKHIuY29sb3IpfWBdXTtcbiAgfVxufSkocWUoKHtcbiAgdGhlbWU6IGVcbn0pID0+ICh7XG4gIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiB7XG4gICAgICB2YXJpYW50OiBcImRldGVybWluYXRlXCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICB0cmFuc2l0aW9uOiBlLnRyYW5zaXRpb25zLmNyZWF0ZShcInRyYW5zZm9ybVwiKVxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiB7XG4gICAgICB2YXJpYW50OiBcImluZGV0ZXJtaW5hdGVcIlxuICAgIH0sXG4gICAgc3R5bGU6IEVkIHx8IHtcbiAgICAgIGFuaW1hdGlvbjogYCR7Z299IDEuNHMgbGluZWFyIGluZmluaXRlYFxuICAgIH1cbiAgfSwgLi4uT2JqZWN0LmVudHJpZXMoZS5wYWxldHRlKS5maWx0ZXIoUHQoKSkubWFwKChbdF0pID0+ICh7XG4gICAgcHJvcHM6IHtcbiAgICAgIGNvbG9yOiB0XG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZVt0XS5tYWluXG4gICAgfVxuICB9KSldXG59KSkpLCBPZCA9IGxlKFwic3ZnXCIsIHtcbiAgbmFtZTogXCJNdWlDaXJjdWxhclByb2dyZXNzXCIsXG4gIHNsb3Q6IFwiU3ZnXCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4gdC5zdmdcbn0pKHtcbiAgZGlzcGxheTogXCJibG9ja1wiXG4gIC8vIEtlZXBzIHRoZSBwcm9ncmVzcyBjZW50ZXJlZFxufSksIFJkID0gbGUoXCJjaXJjbGVcIiwge1xuICBuYW1lOiBcIk11aUNpcmN1bGFyUHJvZ3Jlc3NcIixcbiAgc2xvdDogXCJDaXJjbGVcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJTdGF0ZTogclxuICAgIH0gPSBlO1xuICAgIHJldHVybiBbdC5jaXJjbGUsIHRbYGNpcmNsZSR7ZWUoci52YXJpYW50KX1gXSwgci5kaXNhYmxlU2hyaW5rICYmIHQuY2lyY2xlRGlzYWJsZVNocmlua107XG4gIH1cbn0pKHFlKCh7XG4gIHRoZW1lOiBlXG59KSA9PiAoe1xuICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiB7XG4gICAgICB2YXJpYW50OiBcImRldGVybWluYXRlXCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICB0cmFuc2l0aW9uOiBlLnRyYW5zaXRpb25zLmNyZWF0ZShcInN0cm9rZS1kYXNob2Zmc2V0XCIpXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHZhcmlhbnQ6IFwiaW5kZXRlcm1pbmF0ZVwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgLy8gU29tZSBkZWZhdWx0IHZhbHVlIHRoYXQgbG9va3MgZmluZSB3YWl0aW5nIGZvciB0aGUgYW5pbWF0aW9uIHRvIGtpY2tzIGluLlxuICAgICAgc3Ryb2tlRGFzaGFycmF5OiBcIjgwcHgsIDIwMHB4XCIsXG4gICAgICBzdHJva2VEYXNob2Zmc2V0OiAwXG4gICAgICAvLyBBZGQgdGhlIHVuaXQgdG8gZml4IGEgRWRnZSAxNiBhbmQgYmVsb3cgYnVnLlxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+IHQudmFyaWFudCA9PT0gXCJpbmRldGVybWluYXRlXCIgJiYgIXQuZGlzYWJsZVNocmluayxcbiAgICBzdHlsZTogQ2QgfHwge1xuICAgICAgLy8gQXQgcnVudGltZSBmb3IgUGlnbWVudCBDU1MsIGBidWZmZXJBbmltYXRpb25gIHdpbGwgYmUgbnVsbCBhbmQgdGhlIGdlbmVyYXRlZCBrZXlmcmFtZSB3aWxsIGJlIHVzZWQuXG4gICAgICBhbmltYXRpb246IGAke3lvfSAxLjRzIGVhc2UtaW4tb3V0IGluZmluaXRlYFxuICAgIH1cbiAgfV1cbn0pKSksIEVzID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IG4gPSBIZSh7XG4gICAgcHJvcHM6IHQsXG4gICAgbmFtZTogXCJNdWlDaXJjdWxhclByb2dyZXNzXCJcbiAgfSksIHtcbiAgICBjbGFzc05hbWU6IG8sXG4gICAgY29sb3I6IGkgPSBcInByaW1hcnlcIixcbiAgICBkaXNhYmxlU2hyaW5rOiBzID0gITEsXG4gICAgc2l6ZTogYyA9IDQwLFxuICAgIHN0eWxlOiBsLFxuICAgIHRoaWNrbmVzczogdSA9IDMuNixcbiAgICB2YWx1ZTogcCA9IDAsXG4gICAgdmFyaWFudDogbSA9IFwiaW5kZXRlcm1pbmF0ZVwiLFxuICAgIC4uLmdcbiAgfSA9IG4sIHggPSB7XG4gICAgLi4ubixcbiAgICBjb2xvcjogaSxcbiAgICBkaXNhYmxlU2hyaW5rOiBzLFxuICAgIHNpemU6IGMsXG4gICAgdGhpY2tuZXNzOiB1LFxuICAgIHZhbHVlOiBwLFxuICAgIHZhcmlhbnQ6IG1cbiAgfSwgeSA9IFRkKHgpLCBmID0ge30sIFMgPSB7fSwgRSA9IHt9O1xuICBpZiAobSA9PT0gXCJkZXRlcm1pbmF0ZVwiKSB7XG4gICAgY29uc3QgUCA9IDIgKiBNYXRoLlBJICogKCgkdCAtIHUpIC8gMik7XG4gICAgZi5zdHJva2VEYXNoYXJyYXkgPSBQLnRvRml4ZWQoMyksIEVbXCJhcmlhLXZhbHVlbm93XCJdID0gTWF0aC5yb3VuZChwKSwgZi5zdHJva2VEYXNob2Zmc2V0ID0gYCR7KCgxMDAgLSBwKSAvIDEwMCAqIFApLnRvRml4ZWQoMyl9cHhgLCBTLnRyYW5zZm9ybSA9IFwicm90YXRlKC05MGRlZylcIjtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KHdkLCB7XG4gICAgY2xhc3NOYW1lOiBzZSh5LnJvb3QsIG8pLFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogYyxcbiAgICAgIGhlaWdodDogYyxcbiAgICAgIC4uLlMsXG4gICAgICAuLi5sXG4gICAgfSxcbiAgICBvd25lclN0YXRlOiB4LFxuICAgIHJlZjogcixcbiAgICByb2xlOiBcInByb2dyZXNzYmFyXCIsXG4gICAgLi4uRSxcbiAgICAuLi5nLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goT2QsIHtcbiAgICAgIGNsYXNzTmFtZTogeS5zdmcsXG4gICAgICBvd25lclN0YXRlOiB4LFxuICAgICAgdmlld0JveDogYCR7JHQgLyAyfSAkeyR0IC8gMn0gJHskdH0gJHskdH1gLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChSZCwge1xuICAgICAgICBjbGFzc05hbWU6IHkuY2lyY2xlLFxuICAgICAgICBzdHlsZTogZixcbiAgICAgICAgb3duZXJTdGF0ZTogeCxcbiAgICAgICAgY3g6ICR0LFxuICAgICAgICBjeTogJHQsXG4gICAgICAgIHI6ICgkdCAtIHUpIC8gMixcbiAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB1XG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKEVzLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgICAgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjbGFzc2VzOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC5cbiAgICogSXQgc3VwcG9ydHMgYm90aCBkZWZhdWx0IGFuZCBjdXN0b20gdGhlbWUgY29sb3JzLCB3aGljaCBjYW4gYmUgYWRkZWQgYXMgc2hvd24gaW4gdGhlXG4gICAqIFtwYWxldHRlIGN1c3RvbWl6YXRpb24gZ3VpZGVdKGh0dHBzOi8vbXVpLmNvbS9tYXRlcmlhbC11aS9jdXN0b21pemF0aW9uL3BhbGV0dGUvI2N1c3RvbS1jb2xvcnMpLlxuICAgKiBAZGVmYXVsdCAncHJpbWFyeSdcbiAgICovXG4gIGNvbG9yOiBhLm9uZU9mVHlwZShbYS5vbmVPZihbXCJpbmhlcml0XCIsIFwicHJpbWFyeVwiLCBcInNlY29uZGFyeVwiLCBcImVycm9yXCIsIFwiaW5mb1wiLCBcInN1Y2Nlc3NcIiwgXCJ3YXJuaW5nXCJdKSwgYS5zdHJpbmddKSxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHNocmluayBhbmltYXRpb24gaXMgZGlzYWJsZWQuXG4gICAqIFRoaXMgb25seSB3b3JrcyBpZiB2YXJpYW50IGlzIGBpbmRldGVybWluYXRlYC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVTaHJpbms6IGFyKGEuYm9vbCwgKGUpID0+IGUuZGlzYWJsZVNocmluayAmJiBlLnZhcmlhbnQgJiYgZS52YXJpYW50ICE9PSBcImluZGV0ZXJtaW5hdGVcIiA/IG5ldyBFcnJvcihcIk1VSTogWW91IGhhdmUgcHJvdmlkZWQgdGhlIGBkaXNhYmxlU2hyaW5rYCBwcm9wIHdpdGggYSB2YXJpYW50IG90aGVyIHRoYW4gYGluZGV0ZXJtaW5hdGVgLiBUaGlzIHdpbGwgaGF2ZSBubyBlZmZlY3QuXCIpIDogbnVsbCksXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKiBJZiB1c2luZyBhIG51bWJlciwgdGhlIHBpeGVsIHVuaXQgaXMgYXNzdW1lZC5cbiAgICogSWYgdXNpbmcgYSBzdHJpbmcsIHlvdSBuZWVkIHRvIHByb3ZpZGUgdGhlIENTUyB1bml0LCBmb3IgZXhhbXBsZSAnM3JlbScuXG4gICAqIEBkZWZhdWx0IDQwXG4gICAqL1xuICBzaXplOiBhLm9uZU9mVHlwZShbYS5udW1iZXIsIGEuc3RyaW5nXSksXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdHlsZTogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHByb3AgdGhhdCBhbGxvd3MgZGVmaW5pbmcgc3lzdGVtIG92ZXJyaWRlcyBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHN4OiBhLm9uZU9mVHlwZShbYS5hcnJheU9mKGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0LCBhLmJvb2xdKSksIGEuZnVuYywgYS5vYmplY3RdKSxcbiAgLyoqXG4gICAqIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNpcmNsZS5cbiAgICogQGRlZmF1bHQgMy42XG4gICAqL1xuICB0aGlja25lc3M6IGEubnVtYmVyLFxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IgZm9yIHRoZSBkZXRlcm1pbmF0ZSB2YXJpYW50LlxuICAgKiBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgdmFsdWU6IGEubnVtYmVyLFxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgdG8gdXNlLlxuICAgKiBVc2UgaW5kZXRlcm1pbmF0ZSB3aGVuIHRoZXJlIGlzIG5vIHByb2dyZXNzIHZhbHVlLlxuICAgKiBAZGVmYXVsdCAnaW5kZXRlcm1pbmF0ZSdcbiAgICovXG4gIHZhcmlhbnQ6IGEub25lT2YoW1wiZGV0ZXJtaW5hdGVcIiwgXCJpbmRldGVybWluYXRlXCJdKVxufSk7XG5mdW5jdGlvbiAkZChlKSB7XG4gIHJldHVybiBWZShcIk11aUljb25CdXR0b25cIiwgZSk7XG59XG5jb25zdCBhYSA9IEZlKFwiTXVpSWNvbkJ1dHRvblwiLCBbXCJyb290XCIsIFwiZGlzYWJsZWRcIiwgXCJjb2xvckluaGVyaXRcIiwgXCJjb2xvclByaW1hcnlcIiwgXCJjb2xvclNlY29uZGFyeVwiLCBcImNvbG9yRXJyb3JcIiwgXCJjb2xvckluZm9cIiwgXCJjb2xvclN1Y2Nlc3NcIiwgXCJjb2xvcldhcm5pbmdcIiwgXCJlZGdlU3RhcnRcIiwgXCJlZGdlRW5kXCIsIFwic2l6ZVNtYWxsXCIsIFwic2l6ZU1lZGl1bVwiLCBcInNpemVMYXJnZVwiLCBcImxvYWRpbmdcIiwgXCJsb2FkaW5nSW5kaWNhdG9yXCIsIFwibG9hZGluZ1dyYXBwZXJcIl0pLCBQZCA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjbGFzc2VzOiB0LFxuICAgIGRpc2FibGVkOiByLFxuICAgIGNvbG9yOiBuLFxuICAgIGVkZ2U6IG8sXG4gICAgc2l6ZTogaSxcbiAgICBsb2FkaW5nOiBzXG4gIH0gPSBlLCBjID0ge1xuICAgIHJvb3Q6IFtcInJvb3RcIiwgcyAmJiBcImxvYWRpbmdcIiwgciAmJiBcImRpc2FibGVkXCIsIG4gIT09IFwiZGVmYXVsdFwiICYmIGBjb2xvciR7ZWUobil9YCwgbyAmJiBgZWRnZSR7ZWUobyl9YCwgYHNpemUke2VlKGkpfWBdLFxuICAgIGxvYWRpbmdJbmRpY2F0b3I6IFtcImxvYWRpbmdJbmRpY2F0b3JcIl0sXG4gICAgbG9hZGluZ1dyYXBwZXI6IFtcImxvYWRpbmdXcmFwcGVyXCJdXG4gIH07XG4gIHJldHVybiBHZShjLCAkZCwgdCk7XG59LCBrZCA9IGxlKCRyLCB7XG4gIG5hbWU6IFwiTXVpSWNvbkJ1dHRvblwiLFxuICBzbG90OiBcIlJvb3RcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJTdGF0ZTogclxuICAgIH0gPSBlO1xuICAgIHJldHVybiBbdC5yb290LCByLmxvYWRpbmcgJiYgdC5sb2FkaW5nLCByLmNvbG9yICE9PSBcImRlZmF1bHRcIiAmJiB0W2Bjb2xvciR7ZWUoci5jb2xvcil9YF0sIHIuZWRnZSAmJiB0W2BlZGdlJHtlZShyLmVkZ2UpfWBdLCB0W2BzaXplJHtlZShyLnNpemUpfWBdXTtcbiAgfVxufSkocWUoKHtcbiAgdGhlbWU6IGVcbn0pID0+ICh7XG4gIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgZmxleDogXCIwIDAgYXV0b1wiLFxuICBmb250U2l6ZTogZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjQpLFxuICBwYWRkaW5nOiA4LFxuICBib3JkZXJSYWRpdXM6IFwiNTAlXCIsXG4gIGNvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGUuYWN0aW9uLmFjdGl2ZSxcbiAgdHJhbnNpdGlvbjogZS50cmFuc2l0aW9ucy5jcmVhdGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIHtcbiAgICBkdXJhdGlvbjogZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVzdFxuICB9KSxcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6ICh0KSA9PiAhdC5kaXNhYmxlUmlwcGxlLFxuICAgIHN0eWxlOiB7XG4gICAgICBcIi0tSWNvbkJ1dHRvbi1ob3ZlckJnXCI6IGUudmFycyA/IGByZ2JhKCR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLmFjdGl2ZUNoYW5uZWx9IC8gJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5fSlgIDogRGUoZS5wYWxldHRlLmFjdGlvbi5hY3RpdmUsIGUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KSxcbiAgICAgIFwiJjpob3ZlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ2YXIoLS1JY29uQnV0dG9uLWhvdmVyQmcpXCIsXG4gICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgIFwiQG1lZGlhIChob3Zlcjogbm9uZSlcIjoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgZWRnZTogXCJzdGFydFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgbWFyZ2luTGVmdDogLTEyXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGVkZ2U6IFwic3RhcnRcIixcbiAgICAgIHNpemU6IFwic21hbGxcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIG1hcmdpbkxlZnQ6IC0zXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGVkZ2U6IFwiZW5kXCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBtYXJnaW5SaWdodDogLTEyXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGVkZ2U6IFwiZW5kXCIsXG4gICAgICBzaXplOiBcInNtYWxsXCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBtYXJnaW5SaWdodDogLTNcbiAgICB9XG4gIH1dXG59KSksIHFlKCh7XG4gIHRoZW1lOiBlXG59KSA9PiAoe1xuICB2YXJpYW50czogW3tcbiAgICBwcm9wczoge1xuICAgICAgY29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfVxuICB9LCAuLi5PYmplY3QuZW50cmllcyhlLnBhbGV0dGUpLmZpbHRlcihQdCgpKS5tYXAoKFt0XSkgPT4gKHtcbiAgICBwcm9wczoge1xuICAgICAgY29sb3I6IHRcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlW3RdLm1haW5cbiAgICB9XG4gIH0pKSwgLi4uT2JqZWN0LmVudHJpZXMoZS5wYWxldHRlKS5maWx0ZXIoUHQoKSkubWFwKChbdF0pID0+ICh7XG4gICAgcHJvcHM6IHtcbiAgICAgIGNvbG9yOiB0XG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgXCItLUljb25CdXR0b24taG92ZXJCZ1wiOiBlLnZhcnMgPyBgcmdiYSgkeyhlLnZhcnMgfHwgZSkucGFsZXR0ZVt0XS5tYWluQ2hhbm5lbH0gLyAke2UudmFycy5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHl9KWAgOiBEZSgoZS52YXJzIHx8IGUpLnBhbGV0dGVbdF0ubWFpbiwgZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpXG4gICAgfVxuICB9KSksIHtcbiAgICBwcm9wczoge1xuICAgICAgc2l6ZTogXCJzbWFsbFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZzogNSxcbiAgICAgIGZvbnRTaXplOiBlLnR5cG9ncmFwaHkucHhUb1JlbSgxOClcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgc2l6ZTogXCJsYXJnZVwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZzogMTIsXG4gICAgICBmb250U2l6ZTogZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjgpXG4gICAgfVxuICB9XSxcbiAgW2AmLiR7YWEuZGlzYWJsZWR9YF06IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZFxuICB9LFxuICBbYCYuJHthYS5sb2FkaW5nfWBdOiB7XG4gICAgY29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICB9XG59KSkpLCBBZCA9IGxlKFwic3BhblwiLCB7XG4gIG5hbWU6IFwiTXVpSWNvbkJ1dHRvblwiLFxuICBzbG90OiBcIkxvYWRpbmdJbmRpY2F0b3JcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB0LmxvYWRpbmdJbmRpY2F0b3Jcbn0pKCh7XG4gIHRoZW1lOiBlXG59KSA9PiAoe1xuICBkaXNwbGF5OiBcIm5vbmVcIixcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgdmlzaWJpbGl0eTogXCJ2aXNpYmxlXCIsXG4gIHRvcDogXCI1MCVcIixcbiAgbGVmdDogXCI1MCVcIixcbiAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtNTAlLCAtNTAlKVwiLFxuICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZCxcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6IHtcbiAgICAgIGxvYWRpbmc6ICEwXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogXCJmbGV4XCJcbiAgICB9XG4gIH1dXG59KSksIENzID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IG4gPSBIZSh7XG4gICAgcHJvcHM6IHQsXG4gICAgbmFtZTogXCJNdWlJY29uQnV0dG9uXCJcbiAgfSksIHtcbiAgICBlZGdlOiBvID0gITEsXG4gICAgY2hpbGRyZW46IGksXG4gICAgY2xhc3NOYW1lOiBzLFxuICAgIGNvbG9yOiBjID0gXCJkZWZhdWx0XCIsXG4gICAgZGlzYWJsZWQ6IGwgPSAhMSxcbiAgICBkaXNhYmxlRm9jdXNSaXBwbGU6IHUgPSAhMSxcbiAgICBzaXplOiBwID0gXCJtZWRpdW1cIixcbiAgICBpZDogbSxcbiAgICBsb2FkaW5nOiBnID0gbnVsbCxcbiAgICBsb2FkaW5nSW5kaWNhdG9yOiB4LFxuICAgIC4uLnlcbiAgfSA9IG4sIGYgPSBRYShtKSwgUyA9IHggPz8gLyogQF9fUFVSRV9fICovIE4uanN4KEVzLCB7XG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogZixcbiAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgc2l6ZTogMTZcbiAgfSksIEUgPSB7XG4gICAgLi4ubixcbiAgICBlZGdlOiBvLFxuICAgIGNvbG9yOiBjLFxuICAgIGRpc2FibGVkOiBsLFxuICAgIGRpc2FibGVGb2N1c1JpcHBsZTogdSxcbiAgICBsb2FkaW5nOiBnLFxuICAgIGxvYWRpbmdJbmRpY2F0b3I6IFMsXG4gICAgc2l6ZTogcFxuICB9LCBQID0gUGQoRSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3hzKGtkLCB7XG4gICAgaWQ6IGYsXG4gICAgY2xhc3NOYW1lOiBzZShQLnJvb3QsIHMpLFxuICAgIGNlbnRlclJpcHBsZTogITAsXG4gICAgZm9jdXNSaXBwbGU6ICF1LFxuICAgIGRpc2FibGVkOiBsIHx8IGcsXG4gICAgcmVmOiByLFxuICAgIC4uLnksXG4gICAgb3duZXJTdGF0ZTogRSxcbiAgICBjaGlsZHJlbjogW3R5cGVvZiBnID09IFwiYm9vbGVhblwiICYmIC8vIHVzZSBwbGFpbiBIVE1MIHNwYW4gdG8gbWluaW1pemUgdGhlIHJ1bnRpbWUgb3ZlcmhlYWRcbiAgICAvKiBAX19QVVJFX18gKi8gTi5qc3goXCJzcGFuXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogUC5sb2FkaW5nV3JhcHBlcixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiY29udGVudHNcIlxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goQWQsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBQLmxvYWRpbmdJbmRpY2F0b3IsXG4gICAgICAgIG93bmVyU3RhdGU6IEUsXG4gICAgICAgIGNoaWxkcmVuOiBnICYmIFNcbiAgICAgIH0pXG4gICAgfSksIGldXG4gIH0pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKENzLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgICAgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBUaGUgaWNvbiB0byBkaXNwbGF5LlxuICAgKi9cbiAgY2hpbGRyZW46IGFyKGEubm9kZSwgKGUpID0+IEMuQ2hpbGRyZW4udG9BcnJheShlLmNoaWxkcmVuKS5zb21lKChyKSA9PiAvKiBAX19QVVJFX18gKi8gQy5pc1ZhbGlkRWxlbWVudChyKSAmJiByLnByb3BzLm9uQ2xpY2spID8gbmV3IEVycm9yKFtcIk1VSTogWW91IGFyZSBwcm92aWRpbmcgYW4gb25DbGljayBldmVudCBsaXN0ZW5lciB0byBhIGNoaWxkIG9mIGEgYnV0dG9uIGVsZW1lbnQuXCIsIFwiUHJlZmVyIGFwcGx5aW5nIGl0IHRvIHRoZSBJY29uQnV0dG9uIGRpcmVjdGx5LlwiLCBcIlRoaXMgZ3VhcmFudGVlcyB0aGF0IHRoZSB3aG9sZSA8YnV0dG9uPiB3aWxsIGJlIHJlc3BvbnNpdmUgdG8gY2xpY2sgZXZlbnRzLlwiXS5qb2luKGBcbmApKSA6IG51bGwpLFxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIEl0IHN1cHBvcnRzIGJvdGggZGVmYXVsdCBhbmQgY3VzdG9tIHRoZW1lIGNvbG9ycywgd2hpY2ggY2FuIGJlIGFkZGVkIGFzIHNob3duIGluIHRoZVxuICAgKiBbcGFsZXR0ZSBjdXN0b21pemF0aW9uIGd1aWRlXShodHRwczovL211aS5jb20vbWF0ZXJpYWwtdWkvY3VzdG9taXphdGlvbi9wYWxldHRlLyNjdXN0b20tY29sb3JzKS5cbiAgICogQGRlZmF1bHQgJ2RlZmF1bHQnXG4gICAqL1xuICBjb2xvcjogYS5vbmVPZlR5cGUoW2Eub25lT2YoW1wiaW5oZXJpdFwiLCBcImRlZmF1bHRcIiwgXCJwcmltYXJ5XCIsIFwic2Vjb25kYXJ5XCIsIFwiZXJyb3JcIiwgXCJpbmZvXCIsIFwic3VjY2Vzc1wiLCBcIndhcm5pbmdcIl0pLCBhLnN0cmluZ10pLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IGlzIGRpc2FibGVkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZWQ6IGEuYm9vbCxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlICBrZXlib2FyZCBmb2N1cyByaXBwbGUgaXMgZGlzYWJsZWQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlRm9jdXNSaXBwbGU6IGEuYm9vbCxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHJpcHBsZSBlZmZlY3QgaXMgZGlzYWJsZWQuXG4gICAqXG4gICAqIOKaoO+4jyBXaXRob3V0IGEgcmlwcGxlIHRoZXJlIGlzIG5vIHN0eWxpbmcgZm9yIDpmb2N1cy12aXNpYmxlIGJ5IGRlZmF1bHQuIEJlIHN1cmVcbiAgICogdG8gaGlnaGxpZ2h0IHRoZSBlbGVtZW50IGJ5IGFwcGx5aW5nIHNlcGFyYXRlIHN0eWxlcyB3aXRoIHRoZSBgLk11aS1mb2N1c1Zpc2libGVgIGNsYXNzLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZVJpcHBsZTogYS5ib29sLFxuICAvKipcbiAgICogSWYgZ2l2ZW4sIHVzZXMgYSBuZWdhdGl2ZSBtYXJnaW4gdG8gY291bnRlcmFjdCB0aGUgcGFkZGluZyBvbiBvbmVcbiAgICogc2lkZSAodGhpcyBpcyBvZnRlbiBoZWxwZnVsIGZvciBhbGlnbmluZyB0aGUgbGVmdCBvciByaWdodFxuICAgKiBzaWRlIG9mIHRoZSBpY29uIHdpdGggY29udGVudCBhYm92ZSBvciBiZWxvdywgd2l0aG91dCBydWluaW5nIHRoZSBib3JkZXJcbiAgICogc2l6ZSBhbmQgc2hhcGUpLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZWRnZTogYS5vbmVPZihbXCJlbmRcIiwgXCJzdGFydFwiLCAhMV0pLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgaWQ6IGEuc3RyaW5nLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbG9hZGluZyBpbmRpY2F0b3IgaXMgdmlzaWJsZSBhbmQgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZC5cbiAgICogSWYgYHRydWUgfCBmYWxzZWAsIHRoZSBsb2FkaW5nIHdyYXBwZXIgaXMgYWx3YXlzIHJlbmRlcmVkIGJlZm9yZSB0aGUgY2hpbGRyZW4gdG8gcHJldmVudCBbR29vZ2xlIFRyYW5zbGF0aW9uIENyYXNoXShodHRwczovL2dpdGh1Yi5jb20vbXVpL21hdGVyaWFsLXVpL2lzc3Vlcy8yNzg1MykuXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGxvYWRpbmc6IGEuYm9vbCxcbiAgLyoqXG4gICAqIEVsZW1lbnQgcGxhY2VkIGJlZm9yZSB0aGUgY2hpbGRyZW4gaWYgdGhlIGJ1dHRvbiBpcyBpbiBsb2FkaW5nIHN0YXRlLlxuICAgKiBUaGUgbm9kZSBzaG91bGQgY29udGFpbiBhbiBlbGVtZW50IHdpdGggYHJvbGU9XCJwcm9ncmVzc2JhclwiYCB3aXRoIGFuIGFjY2Vzc2libGUgbmFtZS5cbiAgICogQnkgZGVmYXVsdCwgaXQgcmVuZGVycyBhIGBDaXJjdWxhclByb2dyZXNzYCB0aGF0IGlzIGxhYmVsZWQgYnkgdGhlIGJ1dHRvbiBpdHNlbGYuXG4gICAqIEBkZWZhdWx0IDxDaXJjdWxhclByb2dyZXNzIGNvbG9yPVwiaW5oZXJpdFwiIHNpemU9ezE2fSAvPlxuICAgKi9cbiAgbG9hZGluZ0luZGljYXRvcjogYS5ub2RlLFxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICogYHNtYWxsYCBpcyBlcXVpdmFsZW50IHRvIHRoZSBkZW5zZSBidXR0b24gc3R5bGluZy5cbiAgICogQGRlZmF1bHQgJ21lZGl1bSdcbiAgICovXG4gIHNpemU6IGEub25lT2ZUeXBlKFthLm9uZU9mKFtcInNtYWxsXCIsIFwibWVkaXVtXCIsIFwibGFyZ2VcIl0pLCBhLnN0cmluZ10pLFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSlcbn0pO1xuZnVuY3Rpb24gTmQoZSkge1xuICByZXR1cm4gVmUoXCJNdWlUeXBvZ3JhcGh5XCIsIGUpO1xufVxuY29uc3Qgc2EgPSBGZShcIk11aVR5cG9ncmFwaHlcIiwgW1wicm9vdFwiLCBcImgxXCIsIFwiaDJcIiwgXCJoM1wiLCBcImg0XCIsIFwiaDVcIiwgXCJoNlwiLCBcInN1YnRpdGxlMVwiLCBcInN1YnRpdGxlMlwiLCBcImJvZHkxXCIsIFwiYm9keTJcIiwgXCJpbmhlcml0XCIsIFwiYnV0dG9uXCIsIFwiY2FwdGlvblwiLCBcIm92ZXJsaW5lXCIsIFwiYWxpZ25MZWZ0XCIsIFwiYWxpZ25SaWdodFwiLCBcImFsaWduQ2VudGVyXCIsIFwiYWxpZ25KdXN0aWZ5XCIsIFwibm9XcmFwXCIsIFwiZ3V0dGVyQm90dG9tXCIsIFwicGFyYWdyYXBoXCJdKSwgTWQgPSB7XG4gIHByaW1hcnk6ICEwLFxuICBzZWNvbmRhcnk6ICEwLFxuICBlcnJvcjogITAsXG4gIGluZm86ICEwLFxuICBzdWNjZXNzOiAhMCxcbiAgd2FybmluZzogITAsXG4gIHRleHRQcmltYXJ5OiAhMCxcbiAgdGV4dFNlY29uZGFyeTogITAsXG4gIHRleHREaXNhYmxlZDogITBcbn0sIElkID0gV2YoKSwgX2QgPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgYWxpZ246IHQsXG4gICAgZ3V0dGVyQm90dG9tOiByLFxuICAgIG5vV3JhcDogbixcbiAgICBwYXJhZ3JhcGg6IG8sXG4gICAgdmFyaWFudDogaSxcbiAgICBjbGFzc2VzOiBzXG4gIH0gPSBlLCBjID0ge1xuICAgIHJvb3Q6IFtcInJvb3RcIiwgaSwgZS5hbGlnbiAhPT0gXCJpbmhlcml0XCIgJiYgYGFsaWduJHtlZSh0KX1gLCByICYmIFwiZ3V0dGVyQm90dG9tXCIsIG4gJiYgXCJub1dyYXBcIiwgbyAmJiBcInBhcmFncmFwaFwiXVxuICB9O1xuICByZXR1cm4gR2UoYywgTmQsIHMpO1xufSwgamQgPSBsZShcInNwYW5cIiwge1xuICBuYW1lOiBcIk11aVR5cG9ncmFwaHlcIixcbiAgc2xvdDogXCJSb290XCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyU3RhdGU6IHJcbiAgICB9ID0gZTtcbiAgICByZXR1cm4gW3Qucm9vdCwgci52YXJpYW50ICYmIHRbci52YXJpYW50XSwgci5hbGlnbiAhPT0gXCJpbmhlcml0XCIgJiYgdFtgYWxpZ24ke2VlKHIuYWxpZ24pfWBdLCByLm5vV3JhcCAmJiB0Lm5vV3JhcCwgci5ndXR0ZXJCb3R0b20gJiYgdC5ndXR0ZXJCb3R0b20sIHIucGFyYWdyYXBoICYmIHQucGFyYWdyYXBoXTtcbiAgfVxufSkocWUoKHtcbiAgdGhlbWU6IGVcbn0pID0+IHtcbiAgdmFyIHQ7XG4gIHJldHVybiB7XG4gICAgbWFyZ2luOiAwLFxuICAgIHZhcmlhbnRzOiBbe1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdmFyaWFudDogXCJpbmhlcml0XCJcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICAvLyBTb21lIGVsZW1lbnRzLCBsaWtlIDxidXR0b24+IG9uIENocm9tZSBoYXZlIGRlZmF1bHQgZm9udCB0aGF0IGRvZXNuJ3QgaW5oZXJpdCwgcmVzZXQgdGhpcy5cbiAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICBsZXR0ZXJTcGFjaW5nOiBcImluaGVyaXRcIlxuICAgICAgfVxuICAgIH0sIC4uLk9iamVjdC5lbnRyaWVzKGUudHlwb2dyYXBoeSkuZmlsdGVyKChbciwgbl0pID0+IHIgIT09IFwiaW5oZXJpdFwiICYmIG4gJiYgdHlwZW9mIG4gPT0gXCJvYmplY3RcIikubWFwKChbciwgbl0pID0+ICh7XG4gICAgICBwcm9wczoge1xuICAgICAgICB2YXJpYW50OiByXG4gICAgICB9LFxuICAgICAgc3R5bGU6IG5cbiAgICB9KSksIC4uLk9iamVjdC5lbnRyaWVzKGUucGFsZXR0ZSkuZmlsdGVyKFB0KCkpLm1hcCgoW3JdKSA9PiAoe1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IHJcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlW3JdLm1haW5cbiAgICAgIH1cbiAgICB9KSksIC4uLk9iamVjdC5lbnRyaWVzKCgodCA9IGUucGFsZXR0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHQudGV4dCkgfHwge30pLmZpbHRlcigoWywgcl0pID0+IHR5cGVvZiByID09IFwic3RyaW5nXCIpLm1hcCgoW3JdKSA9PiAoe1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IGB0ZXh0JHtlZShyKX1gXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS50ZXh0W3JdXG4gICAgICB9XG4gICAgfSkpLCB7XG4gICAgICBwcm9wczogKHtcbiAgICAgICAgb3duZXJTdGF0ZTogclxuICAgICAgfSkgPT4gci5hbGlnbiAhPT0gXCJpbmhlcml0XCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICB0ZXh0QWxpZ246IFwidmFyKC0tVHlwb2dyYXBoeS10ZXh0QWxpZ24pXCJcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwcm9wczogKHtcbiAgICAgICAgb3duZXJTdGF0ZTogclxuICAgICAgfSkgPT4gci5ub1dyYXAsXG4gICAgICBzdHlsZToge1xuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgdGV4dE92ZXJmbG93OiBcImVsbGlwc2lzXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCJcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwcm9wczogKHtcbiAgICAgICAgb3duZXJTdGF0ZTogclxuICAgICAgfSkgPT4gci5ndXR0ZXJCb3R0b20sXG4gICAgICBzdHlsZToge1xuICAgICAgICBtYXJnaW5Cb3R0b206IFwiMC4zNWVtXCJcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwcm9wczogKHtcbiAgICAgICAgb3duZXJTdGF0ZTogclxuICAgICAgfSkgPT4gci5wYXJhZ3JhcGgsXG4gICAgICBzdHlsZToge1xuICAgICAgICBtYXJnaW5Cb3R0b206IDE2XG4gICAgICB9XG4gICAgfV1cbiAgfTtcbn0pKSwgY2EgPSB7XG4gIGgxOiBcImgxXCIsXG4gIGgyOiBcImgyXCIsXG4gIGgzOiBcImgzXCIsXG4gIGg0OiBcImg0XCIsXG4gIGg1OiBcImg1XCIsXG4gIGg2OiBcImg2XCIsXG4gIHN1YnRpdGxlMTogXCJoNlwiLFxuICBzdWJ0aXRsZTI6IFwiaDZcIixcbiAgYm9keTE6IFwicFwiLFxuICBib2R5MjogXCJwXCIsXG4gIGluaGVyaXQ6IFwicFwiXG59LCBidCA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCB7XG4gICAgY29sb3I6IG4sXG4gICAgLi4ub1xuICB9ID0gSGUoe1xuICAgIHByb3BzOiB0LFxuICAgIG5hbWU6IFwiTXVpVHlwb2dyYXBoeVwiXG4gIH0pLCBpID0gIU1kW25dLCBzID0gSWQoe1xuICAgIC4uLm8sXG4gICAgLi4uaSAmJiB7XG4gICAgICBjb2xvcjogblxuICAgIH1cbiAgfSksIHtcbiAgICBhbGlnbjogYyA9IFwiaW5oZXJpdFwiLFxuICAgIGNsYXNzTmFtZTogbCxcbiAgICBjb21wb25lbnQ6IHUsXG4gICAgZ3V0dGVyQm90dG9tOiBwID0gITEsXG4gICAgbm9XcmFwOiBtID0gITEsXG4gICAgcGFyYWdyYXBoOiBnID0gITEsXG4gICAgdmFyaWFudDogeCA9IFwiYm9keTFcIixcbiAgICB2YXJpYW50TWFwcGluZzogeSA9IGNhLFxuICAgIC4uLmZcbiAgfSA9IHMsIFMgPSB7XG4gICAgLi4ucyxcbiAgICBhbGlnbjogYyxcbiAgICBjb2xvcjogbixcbiAgICBjbGFzc05hbWU6IGwsXG4gICAgY29tcG9uZW50OiB1LFxuICAgIGd1dHRlckJvdHRvbTogcCxcbiAgICBub1dyYXA6IG0sXG4gICAgcGFyYWdyYXBoOiBnLFxuICAgIHZhcmlhbnQ6IHgsXG4gICAgdmFyaWFudE1hcHBpbmc6IHlcbiAgfSwgRSA9IHUgfHwgKGcgPyBcInBcIiA6IHlbeF0gfHwgY2FbeF0pIHx8IFwic3BhblwiLCBQID0gX2QoUyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goamQsIHtcbiAgICBhczogRSxcbiAgICByZWY6IHIsXG4gICAgY2xhc3NOYW1lOiBzZShQLnJvb3QsIGwpLFxuICAgIC4uLmYsXG4gICAgb3duZXJTdGF0ZTogUyxcbiAgICBzdHlsZToge1xuICAgICAgLi4uYyAhPT0gXCJpbmhlcml0XCIgJiYge1xuICAgICAgICBcIi0tVHlwb2dyYXBoeS10ZXh0QWxpZ25cIjogY1xuICAgICAgfSxcbiAgICAgIC4uLmYuc3R5bGVcbiAgICB9XG4gIH0pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGJ0LnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgICAgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQtYWxpZ24gb24gdGhlIGNvbXBvbmVudC5cbiAgICogQGRlZmF1bHQgJ2luaGVyaXQnXG4gICAqL1xuICBhbGlnbjogYS5vbmVPZihbXCJjZW50ZXJcIiwgXCJpbmhlcml0XCIsIFwianVzdGlmeVwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSksXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LlxuICAgKiBJdCBzdXBwb3J0cyBib3RoIGRlZmF1bHQgYW5kIGN1c3RvbSB0aGVtZSBjb2xvcnMsIHdoaWNoIGNhbiBiZSBhZGRlZCBhcyBzaG93biBpbiB0aGVcbiAgICogW3BhbGV0dGUgY3VzdG9taXphdGlvbiBndWlkZV0oaHR0cHM6Ly9tdWkuY29tL21hdGVyaWFsLXVpL2N1c3RvbWl6YXRpb24vcGFsZXR0ZS8jY3VzdG9tLWNvbG9ycykuXG4gICAqL1xuICBjb2xvcjogYS5vbmVPZlR5cGUoW2Eub25lT2YoW1wicHJpbWFyeVwiLCBcInNlY29uZGFyeVwiLCBcInN1Y2Nlc3NcIiwgXCJlcnJvclwiLCBcImluZm9cIiwgXCJ3YXJuaW5nXCIsIFwidGV4dFByaW1hcnlcIiwgXCJ0ZXh0U2Vjb25kYXJ5XCIsIFwidGV4dERpc2FibGVkXCJdKSwgYS5zdHJpbmddKSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogYS5lbGVtZW50VHlwZSxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHRleHQgd2lsbCBoYXZlIGEgYm90dG9tIG1hcmdpbi5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGd1dHRlckJvdHRvbTogYS5ib29sLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgdGV4dCB3aWxsIG5vdCB3cmFwLCBidXQgaW5zdGVhZCB3aWxsIHRydW5jYXRlIHdpdGggYSB0ZXh0IG92ZXJmbG93IGVsbGlwc2lzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGV4dCBvdmVyZmxvdyBjYW4gb25seSBoYXBwZW4gd2l0aCBibG9jayBvciBpbmxpbmUtYmxvY2sgbGV2ZWwgZWxlbWVudHNcbiAgICogKHRoZSBlbGVtZW50IG5lZWRzIHRvIGhhdmUgYSB3aWR0aCBpbiBvcmRlciB0byBvdmVyZmxvdykuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBub1dyYXA6IGEuYm9vbCxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGVsZW1lbnQgd2lsbCBiZSBhIHBhcmFncmFwaCBlbGVtZW50LlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBjb21wb25lbnRgIHByb3AgaW5zdGVhZC4gVGhpcyBwcm9wIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4gU2VlIFtNaWdyYXRpbmcgZnJvbSBkZXByZWNhdGVkIEFQSXNdKGh0dHBzOi8vbXVpLmNvbS9tYXRlcmlhbC11aS9taWdyYXRpb24vbWlncmF0aW5nLWZyb20tZGVwcmVjYXRlZC1hcGlzLykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIHBhcmFncmFwaDogYS5ib29sLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3R5bGU6IGEub2JqZWN0LFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSksXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSB0aGVtZSB0eXBvZ3JhcGh5IHN0eWxlcy5cbiAgICogQGRlZmF1bHQgJ2JvZHkxJ1xuICAgKi9cbiAgdmFyaWFudDogYS5vbmVPZlR5cGUoW2Eub25lT2YoW1wiYm9keTFcIiwgXCJib2R5MlwiLCBcImJ1dHRvblwiLCBcImNhcHRpb25cIiwgXCJoMVwiLCBcImgyXCIsIFwiaDNcIiwgXCJoNFwiLCBcImg1XCIsIFwiaDZcIiwgXCJpbmhlcml0XCIsIFwib3ZlcmxpbmVcIiwgXCJzdWJ0aXRsZTFcIiwgXCJzdWJ0aXRsZTJcIl0pLCBhLnN0cmluZ10pLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCBtYXBzIHRoZSB2YXJpYW50IHByb3AgdG8gYSByYW5nZSBvZiBkaWZmZXJlbnQgSFRNTCBlbGVtZW50IHR5cGVzLlxuICAgKiBGb3IgaW5zdGFuY2UsIHN1YnRpdGxlMSB0byBgPGg2PmAuXG4gICAqIElmIHlvdSB3aXNoIHRvIGNoYW5nZSB0aGF0IG1hcHBpbmcsIHlvdSBjYW4gcHJvdmlkZSB5b3VyIG93bi5cbiAgICogQWx0ZXJuYXRpdmVseSwgeW91IGNhbiB1c2UgdGhlIGBjb21wb25lbnRgIHByb3AuXG4gICAqIEBkZWZhdWx0IHtcbiAgICogICBoMTogJ2gxJyxcbiAgICogICBoMjogJ2gyJyxcbiAgICogICBoMzogJ2gzJyxcbiAgICogICBoNDogJ2g0JyxcbiAgICogICBoNTogJ2g1JyxcbiAgICogICBoNjogJ2g2JyxcbiAgICogICBzdWJ0aXRsZTE6ICdoNicsXG4gICAqICAgc3VidGl0bGUyOiAnaDYnLFxuICAgKiAgIGJvZHkxOiAncCcsXG4gICAqICAgYm9keTI6ICdwJyxcbiAgICogICBpbmhlcml0OiAncCcsXG4gICAqIH1cbiAgICovXG4gIHZhcmlhbnRNYXBwaW5nOiBhLm9iamVjdFxufSk7XG52YXIgS2UgPSBcInRvcFwiLCBzdCA9IFwiYm90dG9tXCIsIGN0ID0gXCJyaWdodFwiLCBYZSA9IFwibGVmdFwiLCBxbyA9IFwiYXV0b1wiLCBCciA9IFtLZSwgc3QsIGN0LCBYZV0sIGVyID0gXCJzdGFydFwiLCBQciA9IFwiZW5kXCIsIERkID0gXCJjbGlwcGluZ1BhcmVudHNcIiwgVHMgPSBcInZpZXdwb3J0XCIsIHByID0gXCJwb3BwZXJcIiwgTGQgPSBcInJlZmVyZW5jZVwiLCBsYSA9IC8qIEBfX1BVUkVfXyAqLyBCci5yZWR1Y2UoZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gZS5jb25jYXQoW3QgKyBcIi1cIiArIGVyLCB0ICsgXCItXCIgKyBQcl0pO1xufSwgW10pLCB3cyA9IC8qIEBfX1BVUkVfXyAqLyBbXS5jb25jYXQoQnIsIFtxb10pLnJlZHVjZShmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBlLmNvbmNhdChbdCwgdCArIFwiLVwiICsgZXIsIHQgKyBcIi1cIiArIFByXSk7XG59LCBbXSksIEJkID0gXCJiZWZvcmVSZWFkXCIsIFZkID0gXCJyZWFkXCIsIEZkID0gXCJhZnRlclJlYWRcIiwgemQgPSBcImJlZm9yZU1haW5cIiwgV2QgPSBcIm1haW5cIiwgVWQgPSBcImFmdGVyTWFpblwiLCBZZCA9IFwiYmVmb3JlV3JpdGVcIiwgSGQgPSBcIndyaXRlXCIsIHFkID0gXCJhZnRlcldyaXRlXCIsIEdkID0gW0JkLCBWZCwgRmQsIHpkLCBXZCwgVWQsIFlkLCBIZCwgcWRdO1xuZnVuY3Rpb24gU3QoZSkge1xuICByZXR1cm4gZSA/IChlLm5vZGVOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufVxuZnVuY3Rpb24gcnQoZSkge1xuICBpZiAoZSA9PSBudWxsKVxuICAgIHJldHVybiB3aW5kb3c7XG4gIGlmIChlLnRvU3RyaW5nKCkgIT09IFwiW29iamVjdCBXaW5kb3ddXCIpIHtcbiAgICB2YXIgdCA9IGUub3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gdCAmJiB0LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHp0KGUpIHtcbiAgdmFyIHQgPSBydChlKS5FbGVtZW50O1xuICByZXR1cm4gZSBpbnN0YW5jZW9mIHQgfHwgZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpdChlKSB7XG4gIHZhciB0ID0gcnQoZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBlIGluc3RhbmNlb2YgdCB8fCBlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBHbyhlKSB7XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA+IFwidVwiKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIHQgPSBydChlKS5TaGFkb3dSb290O1xuICByZXR1cm4gZSBpbnN0YW5jZW9mIHQgfHwgZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBLZChlKSB7XG4gIHZhciB0ID0gZS5zdGF0ZTtcbiAgT2JqZWN0LmtleXModC5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgdmFyIG4gPSB0LnN0eWxlc1tyXSB8fCB7fSwgbyA9IHQuYXR0cmlidXRlc1tyXSB8fCB7fSwgaSA9IHQuZWxlbWVudHNbcl07XG4gICAgIWl0KGkpIHx8ICFTdChpKSB8fCAoT2JqZWN0LmFzc2lnbihpLnN0eWxlLCBuKSwgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgYyA9IG9bc107XG4gICAgICBjID09PSAhMSA/IGkucmVtb3ZlQXR0cmlidXRlKHMpIDogaS5zZXRBdHRyaWJ1dGUocywgYyA9PT0gITAgPyBcIlwiIDogYyk7XG4gICAgfSkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFhkKGUpIHtcbiAgdmFyIHQgPSBlLnN0YXRlLCByID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHQub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGxlZnQ6IFwiMFwiLFxuICAgICAgdG9wOiBcIjBcIixcbiAgICAgIG1hcmdpbjogXCIwXCJcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHQuZWxlbWVudHMucG9wcGVyLnN0eWxlLCByLnBvcHBlciksIHQuc3R5bGVzID0gciwgdC5lbGVtZW50cy5hcnJvdyAmJiBPYmplY3QuYXNzaWduKHQuZWxlbWVudHMuYXJyb3cuc3R5bGUsIHIuYXJyb3cpLCBmdW5jdGlvbigpIHtcbiAgICBPYmplY3Qua2V5cyh0LmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICAgIHZhciBvID0gdC5lbGVtZW50c1tuXSwgaSA9IHQuYXR0cmlidXRlc1tuXSB8fCB7fSwgcyA9IE9iamVjdC5rZXlzKHQuc3R5bGVzLmhhc093blByb3BlcnR5KG4pID8gdC5zdHlsZXNbbl0gOiByW25dKSwgYyA9IHMucmVkdWNlKGZ1bmN0aW9uKGwsIHUpIHtcbiAgICAgICAgcmV0dXJuIGxbdV0gPSBcIlwiLCBsO1xuICAgICAgfSwge30pO1xuICAgICAgIWl0KG8pIHx8ICFTdChvKSB8fCAoT2JqZWN0LmFzc2lnbihvLnN0eWxlLCBjKSwgT2JqZWN0LmtleXMoaSkuZm9yRWFjaChmdW5jdGlvbihsKSB7XG4gICAgICAgIG8ucmVtb3ZlQXR0cmlidXRlKGwpO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9O1xufVxuY29uc3QgSmQgPSB7XG4gIG5hbWU6IFwiYXBwbHlTdHlsZXNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIndyaXRlXCIsXG4gIGZuOiBLZCxcbiAgZWZmZWN0OiBYZCxcbiAgcmVxdWlyZXM6IFtcImNvbXB1dGVTdHlsZXNcIl1cbn07XG5mdW5jdGlvbiB4dChlKSB7XG4gIHJldHVybiBlLnNwbGl0KFwiLVwiKVswXTtcbn1cbnZhciBWdCA9IE1hdGgubWF4LCBFbiA9IE1hdGgubWluLCB0ciA9IE1hdGgucm91bmQ7XG5mdW5jdGlvbiBibygpIHtcbiAgdmFyIGUgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiBlLmJyYW5kcyAmJiBBcnJheS5pc0FycmF5KGUuYnJhbmRzKSA/IGUuYnJhbmRzLm1hcChmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQuYnJhbmQgKyBcIi9cIiArIHQudmVyc2lvbjtcbiAgfSkuam9pbihcIiBcIikgOiBuYXZpZ2F0b3IudXNlckFnZW50O1xufVxuZnVuY3Rpb24gT3MoKSB7XG4gIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChibygpKTtcbn1cbmZ1bmN0aW9uIHJyKGUsIHQsIHIpIHtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0gITEpLCByID09PSB2b2lkIDAgJiYgKHIgPSAhMSk7XG4gIHZhciBuID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbyA9IDEsIGkgPSAxO1xuICB0ICYmIGl0KGUpICYmIChvID0gZS5vZmZzZXRXaWR0aCA+IDAgJiYgdHIobi53aWR0aCkgLyBlLm9mZnNldFdpZHRoIHx8IDEsIGkgPSBlLm9mZnNldEhlaWdodCA+IDAgJiYgdHIobi5oZWlnaHQpIC8gZS5vZmZzZXRIZWlnaHQgfHwgMSk7XG4gIHZhciBzID0genQoZSkgPyBydChlKSA6IHdpbmRvdywgYyA9IHMudmlzdWFsVmlld3BvcnQsIGwgPSAhT3MoKSAmJiByLCB1ID0gKG4ubGVmdCArIChsICYmIGMgPyBjLm9mZnNldExlZnQgOiAwKSkgLyBvLCBwID0gKG4udG9wICsgKGwgJiYgYyA/IGMub2Zmc2V0VG9wIDogMCkpIC8gaSwgbSA9IG4ud2lkdGggLyBvLCBnID0gbi5oZWlnaHQgLyBpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBtLFxuICAgIGhlaWdodDogZyxcbiAgICB0b3A6IHAsXG4gICAgcmlnaHQ6IHUgKyBtLFxuICAgIGJvdHRvbTogcCArIGcsXG4gICAgbGVmdDogdSxcbiAgICB4OiB1LFxuICAgIHk6IHBcbiAgfTtcbn1cbmZ1bmN0aW9uIEtvKGUpIHtcbiAgdmFyIHQgPSBycihlKSwgciA9IGUub2Zmc2V0V2lkdGgsIG4gPSBlLm9mZnNldEhlaWdodDtcbiAgcmV0dXJuIE1hdGguYWJzKHQud2lkdGggLSByKSA8PSAxICYmIChyID0gdC53aWR0aCksIE1hdGguYWJzKHQuaGVpZ2h0IC0gbikgPD0gMSAmJiAobiA9IHQuaGVpZ2h0KSwge1xuICAgIHg6IGUub2Zmc2V0TGVmdCxcbiAgICB5OiBlLm9mZnNldFRvcCxcbiAgICB3aWR0aDogcixcbiAgICBoZWlnaHQ6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIFJzKGUsIHQpIHtcbiAgdmFyIHIgPSB0LmdldFJvb3ROb2RlICYmIHQuZ2V0Um9vdE5vZGUoKTtcbiAgaWYgKGUuY29udGFpbnModCkpXG4gICAgcmV0dXJuICEwO1xuICBpZiAociAmJiBHbyhyKSkge1xuICAgIHZhciBuID0gdDtcbiAgICBkbyB7XG4gICAgICBpZiAobiAmJiBlLmlzU2FtZU5vZGUobikpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIG4gPSBuLnBhcmVudE5vZGUgfHwgbi5ob3N0O1xuICAgIH0gd2hpbGUgKG4pO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIFJ0KGUpIHtcbiAgcmV0dXJuIHJ0KGUpLmdldENvbXB1dGVkU3R5bGUoZSk7XG59XG5mdW5jdGlvbiBRZChlKSB7XG4gIHJldHVybiBbXCJ0YWJsZVwiLCBcInRkXCIsIFwidGhcIl0uaW5kZXhPZihTdChlKSkgPj0gMDtcbn1cbmZ1bmN0aW9uIEl0KGUpIHtcbiAgcmV0dXJuICgoenQoZSkgPyBlLm93bmVyRG9jdW1lbnQgOiAoXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZS5kb2N1bWVudFxuICApKSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uIHpuKGUpIHtcbiAgcmV0dXJuIFN0KGUpID09PSBcImh0bWxcIiA/IGUgOiAoXG4gICAgLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZS5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlLnBhcmVudE5vZGUgfHwgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICAoR28oZSkgPyBlLmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIEl0KGUpXG4gICk7XG59XG5mdW5jdGlvbiB1YShlKSB7XG4gIHJldHVybiAhaXQoZSkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgUnQoZSkucG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IG51bGwgOiBlLm9mZnNldFBhcmVudDtcbn1cbmZ1bmN0aW9uIFpkKGUpIHtcbiAgdmFyIHQgPSAvZmlyZWZveC9pLnRlc3QoYm8oKSksIHIgPSAvVHJpZGVudC9pLnRlc3QoYm8oKSk7XG4gIGlmIChyICYmIGl0KGUpKSB7XG4gICAgdmFyIG4gPSBSdChlKTtcbiAgICBpZiAobi5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKVxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG8gPSB6bihlKTtcbiAgZm9yIChHbyhvKSAmJiAobyA9IG8uaG9zdCk7IGl0KG8pICYmIFtcImh0bWxcIiwgXCJib2R5XCJdLmluZGV4T2YoU3QobykpIDwgMDsgKSB7XG4gICAgdmFyIGkgPSBSdChvKTtcbiAgICBpZiAoaS50cmFuc2Zvcm0gIT09IFwibm9uZVwiIHx8IGkucGVyc3BlY3RpdmUgIT09IFwibm9uZVwiIHx8IGkuY29udGFpbiA9PT0gXCJwYWludFwiIHx8IFtcInRyYW5zZm9ybVwiLCBcInBlcnNwZWN0aXZlXCJdLmluZGV4T2YoaS53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgdCAmJiBpLndpbGxDaGFuZ2UgPT09IFwiZmlsdGVyXCIgfHwgdCAmJiBpLmZpbHRlciAmJiBpLmZpbHRlciAhPT0gXCJub25lXCIpXG4gICAgICByZXR1cm4gbztcbiAgICBvID0gby5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gVnIoZSkge1xuICBmb3IgKHZhciB0ID0gcnQoZSksIHIgPSB1YShlKTsgciAmJiBRZChyKSAmJiBSdChyKS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIjsgKVxuICAgIHIgPSB1YShyKTtcbiAgcmV0dXJuIHIgJiYgKFN0KHIpID09PSBcImh0bWxcIiB8fCBTdChyKSA9PT0gXCJib2R5XCIgJiYgUnQocikucG9zaXRpb24gPT09IFwic3RhdGljXCIpID8gdCA6IHIgfHwgWmQoZSkgfHwgdDtcbn1cbmZ1bmN0aW9uIFhvKGUpIHtcbiAgcmV0dXJuIFtcInRvcFwiLCBcImJvdHRvbVwiXS5pbmRleE9mKGUpID49IDAgPyBcInhcIiA6IFwieVwiO1xufVxuZnVuY3Rpb24geHIoZSwgdCwgcikge1xuICByZXR1cm4gVnQoZSwgRW4odCwgcikpO1xufVxuZnVuY3Rpb24gZXAoZSwgdCwgcikge1xuICB2YXIgbiA9IHhyKGUsIHQsIHIpO1xuICByZXR1cm4gbiA+IHIgPyByIDogbjtcbn1cbmZ1bmN0aW9uICRzKCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufVxuZnVuY3Rpb24gUHMoZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgJHMoKSwgZSk7XG59XG5mdW5jdGlvbiBrcyhlLCB0KSB7XG4gIHJldHVybiB0LnJlZHVjZShmdW5jdGlvbihyLCBuKSB7XG4gICAgcmV0dXJuIHJbbl0gPSBlLCByO1xuICB9LCB7fSk7XG59XG52YXIgdHAgPSBmdW5jdGlvbih0LCByKSB7XG4gIHJldHVybiB0ID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdChPYmplY3QuYXNzaWduKHt9LCByLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiByLnBsYWNlbWVudFxuICB9KSkgOiB0LCBQcyh0eXBlb2YgdCAhPSBcIm51bWJlclwiID8gdCA6IGtzKHQsIEJyKSk7XG59O1xuZnVuY3Rpb24gcnAoZSkge1xuICB2YXIgdCwgciA9IGUuc3RhdGUsIG4gPSBlLm5hbWUsIG8gPSBlLm9wdGlvbnMsIGkgPSByLmVsZW1lbnRzLmFycm93LCBzID0gci5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsIGMgPSB4dChyLnBsYWNlbWVudCksIGwgPSBYbyhjKSwgdSA9IFtYZSwgY3RdLmluZGV4T2YoYykgPj0gMCwgcCA9IHUgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICBpZiAoISghaSB8fCAhcykpIHtcbiAgICB2YXIgbSA9IHRwKG8ucGFkZGluZywgciksIGcgPSBLbyhpKSwgeCA9IGwgPT09IFwieVwiID8gS2UgOiBYZSwgeSA9IGwgPT09IFwieVwiID8gc3QgOiBjdCwgZiA9IHIucmVjdHMucmVmZXJlbmNlW3BdICsgci5yZWN0cy5yZWZlcmVuY2VbbF0gLSBzW2xdIC0gci5yZWN0cy5wb3BwZXJbcF0sIFMgPSBzW2xdIC0gci5yZWN0cy5yZWZlcmVuY2VbbF0sIEUgPSBWcihpKSwgUCA9IEUgPyBsID09PSBcInlcIiA/IEUuY2xpZW50SGVpZ2h0IHx8IDAgOiBFLmNsaWVudFdpZHRoIHx8IDAgOiAwLCBUID0gZiAvIDIgLSBTIC8gMiwgYiA9IG1beF0sIGggPSBQIC0gZ1twXSAtIG1beV0sIHcgPSBQIC8gMiAtIGdbcF0gLyAyICsgVCwgayA9IHhyKGIsIHcsIGgpLCBMID0gbDtcbiAgICByLm1vZGlmaWVyc0RhdGFbbl0gPSAodCA9IHt9LCB0W0xdID0gaywgdC5jZW50ZXJPZmZzZXQgPSBrIC0gdywgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5wKGUpIHtcbiAgdmFyIHQgPSBlLnN0YXRlLCByID0gZS5vcHRpb25zLCBuID0gci5lbGVtZW50LCBvID0gbiA9PT0gdm9pZCAwID8gXCJbZGF0YS1wb3BwZXItYXJyb3ddXCIgOiBuO1xuICBvICE9IG51bGwgJiYgKHR5cGVvZiBvID09IFwic3RyaW5nXCIgJiYgKG8gPSB0LmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKG8pLCAhbykgfHwgUnModC5lbGVtZW50cy5wb3BwZXIsIG8pICYmICh0LmVsZW1lbnRzLmFycm93ID0gbykpO1xufVxuY29uc3Qgb3AgPSB7XG4gIG5hbWU6IFwiYXJyb3dcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgZm46IHJwLFxuICBlZmZlY3Q6IG5wLFxuICByZXF1aXJlczogW1wicG9wcGVyT2Zmc2V0c1wiXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wicHJldmVudE92ZXJmbG93XCJdXG59O1xuZnVuY3Rpb24gbnIoZSkge1xuICByZXR1cm4gZS5zcGxpdChcIi1cIilbMV07XG59XG52YXIgaXAgPSB7XG4gIHRvcDogXCJhdXRvXCIsXG4gIHJpZ2h0OiBcImF1dG9cIixcbiAgYm90dG9tOiBcImF1dG9cIixcbiAgbGVmdDogXCJhdXRvXCJcbn07XG5mdW5jdGlvbiBhcChlLCB0KSB7XG4gIHZhciByID0gZS54LCBuID0gZS55LCBvID0gdC5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogdHIociAqIG8pIC8gbyB8fCAwLFxuICAgIHk6IHRyKG4gKiBvKSAvIG8gfHwgMFxuICB9O1xufVxuZnVuY3Rpb24gZmEoZSkge1xuICB2YXIgdCwgciA9IGUucG9wcGVyLCBuID0gZS5wb3BwZXJSZWN0LCBvID0gZS5wbGFjZW1lbnQsIGkgPSBlLnZhcmlhdGlvbiwgcyA9IGUub2Zmc2V0cywgYyA9IGUucG9zaXRpb24sIGwgPSBlLmdwdUFjY2VsZXJhdGlvbiwgdSA9IGUuYWRhcHRpdmUsIHAgPSBlLnJvdW5kT2Zmc2V0cywgbSA9IGUuaXNGaXhlZCwgZyA9IHMueCwgeCA9IGcgPT09IHZvaWQgMCA/IDAgOiBnLCB5ID0gcy55LCBmID0geSA9PT0gdm9pZCAwID8gMCA6IHksIFMgPSB0eXBlb2YgcCA9PSBcImZ1bmN0aW9uXCIgPyBwKHtcbiAgICB4LFxuICAgIHk6IGZcbiAgfSkgOiB7XG4gICAgeCxcbiAgICB5OiBmXG4gIH07XG4gIHggPSBTLngsIGYgPSBTLnk7XG4gIHZhciBFID0gcy5oYXNPd25Qcm9wZXJ0eShcInhcIiksIFAgPSBzLmhhc093blByb3BlcnR5KFwieVwiKSwgVCA9IFhlLCBiID0gS2UsIGggPSB3aW5kb3c7XG4gIGlmICh1KSB7XG4gICAgdmFyIHcgPSBWcihyKSwgayA9IFwiY2xpZW50SGVpZ2h0XCIsIEwgPSBcImNsaWVudFdpZHRoXCI7XG4gICAgaWYgKHcgPT09IHJ0KHIpICYmICh3ID0gSXQociksIFJ0KHcpLnBvc2l0aW9uICE9PSBcInN0YXRpY1wiICYmIGMgPT09IFwiYWJzb2x1dGVcIiAmJiAoayA9IFwic2Nyb2xsSGVpZ2h0XCIsIEwgPSBcInNjcm9sbFdpZHRoXCIpKSwgdyA9IHcsIG8gPT09IEtlIHx8IChvID09PSBYZSB8fCBvID09PSBjdCkgJiYgaSA9PT0gUHIpIHtcbiAgICAgIGIgPSBzdDtcbiAgICAgIHZhciBCID0gbSAmJiB3ID09PSBoICYmIGgudmlzdWFsVmlld3BvcnQgPyBoLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IChcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgIHdba11cbiAgICAgICk7XG4gICAgICBmIC09IEIgLSBuLmhlaWdodCwgZiAqPSBsID8gMSA6IC0xO1xuICAgIH1cbiAgICBpZiAobyA9PT0gWGUgfHwgKG8gPT09IEtlIHx8IG8gPT09IHN0KSAmJiBpID09PSBQcikge1xuICAgICAgVCA9IGN0O1xuICAgICAgdmFyIGQgPSBtICYmIHcgPT09IGggJiYgaC52aXN1YWxWaWV3cG9ydCA/IGgudmlzdWFsVmlld3BvcnQud2lkdGggOiAoXG4gICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICB3W0xdXG4gICAgICApO1xuICAgICAgeCAtPSBkIC0gbi53aWR0aCwgeCAqPSBsID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuICB2YXIgQSA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBjXG4gIH0sIHUgJiYgaXApLCBEID0gcCA9PT0gITAgPyBhcCh7XG4gICAgeCxcbiAgICB5OiBmXG4gIH0sIHJ0KHIpKSA6IHtcbiAgICB4LFxuICAgIHk6IGZcbiAgfTtcbiAgaWYgKHggPSBELngsIGYgPSBELnksIGwpIHtcbiAgICB2YXIgajtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgQSwgKGogPSB7fSwgaltiXSA9IFAgPyBcIjBcIiA6IFwiXCIsIGpbVF0gPSBFID8gXCIwXCIgOiBcIlwiLCBqLnRyYW5zZm9ybSA9IChoLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgZiArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgZiArIFwicHgsIDApXCIsIGopKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgQSwgKHQgPSB7fSwgdFtiXSA9IFAgPyBmICsgXCJweFwiIDogXCJcIiwgdFtUXSA9IEUgPyB4ICsgXCJweFwiIDogXCJcIiwgdC50cmFuc2Zvcm0gPSBcIlwiLCB0KSk7XG59XG5mdW5jdGlvbiBzcChlKSB7XG4gIHZhciB0ID0gZS5zdGF0ZSwgciA9IGUub3B0aW9ucywgbiA9IHIuZ3B1QWNjZWxlcmF0aW9uLCBvID0gbiA9PT0gdm9pZCAwID8gITAgOiBuLCBpID0gci5hZGFwdGl2ZSwgcyA9IGkgPT09IHZvaWQgMCA/ICEwIDogaSwgYyA9IHIucm91bmRPZmZzZXRzLCBsID0gYyA9PT0gdm9pZCAwID8gITAgOiBjLCB1ID0ge1xuICAgIHBsYWNlbWVudDogeHQodC5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogbnIodC5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogdC5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogdC5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBvLFxuICAgIGlzRml4ZWQ6IHQub3B0aW9ucy5zdHJhdGVneSA9PT0gXCJmaXhlZFwiXG4gIH07XG4gIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwgJiYgKHQuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHQuc3R5bGVzLnBvcHBlciwgZmEoT2JqZWN0LmFzc2lnbih7fSwgdSwge1xuICAgIG9mZnNldHM6IHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgIHBvc2l0aW9uOiB0Lm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgYWRhcHRpdmU6IHMsXG4gICAgcm91bmRPZmZzZXRzOiBsXG4gIH0pKSkpLCB0Lm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCAmJiAodC5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCB0LnN0eWxlcy5hcnJvdywgZmEoT2JqZWN0LmFzc2lnbih7fSwgdSwge1xuICAgIG9mZnNldHM6IHQubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIGFkYXB0aXZlOiAhMSxcbiAgICByb3VuZE9mZnNldHM6IGxcbiAgfSkpKSksIHQuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0LmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgXCJkYXRhLXBvcHBlci1wbGFjZW1lbnRcIjogdC5wbGFjZW1lbnRcbiAgfSk7XG59XG5jb25zdCBjcCA9IHtcbiAgbmFtZTogXCJjb21wdXRlU3R5bGVzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJiZWZvcmVXcml0ZVwiLFxuICBmbjogc3AsXG4gIGRhdGE6IHt9XG59O1xudmFyIFpyID0ge1xuICBwYXNzaXZlOiAhMFxufTtcbmZ1bmN0aW9uIGxwKGUpIHtcbiAgdmFyIHQgPSBlLnN0YXRlLCByID0gZS5pbnN0YW5jZSwgbiA9IGUub3B0aW9ucywgbyA9IG4uc2Nyb2xsLCBpID0gbyA9PT0gdm9pZCAwID8gITAgOiBvLCBzID0gbi5yZXNpemUsIGMgPSBzID09PSB2b2lkIDAgPyAhMCA6IHMsIGwgPSBydCh0LmVsZW1lbnRzLnBvcHBlciksIHUgPSBbXS5jb25jYXQodC5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgdC5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG4gIHJldHVybiBpICYmIHUuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgcC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHIudXBkYXRlLCBacik7XG4gIH0pLCBjICYmIGwuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByLnVwZGF0ZSwgWnIpLCBmdW5jdGlvbigpIHtcbiAgICBpICYmIHUuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICBwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgci51cGRhdGUsIFpyKTtcbiAgICB9KSwgYyAmJiBsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgci51cGRhdGUsIFpyKTtcbiAgfTtcbn1cbmNvbnN0IHVwID0ge1xuICBuYW1lOiBcImV2ZW50TGlzdGVuZXJzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJ3cml0ZVwiLFxuICBmbjogZnVuY3Rpb24oKSB7XG4gIH0sXG4gIGVmZmVjdDogbHAsXG4gIGRhdGE6IHt9XG59O1xudmFyIGZwID0ge1xuICBsZWZ0OiBcInJpZ2h0XCIsXG4gIHJpZ2h0OiBcImxlZnRcIixcbiAgYm90dG9tOiBcInRvcFwiLFxuICB0b3A6IFwiYm90dG9tXCJcbn07XG5mdW5jdGlvbiB1bihlKSB7XG4gIHJldHVybiBlLnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGZwW3RdO1xuICB9KTtcbn1cbnZhciBkcCA9IHtcbiAgc3RhcnQ6IFwiZW5kXCIsXG4gIGVuZDogXCJzdGFydFwiXG59O1xuZnVuY3Rpb24gZGEoZSkge1xuICByZXR1cm4gZS5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBkcFt0XTtcbiAgfSk7XG59XG5mdW5jdGlvbiBKbyhlKSB7XG4gIHZhciB0ID0gcnQoZSksIHIgPSB0LnBhZ2VYT2Zmc2V0LCBuID0gdC5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiByLFxuICAgIHNjcm9sbFRvcDogblxuICB9O1xufVxuZnVuY3Rpb24gUW8oZSkge1xuICByZXR1cm4gcnIoSXQoZSkpLmxlZnQgKyBKbyhlKS5zY3JvbGxMZWZ0O1xufVxuZnVuY3Rpb24gcHAoZSwgdCkge1xuICB2YXIgciA9IHJ0KGUpLCBuID0gSXQoZSksIG8gPSByLnZpc3VhbFZpZXdwb3J0LCBpID0gbi5jbGllbnRXaWR0aCwgcyA9IG4uY2xpZW50SGVpZ2h0LCBjID0gMCwgbCA9IDA7XG4gIGlmIChvKSB7XG4gICAgaSA9IG8ud2lkdGgsIHMgPSBvLmhlaWdodDtcbiAgICB2YXIgdSA9IE9zKCk7XG4gICAgKHUgfHwgIXUgJiYgdCA9PT0gXCJmaXhlZFwiKSAmJiAoYyA9IG8ub2Zmc2V0TGVmdCwgbCA9IG8ub2Zmc2V0VG9wKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiBpLFxuICAgIGhlaWdodDogcyxcbiAgICB4OiBjICsgUW8oZSksXG4gICAgeTogbFxuICB9O1xufVxuZnVuY3Rpb24gbXAoZSkge1xuICB2YXIgdCwgciA9IEl0KGUpLCBuID0gSm8oZSksIG8gPSAodCA9IGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHQuYm9keSwgaSA9IFZ0KHIuc2Nyb2xsV2lkdGgsIHIuY2xpZW50V2lkdGgsIG8gPyBvLnNjcm9sbFdpZHRoIDogMCwgbyA/IG8uY2xpZW50V2lkdGggOiAwKSwgcyA9IFZ0KHIuc2Nyb2xsSGVpZ2h0LCByLmNsaWVudEhlaWdodCwgbyA/IG8uc2Nyb2xsSGVpZ2h0IDogMCwgbyA/IG8uY2xpZW50SGVpZ2h0IDogMCksIGMgPSAtbi5zY3JvbGxMZWZ0ICsgUW8oZSksIGwgPSAtbi5zY3JvbGxUb3A7XG4gIHJldHVybiBSdChvIHx8IHIpLmRpcmVjdGlvbiA9PT0gXCJydGxcIiAmJiAoYyArPSBWdChyLmNsaWVudFdpZHRoLCBvID8gby5jbGllbnRXaWR0aCA6IDApIC0gaSksIHtcbiAgICB3aWR0aDogaSxcbiAgICBoZWlnaHQ6IHMsXG4gICAgeDogYyxcbiAgICB5OiBsXG4gIH07XG59XG5mdW5jdGlvbiBabyhlKSB7XG4gIHZhciB0ID0gUnQoZSksIHIgPSB0Lm92ZXJmbG93LCBuID0gdC5vdmVyZmxvd1gsIG8gPSB0Lm92ZXJmbG93WTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChyICsgbyArIG4pO1xufVxuZnVuY3Rpb24gQXMoZSkge1xuICByZXR1cm4gW1wiaHRtbFwiLCBcImJvZHlcIiwgXCIjZG9jdW1lbnRcIl0uaW5kZXhPZihTdChlKSkgPj0gMCA/IGUub3duZXJEb2N1bWVudC5ib2R5IDogaXQoZSkgJiYgWm8oZSkgPyBlIDogQXMoem4oZSkpO1xufVxuZnVuY3Rpb24gU3IoZSwgdCkge1xuICB2YXIgcjtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0gW10pO1xuICB2YXIgbiA9IEFzKGUpLCBvID0gbiA9PT0gKChyID0gZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogci5ib2R5KSwgaSA9IHJ0KG4pLCBzID0gbyA/IFtpXS5jb25jYXQoaS52aXN1YWxWaWV3cG9ydCB8fCBbXSwgWm8obikgPyBuIDogW10pIDogbiwgYyA9IHQuY29uY2F0KHMpO1xuICByZXR1cm4gbyA/IGMgOiAoXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gICAgYy5jb25jYXQoU3Ioem4ocykpKVxuICApO1xufVxuZnVuY3Rpb24gdm8oZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZSwge1xuICAgIGxlZnQ6IGUueCxcbiAgICB0b3A6IGUueSxcbiAgICByaWdodDogZS54ICsgZS53aWR0aCxcbiAgICBib3R0b206IGUueSArIGUuaGVpZ2h0XG4gIH0pO1xufVxuZnVuY3Rpb24gaHAoZSwgdCkge1xuICB2YXIgciA9IHJyKGUsICExLCB0ID09PSBcImZpeGVkXCIpO1xuICByZXR1cm4gci50b3AgPSByLnRvcCArIGUuY2xpZW50VG9wLCByLmxlZnQgPSByLmxlZnQgKyBlLmNsaWVudExlZnQsIHIuYm90dG9tID0gci50b3AgKyBlLmNsaWVudEhlaWdodCwgci5yaWdodCA9IHIubGVmdCArIGUuY2xpZW50V2lkdGgsIHIud2lkdGggPSBlLmNsaWVudFdpZHRoLCByLmhlaWdodCA9IGUuY2xpZW50SGVpZ2h0LCByLnggPSByLmxlZnQsIHIueSA9IHIudG9wLCByO1xufVxuZnVuY3Rpb24gcGEoZSwgdCwgcikge1xuICByZXR1cm4gdCA9PT0gVHMgPyB2byhwcChlLCByKSkgOiB6dCh0KSA/IGhwKHQsIHIpIDogdm8obXAoSXQoZSkpKTtcbn1cbmZ1bmN0aW9uIGdwKGUpIHtcbiAgdmFyIHQgPSBTcih6bihlKSksIHIgPSBbXCJhYnNvbHV0ZVwiLCBcImZpeGVkXCJdLmluZGV4T2YoUnQoZSkucG9zaXRpb24pID49IDAsIG4gPSByICYmIGl0KGUpID8gVnIoZSkgOiBlO1xuICByZXR1cm4genQobikgPyB0LmZpbHRlcihmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIHp0KG8pICYmIFJzKG8sIG4pICYmIFN0KG8pICE9PSBcImJvZHlcIjtcbiAgfSkgOiBbXTtcbn1cbmZ1bmN0aW9uIHlwKGUsIHQsIHIsIG4pIHtcbiAgdmFyIG8gPSB0ID09PSBcImNsaXBwaW5nUGFyZW50c1wiID8gZ3AoZSkgOiBbXS5jb25jYXQodCksIGkgPSBbXS5jb25jYXQobywgW3JdKSwgcyA9IGlbMF0sIGMgPSBpLnJlZHVjZShmdW5jdGlvbihsLCB1KSB7XG4gICAgdmFyIHAgPSBwYShlLCB1LCBuKTtcbiAgICByZXR1cm4gbC50b3AgPSBWdChwLnRvcCwgbC50b3ApLCBsLnJpZ2h0ID0gRW4ocC5yaWdodCwgbC5yaWdodCksIGwuYm90dG9tID0gRW4ocC5ib3R0b20sIGwuYm90dG9tKSwgbC5sZWZ0ID0gVnQocC5sZWZ0LCBsLmxlZnQpLCBsO1xuICB9LCBwYShlLCBzLCBuKSk7XG4gIHJldHVybiBjLndpZHRoID0gYy5yaWdodCAtIGMubGVmdCwgYy5oZWlnaHQgPSBjLmJvdHRvbSAtIGMudG9wLCBjLnggPSBjLmxlZnQsIGMueSA9IGMudG9wLCBjO1xufVxuZnVuY3Rpb24gTnMoZSkge1xuICB2YXIgdCA9IGUucmVmZXJlbmNlLCByID0gZS5lbGVtZW50LCBuID0gZS5wbGFjZW1lbnQsIG8gPSBuID8geHQobikgOiBudWxsLCBpID0gbiA/IG5yKG4pIDogbnVsbCwgcyA9IHQueCArIHQud2lkdGggLyAyIC0gci53aWR0aCAvIDIsIGMgPSB0LnkgKyB0LmhlaWdodCAvIDIgLSByLmhlaWdodCAvIDIsIGw7XG4gIHN3aXRjaCAobykge1xuICAgIGNhc2UgS2U6XG4gICAgICBsID0ge1xuICAgICAgICB4OiBzLFxuICAgICAgICB5OiB0LnkgLSByLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2Ugc3Q6XG4gICAgICBsID0ge1xuICAgICAgICB4OiBzLFxuICAgICAgICB5OiB0LnkgKyB0LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgY3Q6XG4gICAgICBsID0ge1xuICAgICAgICB4OiB0LnggKyB0LndpZHRoLFxuICAgICAgICB5OiBjXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBYZTpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IHQueCAtIHIud2lkdGgsXG4gICAgICAgIHk6IGNcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54LFxuICAgICAgICB5OiB0LnlcbiAgICAgIH07XG4gIH1cbiAgdmFyIHUgPSBvID8gWG8obykgOiBudWxsO1xuICBpZiAodSAhPSBudWxsKSB7XG4gICAgdmFyIHAgPSB1ID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG4gICAgc3dpdGNoIChpKSB7XG4gICAgICBjYXNlIGVyOlxuICAgICAgICBsW3VdID0gbFt1XSAtICh0W3BdIC8gMiAtIHJbcF0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFByOlxuICAgICAgICBsW3VdID0gbFt1XSArICh0W3BdIC8gMiAtIHJbcF0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBsO1xufVxuZnVuY3Rpb24ga3IoZSwgdCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XG4gIHZhciByID0gdCwgbiA9IHIucGxhY2VtZW50LCBvID0gbiA9PT0gdm9pZCAwID8gZS5wbGFjZW1lbnQgOiBuLCBpID0gci5zdHJhdGVneSwgcyA9IGkgPT09IHZvaWQgMCA/IGUuc3RyYXRlZ3kgOiBpLCBjID0gci5ib3VuZGFyeSwgbCA9IGMgPT09IHZvaWQgMCA/IERkIDogYywgdSA9IHIucm9vdEJvdW5kYXJ5LCBwID0gdSA9PT0gdm9pZCAwID8gVHMgOiB1LCBtID0gci5lbGVtZW50Q29udGV4dCwgZyA9IG0gPT09IHZvaWQgMCA/IHByIDogbSwgeCA9IHIuYWx0Qm91bmRhcnksIHkgPSB4ID09PSB2b2lkIDAgPyAhMSA6IHgsIGYgPSByLnBhZGRpbmcsIFMgPSBmID09PSB2b2lkIDAgPyAwIDogZiwgRSA9IFBzKHR5cGVvZiBTICE9IFwibnVtYmVyXCIgPyBTIDoga3MoUywgQnIpKSwgUCA9IGcgPT09IHByID8gTGQgOiBwciwgVCA9IGUucmVjdHMucG9wcGVyLCBiID0gZS5lbGVtZW50c1t5ID8gUCA6IGddLCBoID0geXAoenQoYikgPyBiIDogYi5jb250ZXh0RWxlbWVudCB8fCBJdChlLmVsZW1lbnRzLnBvcHBlciksIGwsIHAsIHMpLCB3ID0gcnIoZS5lbGVtZW50cy5yZWZlcmVuY2UpLCBrID0gTnMoe1xuICAgIHJlZmVyZW5jZTogdyxcbiAgICBlbGVtZW50OiBULFxuICAgIHN0cmF0ZWd5OiBcImFic29sdXRlXCIsXG4gICAgcGxhY2VtZW50OiBvXG4gIH0pLCBMID0gdm8oT2JqZWN0LmFzc2lnbih7fSwgVCwgaykpLCBCID0gZyA9PT0gcHIgPyBMIDogdywgZCA9IHtcbiAgICB0b3A6IGgudG9wIC0gQi50b3AgKyBFLnRvcCxcbiAgICBib3R0b206IEIuYm90dG9tIC0gaC5ib3R0b20gKyBFLmJvdHRvbSxcbiAgICBsZWZ0OiBoLmxlZnQgLSBCLmxlZnQgKyBFLmxlZnQsXG4gICAgcmlnaHQ6IEIucmlnaHQgLSBoLnJpZ2h0ICsgRS5yaWdodFxuICB9LCBBID0gZS5tb2RpZmllcnNEYXRhLm9mZnNldDtcbiAgaWYgKGcgPT09IHByICYmIEEpIHtcbiAgICB2YXIgRCA9IEFbb107XG4gICAgT2JqZWN0LmtleXMoZCkuZm9yRWFjaChmdW5jdGlvbihqKSB7XG4gICAgICB2YXIgVyA9IFtjdCwgc3RdLmluZGV4T2YoaikgPj0gMCA/IDEgOiAtMSwgeiA9IFtLZSwgc3RdLmluZGV4T2YoaikgPj0gMCA/IFwieVwiIDogXCJ4XCI7XG4gICAgICBkW2pdICs9IERbel0gKiBXO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBkO1xufVxuZnVuY3Rpb24gYnAoZSwgdCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XG4gIHZhciByID0gdCwgbiA9IHIucGxhY2VtZW50LCBvID0gci5ib3VuZGFyeSwgaSA9IHIucm9vdEJvdW5kYXJ5LCBzID0gci5wYWRkaW5nLCBjID0gci5mbGlwVmFyaWF0aW9ucywgbCA9IHIuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLCB1ID0gbCA9PT0gdm9pZCAwID8gd3MgOiBsLCBwID0gbnIobiksIG0gPSBwID8gYyA/IGxhIDogbGEuZmlsdGVyKGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gbnIoeSkgPT09IHA7XG4gIH0pIDogQnIsIGcgPSBtLmZpbHRlcihmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHUuaW5kZXhPZih5KSA+PSAwO1xuICB9KTtcbiAgZy5sZW5ndGggPT09IDAgJiYgKGcgPSBtKTtcbiAgdmFyIHggPSBnLnJlZHVjZShmdW5jdGlvbih5LCBmKSB7XG4gICAgcmV0dXJuIHlbZl0gPSBrcihlLCB7XG4gICAgICBwbGFjZW1lbnQ6IGYsXG4gICAgICBib3VuZGFyeTogbyxcbiAgICAgIHJvb3RCb3VuZGFyeTogaSxcbiAgICAgIHBhZGRpbmc6IHNcbiAgICB9KVt4dChmKV0sIHk7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHgpLnNvcnQoZnVuY3Rpb24oeSwgZikge1xuICAgIHJldHVybiB4W3ldIC0geFtmXTtcbiAgfSk7XG59XG5mdW5jdGlvbiB2cChlKSB7XG4gIGlmICh4dChlKSA9PT0gcW8pXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgdCA9IHVuKGUpO1xuICByZXR1cm4gW2RhKGUpLCB0LCBkYSh0KV07XG59XG5mdW5jdGlvbiB4cChlKSB7XG4gIHZhciB0ID0gZS5zdGF0ZSwgciA9IGUub3B0aW9ucywgbiA9IGUubmFtZTtcbiAgaWYgKCF0Lm1vZGlmaWVyc0RhdGFbbl0uX3NraXApIHtcbiAgICBmb3IgKHZhciBvID0gci5tYWluQXhpcywgaSA9IG8gPT09IHZvaWQgMCA/ICEwIDogbywgcyA9IHIuYWx0QXhpcywgYyA9IHMgPT09IHZvaWQgMCA/ICEwIDogcywgbCA9IHIuZmFsbGJhY2tQbGFjZW1lbnRzLCB1ID0gci5wYWRkaW5nLCBwID0gci5ib3VuZGFyeSwgbSA9IHIucm9vdEJvdW5kYXJ5LCBnID0gci5hbHRCb3VuZGFyeSwgeCA9IHIuZmxpcFZhcmlhdGlvbnMsIHkgPSB4ID09PSB2b2lkIDAgPyAhMCA6IHgsIGYgPSByLmFsbG93ZWRBdXRvUGxhY2VtZW50cywgUyA9IHQub3B0aW9ucy5wbGFjZW1lbnQsIEUgPSB4dChTKSwgUCA9IEUgPT09IFMsIFQgPSBsIHx8IChQIHx8ICF5ID8gW3VuKFMpXSA6IHZwKFMpKSwgYiA9IFtTXS5jb25jYXQoVCkucmVkdWNlKGZ1bmN0aW9uKEgsIFgpIHtcbiAgICAgIHJldHVybiBILmNvbmNhdCh4dChYKSA9PT0gcW8gPyBicCh0LCB7XG4gICAgICAgIHBsYWNlbWVudDogWCxcbiAgICAgICAgYm91bmRhcnk6IHAsXG4gICAgICAgIHJvb3RCb3VuZGFyeTogbSxcbiAgICAgICAgcGFkZGluZzogdSxcbiAgICAgICAgZmxpcFZhcmlhdGlvbnM6IHksXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogZlxuICAgICAgfSkgOiBYKTtcbiAgICB9LCBbXSksIGggPSB0LnJlY3RzLnJlZmVyZW5jZSwgdyA9IHQucmVjdHMucG9wcGVyLCBrID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgTCA9ICEwLCBCID0gYlswXSwgZCA9IDA7IGQgPCBiLmxlbmd0aDsgZCsrKSB7XG4gICAgICB2YXIgQSA9IGJbZF0sIEQgPSB4dChBKSwgaiA9IG5yKEEpID09PSBlciwgVyA9IFtLZSwgc3RdLmluZGV4T2YoRCkgPj0gMCwgeiA9IFcgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCBVID0ga3IodCwge1xuICAgICAgICBwbGFjZW1lbnQ6IEEsXG4gICAgICAgIGJvdW5kYXJ5OiBwLFxuICAgICAgICByb290Qm91bmRhcnk6IG0sXG4gICAgICAgIGFsdEJvdW5kYXJ5OiBnLFxuICAgICAgICBwYWRkaW5nOiB1XG4gICAgICB9KSwgViA9IFcgPyBqID8gY3QgOiBYZSA6IGogPyBzdCA6IEtlO1xuICAgICAgaFt6XSA+IHdbel0gJiYgKFYgPSB1bihWKSk7XG4gICAgICB2YXIgdGUgPSB1bihWKSwgRiA9IFtdO1xuICAgICAgaWYgKGkgJiYgRi5wdXNoKFVbRF0gPD0gMCksIGMgJiYgRi5wdXNoKFVbVl0gPD0gMCwgVVt0ZV0gPD0gMCksIEYuZXZlcnkoZnVuY3Rpb24oSCkge1xuICAgICAgICByZXR1cm4gSDtcbiAgICAgIH0pKSB7XG4gICAgICAgIEIgPSBBLCBMID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgay5zZXQoQSwgRik7XG4gICAgfVxuICAgIGlmIChMKVxuICAgICAgZm9yICh2YXIgUiA9IHkgPyAzIDogMSwgSSA9IGZ1bmN0aW9uKFgpIHtcbiAgICAgICAgdmFyIF8gPSBiLmZpbmQoZnVuY3Rpb24ocSkge1xuICAgICAgICAgIHZhciBHID0gay5nZXQocSk7XG4gICAgICAgICAgaWYgKEcpXG4gICAgICAgICAgICByZXR1cm4gRy5zbGljZSgwLCBYKS5ldmVyeShmdW5jdGlvbihyZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfKVxuICAgICAgICAgIHJldHVybiBCID0gXywgXCJicmVha1wiO1xuICAgICAgfSwgSiA9IFI7IEogPiAwOyBKLS0pIHtcbiAgICAgICAgdmFyIFEgPSBJKEopO1xuICAgICAgICBpZiAoUSA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICAgIH1cbiAgICB0LnBsYWNlbWVudCAhPT0gQiAmJiAodC5tb2RpZmllcnNEYXRhW25dLl9za2lwID0gITAsIHQucGxhY2VtZW50ID0gQiwgdC5yZXNldCA9ICEwKTtcbiAgfVxufVxuY29uc3QgU3AgPSB7XG4gIG5hbWU6IFwiZmxpcFwiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICBmbjogeHAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcIm9mZnNldFwiXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiAhMVxuICB9XG59O1xuZnVuY3Rpb24gbWEoZSwgdCwgcikge1xuICByZXR1cm4gciA9PT0gdm9pZCAwICYmIChyID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9KSwge1xuICAgIHRvcDogZS50b3AgLSB0LmhlaWdodCAtIHIueSxcbiAgICByaWdodDogZS5yaWdodCAtIHQud2lkdGggKyByLngsXG4gICAgYm90dG9tOiBlLmJvdHRvbSAtIHQuaGVpZ2h0ICsgci55LFxuICAgIGxlZnQ6IGUubGVmdCAtIHQud2lkdGggLSByLnhcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhKGUpIHtcbiAgcmV0dXJuIFtLZSwgY3QsIHN0LCBYZV0uc29tZShmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGVbdF0gPj0gMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBFcChlKSB7XG4gIHZhciB0ID0gZS5zdGF0ZSwgciA9IGUubmFtZSwgbiA9IHQucmVjdHMucmVmZXJlbmNlLCBvID0gdC5yZWN0cy5wb3BwZXIsIGkgPSB0Lm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93LCBzID0ga3IodCwge1xuICAgIGVsZW1lbnRDb250ZXh0OiBcInJlZmVyZW5jZVwiXG4gIH0pLCBjID0ga3IodCwge1xuICAgIGFsdEJvdW5kYXJ5OiAhMFxuICB9KSwgbCA9IG1hKHMsIG4pLCB1ID0gbWEoYywgbywgaSksIHAgPSBoYShsKSwgbSA9IGhhKHUpO1xuICB0Lm1vZGlmaWVyc0RhdGFbcl0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiBsLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHUsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IHAsXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogbVxuICB9LCB0LmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgIFwiZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlblwiOiBwLFxuICAgIFwiZGF0YS1wb3BwZXItZXNjYXBlZFwiOiBtXG4gIH0pO1xufVxuY29uc3QgQ3AgPSB7XG4gIG5hbWU6IFwiaGlkZVwiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJwcmV2ZW50T3ZlcmZsb3dcIl0sXG4gIGZuOiBFcFxufTtcbmZ1bmN0aW9uIFRwKGUsIHQsIHIpIHtcbiAgdmFyIG4gPSB4dChlKSwgbyA9IFtYZSwgS2VdLmluZGV4T2YobikgPj0gMCA/IC0xIDogMSwgaSA9IHR5cGVvZiByID09IFwiZnVuY3Rpb25cIiA/IHIoT2JqZWN0LmFzc2lnbih7fSwgdCwge1xuICAgIHBsYWNlbWVudDogZVxuICB9KSkgOiByLCBzID0gaVswXSwgYyA9IGlbMV07XG4gIHJldHVybiBzID0gcyB8fCAwLCBjID0gKGMgfHwgMCkgKiBvLCBbWGUsIGN0XS5pbmRleE9mKG4pID49IDAgPyB7XG4gICAgeDogYyxcbiAgICB5OiBzXG4gIH0gOiB7XG4gICAgeDogcyxcbiAgICB5OiBjXG4gIH07XG59XG5mdW5jdGlvbiB3cChlKSB7XG4gIHZhciB0ID0gZS5zdGF0ZSwgciA9IGUub3B0aW9ucywgbiA9IGUubmFtZSwgbyA9IHIub2Zmc2V0LCBpID0gbyA9PT0gdm9pZCAwID8gWzAsIDBdIDogbywgcyA9IHdzLnJlZHVjZShmdW5jdGlvbihwLCBtKSB7XG4gICAgcmV0dXJuIHBbbV0gPSBUcChtLCB0LnJlY3RzLCBpKSwgcDtcbiAgfSwge30pLCBjID0gc1t0LnBsYWNlbWVudF0sIGwgPSBjLngsIHUgPSBjLnk7XG4gIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwgJiYgKHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0gbCwgdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB1KSwgdC5tb2RpZmllcnNEYXRhW25dID0gcztcbn1cbmNvbnN0IE9wID0ge1xuICBuYW1lOiBcIm9mZnNldFwiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICByZXF1aXJlczogW1wicG9wcGVyT2Zmc2V0c1wiXSxcbiAgZm46IHdwXG59O1xuZnVuY3Rpb24gUnAoZSkge1xuICB2YXIgdCA9IGUuc3RhdGUsIHIgPSBlLm5hbWU7XG4gIHQubW9kaWZpZXJzRGF0YVtyXSA9IE5zKHtcbiAgICByZWZlcmVuY2U6IHQucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHQucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiBcImFic29sdXRlXCIsXG4gICAgcGxhY2VtZW50OiB0LnBsYWNlbWVudFxuICB9KTtcbn1cbmNvbnN0ICRwID0ge1xuICBuYW1lOiBcInBvcHBlck9mZnNldHNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcInJlYWRcIixcbiAgZm46IFJwLFxuICBkYXRhOiB7fVxufTtcbmZ1bmN0aW9uIFBwKGUpIHtcbiAgcmV0dXJuIGUgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbn1cbmZ1bmN0aW9uIGtwKGUpIHtcbiAgdmFyIHQgPSBlLnN0YXRlLCByID0gZS5vcHRpb25zLCBuID0gZS5uYW1lLCBvID0gci5tYWluQXhpcywgaSA9IG8gPT09IHZvaWQgMCA/ICEwIDogbywgcyA9IHIuYWx0QXhpcywgYyA9IHMgPT09IHZvaWQgMCA/ICExIDogcywgbCA9IHIuYm91bmRhcnksIHUgPSByLnJvb3RCb3VuZGFyeSwgcCA9IHIuYWx0Qm91bmRhcnksIG0gPSByLnBhZGRpbmcsIGcgPSByLnRldGhlciwgeCA9IGcgPT09IHZvaWQgMCA/ICEwIDogZywgeSA9IHIudGV0aGVyT2Zmc2V0LCBmID0geSA9PT0gdm9pZCAwID8gMCA6IHksIFMgPSBrcih0LCB7XG4gICAgYm91bmRhcnk6IGwsXG4gICAgcm9vdEJvdW5kYXJ5OiB1LFxuICAgIHBhZGRpbmc6IG0sXG4gICAgYWx0Qm91bmRhcnk6IHBcbiAgfSksIEUgPSB4dCh0LnBsYWNlbWVudCksIFAgPSBucih0LnBsYWNlbWVudCksIFQgPSAhUCwgYiA9IFhvKEUpLCBoID0gUHAoYiksIHcgPSB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cywgayA9IHQucmVjdHMucmVmZXJlbmNlLCBMID0gdC5yZWN0cy5wb3BwZXIsIEIgPSB0eXBlb2YgZiA9PSBcImZ1bmN0aW9uXCIgPyBmKE9iamVjdC5hc3NpZ24oe30sIHQucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHQucGxhY2VtZW50XG4gIH0pKSA6IGYsIGQgPSB0eXBlb2YgQiA9PSBcIm51bWJlclwiID8ge1xuICAgIG1haW5BeGlzOiBCLFxuICAgIGFsdEF4aXM6IEJcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgQiksIEEgPSB0Lm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gdC5tb2RpZmllcnNEYXRhLm9mZnNldFt0LnBsYWNlbWVudF0gOiBudWxsLCBEID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBpZiAodykge1xuICAgIGlmIChpKSB7XG4gICAgICB2YXIgaiwgVyA9IGIgPT09IFwieVwiID8gS2UgOiBYZSwgeiA9IGIgPT09IFwieVwiID8gc3QgOiBjdCwgVSA9IGIgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgViA9IHdbYl0sIHRlID0gViArIFNbV10sIEYgPSBWIC0gU1t6XSwgUiA9IHggPyAtTFtVXSAvIDIgOiAwLCBJID0gUCA9PT0gZXIgPyBrW1VdIDogTFtVXSwgSiA9IFAgPT09IGVyID8gLUxbVV0gOiAta1tVXSwgUSA9IHQuZWxlbWVudHMuYXJyb3csIEggPSB4ICYmIFEgPyBLbyhRKSA6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSwgWCA9IHQubW9kaWZpZXJzRGF0YVtcImFycm93I3BlcnNpc3RlbnRcIl0gPyB0Lm1vZGlmaWVyc0RhdGFbXCJhcnJvdyNwZXJzaXN0ZW50XCJdLnBhZGRpbmcgOiAkcygpLCBfID0gWFtXXSwgcSA9IFhbel0sIEcgPSB4cigwLCBrW1VdLCBIW1VdKSwgcmUgPSBUID8ga1tVXSAvIDIgLSBSIC0gRyAtIF8gLSBkLm1haW5BeGlzIDogSSAtIEcgLSBfIC0gZC5tYWluQXhpcywgWiA9IFQgPyAta1tVXSAvIDIgKyBSICsgRyArIHEgKyBkLm1haW5BeGlzIDogSiArIEcgKyBxICsgZC5tYWluQXhpcywgYWUgPSB0LmVsZW1lbnRzLmFycm93ICYmIFZyKHQuZWxlbWVudHMuYXJyb3cpLCBPID0gYWUgPyBiID09PSBcInlcIiA/IGFlLmNsaWVudFRvcCB8fCAwIDogYWUuY2xpZW50TGVmdCB8fCAwIDogMCwgeWUgPSAoaiA9IEEgPT0gbnVsbCA/IHZvaWQgMCA6IEFbYl0pICE9IG51bGwgPyBqIDogMCwgRWUgPSBWICsgcmUgLSB5ZSAtIE8sIE1lID0gViArIFogLSB5ZSwgUWUgPSB4cih4ID8gRW4odGUsIEVlKSA6IHRlLCBWLCB4ID8gVnQoRiwgTWUpIDogRik7XG4gICAgICB3W2JdID0gUWUsIERbYl0gPSBRZSAtIFY7XG4gICAgfVxuICAgIGlmIChjKSB7XG4gICAgICB2YXIgdmUsIFBlID0gYiA9PT0gXCJ4XCIgPyBLZSA6IFhlLCB6ZSA9IGIgPT09IFwieFwiID8gc3QgOiBjdCwgTGUgPSB3W2hdLCB2ID0gaCA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLCBNID0gTGUgKyBTW1BlXSwgWSA9IExlIC0gU1t6ZV0sIG9lID0gW0tlLCBYZV0uaW5kZXhPZihFKSAhPT0gLTEsIFJlID0gKHZlID0gQSA9PSBudWxsID8gdm9pZCAwIDogQVtoXSkgIT0gbnVsbCA/IHZlIDogMCwgdWUgPSBvZSA/IE0gOiBMZSAtIGtbdl0gLSBMW3ZdIC0gUmUgKyBkLmFsdEF4aXMsIEsgPSBvZSA/IExlICsga1t2XSArIExbdl0gLSBSZSAtIGQuYWx0QXhpcyA6IFksIGJlID0geCAmJiBvZSA/IGVwKHVlLCBMZSwgSykgOiB4cih4ID8gdWUgOiBNLCBMZSwgeCA/IEsgOiBZKTtcbiAgICAgIHdbaF0gPSBiZSwgRFtoXSA9IGJlIC0gTGU7XG4gICAgfVxuICAgIHQubW9kaWZpZXJzRGF0YVtuXSA9IEQ7XG4gIH1cbn1cbmNvbnN0IEFwID0ge1xuICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICBmbjoga3AsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcIm9mZnNldFwiXVxufTtcbmZ1bmN0aW9uIE5wKGUpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlLnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlLnNjcm9sbFRvcFxuICB9O1xufVxuZnVuY3Rpb24gTXAoZSkge1xuICByZXR1cm4gZSA9PT0gcnQoZSkgfHwgIWl0KGUpID8gSm8oZSkgOiBOcChlKTtcbn1cbmZ1bmN0aW9uIElwKGUpIHtcbiAgdmFyIHQgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCByID0gdHIodC53aWR0aCkgLyBlLm9mZnNldFdpZHRoIHx8IDEsIG4gPSB0cih0LmhlaWdodCkgLyBlLm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gciAhPT0gMSB8fCBuICE9PSAxO1xufVxuZnVuY3Rpb24gX3AoZSwgdCwgcikge1xuICByID09PSB2b2lkIDAgJiYgKHIgPSAhMSk7XG4gIHZhciBuID0gaXQodCksIG8gPSBpdCh0KSAmJiBJcCh0KSwgaSA9IEl0KHQpLCBzID0gcnIoZSwgbywgciksIGMgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfSwgbCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgcmV0dXJuIChuIHx8ICFuICYmICFyKSAmJiAoKFN0KHQpICE9PSBcImJvZHlcIiB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgWm8oaSkpICYmIChjID0gTXAodCkpLCBpdCh0KSA/IChsID0gcnIodCwgITApLCBsLnggKz0gdC5jbGllbnRMZWZ0LCBsLnkgKz0gdC5jbGllbnRUb3ApIDogaSAmJiAobC54ID0gUW8oaSkpKSwge1xuICAgIHg6IHMubGVmdCArIGMuc2Nyb2xsTGVmdCAtIGwueCxcbiAgICB5OiBzLnRvcCArIGMuc2Nyb2xsVG9wIC0gbC55LFxuICAgIHdpZHRoOiBzLndpZHRoLFxuICAgIGhlaWdodDogcy5oZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGpwKGUpIHtcbiAgdmFyIHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCByID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbiA9IFtdO1xuICBlLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgIHQuc2V0KGkubmFtZSwgaSk7XG4gIH0pO1xuICBmdW5jdGlvbiBvKGkpIHtcbiAgICByLmFkZChpLm5hbWUpO1xuICAgIHZhciBzID0gW10uY29uY2F0KGkucmVxdWlyZXMgfHwgW10sIGkucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgIGlmICghci5oYXMoYykpIHtcbiAgICAgICAgdmFyIGwgPSB0LmdldChjKTtcbiAgICAgICAgbCAmJiBvKGwpO1xuICAgICAgfVxuICAgIH0pLCBuLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgci5oYXMoaS5uYW1lKSB8fCBvKGkpO1xuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIERwKGUpIHtcbiAgdmFyIHQgPSBqcChlKTtcbiAgcmV0dXJuIEdkLnJlZHVjZShmdW5jdGlvbihyLCBuKSB7XG4gICAgcmV0dXJuIHIuY29uY2F0KHQuZmlsdGVyKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBvLnBoYXNlID09PSBuO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gTHAoZSkge1xuICB2YXIgdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0IHx8ICh0ID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocikge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgdCA9IHZvaWQgMCwgcihlKCkpO1xuICAgICAgfSk7XG4gICAgfSkpLCB0O1xuICB9O1xufVxuZnVuY3Rpb24gQnAoZSkge1xuICB2YXIgdCA9IGUucmVkdWNlKGZ1bmN0aW9uKHIsIG4pIHtcbiAgICB2YXIgbyA9IHJbbi5uYW1lXTtcbiAgICByZXR1cm4gcltuLm5hbWVdID0gbyA/IE9iamVjdC5hc3NpZ24oe30sIG8sIG4sIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG8ub3B0aW9ucywgbi5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIG8uZGF0YSwgbi5kYXRhKVxuICAgIH0pIDogbiwgcjtcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXModCkubWFwKGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gdFtyXTtcbiAgfSk7XG59XG52YXIgZ2EgPSB7XG4gIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIlxufTtcbmZ1bmN0aW9uIHlhKCkge1xuICBmb3IgKHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShlKSwgciA9IDA7IHIgPCBlOyByKyspXG4gICAgdFtyXSA9IGFyZ3VtZW50c1tyXTtcbiAgcmV0dXJuICF0LnNvbWUoZnVuY3Rpb24obikge1xuICAgIHJldHVybiAhKG4gJiYgdHlwZW9mIG4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09IFwiZnVuY3Rpb25cIik7XG4gIH0pO1xufVxuZnVuY3Rpb24gVnAoZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSB7fSk7XG4gIHZhciB0ID0gZSwgciA9IHQuZGVmYXVsdE1vZGlmaWVycywgbiA9IHIgPT09IHZvaWQgMCA/IFtdIDogciwgbyA9IHQuZGVmYXVsdE9wdGlvbnMsIGkgPSBvID09PSB2b2lkIDAgPyBnYSA6IG87XG4gIHJldHVybiBmdW5jdGlvbihjLCBsLCB1KSB7XG4gICAgdSA9PT0gdm9pZCAwICYmICh1ID0gaSk7XG4gICAgdmFyIHAgPSB7XG4gICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGdhLCBpKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiBjLFxuICAgICAgICBwb3BwZXI6IGxcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9LCBtID0gW10sIGcgPSAhMSwgeCA9IHtcbiAgICAgIHN0YXRlOiBwLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24oRSkge1xuICAgICAgICB2YXIgUCA9IHR5cGVvZiBFID09IFwiZnVuY3Rpb25cIiA/IEUocC5vcHRpb25zKSA6IEU7XG4gICAgICAgIGYoKSwgcC5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaSwgcC5vcHRpb25zLCBQKSwgcC5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogenQoYykgPyBTcihjKSA6IGMuY29udGV4dEVsZW1lbnQgPyBTcihjLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogU3IobClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIFQgPSBEcChCcChbXS5jb25jYXQobiwgcC5vcHRpb25zLm1vZGlmaWVycykpKTtcbiAgICAgICAgcmV0dXJuIHAub3JkZXJlZE1vZGlmaWVycyA9IFQuZmlsdGVyKGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICByZXR1cm4gYi5lbmFibGVkO1xuICAgICAgICB9KSwgeSgpLCB4LnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFnKSB7XG4gICAgICAgICAgdmFyIEUgPSBwLmVsZW1lbnRzLCBQID0gRS5yZWZlcmVuY2UsIFQgPSBFLnBvcHBlcjtcbiAgICAgICAgICBpZiAoeWEoUCwgVCkpIHtcbiAgICAgICAgICAgIHAucmVjdHMgPSB7XG4gICAgICAgICAgICAgIHJlZmVyZW5jZTogX3AoUCwgVnIoVCksIHAub3B0aW9ucy5zdHJhdGVneSA9PT0gXCJmaXhlZFwiKSxcbiAgICAgICAgICAgICAgcG9wcGVyOiBLbyhUKVxuICAgICAgICAgICAgfSwgcC5yZXNldCA9ICExLCBwLnBsYWNlbWVudCA9IHAub3B0aW9ucy5wbGFjZW1lbnQsIHAub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHAubW9kaWZpZXJzRGF0YVtkLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgZC5kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBwLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgICAgaWYgKHAucmVzZXQgPT09ICEwKSB7XG4gICAgICAgICAgICAgICAgcC5yZXNldCA9ICExLCBiID0gLTE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGggPSBwLm9yZGVyZWRNb2RpZmllcnNbYl0sIHcgPSBoLmZuLCBrID0gaC5vcHRpb25zLCBMID0gayA9PT0gdm9pZCAwID8ge30gOiBrLCBCID0gaC5uYW1lO1xuICAgICAgICAgICAgICB0eXBlb2YgdyA9PSBcImZ1bmN0aW9uXCIgJiYgKHAgPSB3KHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogcCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBMLFxuICAgICAgICAgICAgICAgIG5hbWU6IEIsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHhcbiAgICAgICAgICAgICAgfSkgfHwgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogTHAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihTKSB7XG4gICAgICAgICAgeC5mb3JjZVVwZGF0ZSgpLCBTKHApO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGYoKSwgZyA9ICEwO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCF5YShjLCBsKSlcbiAgICAgIHJldHVybiB4O1xuICAgIHguc2V0T3B0aW9ucyh1KS50aGVuKGZ1bmN0aW9uKFMpIHtcbiAgICAgICFnICYmIHUub25GaXJzdFVwZGF0ZSAmJiB1Lm9uRmlyc3RVcGRhdGUoUyk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24geSgpIHtcbiAgICAgIHAub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgdmFyIEUgPSBTLm5hbWUsIFAgPSBTLm9wdGlvbnMsIFQgPSBQID09PSB2b2lkIDAgPyB7fSA6IFAsIGIgPSBTLmVmZmVjdDtcbiAgICAgICAgaWYgKHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHZhciBoID0gYih7XG4gICAgICAgICAgICBzdGF0ZTogcCxcbiAgICAgICAgICAgIG5hbWU6IEUsXG4gICAgICAgICAgICBpbnN0YW5jZTogeCxcbiAgICAgICAgICAgIG9wdGlvbnM6IFRcbiAgICAgICAgICB9KSwgdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIH07XG4gICAgICAgICAgbS5wdXNoKGggfHwgdyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgcmV0dXJuIFMoKTtcbiAgICAgIH0pLCBtID0gW107XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9O1xufVxudmFyIEZwID0gW3VwLCAkcCwgY3AsIEpkLCBPcCwgU3AsIEFwLCBvcCwgQ3BdLCB6cCA9IC8qIEBfX1BVUkVfXyAqLyBWcCh7XG4gIGRlZmF1bHRNb2RpZmllcnM6IEZwXG59KTtcbmZ1bmN0aW9uIFdwKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUoKSA6IGU7XG59XG5jb25zdCBDbiA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW46IG4sXG4gICAgY29udGFpbmVyOiBvLFxuICAgIGRpc2FibGVQb3J0YWw6IGkgPSAhMVxuICB9ID0gdCwgW3MsIGNdID0gQy51c2VTdGF0ZShudWxsKSwgbCA9IGF0KC8qIEBfX1BVUkVfXyAqLyBDLmlzVmFsaWRFbGVtZW50KG4pID8gQm8obikgOiBudWxsLCByKTtcbiAgaWYgKEZ0KCgpID0+IHtcbiAgICBpIHx8IGMoV3AobykgfHwgZG9jdW1lbnQuYm9keSk7XG4gIH0sIFtvLCBpXSksIEZ0KCgpID0+IHtcbiAgICBpZiAocyAmJiAhaSlcbiAgICAgIHJldHVybiB1byhyLCBzKSwgKCkgPT4ge1xuICAgICAgICB1byhyLCBudWxsKTtcbiAgICAgIH07XG4gIH0sIFtyLCBzLCBpXSksIGkpIHtcbiAgICBpZiAoLyogQF9fUFVSRV9fICovIEMuaXNWYWxpZEVsZW1lbnQobikpIHtcbiAgICAgIGNvbnN0IHUgPSB7XG4gICAgICAgIHJlZjogbFxuICAgICAgfTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gQy5jbG9uZUVsZW1lbnQobiwgdSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIHJldHVybiBzICYmIC8qIEBfX1BVUkVfXyAqLyBacy5jcmVhdGVQb3J0YWwobiwgcyk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoQ24ucHJvcFR5cGVzID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgVHlwZVNjcmlwdCB0eXBlcyBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICAqIFRoZSBjaGlsZHJlbiB0byByZW5kZXIgaW50byB0aGUgYGNvbnRhaW5lcmAuXG4gICAqL1xuICBjaGlsZHJlbjogYS5ub2RlLFxuICAvKipcbiAgICogQW4gSFRNTCBlbGVtZW50IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBvbmUuXG4gICAqIFRoZSBgY29udGFpbmVyYCB3aWxsIGhhdmUgdGhlIHBvcnRhbCBjaGlsZHJlbiBhcHBlbmRlZCB0byBpdC5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBjYWxsYmFjaywgd2hpY2ggaXMgY2FsbGVkIGluIGEgUmVhY3QgbGF5b3V0IGVmZmVjdC5cbiAgICogVGhpcyBsZXRzIHlvdSBzZXQgdGhlIGNvbnRhaW5lciBmcm9tIGEgcmVmLCBhbmQgYWxzbyBtYWtlcyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcG9zc2libGUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgdGhlIGJvZHkgb2YgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBvYmplY3QsXG4gICAqIHNvIGl0J3Mgc2ltcGx5IGBkb2N1bWVudC5ib2R5YCBtb3N0IG9mIHRoZSB0aW1lLlxuICAgKi9cbiAgY29udGFpbmVyOiBhLm9uZU9mVHlwZShbT3IsIGEuZnVuY10pLFxuICAvKipcbiAgICogVGhlIGBjaGlsZHJlbmAgd2lsbCBiZSB1bmRlciB0aGUgRE9NIGhpZXJhcmNoeSBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVQb3J0YWw6IGEuYm9vbFxufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKENuLnByb3BUeXBlcyA9IERvKENuLnByb3BUeXBlcykpO1xuZnVuY3Rpb24gVXAoZSkge1xuICByZXR1cm4gVmUoXCJNdWlQb3BwZXJcIiwgZSk7XG59XG5GZShcIk11aVBvcHBlclwiLCBbXCJyb290XCJdKTtcbmZ1bmN0aW9uIFlwKGUsIHQpIHtcbiAgaWYgKHQgPT09IFwibHRyXCIpXG4gICAgcmV0dXJuIGU7XG4gIHN3aXRjaCAoZSkge1xuICAgIGNhc2UgXCJib3R0b20tZW5kXCI6XG4gICAgICByZXR1cm4gXCJib3R0b20tc3RhcnRcIjtcbiAgICBjYXNlIFwiYm90dG9tLXN0YXJ0XCI6XG4gICAgICByZXR1cm4gXCJib3R0b20tZW5kXCI7XG4gICAgY2FzZSBcInRvcC1lbmRcIjpcbiAgICAgIHJldHVybiBcInRvcC1zdGFydFwiO1xuICAgIGNhc2UgXCJ0b3Atc3RhcnRcIjpcbiAgICAgIHJldHVybiBcInRvcC1lbmRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGU7XG4gIH1cbn1cbmZ1bmN0aW9uIFRuKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUoKSA6IGU7XG59XG5mdW5jdGlvbiBXbihlKSB7XG4gIHJldHVybiBlLm5vZGVUeXBlICE9PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBIcChlKSB7XG4gIHJldHVybiAhV24oZSk7XG59XG5jb25zdCBxcCA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjbGFzc2VzOiB0XG4gIH0gPSBlO1xuICByZXR1cm4gR2Uoe1xuICAgIHJvb3Q6IFtcInJvb3RcIl1cbiAgfSwgVXAsIHQpO1xufSwgR3AgPSB7fSwgS3AgPSAvKiBAX19QVVJFX18gKi8gQy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsIHIpIHtcbiAgY29uc3Qge1xuICAgIGFuY2hvckVsOiBuLFxuICAgIGNoaWxkcmVuOiBvLFxuICAgIGRpcmVjdGlvbjogaSxcbiAgICBkaXNhYmxlUG9ydGFsOiBzLFxuICAgIG1vZGlmaWVyczogYyxcbiAgICBvcGVuOiBsLFxuICAgIHBsYWNlbWVudDogdSxcbiAgICBwb3BwZXJPcHRpb25zOiBwLFxuICAgIHBvcHBlclJlZjogbSxcbiAgICBzbG90UHJvcHM6IGcgPSB7fSxcbiAgICBzbG90czogeCA9IHt9LFxuICAgIFRyYW5zaXRpb25Qcm9wczogeSxcbiAgICAvLyBAdHMtaWdub3JlIGludGVybmFsIGxvZ2ljXG4gICAgb3duZXJTdGF0ZTogZixcbiAgICAvLyBwcmV2ZW50IGZyb20gc3ByZWFkaW5nIHRvIERPTSwgaXQgY2FuIGNvbWUgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudCBlLmcuIFNlbGVjdC5cbiAgICAuLi5TXG4gIH0gPSB0LCBFID0gQy51c2VSZWYobnVsbCksIFAgPSBhdChFLCByKSwgVCA9IEMudXNlUmVmKG51bGwpLCBiID0gYXQoVCwgbSksIGggPSBDLnVzZVJlZihiKTtcbiAgRnQoKCkgPT4ge1xuICAgIGguY3VycmVudCA9IGI7XG4gIH0sIFtiXSksIEMudXNlSW1wZXJhdGl2ZUhhbmRsZShtLCAoKSA9PiBULmN1cnJlbnQsIFtdKTtcbiAgY29uc3QgdyA9IFlwKHUsIGkpLCBbaywgTF0gPSBDLnVzZVN0YXRlKHcpLCBbQiwgZF0gPSBDLnVzZVN0YXRlKFRuKG4pKTtcbiAgQy51c2VFZmZlY3QoKCkgPT4ge1xuICAgIFQuY3VycmVudCAmJiBULmN1cnJlbnQuZm9yY2VVcGRhdGUoKTtcbiAgfSksIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBuICYmIGQoVG4obikpO1xuICB9LCBbbl0pLCBGdCgoKSA9PiB7XG4gICAgaWYgKCFCIHx8ICFsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHogPSAodGUpID0+IHtcbiAgICAgIEwodGUucGxhY2VtZW50KTtcbiAgICB9O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgQiAmJiBXbihCKSAmJiBCLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICBjb25zdCB0ZSA9IEIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJ0ZXN0XCIgJiYgdGUudG9wID09PSAwICYmIHRlLmxlZnQgPT09IDAgJiYgdGUucmlnaHQgPT09IDAgJiYgdGUuYm90dG9tID09PSAwICYmIGNvbnNvbGUud2FybihbXCJNVUk6IFRoZSBgYW5jaG9yRWxgIHByb3AgcHJvdmlkZWQgdG8gdGhlIGNvbXBvbmVudCBpcyBpbnZhbGlkLlwiLCBcIlRoZSBhbmNob3IgZWxlbWVudCBzaG91bGQgYmUgcGFydCBvZiB0aGUgZG9jdW1lbnQgbGF5b3V0LlwiLCBcIk1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyBwcmVzZW50IGluIHRoZSBkb2N1bWVudCBvciB0aGF0IGl0J3Mgbm90IGRpc3BsYXkgbm9uZS5cIl0uam9pbihgXG5gKSk7XG4gICAgfVxuICAgIGxldCBVID0gW3tcbiAgICAgIG5hbWU6IFwicHJldmVudE92ZXJmbG93XCIsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGFsdEJvdW5kYXJ5OiBzXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogXCJmbGlwXCIsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGFsdEJvdW5kYXJ5OiBzXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogXCJvblVwZGF0ZVwiLFxuICAgICAgZW5hYmxlZDogITAsXG4gICAgICBwaGFzZTogXCJhZnRlcldyaXRlXCIsXG4gICAgICBmbjogKHtcbiAgICAgICAgc3RhdGU6IHRlXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHoodGUpO1xuICAgICAgfVxuICAgIH1dO1xuICAgIGMgIT0gbnVsbCAmJiAoVSA9IFUuY29uY2F0KGMpKSwgcCAmJiBwLm1vZGlmaWVycyAhPSBudWxsICYmIChVID0gVS5jb25jYXQocC5tb2RpZmllcnMpKTtcbiAgICBjb25zdCBWID0genAoQiwgRS5jdXJyZW50LCB7XG4gICAgICBwbGFjZW1lbnQ6IHcsXG4gICAgICAuLi5wLFxuICAgICAgbW9kaWZpZXJzOiBVXG4gICAgfSk7XG4gICAgcmV0dXJuIGguY3VycmVudChWKSwgKCkgPT4ge1xuICAgICAgVi5kZXN0cm95KCksIGguY3VycmVudChudWxsKTtcbiAgICB9O1xuICB9LCBbQiwgcywgYywgbCwgcCwgd10pO1xuICBjb25zdCBBID0ge1xuICAgIHBsYWNlbWVudDoga1xuICB9O1xuICB5ICE9PSBudWxsICYmIChBLlRyYW5zaXRpb25Qcm9wcyA9IHkpO1xuICBjb25zdCBEID0gcXAodCksIGogPSB4LnJvb3QgPz8gXCJkaXZcIiwgVyA9IFl1KHtcbiAgICBlbGVtZW50VHlwZTogaixcbiAgICBleHRlcm5hbFNsb3RQcm9wczogZy5yb290LFxuICAgIGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6IFMsXG4gICAgYWRkaXRpb25hbFByb3BzOiB7XG4gICAgICByb2xlOiBcInRvb2x0aXBcIixcbiAgICAgIHJlZjogUFxuICAgIH0sXG4gICAgb3duZXJTdGF0ZTogdCxcbiAgICBjbGFzc05hbWU6IEQucm9vdFxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChqLCB7XG4gICAgLi4uVyxcbiAgICBjaGlsZHJlbjogdHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiID8gbyhBKSA6IG9cbiAgfSk7XG59KSwgTXMgPSAvKiBAX19QVVJFX18gKi8gQy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsIHIpIHtcbiAgY29uc3Qge1xuICAgIGFuY2hvckVsOiBuLFxuICAgIGNoaWxkcmVuOiBvLFxuICAgIGNvbnRhaW5lcjogaSxcbiAgICBkaXJlY3Rpb246IHMgPSBcImx0clwiLFxuICAgIGRpc2FibGVQb3J0YWw6IGMgPSAhMSxcbiAgICBrZWVwTW91bnRlZDogbCA9ICExLFxuICAgIG1vZGlmaWVyczogdSxcbiAgICBvcGVuOiBwLFxuICAgIHBsYWNlbWVudDogbSA9IFwiYm90dG9tXCIsXG4gICAgcG9wcGVyT3B0aW9uczogZyA9IEdwLFxuICAgIHBvcHBlclJlZjogeCxcbiAgICBzdHlsZTogeSxcbiAgICB0cmFuc2l0aW9uOiBmID0gITEsXG4gICAgc2xvdFByb3BzOiBTID0ge30sXG4gICAgc2xvdHM6IEUgPSB7fSxcbiAgICAuLi5QXG4gIH0gPSB0LCBbVCwgYl0gPSBDLnVzZVN0YXRlKCEwKSwgaCA9ICgpID0+IHtcbiAgICBiKCExKTtcbiAgfSwgdyA9ICgpID0+IHtcbiAgICBiKCEwKTtcbiAgfTtcbiAgaWYgKCFsICYmICFwICYmICghZiB8fCBUKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IGs7XG4gIGlmIChpKVxuICAgIGsgPSBpO1xuICBlbHNlIGlmIChuKSB7XG4gICAgY29uc3QgZCA9IFRuKG4pO1xuICAgIGsgPSBkICYmIFduKGQpID8gemkoZCkuYm9keSA6IHppKG51bGwpLmJvZHk7XG4gIH1cbiAgY29uc3QgTCA9ICFwICYmIGwgJiYgKCFmIHx8IFQpID8gXCJub25lXCIgOiB2b2lkIDAsIEIgPSBmID8ge1xuICAgIGluOiBwLFxuICAgIG9uRW50ZXI6IGgsXG4gICAgb25FeGl0ZWQ6IHdcbiAgfSA6IHZvaWQgMDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChDbiwge1xuICAgIGRpc2FibGVQb3J0YWw6IGMsXG4gICAgY29udGFpbmVyOiBrLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goS3AsIHtcbiAgICAgIGFuY2hvckVsOiBuLFxuICAgICAgZGlyZWN0aW9uOiBzLFxuICAgICAgZGlzYWJsZVBvcnRhbDogYyxcbiAgICAgIG1vZGlmaWVyczogdSxcbiAgICAgIHJlZjogcixcbiAgICAgIG9wZW46IGYgPyAhVCA6IHAsXG4gICAgICBwbGFjZW1lbnQ6IG0sXG4gICAgICBwb3BwZXJPcHRpb25zOiBnLFxuICAgICAgcG9wcGVyUmVmOiB4LFxuICAgICAgc2xvdFByb3BzOiBTLFxuICAgICAgc2xvdHM6IEUsXG4gICAgICAuLi5QLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLy8gUHJldmVudHMgc2Nyb2xsIGlzc3VlLCB3YWl0aW5nIGZvciBQb3BwZXIuanMgdG8gYWRkIHRoaXMgc3R5bGUgb25jZSBpbml0aWF0ZWQuXG4gICAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgICAgIC8vIEZpeCBQb3BwZXIuanMgZGlzcGxheSBpc3N1ZVxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGRpc3BsYXk6IEwsXG4gICAgICAgIC4uLnlcbiAgICAgIH0sXG4gICAgICBUcmFuc2l0aW9uUHJvcHM6IEIsXG4gICAgICBjaGlsZHJlbjogb1xuICAgIH0pXG4gIH0pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKE1zLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIFR5cGVTY3JpcHQgdHlwZXMgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBBbiBIVE1MIGVsZW1lbnQsIFt2aXJ0dWFsRWxlbWVudF0oaHR0cHM6Ly9wb3BwZXIuanMub3JnL2RvY3MvdjIvdmlydHVhbC1lbGVtZW50cy8pLFxuICAgKiBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlaXRoZXIuXG4gICAqIEl0J3MgdXNlZCB0byBzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIuXG4gICAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBwYXNzZWQgYXMgdGhlIHJlZmVyZW5jZSBvYmplY3Qgb2YgdGhlIFBvcHBlciBpbnN0YW5jZS5cbiAgICovXG4gIGFuY2hvckVsOiBhcihhLm9uZU9mVHlwZShbT3IsIGEub2JqZWN0LCBhLmZ1bmNdKSwgKGUpID0+IHtcbiAgICBpZiAoZS5vcGVuKSB7XG4gICAgICBjb25zdCB0ID0gVG4oZS5hbmNob3JFbCk7XG4gICAgICBpZiAodCAmJiBXbih0KSAmJiB0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHIgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwidGVzdFwiICYmIHIudG9wID09PSAwICYmIHIubGVmdCA9PT0gMCAmJiByLnJpZ2h0ID09PSAwICYmIHIuYm90dG9tID09PSAwKVxuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoW1wiTVVJOiBUaGUgYGFuY2hvckVsYCBwcm9wIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQgaXMgaW52YWxpZC5cIiwgXCJUaGUgYW5jaG9yIGVsZW1lbnQgc2hvdWxkIGJlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGxheW91dC5cIiwgXCJNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgcHJlc2VudCBpbiB0aGUgZG9jdW1lbnQgb3IgdGhhdCBpdCdzIG5vdCBkaXNwbGF5IG5vbmUuXCJdLmpvaW4oYFxuYCkpO1xuICAgICAgfSBlbHNlIGlmICghdCB8fCB0eXBlb2YgdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT0gXCJmdW5jdGlvblwiIHx8IEhwKHQpICYmIHQuY29udGV4dEVsZW1lbnQgIT0gbnVsbCAmJiB0LmNvbnRleHRFbGVtZW50Lm5vZGVUeXBlICE9PSAxKVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFtcIk1VSTogVGhlIGBhbmNob3JFbGAgcHJvcCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGlzIGludmFsaWQuXCIsIFwiSXQgc2hvdWxkIGJlIGFuIEhUTUwgZWxlbWVudCBpbnN0YW5jZSBvciBhIHZpcnR1YWxFbGVtZW50IFwiLCBcIihodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92Mi92aXJ0dWFsLWVsZW1lbnRzLykuXCJdLmpvaW4oYFxuYCkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSksXG4gIC8qKlxuICAgKiBQb3BwZXIgcmVuZGVyIGZ1bmN0aW9uIG9yIG5vZGUuXG4gICAqL1xuICBjaGlsZHJlbjogYS5vbmVPZlR5cGUoW2Eubm9kZSwgYS5mdW5jXSksXG4gIC8qKlxuICAgKiBBbiBIVE1MIGVsZW1lbnQgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG9uZS5cbiAgICogVGhlIGBjb250YWluZXJgIHdpbGwgaGF2ZSB0aGUgcG9ydGFsIGNoaWxkcmVuIGFwcGVuZGVkIHRvIGl0LlxuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIGNhbGxiYWNrLCB3aGljaCBpcyBjYWxsZWQgaW4gYSBSZWFjdCBsYXlvdXQgZWZmZWN0LlxuICAgKiBUaGlzIGxldHMgeW91IHNldCB0aGUgY29udGFpbmVyIGZyb20gYSByZWYsIGFuZCBhbHNvIG1ha2VzIHNlcnZlci1zaWRlIHJlbmRlcmluZyBwb3NzaWJsZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgaXQgdXNlcyB0aGUgYm9keSBvZiB0aGUgdG9wLWxldmVsIGRvY3VtZW50IG9iamVjdCxcbiAgICogc28gaXQncyBzaW1wbHkgYGRvY3VtZW50LmJvZHlgIG1vc3Qgb2YgdGhlIHRpbWUuXG4gICAqL1xuICBjb250YWluZXI6IGEub25lT2ZUeXBlKFtPciwgYS5mdW5jXSksXG4gIC8qKlxuICAgKiBEaXJlY3Rpb24gb2YgdGhlIHRleHQuXG4gICAqIEBkZWZhdWx0ICdsdHInXG4gICAqL1xuICBkaXJlY3Rpb246IGEub25lT2YoW1wibHRyXCIsIFwicnRsXCJdKSxcbiAgLyoqXG4gICAqIFRoZSBgY2hpbGRyZW5gIHdpbGwgYmUgdW5kZXIgdGhlIERPTSBoaWVyYXJjaHkgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlUG9ydGFsOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBBbHdheXMga2VlcCB0aGUgY2hpbGRyZW4gaW4gdGhlIERPTS5cbiAgICogVGhpcyBwcm9wIGNhbiBiZSB1c2VmdWwgaW4gU0VPIHNpdHVhdGlvbiBvclxuICAgKiB3aGVuIHlvdSB3YW50IHRvIG1heGltaXplIHRoZSByZXNwb25zaXZlbmVzcyBvZiB0aGUgUG9wcGVyLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAga2VlcE1vdW50ZWQ6IGEuYm9vbCxcbiAgLyoqXG4gICAqIFBvcHBlci5qcyBpcyBiYXNlZCBvbiBhIFwicGx1Z2luLWxpa2VcIiBhcmNoaXRlY3R1cmUsXG4gICAqIG1vc3Qgb2YgaXRzIGZlYXR1cmVzIGFyZSBmdWxseSBlbmNhcHN1bGF0ZWQgXCJtb2RpZmllcnNcIi5cbiAgICpcbiAgICogQSBtb2RpZmllciBpcyBhIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGVhY2ggdGltZSBQb3BwZXIuanMgbmVlZHMgdG9cbiAgICogY29tcHV0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlci5cbiAgICogRm9yIHRoaXMgcmVhc29uLCBtb2RpZmllcnMgc2hvdWxkIGJlIHZlcnkgcGVyZm9ybWFudCB0byBhdm9pZCBib3R0bGVuZWNrcy5cbiAgICogVG8gbGVhcm4gaG93IHRvIGNyZWF0ZSBhIG1vZGlmaWVyLCBbcmVhZCB0aGUgbW9kaWZpZXJzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vcG9wcGVyLmpzLm9yZy9kb2NzL3YyL21vZGlmaWVycy8pLlxuICAgKi9cbiAgbW9kaWZpZXJzOiBhLmFycmF5T2YoYS5zaGFwZSh7XG4gICAgZGF0YTogYS5vYmplY3QsXG4gICAgZWZmZWN0OiBhLmZ1bmMsXG4gICAgZW5hYmxlZDogYS5ib29sLFxuICAgIGZuOiBhLmZ1bmMsXG4gICAgbmFtZTogYS5hbnksXG4gICAgb3B0aW9uczogYS5vYmplY3QsXG4gICAgcGhhc2U6IGEub25lT2YoW1wiYWZ0ZXJNYWluXCIsIFwiYWZ0ZXJSZWFkXCIsIFwiYWZ0ZXJXcml0ZVwiLCBcImJlZm9yZU1haW5cIiwgXCJiZWZvcmVSZWFkXCIsIFwiYmVmb3JlV3JpdGVcIiwgXCJtYWluXCIsIFwicmVhZFwiLCBcIndyaXRlXCJdKSxcbiAgICByZXF1aXJlczogYS5hcnJheU9mKGEuc3RyaW5nKSxcbiAgICByZXF1aXJlc0lmRXhpc3RzOiBhLmFycmF5T2YoYS5zdHJpbmcpXG4gIH0pKSxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBpcyBzaG93bi5cbiAgICovXG4gIG9wZW46IGEuYm9vbC5pc1JlcXVpcmVkLFxuICAvKipcbiAgICogUG9wcGVyIHBsYWNlbWVudC5cbiAgICogQGRlZmF1bHQgJ2JvdHRvbSdcbiAgICovXG4gIHBsYWNlbWVudDogYS5vbmVPZihbXCJhdXRvLWVuZFwiLCBcImF1dG8tc3RhcnRcIiwgXCJhdXRvXCIsIFwiYm90dG9tLWVuZFwiLCBcImJvdHRvbS1zdGFydFwiLCBcImJvdHRvbVwiLCBcImxlZnQtZW5kXCIsIFwibGVmdC1zdGFydFwiLCBcImxlZnRcIiwgXCJyaWdodC1lbmRcIiwgXCJyaWdodC1zdGFydFwiLCBcInJpZ2h0XCIsIFwidG9wLWVuZFwiLCBcInRvcC1zdGFydFwiLCBcInRvcFwiXSksXG4gIC8qKlxuICAgKiBPcHRpb25zIHByb3ZpZGVkIHRvIHRoZSBbYFBvcHBlci5qc2BdKGh0dHBzOi8vcG9wcGVyLmpzLm9yZy9kb2NzL3YyL2NvbnN0cnVjdG9ycy8jb3B0aW9ucykgaW5zdGFuY2UuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBwb3BwZXJPcHRpb25zOiBhLnNoYXBlKHtcbiAgICBtb2RpZmllcnM6IGEuYXJyYXksXG4gICAgb25GaXJzdFVwZGF0ZTogYS5mdW5jLFxuICAgIHBsYWNlbWVudDogYS5vbmVPZihbXCJhdXRvLWVuZFwiLCBcImF1dG8tc3RhcnRcIiwgXCJhdXRvXCIsIFwiYm90dG9tLWVuZFwiLCBcImJvdHRvbS1zdGFydFwiLCBcImJvdHRvbVwiLCBcImxlZnQtZW5kXCIsIFwibGVmdC1zdGFydFwiLCBcImxlZnRcIiwgXCJyaWdodC1lbmRcIiwgXCJyaWdodC1zdGFydFwiLCBcInJpZ2h0XCIsIFwidG9wLWVuZFwiLCBcInRvcC1zdGFydFwiLCBcInRvcFwiXSksXG4gICAgc3RyYXRlZ3k6IGEub25lT2YoW1wiYWJzb2x1dGVcIiwgXCJmaXhlZFwiXSlcbiAgfSksXG4gIC8qKlxuICAgKiBBIHJlZiB0aGF0IHBvaW50cyB0byB0aGUgdXNlZCBwb3BwZXIgaW5zdGFuY2UuXG4gICAqL1xuICBwb3BwZXJSZWY6IExvLFxuICAvKipcbiAgICogVGhlIHByb3BzIHVzZWQgZm9yIGVhY2ggc2xvdCBpbnNpZGUgdGhlIFBvcHBlci5cbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIHNsb3RQcm9wczogYS5zaGFwZSh7XG4gICAgcm9vdDogYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3RdKVxuICB9KSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnRzIHVzZWQgZm9yIGVhY2ggc2xvdCBpbnNpZGUgdGhlIFBvcHBlci5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIHNsb3RzOiBhLnNoYXBlKHtcbiAgICByb290OiBhLmVsZW1lbnRUeXBlXG4gIH0pLFxuICAvKipcbiAgICogSGVscCBzdXBwb3J0aW5nIGEgcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9UcmFuc2l0aW9uIGNvbXBvbmVudC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHRyYW5zaXRpb246IGEuYm9vbFxufSk7XG5jb25zdCBYcCA9IGxlKE1zLCB7XG4gIG5hbWU6IFwiTXVpUG9wcGVyXCIsXG4gIHNsb3Q6IFwiUm9vdFwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHQucm9vdFxufSkoe30pLCBlaSA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCBuID0gaXMoKSwgbyA9IEhlKHtcbiAgICBwcm9wczogdCxcbiAgICBuYW1lOiBcIk11aVBvcHBlclwiXG4gIH0pLCB7XG4gICAgYW5jaG9yRWw6IGksXG4gICAgY29tcG9uZW50OiBzLFxuICAgIGNvbXBvbmVudHM6IGMsXG4gICAgY29tcG9uZW50c1Byb3BzOiBsLFxuICAgIGNvbnRhaW5lcjogdSxcbiAgICBkaXNhYmxlUG9ydGFsOiBwLFxuICAgIGtlZXBNb3VudGVkOiBtLFxuICAgIG1vZGlmaWVyczogZyxcbiAgICBvcGVuOiB4LFxuICAgIHBsYWNlbWVudDogeSxcbiAgICBwb3BwZXJPcHRpb25zOiBmLFxuICAgIHBvcHBlclJlZjogUyxcbiAgICB0cmFuc2l0aW9uOiBFLFxuICAgIHNsb3RzOiBQLFxuICAgIHNsb3RQcm9wczogVCxcbiAgICAuLi5iXG4gIH0gPSBvLCBoID0gKFAgPT0gbnVsbCA/IHZvaWQgMCA6IFAucm9vdCkgPz8gKGMgPT0gbnVsbCA/IHZvaWQgMCA6IGMuUm9vdCksIHcgPSB7XG4gICAgYW5jaG9yRWw6IGksXG4gICAgY29udGFpbmVyOiB1LFxuICAgIGRpc2FibGVQb3J0YWw6IHAsXG4gICAga2VlcE1vdW50ZWQ6IG0sXG4gICAgbW9kaWZpZXJzOiBnLFxuICAgIG9wZW46IHgsXG4gICAgcGxhY2VtZW50OiB5LFxuICAgIHBvcHBlck9wdGlvbnM6IGYsXG4gICAgcG9wcGVyUmVmOiBTLFxuICAgIHRyYW5zaXRpb246IEUsXG4gICAgLi4uYlxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KFhwLCB7XG4gICAgYXM6IHMsXG4gICAgZGlyZWN0aW9uOiBuID8gXCJydGxcIiA6IFwibHRyXCIsXG4gICAgc2xvdHM6IHtcbiAgICAgIHJvb3Q6IGhcbiAgICB9LFxuICAgIHNsb3RQcm9wczogVCA/PyBsLFxuICAgIC4uLncsXG4gICAgcmVmOiByXG4gIH0pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGVpLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIFR5cGVTY3JpcHQgdHlwZXMgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBBbiBIVE1MIGVsZW1lbnQsIFt2aXJ0dWFsRWxlbWVudF0oaHR0cHM6Ly9wb3BwZXIuanMub3JnL2RvY3MvdjIvdmlydHVhbC1lbGVtZW50cy8pLFxuICAgKiBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlaXRoZXIuXG4gICAqIEl0J3MgdXNlZCB0byBzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIuXG4gICAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBwYXNzZWQgYXMgdGhlIHJlZmVyZW5jZSBvYmplY3Qgb2YgdGhlIFBvcHBlciBpbnN0YW5jZS5cbiAgICovXG4gIGFuY2hvckVsOiBhLm9uZU9mVHlwZShbT3IsIGEub2JqZWN0LCBhLmZ1bmNdKSxcbiAgLyoqXG4gICAqIFBvcHBlciByZW5kZXIgZnVuY3Rpb24gb3Igbm9kZS5cbiAgICovXG4gIGNoaWxkcmVuOiBhLm9uZU9mVHlwZShbYS5ub2RlLCBhLmZ1bmNdKSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogYS5lbGVtZW50VHlwZSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnRzIHVzZWQgZm9yIGVhY2ggc2xvdCBpbnNpZGUgdGhlIFBvcHBlci5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHRoZSBgc2xvdHNgIHByb3AgaW5zdGVhZC4gVGhpcyBwcm9wIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4gW0hvdyB0byBtaWdyYXRlXSgvbWF0ZXJpYWwtdWkvbWlncmF0aW9uL21pZ3JhdGluZy1mcm9tLWRlcHJlY2F0ZWQtYXBpcy8pLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgY29tcG9uZW50czogYS5zaGFwZSh7XG4gICAgUm9vdDogYS5lbGVtZW50VHlwZVxuICB9KSxcbiAgLyoqXG4gICAqIFRoZSBwcm9wcyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlIHRoZSBQb3BwZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHVzZSB0aGUgYHNsb3RQcm9wc2AgcHJvcCBpbnN0ZWFkLiBUaGlzIHByb3Agd2lsbCBiZSByZW1vdmVkIGluIHY3LiBbSG93IHRvIG1pZ3JhdGVdKC9tYXRlcmlhbC11aS9taWdyYXRpb24vbWlncmF0aW5nLWZyb20tZGVwcmVjYXRlZC1hcGlzLykuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBjb21wb25lbnRzUHJvcHM6IGEuc2hhcGUoe1xuICAgIHJvb3Q6IGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0XSlcbiAgfSksXG4gIC8qKlxuICAgKiBBbiBIVE1MIGVsZW1lbnQgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG9uZS5cbiAgICogVGhlIGBjb250YWluZXJgIHdpbGwgaGF2ZSB0aGUgcG9ydGFsIGNoaWxkcmVuIGFwcGVuZGVkIHRvIGl0LlxuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIGNhbGxiYWNrLCB3aGljaCBpcyBjYWxsZWQgaW4gYSBSZWFjdCBsYXlvdXQgZWZmZWN0LlxuICAgKiBUaGlzIGxldHMgeW91IHNldCB0aGUgY29udGFpbmVyIGZyb20gYSByZWYsIGFuZCBhbHNvIG1ha2VzIHNlcnZlci1zaWRlIHJlbmRlcmluZyBwb3NzaWJsZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgaXQgdXNlcyB0aGUgYm9keSBvZiB0aGUgdG9wLWxldmVsIGRvY3VtZW50IG9iamVjdCxcbiAgICogc28gaXQncyBzaW1wbHkgYGRvY3VtZW50LmJvZHlgIG1vc3Qgb2YgdGhlIHRpbWUuXG4gICAqL1xuICBjb250YWluZXI6IGEub25lT2ZUeXBlKFtPciwgYS5mdW5jXSksXG4gIC8qKlxuICAgKiBUaGUgYGNoaWxkcmVuYCB3aWxsIGJlIHVuZGVyIHRoZSBET00gaGllcmFyY2h5IG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZVBvcnRhbDogYS5ib29sLFxuICAvKipcbiAgICogQWx3YXlzIGtlZXAgdGhlIGNoaWxkcmVuIGluIHRoZSBET00uXG4gICAqIFRoaXMgcHJvcCBjYW4gYmUgdXNlZnVsIGluIFNFTyBzaXR1YXRpb24gb3JcbiAgICogd2hlbiB5b3Ugd2FudCB0byBtYXhpbWl6ZSB0aGUgcmVzcG9uc2l2ZW5lc3Mgb2YgdGhlIFBvcHBlci5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGtlZXBNb3VudGVkOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBQb3BwZXIuanMgaXMgYmFzZWQgb24gYSBcInBsdWdpbi1saWtlXCIgYXJjaGl0ZWN0dXJlLFxuICAgKiBtb3N0IG9mIGl0cyBmZWF0dXJlcyBhcmUgZnVsbHkgZW5jYXBzdWxhdGVkIFwibW9kaWZpZXJzXCIuXG4gICAqXG4gICAqIEEgbW9kaWZpZXIgaXMgYSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBlYWNoIHRpbWUgUG9wcGVyLmpzIG5lZWRzIHRvXG4gICAqIGNvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIuXG4gICAqIEZvciB0aGlzIHJlYXNvbiwgbW9kaWZpZXJzIHNob3VsZCBiZSB2ZXJ5IHBlcmZvcm1hbnQgdG8gYXZvaWQgYm90dGxlbmVja3MuXG4gICAqIFRvIGxlYXJuIGhvdyB0byBjcmVhdGUgYSBtb2RpZmllciwgW3JlYWQgdGhlIG1vZGlmaWVycyBkb2N1bWVudGF0aW9uXShodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92Mi9tb2RpZmllcnMvKS5cbiAgICovXG4gIG1vZGlmaWVyczogYS5hcnJheU9mKGEuc2hhcGUoe1xuICAgIGRhdGE6IGEub2JqZWN0LFxuICAgIGVmZmVjdDogYS5mdW5jLFxuICAgIGVuYWJsZWQ6IGEuYm9vbCxcbiAgICBmbjogYS5mdW5jLFxuICAgIG5hbWU6IGEuYW55LFxuICAgIG9wdGlvbnM6IGEub2JqZWN0LFxuICAgIHBoYXNlOiBhLm9uZU9mKFtcImFmdGVyTWFpblwiLCBcImFmdGVyUmVhZFwiLCBcImFmdGVyV3JpdGVcIiwgXCJiZWZvcmVNYWluXCIsIFwiYmVmb3JlUmVhZFwiLCBcImJlZm9yZVdyaXRlXCIsIFwibWFpblwiLCBcInJlYWRcIiwgXCJ3cml0ZVwiXSksXG4gICAgcmVxdWlyZXM6IGEuYXJyYXlPZihhLnN0cmluZyksXG4gICAgcmVxdWlyZXNJZkV4aXN0czogYS5hcnJheU9mKGEuc3RyaW5nKVxuICB9KSksXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgaXMgc2hvd24uXG4gICAqL1xuICBvcGVuOiBhLmJvb2wuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIFBvcHBlciBwbGFjZW1lbnQuXG4gICAqIEBkZWZhdWx0ICdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6IGEub25lT2YoW1wiYXV0by1lbmRcIiwgXCJhdXRvLXN0YXJ0XCIsIFwiYXV0b1wiLCBcImJvdHRvbS1lbmRcIiwgXCJib3R0b20tc3RhcnRcIiwgXCJib3R0b21cIiwgXCJsZWZ0LWVuZFwiLCBcImxlZnQtc3RhcnRcIiwgXCJsZWZ0XCIsIFwicmlnaHQtZW5kXCIsIFwicmlnaHQtc3RhcnRcIiwgXCJyaWdodFwiLCBcInRvcC1lbmRcIiwgXCJ0b3Atc3RhcnRcIiwgXCJ0b3BcIl0pLFxuICAvKipcbiAgICogT3B0aW9ucyBwcm92aWRlZCB0byB0aGUgW2BQb3BwZXIuanNgXShodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92Mi9jb25zdHJ1Y3RvcnMvI29wdGlvbnMpIGluc3RhbmNlLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgcG9wcGVyT3B0aW9uczogYS5zaGFwZSh7XG4gICAgbW9kaWZpZXJzOiBhLmFycmF5LFxuICAgIG9uRmlyc3RVcGRhdGU6IGEuZnVuYyxcbiAgICBwbGFjZW1lbnQ6IGEub25lT2YoW1wiYXV0by1lbmRcIiwgXCJhdXRvLXN0YXJ0XCIsIFwiYXV0b1wiLCBcImJvdHRvbS1lbmRcIiwgXCJib3R0b20tc3RhcnRcIiwgXCJib3R0b21cIiwgXCJsZWZ0LWVuZFwiLCBcImxlZnQtc3RhcnRcIiwgXCJsZWZ0XCIsIFwicmlnaHQtZW5kXCIsIFwicmlnaHQtc3RhcnRcIiwgXCJyaWdodFwiLCBcInRvcC1lbmRcIiwgXCJ0b3Atc3RhcnRcIiwgXCJ0b3BcIl0pLFxuICAgIHN0cmF0ZWd5OiBhLm9uZU9mKFtcImFic29sdXRlXCIsIFwiZml4ZWRcIl0pXG4gIH0pLFxuICAvKipcbiAgICogQSByZWYgdGhhdCBwb2ludHMgdG8gdGhlIHVzZWQgcG9wcGVyIGluc3RhbmNlLlxuICAgKi9cbiAgcG9wcGVyUmVmOiBMbyxcbiAgLyoqXG4gICAqIFRoZSBwcm9wcyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlIHRoZSBQb3BwZXIuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBzbG90UHJvcHM6IGEuc2hhcGUoe1xuICAgIHJvb3Q6IGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0XSlcbiAgfSksXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlIHRoZSBQb3BwZXIuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBzbG90czogYS5zaGFwZSh7XG4gICAgcm9vdDogYS5lbGVtZW50VHlwZVxuICB9KSxcbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gcHJvcCB0aGF0IGFsbG93cyBkZWZpbmluZyBzeXN0ZW0gb3ZlcnJpZGVzIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgc3g6IGEub25lT2ZUeXBlKFthLmFycmF5T2YoYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3QsIGEuYm9vbF0pKSwgYS5mdW5jLCBhLm9iamVjdF0pLFxuICAvKipcbiAgICogSGVscCBzdXBwb3J0aW5nIGEgcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9UcmFuc2l0aW9uIGNvbXBvbmVudC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHRyYW5zaXRpb246IGEuYm9vbFxufSk7XG5mdW5jdGlvbiBKcChlKSB7XG4gIHJldHVybiBWZShcIk11aUxpc3RTdWJoZWFkZXJcIiwgZSk7XG59XG5GZShcIk11aUxpc3RTdWJoZWFkZXJcIiwgW1wicm9vdFwiLCBcImNvbG9yUHJpbWFyeVwiLCBcImNvbG9ySW5oZXJpdFwiLCBcImd1dHRlcnNcIiwgXCJpbnNldFwiLCBcInN0aWNreVwiXSk7XG5jb25zdCBRcCA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjbGFzc2VzOiB0LFxuICAgIGNvbG9yOiByLFxuICAgIGRpc2FibGVHdXR0ZXJzOiBuLFxuICAgIGluc2V0OiBvLFxuICAgIGRpc2FibGVTdGlja3k6IGlcbiAgfSA9IGUsIHMgPSB7XG4gICAgcm9vdDogW1wicm9vdFwiLCByICE9PSBcImRlZmF1bHRcIiAmJiBgY29sb3Ike2VlKHIpfWAsICFuICYmIFwiZ3V0dGVyc1wiLCBvICYmIFwiaW5zZXRcIiwgIWkgJiYgXCJzdGlja3lcIl1cbiAgfTtcbiAgcmV0dXJuIEdlKHMsIEpwLCB0KTtcbn0sIFpwID0gbGUoXCJsaVwiLCB7XG4gIG5hbWU6IFwiTXVpTGlzdFN1YmhlYWRlclwiLFxuICBzbG90OiBcIlJvb3RcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJTdGF0ZTogclxuICAgIH0gPSBlO1xuICAgIHJldHVybiBbdC5yb290LCByLmNvbG9yICE9PSBcImRlZmF1bHRcIiAmJiB0W2Bjb2xvciR7ZWUoci5jb2xvcil9YF0sICFyLmRpc2FibGVHdXR0ZXJzICYmIHQuZ3V0dGVycywgci5pbnNldCAmJiB0Lmluc2V0LCAhci5kaXNhYmxlU3RpY2t5ICYmIHQuc3RpY2t5XTtcbiAgfVxufSkocWUoKHtcbiAgdGhlbWU6IGVcbn0pID0+ICh7XG4gIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gIGxpbmVIZWlnaHQ6IFwiNDhweFwiLFxuICBsaXN0U3R5bGU6IFwibm9uZVwiLFxuICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLnRleHQuc2Vjb25kYXJ5LFxuICBmb250RmFtaWx5OiBlLnR5cG9ncmFwaHkuZm9udEZhbWlseSxcbiAgZm9udFdlaWdodDogZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW0sXG4gIGZvbnRTaXplOiBlLnR5cG9ncmFwaHkucHhUb1JlbSgxNCksXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiB7XG4gICAgICBjb2xvcjogXCJwcmltYXJ5XCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLnByaW1hcnkubWFpblxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiB7XG4gICAgICBjb2xvcjogXCJpbmhlcml0XCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCJpbmhlcml0XCJcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiAhdC5kaXNhYmxlR3V0dGVycyxcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZ0xlZnQ6IDE2LFxuICAgICAgcGFkZGluZ1JpZ2h0OiAxNlxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+IHQuaW5zZXQsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmdMZWZ0OiA3MlxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+ICF0LmRpc2FibGVTdGlja3ksXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiBcInN0aWNreVwiLFxuICAgICAgdG9wOiAwLFxuICAgICAgekluZGV4OiAxLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGUuYmFja2dyb3VuZC5wYXBlclxuICAgIH1cbiAgfV1cbn0pKSksIHduID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IG4gPSBIZSh7XG4gICAgcHJvcHM6IHQsXG4gICAgbmFtZTogXCJNdWlMaXN0U3ViaGVhZGVyXCJcbiAgfSksIHtcbiAgICBjbGFzc05hbWU6IG8sXG4gICAgY29sb3I6IGkgPSBcImRlZmF1bHRcIixcbiAgICBjb21wb25lbnQ6IHMgPSBcImxpXCIsXG4gICAgZGlzYWJsZUd1dHRlcnM6IGMgPSAhMSxcbiAgICBkaXNhYmxlU3RpY2t5OiBsID0gITEsXG4gICAgaW5zZXQ6IHUgPSAhMSxcbiAgICAuLi5wXG4gIH0gPSBuLCBtID0ge1xuICAgIC4uLm4sXG4gICAgY29sb3I6IGksXG4gICAgY29tcG9uZW50OiBzLFxuICAgIGRpc2FibGVHdXR0ZXJzOiBjLFxuICAgIGRpc2FibGVTdGlja3k6IGwsXG4gICAgaW5zZXQ6IHVcbiAgfSwgZyA9IFFwKG0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KFpwLCB7XG4gICAgYXM6IHMsXG4gICAgY2xhc3NOYW1lOiBzZShnLnJvb3QsIG8pLFxuICAgIHJlZjogcixcbiAgICBvd25lclN0YXRlOiBtLFxuICAgIC4uLnBcbiAgfSk7XG59KTtcbnduICYmICh3bi5tdWlTa2lwTGlzdEhpZ2hsaWdodCA9ICEwKTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAod24ucHJvcFR5cGVzID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiAgICBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4gICAgIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogYS5ub2RlLFxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKiBAZGVmYXVsdCAnZGVmYXVsdCdcbiAgICovXG4gIGNvbG9yOiBhLm9uZU9mKFtcImRlZmF1bHRcIiwgXCJpbmhlcml0XCIsIFwicHJpbWFyeVwiXSksXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IGEuZWxlbWVudFR5cGUsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBMaXN0IFN1YmhlYWRlciB3aWxsIG5vdCBoYXZlIGd1dHRlcnMuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlR3V0dGVyczogYS5ib29sLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgTGlzdCBTdWJoZWFkZXIgd2lsbCBub3Qgc3RpY2sgdG8gdGhlIHRvcCBkdXJpbmcgc2Nyb2xsLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZVN0aWNreTogYS5ib29sLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgTGlzdCBTdWJoZWFkZXIgaXMgaW5kZW50ZWQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpbnNldDogYS5ib29sLFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSlcbn0pO1xuY29uc3QgZW0gPSBzcigvKiBAX19QVVJFX18gKi8gTi5qc3goXCJwYXRoXCIsIHtcbiAgZDogXCJNMTIgMkM2LjQ3IDIgMiA2LjQ3IDIgMTJzNC40NyAxMCAxMCAxMCAxMC00LjQ3IDEwLTEwUzE3LjUzIDIgMTIgMnptNSAxMy41OUwxNS41OSAxNyAxMiAxMy40MSA4LjQxIDE3IDcgMTUuNTkgMTAuNTkgMTIgNyA4LjQxIDguNDEgNyAxMiAxMC41OSAxNS41OSA3IDE3IDguNDEgMTMuNDEgMTIgMTcgMTUuNTl6XCJcbn0pLCBcIkNhbmNlbFwiKTtcbmZ1bmN0aW9uIHRtKGUpIHtcbiAgcmV0dXJuIFZlKFwiTXVpQ2hpcFwiLCBlKTtcbn1cbmNvbnN0IGllID0gRmUoXCJNdWlDaGlwXCIsIFtcInJvb3RcIiwgXCJzaXplU21hbGxcIiwgXCJzaXplTWVkaXVtXCIsIFwiY29sb3JEZWZhdWx0XCIsIFwiY29sb3JFcnJvclwiLCBcImNvbG9ySW5mb1wiLCBcImNvbG9yUHJpbWFyeVwiLCBcImNvbG9yU2Vjb25kYXJ5XCIsIFwiY29sb3JTdWNjZXNzXCIsIFwiY29sb3JXYXJuaW5nXCIsIFwiZGlzYWJsZWRcIiwgXCJjbGlja2FibGVcIiwgXCJjbGlja2FibGVDb2xvclByaW1hcnlcIiwgXCJjbGlja2FibGVDb2xvclNlY29uZGFyeVwiLCBcImRlbGV0YWJsZVwiLCBcImRlbGV0YWJsZUNvbG9yUHJpbWFyeVwiLCBcImRlbGV0YWJsZUNvbG9yU2Vjb25kYXJ5XCIsIFwib3V0bGluZWRcIiwgXCJmaWxsZWRcIiwgXCJvdXRsaW5lZFByaW1hcnlcIiwgXCJvdXRsaW5lZFNlY29uZGFyeVwiLCBcImZpbGxlZFByaW1hcnlcIiwgXCJmaWxsZWRTZWNvbmRhcnlcIiwgXCJhdmF0YXJcIiwgXCJhdmF0YXJTbWFsbFwiLCBcImF2YXRhck1lZGl1bVwiLCBcImF2YXRhckNvbG9yUHJpbWFyeVwiLCBcImF2YXRhckNvbG9yU2Vjb25kYXJ5XCIsIFwiaWNvblwiLCBcImljb25TbWFsbFwiLCBcImljb25NZWRpdW1cIiwgXCJpY29uQ29sb3JQcmltYXJ5XCIsIFwiaWNvbkNvbG9yU2Vjb25kYXJ5XCIsIFwibGFiZWxcIiwgXCJsYWJlbFNtYWxsXCIsIFwibGFiZWxNZWRpdW1cIiwgXCJkZWxldGVJY29uXCIsIFwiZGVsZXRlSWNvblNtYWxsXCIsIFwiZGVsZXRlSWNvbk1lZGl1bVwiLCBcImRlbGV0ZUljb25Db2xvclByaW1hcnlcIiwgXCJkZWxldGVJY29uQ29sb3JTZWNvbmRhcnlcIiwgXCJkZWxldGVJY29uT3V0bGluZWRDb2xvclByaW1hcnlcIiwgXCJkZWxldGVJY29uT3V0bGluZWRDb2xvclNlY29uZGFyeVwiLCBcImRlbGV0ZUljb25GaWxsZWRDb2xvclByaW1hcnlcIiwgXCJkZWxldGVJY29uRmlsbGVkQ29sb3JTZWNvbmRhcnlcIiwgXCJmb2N1c1Zpc2libGVcIl0pLCBybSA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjbGFzc2VzOiB0LFxuICAgIGRpc2FibGVkOiByLFxuICAgIHNpemU6IG4sXG4gICAgY29sb3I6IG8sXG4gICAgaWNvbkNvbG9yOiBpLFxuICAgIG9uRGVsZXRlOiBzLFxuICAgIGNsaWNrYWJsZTogYyxcbiAgICB2YXJpYW50OiBsXG4gIH0gPSBlLCB1ID0ge1xuICAgIHJvb3Q6IFtcInJvb3RcIiwgbCwgciAmJiBcImRpc2FibGVkXCIsIGBzaXplJHtlZShuKX1gLCBgY29sb3Ike2VlKG8pfWAsIGMgJiYgXCJjbGlja2FibGVcIiwgYyAmJiBgY2xpY2thYmxlQ29sb3Ike2VlKG8pfWAsIHMgJiYgXCJkZWxldGFibGVcIiwgcyAmJiBgZGVsZXRhYmxlQ29sb3Ike2VlKG8pfWAsIGAke2x9JHtlZShvKX1gXSxcbiAgICBsYWJlbDogW1wibGFiZWxcIiwgYGxhYmVsJHtlZShuKX1gXSxcbiAgICBhdmF0YXI6IFtcImF2YXRhclwiLCBgYXZhdGFyJHtlZShuKX1gLCBgYXZhdGFyQ29sb3Ike2VlKG8pfWBdLFxuICAgIGljb246IFtcImljb25cIiwgYGljb24ke2VlKG4pfWAsIGBpY29uQ29sb3Ike2VlKGkpfWBdLFxuICAgIGRlbGV0ZUljb246IFtcImRlbGV0ZUljb25cIiwgYGRlbGV0ZUljb24ke2VlKG4pfWAsIGBkZWxldGVJY29uQ29sb3Ike2VlKG8pfWAsIGBkZWxldGVJY29uJHtlZShsKX1Db2xvciR7ZWUobyl9YF1cbiAgfTtcbiAgcmV0dXJuIEdlKHUsIHRtLCB0KTtcbn0sIG5tID0gbGUoXCJkaXZcIiwge1xuICBuYW1lOiBcIk11aUNoaXBcIixcbiAgc2xvdDogXCJSb290XCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyU3RhdGU6IHJcbiAgICB9ID0gZSwge1xuICAgICAgY29sb3I6IG4sXG4gICAgICBpY29uQ29sb3I6IG8sXG4gICAgICBjbGlja2FibGU6IGksXG4gICAgICBvbkRlbGV0ZTogcyxcbiAgICAgIHNpemU6IGMsXG4gICAgICB2YXJpYW50OiBsXG4gICAgfSA9IHI7XG4gICAgcmV0dXJuIFt7XG4gICAgICBbYCYgLiR7aWUuYXZhdGFyfWBdOiB0LmF2YXRhclxuICAgIH0sIHtcbiAgICAgIFtgJiAuJHtpZS5hdmF0YXJ9YF06IHRbYGF2YXRhciR7ZWUoYyl9YF1cbiAgICB9LCB7XG4gICAgICBbYCYgLiR7aWUuYXZhdGFyfWBdOiB0W2BhdmF0YXJDb2xvciR7ZWUobil9YF1cbiAgICB9LCB7XG4gICAgICBbYCYgLiR7aWUuaWNvbn1gXTogdC5pY29uXG4gICAgfSwge1xuICAgICAgW2AmIC4ke2llLmljb259YF06IHRbYGljb24ke2VlKGMpfWBdXG4gICAgfSwge1xuICAgICAgW2AmIC4ke2llLmljb259YF06IHRbYGljb25Db2xvciR7ZWUobyl9YF1cbiAgICB9LCB7XG4gICAgICBbYCYgLiR7aWUuZGVsZXRlSWNvbn1gXTogdC5kZWxldGVJY29uXG4gICAgfSwge1xuICAgICAgW2AmIC4ke2llLmRlbGV0ZUljb259YF06IHRbYGRlbGV0ZUljb24ke2VlKGMpfWBdXG4gICAgfSwge1xuICAgICAgW2AmIC4ke2llLmRlbGV0ZUljb259YF06IHRbYGRlbGV0ZUljb25Db2xvciR7ZWUobil9YF1cbiAgICB9LCB7XG4gICAgICBbYCYgLiR7aWUuZGVsZXRlSWNvbn1gXTogdFtgZGVsZXRlSWNvbiR7ZWUobCl9Q29sb3Ike2VlKG4pfWBdXG4gICAgfSwgdC5yb290LCB0W2BzaXplJHtlZShjKX1gXSwgdFtgY29sb3Ike2VlKG4pfWBdLCBpICYmIHQuY2xpY2thYmxlLCBpICYmIG4gIT09IFwiZGVmYXVsdFwiICYmIHRbYGNsaWNrYWJsZUNvbG9yJHtlZShuKX0pYF0sIHMgJiYgdC5kZWxldGFibGUsIHMgJiYgbiAhPT0gXCJkZWZhdWx0XCIgJiYgdFtgZGVsZXRhYmxlQ29sb3Ike2VlKG4pfWBdLCB0W2xdLCB0W2Ake2x9JHtlZShuKX1gXV07XG4gIH1cbn0pKHFlKCh7XG4gIHRoZW1lOiBlXG59KSA9PiB7XG4gIGNvbnN0IHQgPSBlLnBhbGV0dGUubW9kZSA9PT0gXCJsaWdodFwiID8gZS5wYWxldHRlLmdyZXlbNzAwXSA6IGUucGFsZXR0ZS5ncmV5WzMwMF07XG4gIHJldHVybiB7XG4gICAgbWF4V2lkdGg6IFwiMTAwJVwiLFxuICAgIGZvbnRGYW1pbHk6IGUudHlwb2dyYXBoeS5mb250RmFtaWx5LFxuICAgIGZvbnRTaXplOiBlLnR5cG9ncmFwaHkucHhUb1JlbSgxMyksXG4gICAgZGlzcGxheTogXCJpbmxpbmUtZmxleFwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgaGVpZ2h0OiAzMixcbiAgICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLnRleHQucHJpbWFyeSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWQsXG4gICAgYm9yZGVyUmFkaXVzOiAzMiAvIDIsXG4gICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICB0cmFuc2l0aW9uOiBlLnRyYW5zaXRpb25zLmNyZWF0ZShbXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiYm94LXNoYWRvd1wiXSksXG4gICAgLy8gcmVzZXQgY3Vyc29yIGV4cGxpY2l0bHkgaW4gY2FzZSBCdXR0b25CYXNlIGlzIHVzZWRcbiAgICBjdXJzb3I6IFwidW5zZXRcIixcbiAgICAvLyBXZSBkaXNhYmxlIHRoZSBmb2N1cyByaW5nIGZvciBtb3VzZSwgdG91Y2ggYW5kIGtleWJvYXJkIHVzZXJzLlxuICAgIG91dGxpbmU6IDAsXG4gICAgdGV4dERlY29yYXRpb246IFwibm9uZVwiLFxuICAgIGJvcmRlcjogMCxcbiAgICAvLyBSZW1vdmUgYGJ1dHRvbmAgYm9yZGVyXG4gICAgcGFkZGluZzogMCxcbiAgICAvLyBSZW1vdmUgYGJ1dHRvbmAgcGFkZGluZ1xuICAgIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICBbYCYuJHtpZS5kaXNhYmxlZH1gXToge1xuICAgICAgb3BhY2l0eTogKGUudmFycyB8fCBlKS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZE9wYWNpdHksXG4gICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgW2AmIC4ke2llLmF2YXRhcn1gXToge1xuICAgICAgbWFyZ2luTGVmdDogNSxcbiAgICAgIG1hcmdpblJpZ2h0OiAtNixcbiAgICAgIHdpZHRoOiAyNCxcbiAgICAgIGhlaWdodDogMjQsXG4gICAgICBjb2xvcjogZS52YXJzID8gZS52YXJzLnBhbGV0dGUuQ2hpcC5kZWZhdWx0QXZhdGFyQ29sb3IgOiB0LFxuICAgICAgZm9udFNpemU6IGUudHlwb2dyYXBoeS5weFRvUmVtKDEyKVxuICAgIH0sXG4gICAgW2AmIC4ke2llLmF2YXRhckNvbG9yUHJpbWFyeX1gXToge1xuICAgICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5wcmltYXJ5LmNvbnRyYXN0VGV4dCxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLnByaW1hcnkuZGFya1xuICAgIH0sXG4gICAgW2AmIC4ke2llLmF2YXRhckNvbG9yU2Vjb25kYXJ5fWBdOiB7XG4gICAgICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLnNlY29uZGFyeS5jb250cmFzdFRleHQsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5zZWNvbmRhcnkuZGFya1xuICAgIH0sXG4gICAgW2AmIC4ke2llLmF2YXRhclNtYWxsfWBdOiB7XG4gICAgICBtYXJnaW5MZWZ0OiA0LFxuICAgICAgbWFyZ2luUmlnaHQ6IC00LFxuICAgICAgd2lkdGg6IDE4LFxuICAgICAgaGVpZ2h0OiAxOCxcbiAgICAgIGZvbnRTaXplOiBlLnR5cG9ncmFwaHkucHhUb1JlbSgxMClcbiAgICB9LFxuICAgIFtgJiAuJHtpZS5pY29ufWBdOiB7XG4gICAgICBtYXJnaW5MZWZ0OiA1LFxuICAgICAgbWFyZ2luUmlnaHQ6IC02XG4gICAgfSxcbiAgICBbYCYgLiR7aWUuZGVsZXRlSWNvbn1gXToge1xuICAgICAgV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgIGNvbG9yOiBlLnZhcnMgPyBgcmdiYSgke2UudmFycy5wYWxldHRlLnRleHQucHJpbWFyeUNoYW5uZWx9IC8gMC4yNilgIDogRGUoZS5wYWxldHRlLnRleHQucHJpbWFyeSwgMC4yNiksXG4gICAgICBmb250U2l6ZTogMjIsXG4gICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgbWFyZ2luOiBcIjAgNXB4IDAgLTZweFwiLFxuICAgICAgXCImOmhvdmVyXCI6IHtcbiAgICAgICAgY29sb3I6IGUudmFycyA/IGByZ2JhKCR7ZS52YXJzLnBhbGV0dGUudGV4dC5wcmltYXJ5Q2hhbm5lbH0gLyAwLjQpYCA6IERlKGUucGFsZXR0ZS50ZXh0LnByaW1hcnksIDAuNClcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhcmlhbnRzOiBbe1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc2l6ZTogXCJzbWFsbFwiXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgaGVpZ2h0OiAyNCxcbiAgICAgICAgW2AmIC4ke2llLmljb259YF06IHtcbiAgICAgICAgICBmb250U2l6ZTogMTgsXG4gICAgICAgICAgbWFyZ2luTGVmdDogNCxcbiAgICAgICAgICBtYXJnaW5SaWdodDogLTRcbiAgICAgICAgfSxcbiAgICAgICAgW2AmIC4ke2llLmRlbGV0ZUljb259YF06IHtcbiAgICAgICAgICBmb250U2l6ZTogMTYsXG4gICAgICAgICAgbWFyZ2luUmlnaHQ6IDQsXG4gICAgICAgICAgbWFyZ2luTGVmdDogLTRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIC4uLk9iamVjdC5lbnRyaWVzKGUucGFsZXR0ZSkuZmlsdGVyKFB0KFtcImNvbnRyYXN0VGV4dFwiXSkpLm1hcCgoW3JdKSA9PiAoe1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IHJcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZVtyXS5tYWluLFxuICAgICAgICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlW3JdLmNvbnRyYXN0VGV4dCxcbiAgICAgICAgW2AmIC4ke2llLmRlbGV0ZUljb259YF06IHtcbiAgICAgICAgICBjb2xvcjogZS52YXJzID8gYHJnYmEoJHtlLnZhcnMucGFsZXR0ZVtyXS5jb250cmFzdFRleHRDaGFubmVsfSAvIDAuNylgIDogRGUoZS5wYWxldHRlW3JdLmNvbnRyYXN0VGV4dCwgMC43KSxcbiAgICAgICAgICBcIiY6aG92ZXIsICY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGNvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGVbcl0uY29udHJhc3RUZXh0XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpLCB7XG4gICAgICBwcm9wczogKHIpID0+IHIuaWNvbkNvbG9yID09PSByLmNvbG9yLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgW2AmIC4ke2llLmljb259YF06IHtcbiAgICAgICAgICBjb2xvcjogZS52YXJzID8gZS52YXJzLnBhbGV0dGUuQ2hpcC5kZWZhdWx0SWNvbkNvbG9yIDogdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcHJvcHM6IChyKSA9PiByLmljb25Db2xvciA9PT0gci5jb2xvciAmJiByLmNvbG9yICE9PSBcImRlZmF1bHRcIixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIFtgJiAuJHtpZS5pY29ufWBdOiB7XG4gICAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBvbkRlbGV0ZTogITBcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBbYCYuJHtpZS5mb2N1c1Zpc2libGV9YF06IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUudmFycyA/IGByZ2JhKCR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkQ2hhbm5lbH0gLyBjYWxjKCR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkT3BhY2l0eX0gKyAke2UudmFycy5wYWxldHRlLmFjdGlvbi5mb2N1c09wYWNpdHl9KSlgIDogRGUoZS5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZCwgZS5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHkgKyBlLnBhbGV0dGUuYWN0aW9uLmZvY3VzT3BhY2l0eSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIC4uLk9iamVjdC5lbnRyaWVzKGUucGFsZXR0ZSkuZmlsdGVyKFB0KFtcImRhcmtcIl0pKS5tYXAoKFtyXSkgPT4gKHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiByLFxuICAgICAgICBvbkRlbGV0ZTogITBcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBbYCYuJHtpZS5mb2N1c1Zpc2libGV9YF06IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAoZS52YXJzIHx8IGUpLnBhbGV0dGVbcl0uZGFya1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpLCB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBjbGlja2FibGU6ICEwXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgdXNlclNlbGVjdDogXCJub25lXCIsXG4gICAgICAgIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgIFwiJjpob3ZlclwiOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLnZhcnMgPyBgcmdiYSgke2UudmFycy5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZENoYW5uZWx9IC8gY2FsYygke2UudmFycy5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHl9ICsgJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5fSkpYCA6IERlKGUucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWQsIGUucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRPcGFjaXR5ICsgZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpXG4gICAgICAgIH0sXG4gICAgICAgIFtgJi4ke2llLmZvY3VzVmlzaWJsZX1gXToge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZS52YXJzID8gYHJnYmEoJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRDaGFubmVsfSAvIGNhbGMoJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRPcGFjaXR5fSArICR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLmZvY3VzT3BhY2l0eX0pKWAgOiBEZShlLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkLCBlLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkT3BhY2l0eSArIGUucGFsZXR0ZS5hY3Rpb24uZm9jdXNPcGFjaXR5KVxuICAgICAgICB9LFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICBib3hTaGFkb3c6IChlLnZhcnMgfHwgZSkuc2hhZG93c1sxXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgLi4uT2JqZWN0LmVudHJpZXMoZS5wYWxldHRlKS5maWx0ZXIoUHQoW1wiZGFya1wiXSkpLm1hcCgoW3JdKSA9PiAoe1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IHIsXG4gICAgICAgIGNsaWNrYWJsZTogITBcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBbYCY6aG92ZXIsICYuJHtpZS5mb2N1c1Zpc2libGV9YF06IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZVtyXS5kYXJrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSksIHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHZhcmlhbnQ6IFwib3V0bGluZWRcIlxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICBib3JkZXI6IGUudmFycyA/IGAxcHggc29saWQgJHtlLnZhcnMucGFsZXR0ZS5DaGlwLmRlZmF1bHRCb3JkZXJ9YCA6IGAxcHggc29saWQgJHtlLnBhbGV0dGUubW9kZSA9PT0gXCJsaWdodFwiID8gZS5wYWxldHRlLmdyZXlbNDAwXSA6IGUucGFsZXR0ZS5ncmV5WzcwMF19YCxcbiAgICAgICAgW2AmLiR7aWUuY2xpY2thYmxlfTpob3ZlcmBdOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGUuYWN0aW9uLmhvdmVyXG4gICAgICAgIH0sXG4gICAgICAgIFtgJi4ke2llLmZvY3VzVmlzaWJsZX1gXToge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLmFjdGlvbi5mb2N1c1xuICAgICAgICB9LFxuICAgICAgICBbYCYgLiR7aWUuYXZhdGFyfWBdOiB7XG4gICAgICAgICAgbWFyZ2luTGVmdDogNFxuICAgICAgICB9LFxuICAgICAgICBbYCYgLiR7aWUuYXZhdGFyU21hbGx9YF06IHtcbiAgICAgICAgICBtYXJnaW5MZWZ0OiAyXG4gICAgICAgIH0sXG4gICAgICAgIFtgJiAuJHtpZS5pY29ufWBdOiB7XG4gICAgICAgICAgbWFyZ2luTGVmdDogNFxuICAgICAgICB9LFxuICAgICAgICBbYCYgLiR7aWUuaWNvblNtYWxsfWBdOiB7XG4gICAgICAgICAgbWFyZ2luTGVmdDogMlxuICAgICAgICB9LFxuICAgICAgICBbYCYgLiR7aWUuZGVsZXRlSWNvbn1gXToge1xuICAgICAgICAgIG1hcmdpblJpZ2h0OiA1XG4gICAgICAgIH0sXG4gICAgICAgIFtgJiAuJHtpZS5kZWxldGVJY29uU21hbGx9YF06IHtcbiAgICAgICAgICBtYXJnaW5SaWdodDogM1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgLi4uT2JqZWN0LmVudHJpZXMoZS5wYWxldHRlKS5maWx0ZXIoUHQoKSkubWFwKChbcl0pID0+ICh7XG4gICAgICBwcm9wczoge1xuICAgICAgICB2YXJpYW50OiBcIm91dGxpbmVkXCIsXG4gICAgICAgIGNvbG9yOiByXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZVtyXS5tYWluLFxuICAgICAgICBib3JkZXI6IGAxcHggc29saWQgJHtlLnZhcnMgPyBgcmdiYSgke2UudmFycy5wYWxldHRlW3JdLm1haW5DaGFubmVsfSAvIDAuNylgIDogRGUoZS5wYWxldHRlW3JdLm1haW4sIDAuNyl9YCxcbiAgICAgICAgW2AmLiR7aWUuY2xpY2thYmxlfTpob3ZlcmBdOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLnZhcnMgPyBgcmdiYSgke2UudmFycy5wYWxldHRlW3JdLm1haW5DaGFubmVsfSAvICR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eX0pYCA6IERlKGUucGFsZXR0ZVtyXS5tYWluLCBlLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSlcbiAgICAgICAgfSxcbiAgICAgICAgW2AmLiR7aWUuZm9jdXNWaXNpYmxlfWBdOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLnZhcnMgPyBgcmdiYSgke2UudmFycy5wYWxldHRlW3JdLm1haW5DaGFubmVsfSAvICR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLmZvY3VzT3BhY2l0eX0pYCA6IERlKGUucGFsZXR0ZVtyXS5tYWluLCBlLnBhbGV0dGUuYWN0aW9uLmZvY3VzT3BhY2l0eSlcbiAgICAgICAgfSxcbiAgICAgICAgW2AmIC4ke2llLmRlbGV0ZUljb259YF06IHtcbiAgICAgICAgICBjb2xvcjogZS52YXJzID8gYHJnYmEoJHtlLnZhcnMucGFsZXR0ZVtyXS5tYWluQ2hhbm5lbH0gLyAwLjcpYCA6IERlKGUucGFsZXR0ZVtyXS5tYWluLCAwLjcpLFxuICAgICAgICAgIFwiJjpob3ZlciwgJjphY3RpdmVcIjoge1xuICAgICAgICAgICAgY29sb3I6IChlLnZhcnMgfHwgZSkucGFsZXR0ZVtyXS5tYWluXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpXVxuICB9O1xufSkpLCBvbSA9IGxlKFwic3BhblwiLCB7XG4gIG5hbWU6IFwiTXVpQ2hpcFwiLFxuICBzbG90OiBcIkxhYmVsXCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyU3RhdGU6IHJcbiAgICB9ID0gZSwge1xuICAgICAgc2l6ZTogblxuICAgIH0gPSByO1xuICAgIHJldHVybiBbdC5sYWJlbCwgdFtgbGFiZWwke2VlKG4pfWBdXTtcbiAgfVxufSkoe1xuICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgdGV4dE92ZXJmbG93OiBcImVsbGlwc2lzXCIsXG4gIHBhZGRpbmdMZWZ0OiAxMixcbiAgcGFkZGluZ1JpZ2h0OiAxMixcbiAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6IHtcbiAgICAgIHZhcmlhbnQ6IFwib3V0bGluZWRcIlxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAxMSxcbiAgICAgIHBhZGRpbmdSaWdodDogMTFcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgc2l6ZTogXCJzbWFsbFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZ0xlZnQ6IDgsXG4gICAgICBwYWRkaW5nUmlnaHQ6IDhcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgdmFyaWFudDogXCJvdXRsaW5lZFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZ0xlZnQ6IDcsXG4gICAgICBwYWRkaW5nUmlnaHQ6IDdcbiAgICB9XG4gIH1dXG59KTtcbmZ1bmN0aW9uIGJhKGUpIHtcbiAgcmV0dXJuIGUua2V5ID09PSBcIkJhY2tzcGFjZVwiIHx8IGUua2V5ID09PSBcIkRlbGV0ZVwiO1xufVxuY29uc3QgSXMgPSAvKiBAX19QVVJFX18gKi8gQy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsIHIpIHtcbiAgY29uc3QgbiA9IEhlKHtcbiAgICBwcm9wczogdCxcbiAgICBuYW1lOiBcIk11aUNoaXBcIlxuICB9KSwge1xuICAgIGF2YXRhcjogbyxcbiAgICBjbGFzc05hbWU6IGksXG4gICAgY2xpY2thYmxlOiBzLFxuICAgIGNvbG9yOiBjID0gXCJkZWZhdWx0XCIsXG4gICAgY29tcG9uZW50OiBsLFxuICAgIGRlbGV0ZUljb246IHUsXG4gICAgZGlzYWJsZWQ6IHAgPSAhMSxcbiAgICBpY29uOiBtLFxuICAgIGxhYmVsOiBnLFxuICAgIG9uQ2xpY2s6IHgsXG4gICAgb25EZWxldGU6IHksXG4gICAgb25LZXlEb3duOiBmLFxuICAgIG9uS2V5VXA6IFMsXG4gICAgc2l6ZTogRSA9IFwibWVkaXVtXCIsXG4gICAgdmFyaWFudDogUCA9IFwiZmlsbGVkXCIsXG4gICAgdGFiSW5kZXg6IFQsXG4gICAgc2tpcEZvY3VzV2hlbkRpc2FibGVkOiBiID0gITEsXG4gICAgLy8gVE9ETyB2NjogUmVuYW1lIHRvIGBmb2N1c2FibGVXaGVuRGlzYWJsZWRgLlxuICAgIC4uLmhcbiAgfSA9IG4sIHcgPSBDLnVzZVJlZihudWxsKSwgayA9IGF0KHcsIHIpLCBMID0gKEYpID0+IHtcbiAgICBGLnN0b3BQcm9wYWdhdGlvbigpLCB5ICYmIHkoRik7XG4gIH0sIEIgPSAoRikgPT4ge1xuICAgIEYuY3VycmVudFRhcmdldCA9PT0gRi50YXJnZXQgJiYgYmEoRikgJiYgRi5wcmV2ZW50RGVmYXVsdCgpLCBmICYmIGYoRik7XG4gIH0sIGQgPSAoRikgPT4ge1xuICAgIEYuY3VycmVudFRhcmdldCA9PT0gRi50YXJnZXQgJiYgeSAmJiBiYShGKSAmJiB5KEYpLCBTICYmIFMoRik7XG4gIH0sIEEgPSBzICE9PSAhMSAmJiB4ID8gITAgOiBzLCBEID0gQSB8fCB5ID8gJHIgOiBsIHx8IFwiZGl2XCIsIGogPSB7XG4gICAgLi4ubixcbiAgICBjb21wb25lbnQ6IEQsXG4gICAgZGlzYWJsZWQ6IHAsXG4gICAgc2l6ZTogRSxcbiAgICBjb2xvcjogYyxcbiAgICBpY29uQ29sb3I6IC8qIEBfX1BVUkVfXyAqLyBDLmlzVmFsaWRFbGVtZW50KG0pICYmIG0ucHJvcHMuY29sb3IgfHwgYyxcbiAgICBvbkRlbGV0ZTogISF5LFxuICAgIGNsaWNrYWJsZTogQSxcbiAgICB2YXJpYW50OiBQXG4gIH0sIFcgPSBybShqKSwgeiA9IEQgPT09ICRyID8ge1xuICAgIGNvbXBvbmVudDogbCB8fCBcImRpdlwiLFxuICAgIGZvY3VzVmlzaWJsZUNsYXNzTmFtZTogVy5mb2N1c1Zpc2libGUsXG4gICAgLi4ueSAmJiB7XG4gICAgICBkaXNhYmxlUmlwcGxlOiAhMFxuICAgIH1cbiAgfSA6IHt9O1xuICBsZXQgVSA9IG51bGw7XG4gIHkgJiYgKFUgPSB1ICYmIC8qIEBfX1BVUkVfXyAqLyBDLmlzVmFsaWRFbGVtZW50KHUpID8gLyogQF9fUFVSRV9fICovIEMuY2xvbmVFbGVtZW50KHUsIHtcbiAgICBjbGFzc05hbWU6IHNlKHUucHJvcHMuY2xhc3NOYW1lLCBXLmRlbGV0ZUljb24pLFxuICAgIG9uQ2xpY2s6IExcbiAgfSkgOiAvKiBAX19QVVJFX18gKi8gTi5qc3goZW0sIHtcbiAgICBjbGFzc05hbWU6IHNlKFcuZGVsZXRlSWNvbiksXG4gICAgb25DbGljazogTFxuICB9KSk7XG4gIGxldCBWID0gbnVsbDtcbiAgbyAmJiAvKiBAX19QVVJFX18gKi8gQy5pc1ZhbGlkRWxlbWVudChvKSAmJiAoViA9IC8qIEBfX1BVUkVfXyAqLyBDLmNsb25lRWxlbWVudChvLCB7XG4gICAgY2xhc3NOYW1lOiBzZShXLmF2YXRhciwgby5wcm9wcy5jbGFzc05hbWUpXG4gIH0pKTtcbiAgbGV0IHRlID0gbnVsbDtcbiAgcmV0dXJuIG0gJiYgLyogQF9fUFVSRV9fICovIEMuaXNWYWxpZEVsZW1lbnQobSkgJiYgKHRlID0gLyogQF9fUFVSRV9fICovIEMuY2xvbmVFbGVtZW50KG0sIHtcbiAgICBjbGFzc05hbWU6IHNlKFcuaWNvbiwgbS5wcm9wcy5jbGFzc05hbWUpXG4gIH0pKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFYgJiYgdGUgJiYgY29uc29sZS5lcnJvcihcIk1VSTogVGhlIENoaXAgY29tcG9uZW50IGNhbiBub3QgaGFuZGxlIHRoZSBhdmF0YXIgYW5kIHRoZSBpY29uIHByb3AgYXQgdGhlIHNhbWUgdGltZS4gUGljayBvbmUuXCIpLCAvKiBAX19QVVJFX18gKi8gTi5qc3hzKG5tLCB7XG4gICAgYXM6IEQsXG4gICAgY2xhc3NOYW1lOiBzZShXLnJvb3QsIGkpLFxuICAgIGRpc2FibGVkOiBBICYmIHAgPyAhMCA6IHZvaWQgMCxcbiAgICBvbkNsaWNrOiB4LFxuICAgIG9uS2V5RG93bjogQixcbiAgICBvbktleVVwOiBkLFxuICAgIHJlZjogayxcbiAgICB0YWJJbmRleDogYiAmJiBwID8gLTEgOiBULFxuICAgIG93bmVyU3RhdGU6IGosXG4gICAgLi4ueixcbiAgICAuLi5oLFxuICAgIGNoaWxkcmVuOiBbViB8fCB0ZSwgLyogQF9fUFVSRV9fICovIE4uanN4KG9tLCB7XG4gICAgICBjbGFzc05hbWU6IHNlKFcubGFiZWwpLFxuICAgICAgb3duZXJTdGF0ZTogaixcbiAgICAgIGNoaWxkcmVuOiBnXG4gICAgfSksIFVdXG4gIH0pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKElzLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgICAgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBUaGUgQXZhdGFyIGVsZW1lbnQgdG8gZGlzcGxheS5cbiAgICovXG4gIGF2YXRhcjogYS5lbGVtZW50LFxuICAvKipcbiAgICogVGhpcyBwcm9wIGlzbid0IHN1cHBvcnRlZC5cbiAgICogVXNlIHRoZSBgY29tcG9uZW50YCBwcm9wIGlmIHlvdSBuZWVkIHRvIGNoYW5nZSB0aGUgY2hpbGRyZW4gc3RydWN0dXJlLlxuICAgKi9cbiAgY2hpbGRyZW46IEJ1LFxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IGEuc3RyaW5nLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY2hpcCB3aWxsIGFwcGVhciBjbGlja2FibGUsIGFuZCB3aWxsIHJhaXNlIHdoZW4gcHJlc3NlZCxcbiAgICogZXZlbiBpZiB0aGUgb25DbGljayBwcm9wIGlzIG5vdCBkZWZpbmVkLlxuICAgKiBJZiBgZmFsc2VgLCB0aGUgY2hpcCB3aWxsIG5vdCBhcHBlYXIgY2xpY2thYmxlLCBldmVuIGlmIG9uQ2xpY2sgcHJvcCBpcyBkZWZpbmVkLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSxcbiAgICogYWxvbmcgd2l0aCB0aGUgY29tcG9uZW50IHByb3AgdG8gaW5kaWNhdGUgYW4gYW5jaG9yIENoaXAgaXMgY2xpY2thYmxlLlxuICAgKiBOb3RlOiB0aGlzIGNvbnRyb2xzIHRoZSBVSSBhbmQgZG9lcyBub3QgYWZmZWN0IHRoZSBvbkNsaWNrIGV2ZW50LlxuICAgKi9cbiAgY2xpY2thYmxlOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC5cbiAgICogSXQgc3VwcG9ydHMgYm90aCBkZWZhdWx0IGFuZCBjdXN0b20gdGhlbWUgY29sb3JzLCB3aGljaCBjYW4gYmUgYWRkZWQgYXMgc2hvd24gaW4gdGhlXG4gICAqIFtwYWxldHRlIGN1c3RvbWl6YXRpb24gZ3VpZGVdKGh0dHBzOi8vbXVpLmNvbS9tYXRlcmlhbC11aS9jdXN0b21pemF0aW9uL3BhbGV0dGUvI2N1c3RvbS1jb2xvcnMpLlxuICAgKiBAZGVmYXVsdCAnZGVmYXVsdCdcbiAgICovXG4gIGNvbG9yOiBhLm9uZU9mVHlwZShbYS5vbmVPZihbXCJkZWZhdWx0XCIsIFwicHJpbWFyeVwiLCBcInNlY29uZGFyeVwiLCBcImVycm9yXCIsIFwiaW5mb1wiLCBcInN1Y2Nlc3NcIiwgXCJ3YXJuaW5nXCJdKSwgYS5zdHJpbmddKSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogYS5lbGVtZW50VHlwZSxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGRlbGV0ZSBpY29uIGVsZW1lbnQuIFNob3duIG9ubHkgaWYgYG9uRGVsZXRlYCBpcyBzZXQuXG4gICAqL1xuICBkZWxldGVJY29uOiBhLmVsZW1lbnQsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgaXMgZGlzYWJsZWQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlZDogYS5ib29sLFxuICAvKipcbiAgICogSWNvbiBlbGVtZW50LlxuICAgKi9cbiAgaWNvbjogYS5lbGVtZW50LFxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGxhYmVsOiBhLm5vZGUsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkNsaWNrOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBkZWxldGUgaWNvbiBpcyBjbGlja2VkLlxuICAgKiBJZiBzZXQsIHRoZSBkZWxldGUgaWNvbiB3aWxsIGJlIHNob3duLlxuICAgKi9cbiAgb25EZWxldGU6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uS2V5RG93bjogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25LZXlVcDogYS5mdW5jLFxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICogQGRlZmF1bHQgJ21lZGl1bSdcbiAgICovXG4gIHNpemU6IGEub25lT2ZUeXBlKFthLm9uZU9mKFtcIm1lZGl1bVwiLCBcInNtYWxsXCJdKSwgYS5zdHJpbmddKSxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYWxsb3dzIHRoZSBkaXNhYmxlZCBjaGlwIHRvIGVzY2FwZSBmb2N1cy5cbiAgICogSWYgYGZhbHNlYCwgYWxsb3dzIHRoZSBkaXNhYmxlZCBjaGlwIHRvIHJlY2VpdmUgZm9jdXMuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBza2lwRm9jdXNXaGVuRGlzYWJsZWQ6IGEuYm9vbCxcbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gcHJvcCB0aGF0IGFsbG93cyBkZWZpbmluZyBzeXN0ZW0gb3ZlcnJpZGVzIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgc3g6IGEub25lT2ZUeXBlKFthLmFycmF5T2YoYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3QsIGEuYm9vbF0pKSwgYS5mdW5jLCBhLm9iamVjdF0pLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdGFiSW5kZXg6IGEubnVtYmVyLFxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgdG8gdXNlLlxuICAgKiBAZGVmYXVsdCAnZmlsbGVkJ1xuICAgKi9cbiAgdmFyaWFudDogYS5vbmVPZlR5cGUoW2Eub25lT2YoW1wiZmlsbGVkXCIsIFwib3V0bGluZWRcIl0pLCBhLnN0cmluZ10pXG59KTtcbmNvbnN0IGltID0gc3IoLyogQF9fUFVSRV9fICovIE4uanN4KFwicGF0aFwiLCB7XG4gIGQ6IFwiTTEyIDEyYzIuMjEgMCA0LTEuNzkgNC00cy0xLjc5LTQtNC00LTQgMS43OS00IDQgMS43OSA0IDQgNHptMCAyYy0yLjY3IDAtOCAxLjM0LTggNHYyaDE2di0yYzAtMi42Ni01LjMzLTQtOC00elwiXG59KSwgXCJQZXJzb25cIik7XG5mdW5jdGlvbiBhbShlKSB7XG4gIHJldHVybiBWZShcIk11aUF2YXRhclwiLCBlKTtcbn1cbkZlKFwiTXVpQXZhdGFyXCIsIFtcInJvb3RcIiwgXCJjb2xvckRlZmF1bHRcIiwgXCJjaXJjdWxhclwiLCBcInJvdW5kZWRcIiwgXCJzcXVhcmVcIiwgXCJpbWdcIiwgXCJmYWxsYmFja1wiXSk7XG5jb25zdCBzbSA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjbGFzc2VzOiB0LFxuICAgIHZhcmlhbnQ6IHIsXG4gICAgY29sb3JEZWZhdWx0OiBuXG4gIH0gPSBlO1xuICByZXR1cm4gR2Uoe1xuICAgIHJvb3Q6IFtcInJvb3RcIiwgciwgbiAmJiBcImNvbG9yRGVmYXVsdFwiXSxcbiAgICBpbWc6IFtcImltZ1wiXSxcbiAgICBmYWxsYmFjazogW1wiZmFsbGJhY2tcIl1cbiAgfSwgYW0sIHQpO1xufSwgY20gPSBsZShcImRpdlwiLCB7XG4gIG5hbWU6IFwiTXVpQXZhdGFyXCIsXG4gIHNsb3Q6IFwiUm9vdFwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lclN0YXRlOiByXG4gICAgfSA9IGU7XG4gICAgcmV0dXJuIFt0LnJvb3QsIHRbci52YXJpYW50XSwgci5jb2xvckRlZmF1bHQgJiYgdC5jb2xvckRlZmF1bHRdO1xuICB9XG59KShxZSgoe1xuICB0aGVtZTogZVxufSkgPT4gKHtcbiAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgZGlzcGxheTogXCJmbGV4XCIsXG4gIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICBmbGV4U2hyaW5rOiAwLFxuICB3aWR0aDogNDAsXG4gIGhlaWdodDogNDAsXG4gIGZvbnRGYW1pbHk6IGUudHlwb2dyYXBoeS5mb250RmFtaWx5LFxuICBmb250U2l6ZTogZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjApLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBib3JkZXJSYWRpdXM6IFwiNTAlXCIsXG4gIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6IHtcbiAgICAgIHZhcmlhbnQ6IFwicm91bmRlZFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgYm9yZGVyUmFkaXVzOiAoZS52YXJzIHx8IGUpLnNoYXBlLmJvcmRlclJhZGl1c1xuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiB7XG4gICAgICB2YXJpYW50OiBcInNxdWFyZVwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgYm9yZGVyUmFkaXVzOiAwXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGNvbG9yRGVmYXVsdDogITBcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLmJhY2tncm91bmQuZGVmYXVsdCxcbiAgICAgIC4uLmUudmFycyA/IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLnZhcnMucGFsZXR0ZS5BdmF0YXIuZGVmYXVsdEJnXG4gICAgICB9IDoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUucGFsZXR0ZS5ncmV5WzQwMF0sXG4gICAgICAgIC4uLmUuYXBwbHlTdHlsZXMoXCJkYXJrXCIsIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUucGFsZXR0ZS5ncmV5WzYwMF1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1dXG59KSkpLCBsbSA9IGxlKFwiaW1nXCIsIHtcbiAgbmFtZTogXCJNdWlBdmF0YXJcIixcbiAgc2xvdDogXCJJbWdcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB0LmltZ1xufSkoe1xuICB3aWR0aDogXCIxMDAlXCIsXG4gIGhlaWdodDogXCIxMDAlXCIsXG4gIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgLy8gSGFuZGxlIG5vbi1zcXVhcmUgaW1hZ2UuXG4gIG9iamVjdEZpdDogXCJjb3ZlclwiLFxuICAvLyBIaWRlIGFsdCB0ZXh0LlxuICBjb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAvLyBIaWRlIHRoZSBpbWFnZSBicm9rZW4gaWNvbiwgb25seSB3b3JrcyBvbiBDaHJvbWUuXG4gIHRleHRJbmRlbnQ6IDFlNFxufSksIHVtID0gbGUoaW0sIHtcbiAgbmFtZTogXCJNdWlBdmF0YXJcIixcbiAgc2xvdDogXCJGYWxsYmFja1wiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHQuZmFsbGJhY2tcbn0pKHtcbiAgd2lkdGg6IFwiNzUlXCIsXG4gIGhlaWdodDogXCI3NSVcIlxufSk7XG5mdW5jdGlvbiBmbSh7XG4gIGNyb3NzT3JpZ2luOiBlLFxuICByZWZlcnJlclBvbGljeTogdCxcbiAgc3JjOiByLFxuICBzcmNTZXQ6IG5cbn0pIHtcbiAgY29uc3QgW28sIGldID0gQy51c2VTdGF0ZSghMSk7XG4gIHJldHVybiBDLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFyICYmICFuKVxuICAgICAgcmV0dXJuO1xuICAgIGkoITEpO1xuICAgIGxldCBzID0gITA7XG4gICAgY29uc3QgYyA9IG5ldyBJbWFnZSgpO1xuICAgIHJldHVybiBjLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHMgJiYgaShcImxvYWRlZFwiKTtcbiAgICB9LCBjLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICBzICYmIGkoXCJlcnJvclwiKTtcbiAgICB9LCBjLmNyb3NzT3JpZ2luID0gZSwgYy5yZWZlcnJlclBvbGljeSA9IHQsIGMuc3JjID0gciwgbiAmJiAoYy5zcmNzZXQgPSBuKSwgKCkgPT4ge1xuICAgICAgcyA9ICExO1xuICAgIH07XG4gIH0sIFtlLCB0LCByLCBuXSksIG87XG59XG5jb25zdCBfcyA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCBuID0gSGUoe1xuICAgIHByb3BzOiB0LFxuICAgIG5hbWU6IFwiTXVpQXZhdGFyXCJcbiAgfSksIHtcbiAgICBhbHQ6IG8sXG4gICAgY2hpbGRyZW46IGksXG4gICAgY2xhc3NOYW1lOiBzLFxuICAgIGNvbXBvbmVudDogYyA9IFwiZGl2XCIsXG4gICAgc2xvdHM6IGwgPSB7fSxcbiAgICBzbG90UHJvcHM6IHUgPSB7fSxcbiAgICBpbWdQcm9wczogcCxcbiAgICBzaXplczogbSxcbiAgICBzcmM6IGcsXG4gICAgc3JjU2V0OiB4LFxuICAgIHZhcmlhbnQ6IHkgPSBcImNpcmN1bGFyXCIsXG4gICAgLi4uZlxuICB9ID0gbjtcbiAgbGV0IFMgPSBudWxsO1xuICBjb25zdCBFID0ge1xuICAgIC4uLm4sXG4gICAgY29tcG9uZW50OiBjLFxuICAgIHZhcmlhbnQ6IHlcbiAgfSwgUCA9IGZtKHtcbiAgICAuLi5wLFxuICAgIC4uLnR5cGVvZiB1LmltZyA9PSBcImZ1bmN0aW9uXCIgPyB1LmltZyhFKSA6IHUuaW1nLFxuICAgIHNyYzogZyxcbiAgICBzcmNTZXQ6IHhcbiAgfSksIFQgPSBnIHx8IHgsIGIgPSBUICYmIFAgIT09IFwiZXJyb3JcIjtcbiAgRS5jb2xvckRlZmF1bHQgPSAhYiwgZGVsZXRlIEUub3duZXJTdGF0ZTtcbiAgY29uc3QgaCA9IHNtKEUpLCBbdywga10gPSBCdChcImltZ1wiLCB7XG4gICAgY2xhc3NOYW1lOiBoLmltZyxcbiAgICBlbGVtZW50VHlwZTogbG0sXG4gICAgZXh0ZXJuYWxGb3J3YXJkZWRQcm9wczoge1xuICAgICAgc2xvdHM6IGwsXG4gICAgICBzbG90UHJvcHM6IHtcbiAgICAgICAgaW1nOiB7XG4gICAgICAgICAgLi4ucCxcbiAgICAgICAgICAuLi51LmltZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhZGRpdGlvbmFsUHJvcHM6IHtcbiAgICAgIGFsdDogbyxcbiAgICAgIHNyYzogZyxcbiAgICAgIHNyY1NldDogeCxcbiAgICAgIHNpemVzOiBtXG4gICAgfSxcbiAgICBvd25lclN0YXRlOiBFXG4gIH0pO1xuICByZXR1cm4gYiA/IFMgPSAvKiBAX19QVVJFX18gKi8gTi5qc3godywge1xuICAgIC4uLmtcbiAgfSkgOiBpIHx8IGkgPT09IDAgPyBTID0gaSA6IFQgJiYgbyA/IFMgPSBvWzBdIDogUyA9IC8qIEBfX1BVUkVfXyAqLyBOLmpzeCh1bSwge1xuICAgIG93bmVyU3RhdGU6IEUsXG4gICAgY2xhc3NOYW1lOiBoLmZhbGxiYWNrXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gTi5qc3goY20sIHtcbiAgICBhczogYyxcbiAgICBjbGFzc05hbWU6IHNlKGgucm9vdCwgcyksXG4gICAgcmVmOiByLFxuICAgIC4uLmYsXG4gICAgb3duZXJTdGF0ZTogRSxcbiAgICBjaGlsZHJlbjogU1xuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChfcy5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCICAgIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiAgICAg4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogVXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBzcmNgIG9yIGBzcmNTZXRgIHRvXG4gICAqIHByb3ZpZGUgYW4gYWx0IGF0dHJpYnV0ZSBmb3IgdGhlIHJlbmRlcmVkIGBpbWdgIGVsZW1lbnQuXG4gICAqL1xuICBhbHQ6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVXNlZCB0byByZW5kZXIgaWNvbiBvciB0ZXh0IGVsZW1lbnRzIGluc2lkZSB0aGUgQXZhdGFyIGlmIGBzcmNgIGlzIG5vdCBzZXQuXG4gICAqIFRoaXMgY2FuIGJlIGFuIGVsZW1lbnQsIG9yIGp1c3QgYSBzdHJpbmcuXG4gICAqL1xuICBjaGlsZHJlbjogYS5ub2RlLFxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgY29tcG9uZW50OiBhLmVsZW1lbnRUeXBlLFxuICAvKipcbiAgICogW0F0dHJpYnV0ZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0cmlidXRlcykgYXBwbGllZCB0byB0aGUgYGltZ2AgZWxlbWVudCBpZiB0aGUgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhbiBpbWFnZS5cbiAgICogSXQgY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciB0aGUgbG9hZGluZyBlcnJvciBldmVudC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzbG90UHJvcHMuaW1nYCBpbnN0ZWFkLiBUaGlzIHByb3Agd2lsbCBiZSByZW1vdmVkIGluIHY3LiBTZWUgW01pZ3JhdGluZyBmcm9tIGRlcHJlY2F0ZWQgQVBJc10oL21hdGVyaWFsLXVpL21pZ3JhdGlvbi9taWdyYXRpbmctZnJvbS1kZXByZWNhdGVkLWFwaXMvKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgaW1nUHJvcHM6IGEub2JqZWN0LFxuICAvKipcbiAgICogVGhlIGBzaXplc2AgYXR0cmlidXRlIGZvciB0aGUgYGltZ2AgZWxlbWVudC5cbiAgICovXG4gIHNpemVzOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFRoZSBwcm9wcyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgc2xvdFByb3BzOiBhLnNoYXBlKHtcbiAgICBpbWc6IGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0XSlcbiAgfSksXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgc2xvdHM6IGEuc2hhcGUoe1xuICAgIGltZzogYS5lbGVtZW50VHlwZVxuICB9KSxcbiAgLyoqXG4gICAqIFRoZSBgc3JjYCBhdHRyaWJ1dGUgZm9yIHRoZSBgaW1nYCBlbGVtZW50LlxuICAgKi9cbiAgc3JjOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFRoZSBgc3JjU2V0YCBhdHRyaWJ1dGUgZm9yIHRoZSBgaW1nYCBlbGVtZW50LlxuICAgKiBVc2UgdGhpcyBhdHRyaWJ1dGUgZm9yIHJlc3BvbnNpdmUgaW1hZ2UgZGlzcGxheS5cbiAgICovXG4gIHNyY1NldDogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHByb3AgdGhhdCBhbGxvd3MgZGVmaW5pbmcgc3lzdGVtIG92ZXJyaWRlcyBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHN4OiBhLm9uZU9mVHlwZShbYS5hcnJheU9mKGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0LCBhLmJvb2xdKSksIGEuZnVuYywgYS5vYmplY3RdKSxcbiAgLyoqXG4gICAqIFRoZSBzaGFwZSBvZiB0aGUgYXZhdGFyLlxuICAgKiBAZGVmYXVsdCAnY2lyY3VsYXInXG4gICAqL1xuICB2YXJpYW50OiBhLm9uZU9mVHlwZShbYS5vbmVPZihbXCJjaXJjdWxhclwiLCBcInJvdW5kZWRcIiwgXCJzcXVhcmVcIl0pLCBhLnN0cmluZ10pXG59KTtcbmNvbnN0IGRtID0gRmUoXCJNdWlCb3hcIiwgW1wicm9vdFwiXSksIHBtID0gRm4oKSwgZHQgPSBidSh7XG4gIHRoZW1lSWQ6IHd0LFxuICBkZWZhdWx0VGhlbWU6IHBtLFxuICBkZWZhdWx0Q2xhc3NOYW1lOiBkbS5yb290LFxuICBnZW5lcmF0ZUNsYXNzTmFtZTogV2EuZ2VuZXJhdGVcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChkdC5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCICAgIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiAgICAg4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogYS5lbGVtZW50VHlwZSxcbiAgLyoqXG4gICAqIFRoZSBzeXN0ZW0gcHJvcCB0aGF0IGFsbG93cyBkZWZpbmluZyBzeXN0ZW0gb3ZlcnJpZGVzIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgc3g6IGEub25lT2ZUeXBlKFthLmFycmF5T2YoYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3QsIGEuYm9vbF0pKSwgYS5mdW5jLCBhLm9iamVjdF0pXG59KTtcbmZ1bmN0aW9uIHhvKGUpIHtcbiAgcmV0dXJuIGBzY2FsZSgke2V9LCAke2UgKiogMn0pYDtcbn1cbmNvbnN0IG1tID0ge1xuICBlbnRlcmluZzoge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgdHJhbnNmb3JtOiB4bygxKVxuICB9LFxuICBlbnRlcmVkOiB7XG4gICAgb3BhY2l0eTogMSxcbiAgICB0cmFuc2Zvcm06IFwibm9uZVwiXG4gIH1cbn0sIG5vID0gdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKihzYWZhcml8bW9iaWxlKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgLyhvcyB8dmVyc2lvblxcLykxNSgufF8pNC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksIE9uID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IHtcbiAgICBhZGRFbmRMaXN0ZW5lcjogbixcbiAgICBhcHBlYXI6IG8gPSAhMCxcbiAgICBjaGlsZHJlbjogaSxcbiAgICBlYXNpbmc6IHMsXG4gICAgaW46IGMsXG4gICAgb25FbnRlcjogbCxcbiAgICBvbkVudGVyZWQ6IHUsXG4gICAgb25FbnRlcmluZzogcCxcbiAgICBvbkV4aXQ6IG0sXG4gICAgb25FeGl0ZWQ6IGcsXG4gICAgb25FeGl0aW5nOiB4LFxuICAgIHN0eWxlOiB5LFxuICAgIHRpbWVvdXQ6IGYgPSBcImF1dG9cIixcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvcHJvcC10eXBlc1xuICAgIFRyYW5zaXRpb25Db21wb25lbnQ6IFMgPSBFdCxcbiAgICAuLi5FXG4gIH0gPSB0LCBQID0gRHQoKSwgVCA9IEMudXNlUmVmKCksIGIgPSBMcigpLCBoID0gQy51c2VSZWYobnVsbCksIHcgPSBhdChoLCBCbyhpKSwgciksIGsgPSAoeikgPT4gKFUpID0+IHtcbiAgICBpZiAoeikge1xuICAgICAgY29uc3QgViA9IGguY3VycmVudDtcbiAgICAgIFUgPT09IHZvaWQgMCA/IHooVikgOiB6KFYsIFUpO1xuICAgIH1cbiAgfSwgTCA9IGsocCksIEIgPSBrKCh6LCBVKSA9PiB7XG4gICAgdGQoeik7XG4gICAgY29uc3Qge1xuICAgICAgZHVyYXRpb246IFYsXG4gICAgICBkZWxheTogdGUsXG4gICAgICBlYXNpbmc6IEZcbiAgICB9ID0gdm4oe1xuICAgICAgc3R5bGU6IHksXG4gICAgICB0aW1lb3V0OiBmLFxuICAgICAgZWFzaW5nOiBzXG4gICAgfSwge1xuICAgICAgbW9kZTogXCJlbnRlclwiXG4gICAgfSk7XG4gICAgbGV0IFI7XG4gICAgZiA9PT0gXCJhdXRvXCIgPyAoUiA9IGIudHJhbnNpdGlvbnMuZ2V0QXV0b0hlaWdodER1cmF0aW9uKHouY2xpZW50SGVpZ2h0KSwgVC5jdXJyZW50ID0gUikgOiBSID0gViwgei5zdHlsZS50cmFuc2l0aW9uID0gW2IudHJhbnNpdGlvbnMuY3JlYXRlKFwib3BhY2l0eVwiLCB7XG4gICAgICBkdXJhdGlvbjogUixcbiAgICAgIGRlbGF5OiB0ZVxuICAgIH0pLCBiLnRyYW5zaXRpb25zLmNyZWF0ZShcInRyYW5zZm9ybVwiLCB7XG4gICAgICBkdXJhdGlvbjogbm8gPyBSIDogUiAqIDAuNjY2LFxuICAgICAgZGVsYXk6IHRlLFxuICAgICAgZWFzaW5nOiBGXG4gICAgfSldLmpvaW4oXCIsXCIpLCBsICYmIGwoeiwgVSk7XG4gIH0pLCBkID0gayh1KSwgQSA9IGsoeCksIEQgPSBrKCh6KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZHVyYXRpb246IFUsXG4gICAgICBkZWxheTogVixcbiAgICAgIGVhc2luZzogdGVcbiAgICB9ID0gdm4oe1xuICAgICAgc3R5bGU6IHksXG4gICAgICB0aW1lb3V0OiBmLFxuICAgICAgZWFzaW5nOiBzXG4gICAgfSwge1xuICAgICAgbW9kZTogXCJleGl0XCJcbiAgICB9KTtcbiAgICBsZXQgRjtcbiAgICBmID09PSBcImF1dG9cIiA/IChGID0gYi50cmFuc2l0aW9ucy5nZXRBdXRvSGVpZ2h0RHVyYXRpb24oei5jbGllbnRIZWlnaHQpLCBULmN1cnJlbnQgPSBGKSA6IEYgPSBVLCB6LnN0eWxlLnRyYW5zaXRpb24gPSBbYi50cmFuc2l0aW9ucy5jcmVhdGUoXCJvcGFjaXR5XCIsIHtcbiAgICAgIGR1cmF0aW9uOiBGLFxuICAgICAgZGVsYXk6IFZcbiAgICB9KSwgYi50cmFuc2l0aW9ucy5jcmVhdGUoXCJ0cmFuc2Zvcm1cIiwge1xuICAgICAgZHVyYXRpb246IG5vID8gRiA6IEYgKiAwLjY2NixcbiAgICAgIGRlbGF5OiBubyA/IFYgOiBWIHx8IEYgKiAwLjMzMyxcbiAgICAgIGVhc2luZzogdGVcbiAgICB9KV0uam9pbihcIixcIiksIHouc3R5bGUub3BhY2l0eSA9IDAsIHouc3R5bGUudHJhbnNmb3JtID0geG8oMC43NSksIG0gJiYgbSh6KTtcbiAgfSksIGogPSBrKGcpLCBXID0gKHopID0+IHtcbiAgICBmID09PSBcImF1dG9cIiAmJiBQLnN0YXJ0KFQuY3VycmVudCB8fCAwLCB6KSwgbiAmJiBuKGguY3VycmVudCwgeik7XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goUywge1xuICAgIGFwcGVhcjogbyxcbiAgICBpbjogYyxcbiAgICBub2RlUmVmOiBoLFxuICAgIG9uRW50ZXI6IEIsXG4gICAgb25FbnRlcmVkOiBkLFxuICAgIG9uRW50ZXJpbmc6IEwsXG4gICAgb25FeGl0OiBELFxuICAgIG9uRXhpdGVkOiBqLFxuICAgIG9uRXhpdGluZzogQSxcbiAgICBhZGRFbmRMaXN0ZW5lcjogVyxcbiAgICB0aW1lb3V0OiBmID09PSBcImF1dG9cIiA/IG51bGwgOiBmLFxuICAgIC4uLkUsXG4gICAgY2hpbGRyZW46ICh6LCB7XG4gICAgICBvd25lclN0YXRlOiBVLFxuICAgICAgLi4uVlxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBDLmNsb25lRWxlbWVudChpLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICB0cmFuc2Zvcm06IHhvKDAuNzUpLFxuICAgICAgICB2aXNpYmlsaXR5OiB6ID09PSBcImV4aXRlZFwiICYmICFjID8gXCJoaWRkZW5cIiA6IHZvaWQgMCxcbiAgICAgICAgLi4ubW1bel0sXG4gICAgICAgIC4uLnksXG4gICAgICAgIC4uLmkucHJvcHMuc3R5bGVcbiAgICAgIH0sXG4gICAgICByZWY6IHcsXG4gICAgICAuLi5WXG4gICAgfSlcbiAgfSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoT24ucHJvcFR5cGVzID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiAgICBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4gICAgIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICAqIEFkZCBhIGN1c3RvbSB0cmFuc2l0aW9uIGVuZCB0cmlnZ2VyLiBDYWxsZWQgd2l0aCB0aGUgdHJhbnNpdGlvbmluZyBET01cbiAgICogbm9kZSBhbmQgYSBkb25lIGNhbGxiYWNrLiBBbGxvd3MgZm9yIG1vcmUgZmluZSBncmFpbmVkIHRyYW5zaXRpb24gZW5kXG4gICAqIGxvZ2ljLiBOb3RlOiBUaW1lb3V0cyBhcmUgc3RpbGwgdXNlZCBhcyBhIGZhbGxiYWNrIGlmIHByb3ZpZGVkLlxuICAgKi9cbiAgYWRkRW5kTGlzdGVuZXI6IGEuZnVuYyxcbiAgLyoqXG4gICAqIFBlcmZvcm0gdGhlIGVudGVyIHRyYW5zaXRpb24gd2hlbiBpdCBmaXJzdCBtb3VudHMgaWYgYGluYCBpcyBhbHNvIGB0cnVlYC5cbiAgICogU2V0IHRoaXMgdG8gYGZhbHNlYCB0byBkaXNhYmxlIHRoaXMgYmVoYXZpb3IuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGFwcGVhcjogYS5ib29sLFxuICAvKipcbiAgICogQSBzaW5nbGUgY2hpbGQgY29udGVudCBlbGVtZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IGpvLmlzUmVxdWlyZWQsXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNpdGlvbiB0aW1pbmcgZnVuY3Rpb24uXG4gICAqIFlvdSBtYXkgc3BlY2lmeSBhIHNpbmdsZSBlYXNpbmcgb3IgYSBvYmplY3QgY29udGFpbmluZyBlbnRlciBhbmQgZXhpdCB2YWx1ZXMuXG4gICAqL1xuICBlYXNpbmc6IGEub25lT2ZUeXBlKFthLnNoYXBlKHtcbiAgICBlbnRlcjogYS5zdHJpbmcsXG4gICAgZXhpdDogYS5zdHJpbmdcbiAgfSksIGEuc3RyaW5nXSksXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgd2lsbCB0cmFuc2l0aW9uIGluLlxuICAgKi9cbiAgaW46IGEuYm9vbCxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRW50ZXI6IGEuZnVuYyxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRW50ZXJlZDogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FbnRlcmluZzogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FeGl0OiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkV4aXRlZDogYS5mdW5jLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FeGl0aW5nOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdHlsZTogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gZm9yIHRoZSB0cmFuc2l0aW9uLCBpbiBtaWxsaXNlY29uZHMuXG4gICAqIFlvdSBtYXkgc3BlY2lmeSBhIHNpbmdsZSB0aW1lb3V0IGZvciBhbGwgdHJhbnNpdGlvbnMsIG9yIGluZGl2aWR1YWxseSB3aXRoIGFuIG9iamVjdC5cbiAgICpcbiAgICogU2V0IHRvICdhdXRvJyB0byBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSB0cmFuc2l0aW9uIHRpbWUgYmFzZWQgb24gaGVpZ2h0LlxuICAgKiBAZGVmYXVsdCAnYXV0bydcbiAgICovXG4gIHRpbWVvdXQ6IGEub25lT2ZUeXBlKFthLm9uZU9mKFtcImF1dG9cIl0pLCBhLm51bWJlciwgYS5zaGFwZSh7XG4gICAgYXBwZWFyOiBhLm51bWJlcixcbiAgICBlbnRlcjogYS5udW1iZXIsXG4gICAgZXhpdDogYS5udW1iZXJcbiAgfSldKVxufSk7XG5PbiAmJiAoT24ubXVpU3VwcG9ydEF1dG8gPSAhMCk7XG5jb25zdCBvciA9IC8qIEBfX1BVUkVfXyAqLyBDLmNyZWF0ZUNvbnRleHQoe30pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChvci5kaXNwbGF5TmFtZSA9IFwiTGlzdENvbnRleHRcIik7XG5mdW5jdGlvbiBobShlKSB7XG4gIHJldHVybiBWZShcIk11aUxpc3RcIiwgZSk7XG59XG5GZShcIk11aUxpc3RcIiwgW1wicm9vdFwiLCBcInBhZGRpbmdcIiwgXCJkZW5zZVwiLCBcInN1YmhlYWRlclwiXSk7XG5jb25zdCBnbSA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjbGFzc2VzOiB0LFxuICAgIGRpc2FibGVQYWRkaW5nOiByLFxuICAgIGRlbnNlOiBuLFxuICAgIHN1YmhlYWRlcjogb1xuICB9ID0gZTtcbiAgcmV0dXJuIEdlKHtcbiAgICByb290OiBbXCJyb290XCIsICFyICYmIFwicGFkZGluZ1wiLCBuICYmIFwiZGVuc2VcIiwgbyAmJiBcInN1YmhlYWRlclwiXVxuICB9LCBobSwgdCk7XG59LCB5bSA9IGxlKFwidWxcIiwge1xuICBuYW1lOiBcIk11aUxpc3RcIixcbiAgc2xvdDogXCJSb290XCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyU3RhdGU6IHJcbiAgICB9ID0gZTtcbiAgICByZXR1cm4gW3Qucm9vdCwgIXIuZGlzYWJsZVBhZGRpbmcgJiYgdC5wYWRkaW5nLCByLmRlbnNlICYmIHQuZGVuc2UsIHIuc3ViaGVhZGVyICYmIHQuc3ViaGVhZGVyXTtcbiAgfVxufSkoe1xuICBsaXN0U3R5bGU6IFwibm9uZVwiLFxuICBtYXJnaW46IDAsXG4gIHBhZGRpbmc6IDAsXG4gIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogZVxuICAgIH0pID0+ICFlLmRpc2FibGVQYWRkaW5nLFxuICAgIHN0eWxlOiB7XG4gICAgICBwYWRkaW5nVG9wOiA4LFxuICAgICAgcGFkZGluZ0JvdHRvbTogOFxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogZVxuICAgIH0pID0+IGUuc3ViaGVhZGVyLFxuICAgIHN0eWxlOiB7XG4gICAgICBwYWRkaW5nVG9wOiAwXG4gICAgfVxuICB9XVxufSksIHRpID0gLyogQF9fUFVSRV9fICovIEMuZm9yd2FyZFJlZihmdW5jdGlvbih0LCByKSB7XG4gIGNvbnN0IG4gPSBIZSh7XG4gICAgcHJvcHM6IHQsXG4gICAgbmFtZTogXCJNdWlMaXN0XCJcbiAgfSksIHtcbiAgICBjaGlsZHJlbjogbyxcbiAgICBjbGFzc05hbWU6IGksXG4gICAgY29tcG9uZW50OiBzID0gXCJ1bFwiLFxuICAgIGRlbnNlOiBjID0gITEsXG4gICAgZGlzYWJsZVBhZGRpbmc6IGwgPSAhMSxcbiAgICBzdWJoZWFkZXI6IHUsXG4gICAgLi4ucFxuICB9ID0gbiwgbSA9IEMudXNlTWVtbygoKSA9PiAoe1xuICAgIGRlbnNlOiBjXG4gIH0pLCBbY10pLCBnID0ge1xuICAgIC4uLm4sXG4gICAgY29tcG9uZW50OiBzLFxuICAgIGRlbnNlOiBjLFxuICAgIGRpc2FibGVQYWRkaW5nOiBsXG4gIH0sIHggPSBnbShnKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChvci5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBtLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3hzKHltLCB7XG4gICAgICBhczogcyxcbiAgICAgIGNsYXNzTmFtZTogc2UoeC5yb290LCBpKSxcbiAgICAgIHJlZjogcixcbiAgICAgIG93bmVyU3RhdGU6IGcsXG4gICAgICAuLi5wLFxuICAgICAgY2hpbGRyZW46IFt1LCBvXVxuICAgIH0pXG4gIH0pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHRpLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgICAgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogYS5lbGVtZW50VHlwZSxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgY29tcGFjdCB2ZXJ0aWNhbCBwYWRkaW5nIGRlc2lnbmVkIGZvciBrZXlib2FyZCBhbmQgbW91c2UgaW5wdXQgaXMgdXNlZCBmb3JcbiAgICogdGhlIGxpc3QgYW5kIGxpc3QgaXRlbXMuXG4gICAqIFRoZSBwcm9wIGlzIGF2YWlsYWJsZSB0byBkZXNjZW5kYW50IGNvbXBvbmVudHMgYXMgdGhlIGBkZW5zZWAgY29udGV4dC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRlbnNlOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHZlcnRpY2FsIHBhZGRpbmcgaXMgcmVtb3ZlZCBmcm9tIHRoZSBsaXN0LlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZVBhZGRpbmc6IGEuYm9vbCxcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBzdWJoZWFkZXIsIG5vcm1hbGx5IGBMaXN0U3ViaGVhZGVyYC5cbiAgICovXG4gIHN1YmhlYWRlcjogYS5ub2RlLFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSlcbn0pO1xuZnVuY3Rpb24gYm0oZSkge1xuICByZXR1cm4gVmUoXCJNdWlMaXN0SXRlbUJ1dHRvblwiLCBlKTtcbn1cbmNvbnN0IG1yID0gRmUoXCJNdWlMaXN0SXRlbUJ1dHRvblwiLCBbXCJyb290XCIsIFwiZm9jdXNWaXNpYmxlXCIsIFwiZGVuc2VcIiwgXCJhbGlnbkl0ZW1zRmxleFN0YXJ0XCIsIFwiZGlzYWJsZWRcIiwgXCJkaXZpZGVyXCIsIFwiZ3V0dGVyc1wiLCBcInNlbGVjdGVkXCJdKSwgdm0gPSAoZSwgdCkgPT4ge1xuICBjb25zdCB7XG4gICAgb3duZXJTdGF0ZTogclxuICB9ID0gZTtcbiAgcmV0dXJuIFt0LnJvb3QsIHIuZGVuc2UgJiYgdC5kZW5zZSwgci5hbGlnbkl0ZW1zID09PSBcImZsZXgtc3RhcnRcIiAmJiB0LmFsaWduSXRlbXNGbGV4U3RhcnQsIHIuZGl2aWRlciAmJiB0LmRpdmlkZXIsICFyLmRpc2FibGVHdXR0ZXJzICYmIHQuZ3V0dGVyc107XG59LCB4bSA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBhbGlnbkl0ZW1zOiB0LFxuICAgIGNsYXNzZXM6IHIsXG4gICAgZGVuc2U6IG4sXG4gICAgZGlzYWJsZWQ6IG8sXG4gICAgZGlzYWJsZUd1dHRlcnM6IGksXG4gICAgZGl2aWRlcjogcyxcbiAgICBzZWxlY3RlZDogY1xuICB9ID0gZSwgdSA9IEdlKHtcbiAgICByb290OiBbXCJyb290XCIsIG4gJiYgXCJkZW5zZVwiLCAhaSAmJiBcImd1dHRlcnNcIiwgcyAmJiBcImRpdmlkZXJcIiwgbyAmJiBcImRpc2FibGVkXCIsIHQgPT09IFwiZmxleC1zdGFydFwiICYmIFwiYWxpZ25JdGVtc0ZsZXhTdGFydFwiLCBjICYmIFwic2VsZWN0ZWRcIl1cbiAgfSwgYm0sIHIpO1xuICByZXR1cm4ge1xuICAgIC4uLnIsXG4gICAgLi4udVxuICB9O1xufSwgU20gPSBsZSgkciwge1xuICBzaG91bGRGb3J3YXJkUHJvcDogKGUpID0+IHlzKGUpIHx8IGUgPT09IFwiY2xhc3Nlc1wiLFxuICBuYW1lOiBcIk11aUxpc3RJdGVtQnV0dG9uXCIsXG4gIHNsb3Q6IFwiUm9vdFwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogdm1cbn0pKHFlKCh7XG4gIHRoZW1lOiBlXG59KSA9PiAoe1xuICBkaXNwbGF5OiBcImZsZXhcIixcbiAgZmxleEdyb3c6IDEsXG4gIGp1c3RpZnlDb250ZW50OiBcImZsZXgtc3RhcnRcIixcbiAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgdGV4dERlY29yYXRpb246IFwibm9uZVwiLFxuICBtaW5XaWR0aDogMCxcbiAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgdGV4dEFsaWduOiBcImxlZnRcIixcbiAgcGFkZGluZ1RvcDogOCxcbiAgcGFkZGluZ0JvdHRvbTogOCxcbiAgdHJhbnNpdGlvbjogZS50cmFuc2l0aW9ucy5jcmVhdGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIHtcbiAgICBkdXJhdGlvbjogZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVzdFxuICB9KSxcbiAgXCImOmhvdmVyXCI6IHtcbiAgICB0ZXh0RGVjb3JhdGlvbjogXCJub25lXCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGUuYWN0aW9uLmhvdmVyLFxuICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgXCJAbWVkaWEgKGhvdmVyOiBub25lKVwiOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgIH1cbiAgfSxcbiAgW2AmLiR7bXIuc2VsZWN0ZWR9YF06IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGUudmFycyA/IGByZ2JhKCR7ZS52YXJzLnBhbGV0dGUucHJpbWFyeS5tYWluQ2hhbm5lbH0gLyAke2UudmFycy5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHl9KWAgOiBEZShlLnBhbGV0dGUucHJpbWFyeS5tYWluLCBlLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkT3BhY2l0eSksXG4gICAgW2AmLiR7bXIuZm9jdXNWaXNpYmxlfWBdOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUudmFycyA/IGByZ2JhKCR7ZS52YXJzLnBhbGV0dGUucHJpbWFyeS5tYWluQ2hhbm5lbH0gLyBjYWxjKCR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkT3BhY2l0eX0gKyAke2UudmFycy5wYWxldHRlLmFjdGlvbi5mb2N1c09wYWNpdHl9KSlgIDogRGUoZS5wYWxldHRlLnByaW1hcnkubWFpbiwgZS5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHkgKyBlLnBhbGV0dGUuYWN0aW9uLmZvY3VzT3BhY2l0eSlcbiAgICB9XG4gIH0sXG4gIFtgJi4ke21yLnNlbGVjdGVkfTpob3ZlcmBdOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBlLnZhcnMgPyBgcmdiYSgke2UudmFycy5wYWxldHRlLnByaW1hcnkubWFpbkNoYW5uZWx9IC8gY2FsYygke2UudmFycy5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHl9ICsgJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5fSkpYCA6IERlKGUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sIGUucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRPcGFjaXR5ICsgZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpLFxuICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgXCJAbWVkaWEgKGhvdmVyOiBub25lKVwiOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUudmFycyA/IGByZ2JhKCR7ZS52YXJzLnBhbGV0dGUucHJpbWFyeS5tYWluQ2hhbm5lbH0gLyAke2UudmFycy5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHl9KWAgOiBEZShlLnBhbGV0dGUucHJpbWFyeS5tYWluLCBlLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkT3BhY2l0eSlcbiAgICB9XG4gIH0sXG4gIFtgJi4ke21yLmZvY3VzVmlzaWJsZX1gXToge1xuICAgIGJhY2tncm91bmRDb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLmFjdGlvbi5mb2N1c1xuICB9LFxuICBbYCYuJHttci5kaXNhYmxlZH1gXToge1xuICAgIG9wYWNpdHk6IChlLnZhcnMgfHwgZSkucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRPcGFjaXR5XG4gIH0sXG4gIHZhcmlhbnRzOiBbe1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+IHQuZGl2aWRlcixcbiAgICBzdHlsZToge1xuICAgICAgYm9yZGVyQm90dG9tOiBgMXB4IHNvbGlkICR7KGUudmFycyB8fCBlKS5wYWxldHRlLmRpdmlkZXJ9YCxcbiAgICAgIGJhY2tncm91bmRDbGlwOiBcInBhZGRpbmctYm94XCJcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0XCJcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnRcIlxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+ICF0LmRpc2FibGVHdXR0ZXJzLFxuICAgIHN0eWxlOiB7XG4gICAgICBwYWRkaW5nTGVmdDogMTYsXG4gICAgICBwYWRkaW5nUmlnaHQ6IDE2XG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiB0XG4gICAgfSkgPT4gdC5kZW5zZSxcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZ1RvcDogNCxcbiAgICAgIHBhZGRpbmdCb3R0b206IDRcbiAgICB9XG4gIH1dXG59KSkpLCByaSA9IC8qIEBfX1BVUkVfXyAqLyBDLmZvcndhcmRSZWYoZnVuY3Rpb24odCwgcikge1xuICBjb25zdCBuID0gSGUoe1xuICAgIHByb3BzOiB0LFxuICAgIG5hbWU6IFwiTXVpTGlzdEl0ZW1CdXR0b25cIlxuICB9KSwge1xuICAgIGFsaWduSXRlbXM6IG8gPSBcImNlbnRlclwiLFxuICAgIGF1dG9Gb2N1czogaSA9ICExLFxuICAgIGNvbXBvbmVudDogcyA9IFwiZGl2XCIsXG4gICAgY2hpbGRyZW46IGMsXG4gICAgZGVuc2U6IGwgPSAhMSxcbiAgICBkaXNhYmxlR3V0dGVyczogdSA9ICExLFxuICAgIGRpdmlkZXI6IHAgPSAhMSxcbiAgICBmb2N1c1Zpc2libGVDbGFzc05hbWU6IG0sXG4gICAgc2VsZWN0ZWQ6IGcgPSAhMSxcbiAgICBjbGFzc05hbWU6IHgsXG4gICAgLi4ueVxuICB9ID0gbiwgZiA9IEMudXNlQ29udGV4dChvciksIFMgPSBDLnVzZU1lbW8oKCkgPT4gKHtcbiAgICBkZW5zZTogbCB8fCBmLmRlbnNlIHx8ICExLFxuICAgIGFsaWduSXRlbXM6IG8sXG4gICAgZGlzYWJsZUd1dHRlcnM6IHVcbiAgfSksIFtvLCBmLmRlbnNlLCBsLCB1XSksIEUgPSBDLnVzZVJlZihudWxsKTtcbiAgRnQoKCkgPT4ge1xuICAgIGkgJiYgKEUuY3VycmVudCA/IEUuY3VycmVudC5mb2N1cygpIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoXCJNVUk6IFVuYWJsZSB0byBzZXQgZm9jdXMgdG8gYSBMaXN0SXRlbUJ1dHRvbiB3aG9zZSBjb21wb25lbnQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkLlwiKSk7XG4gIH0sIFtpXSk7XG4gIGNvbnN0IFAgPSB7XG4gICAgLi4ubixcbiAgICBhbGlnbkl0ZW1zOiBvLFxuICAgIGRlbnNlOiBTLmRlbnNlLFxuICAgIGRpc2FibGVHdXR0ZXJzOiB1LFxuICAgIGRpdmlkZXI6IHAsXG4gICAgc2VsZWN0ZWQ6IGdcbiAgfSwgVCA9IHhtKFApLCBiID0gYXQoRSwgcik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3gob3IuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUyxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KFNtLCB7XG4gICAgICByZWY6IGIsXG4gICAgICBocmVmOiB5LmhyZWYgfHwgeS50byxcbiAgICAgIGNvbXBvbmVudDogKHkuaHJlZiB8fCB5LnRvKSAmJiBzID09PSBcImRpdlwiID8gXCJidXR0b25cIiA6IHMsXG4gICAgICBmb2N1c1Zpc2libGVDbGFzc05hbWU6IHNlKFQuZm9jdXNWaXNpYmxlLCBtKSxcbiAgICAgIG93bmVyU3RhdGU6IFAsXG4gICAgICBjbGFzc05hbWU6IHNlKFQucm9vdCwgeCksXG4gICAgICAuLi55LFxuICAgICAgY2xhc3NlczogVCxcbiAgICAgIGNoaWxkcmVuOiBjXG4gICAgfSlcbiAgfSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAocmkucHJvcFR5cGVzID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiAgICBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4gICAgIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIGBhbGlnbi1pdGVtc2Agc3R5bGUgcHJvcGVydHkuXG4gICAqIEBkZWZhdWx0ICdjZW50ZXInXG4gICAqL1xuICBhbGlnbkl0ZW1zOiBhLm9uZU9mKFtcImNlbnRlclwiLCBcImZsZXgtc3RhcnRcIl0pLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGlzdCBpdGVtIGlzIGZvY3VzZWQgZHVyaW5nIHRoZSBmaXJzdCBtb3VudC5cbiAgICogRm9jdXMgd2lsbCBhbHNvIGJlIHRyaWdnZXJlZCBpZiB0aGUgdmFsdWUgY2hhbmdlcyBmcm9tIGZhbHNlIHRvIHRydWUuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhdXRvRm9jdXM6IGEuYm9vbCxcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQgaWYgYSBgTGlzdEl0ZW1TZWNvbmRhcnlBY3Rpb25gIGlzIHVzZWQgaXQgbXVzdFxuICAgKiBiZSB0aGUgbGFzdCBjaGlsZC5cbiAgICovXG4gIGNoaWxkcmVuOiBhLm5vZGUsXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjbGFzc2VzOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IGEuZWxlbWVudFR5cGUsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGNvbXBhY3QgdmVydGljYWwgcGFkZGluZyBkZXNpZ25lZCBmb3Iga2V5Ym9hcmQgYW5kIG1vdXNlIGlucHV0IGlzIHVzZWQuXG4gICAqIFRoZSBwcm9wIGRlZmF1bHRzIHRvIHRoZSB2YWx1ZSBpbmhlcml0ZWQgZnJvbSB0aGUgcGFyZW50IExpc3QgY29tcG9uZW50LlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGVuc2U6IGEuYm9vbCxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVkOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsZWZ0IGFuZCByaWdodCBwYWRkaW5nIGlzIHJlbW92ZWQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlR3V0dGVyczogYS5ib29sLFxuICAvKipcbiAgICogSWYgYHRydWVgLCBhIDFweCBsaWdodCBib3JkZXIgaXMgYWRkZWQgdG8gdGhlIGJvdHRvbSBvZiB0aGUgbGlzdCBpdGVtLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGl2aWRlcjogYS5ib29sLFxuICAvKipcbiAgICogVGhpcyBwcm9wIGNhbiBoZWxwIGlkZW50aWZ5IHdoaWNoIGVsZW1lbnQgaGFzIGtleWJvYXJkIGZvY3VzLlxuICAgKiBUaGUgY2xhc3MgbmFtZSB3aWxsIGJlIGFwcGxpZWQgd2hlbiB0aGUgZWxlbWVudCBnYWlucyB0aGUgZm9jdXMgdGhyb3VnaCBrZXlib2FyZCBpbnRlcmFjdGlvbi5cbiAgICogSXQncyBhIHBvbHlmaWxsIGZvciB0aGUgW0NTUyA6Zm9jdXMtdmlzaWJsZSBzZWxlY3Rvcl0oaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3NlbGVjdG9ycy00LyN0aGUtZm9jdXMtdmlzaWJsZS1wc2V1ZG8pLlxuICAgKiBUaGUgcmF0aW9uYWxlIGZvciB1c2luZyB0aGlzIGZlYXR1cmUgW2lzIGV4cGxhaW5lZCBoZXJlXShodHRwczovL2dpdGh1Yi5jb20vV0lDRy9mb2N1cy12aXNpYmxlL2Jsb2IvSEVBRC9leHBsYWluZXIubWQpLlxuICAgKiBBIFtwb2x5ZmlsbCBjYW4gYmUgdXNlZF0oaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvZm9jdXMtdmlzaWJsZSkgdG8gYXBwbHkgYSBgZm9jdXMtdmlzaWJsZWAgY2xhc3MgdG8gb3RoZXIgY29tcG9uZW50c1xuICAgKiBpZiBuZWVkZWQuXG4gICAqL1xuICBmb2N1c1Zpc2libGVDbGFzc05hbWU6IGEuc3RyaW5nLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgaHJlZjogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBVc2UgdG8gYXBwbHkgc2VsZWN0ZWQgc3R5bGluZy5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNlbGVjdGVkOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHByb3AgdGhhdCBhbGxvd3MgZGVmaW5pbmcgc3lzdGVtIG92ZXJyaWRlcyBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHN4OiBhLm9uZU9mVHlwZShbYS5hcnJheU9mKGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0LCBhLmJvb2xdKSksIGEuZnVuYywgYS5vYmplY3RdKVxufSk7XG5mdW5jdGlvbiBFbShlKSB7XG4gIHJldHVybiBWZShcIk11aUxpc3RJdGVtSWNvblwiLCBlKTtcbn1cbkZlKFwiTXVpTGlzdEl0ZW1JY29uXCIsIFtcInJvb3RcIiwgXCJhbGlnbkl0ZW1zRmxleFN0YXJ0XCJdKTtcbmNvbnN0IENtID0gKGUpID0+IHtcbiAgY29uc3Qge1xuICAgIGFsaWduSXRlbXM6IHQsXG4gICAgY2xhc3NlczogclxuICB9ID0gZTtcbiAgcmV0dXJuIEdlKHtcbiAgICByb290OiBbXCJyb290XCIsIHQgPT09IFwiZmxleC1zdGFydFwiICYmIFwiYWxpZ25JdGVtc0ZsZXhTdGFydFwiXVxuICB9LCBFbSwgcik7XG59LCBUbSA9IGxlKFwiZGl2XCIsIHtcbiAgbmFtZTogXCJNdWlMaXN0SXRlbUljb25cIixcbiAgc2xvdDogXCJSb290XCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyU3RhdGU6IHJcbiAgICB9ID0gZTtcbiAgICByZXR1cm4gW3Qucm9vdCwgci5hbGlnbkl0ZW1zID09PSBcImZsZXgtc3RhcnRcIiAmJiB0LmFsaWduSXRlbXNGbGV4U3RhcnRdO1xuICB9XG59KShxZSgoe1xuICB0aGVtZTogZVxufSkgPT4gKHtcbiAgbWluV2lkdGg6IDU2LFxuICBjb2xvcjogKGUudmFycyB8fCBlKS5wYWxldHRlLmFjdGlvbi5hY3RpdmUsXG4gIGZsZXhTaHJpbms6IDAsXG4gIGRpc3BsYXk6IFwiaW5saW5lLWZsZXhcIixcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6IHtcbiAgICAgIGFsaWduSXRlbXM6IFwiZmxleC1zdGFydFwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgbWFyZ2luVG9wOiA4XG4gICAgfVxuICB9XVxufSkpKSwgbmkgPSAvKiBAX19QVVJFX18gKi8gQy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsIHIpIHtcbiAgY29uc3QgbiA9IEhlKHtcbiAgICBwcm9wczogdCxcbiAgICBuYW1lOiBcIk11aUxpc3RJdGVtSWNvblwiXG4gIH0pLCB7XG4gICAgY2xhc3NOYW1lOiBvLFxuICAgIC4uLmlcbiAgfSA9IG4sIHMgPSBDLnVzZUNvbnRleHQob3IpLCBjID0ge1xuICAgIC4uLm4sXG4gICAgYWxpZ25JdGVtczogcy5hbGlnbkl0ZW1zXG4gIH0sIGwgPSBDbShjKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChUbSwge1xuICAgIGNsYXNzTmFtZTogc2UobC5yb290LCBvKSxcbiAgICBvd25lclN0YXRlOiBjLFxuICAgIHJlZjogcixcbiAgICAuLi5pXG4gIH0pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKG5pLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgICAgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LCBub3JtYWxseSBgSWNvbmAsIGBTdmdJY29uYCxcbiAgICogb3IgYSBgQG11aS9pY29ucy1tYXRlcmlhbGAgU1ZHIGljb24gZWxlbWVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBhLm5vZGUsXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjbGFzc2VzOiBhLm9iamVjdCxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogYS5zdHJpbmcsXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHByb3AgdGhhdCBhbGxvd3MgZGVmaW5pbmcgc3lzdGVtIG92ZXJyaWRlcyBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHN4OiBhLm9uZU9mVHlwZShbYS5hcnJheU9mKGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0LCBhLmJvb2xdKSksIGEuZnVuYywgYS5vYmplY3RdKVxufSk7XG5mdW5jdGlvbiB3bShlKSB7XG4gIHJldHVybiBWZShcIk11aUxpc3RJdGVtVGV4dFwiLCBlKTtcbn1cbmNvbnN0IGVuID0gRmUoXCJNdWlMaXN0SXRlbVRleHRcIiwgW1wicm9vdFwiLCBcIm11bHRpbGluZVwiLCBcImRlbnNlXCIsIFwiaW5zZXRcIiwgXCJwcmltYXJ5XCIsIFwic2Vjb25kYXJ5XCJdKSwgT20gPSAoZSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xhc3NlczogdCxcbiAgICBpbnNldDogcixcbiAgICBwcmltYXJ5OiBuLFxuICAgIHNlY29uZGFyeTogbyxcbiAgICBkZW5zZTogaVxuICB9ID0gZTtcbiAgcmV0dXJuIEdlKHtcbiAgICByb290OiBbXCJyb290XCIsIHIgJiYgXCJpbnNldFwiLCBpICYmIFwiZGVuc2VcIiwgbiAmJiBvICYmIFwibXVsdGlsaW5lXCJdLFxuICAgIHByaW1hcnk6IFtcInByaW1hcnlcIl0sXG4gICAgc2Vjb25kYXJ5OiBbXCJzZWNvbmRhcnlcIl1cbiAgfSwgd20sIHQpO1xufSwgUm0gPSBsZShcImRpdlwiLCB7XG4gIG5hbWU6IFwiTXVpTGlzdEl0ZW1UZXh0XCIsXG4gIHNsb3Q6IFwiUm9vdFwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKGUsIHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lclN0YXRlOiByXG4gICAgfSA9IGU7XG4gICAgcmV0dXJuIFt7XG4gICAgICBbYCYgLiR7ZW4ucHJpbWFyeX1gXTogdC5wcmltYXJ5XG4gICAgfSwge1xuICAgICAgW2AmIC4ke2VuLnNlY29uZGFyeX1gXTogdC5zZWNvbmRhcnlcbiAgICB9LCB0LnJvb3QsIHIuaW5zZXQgJiYgdC5pbnNldCwgci5wcmltYXJ5ICYmIHIuc2Vjb25kYXJ5ICYmIHQubXVsdGlsaW5lLCByLmRlbnNlICYmIHQuZGVuc2VdO1xuICB9XG59KSh7XG4gIGZsZXg6IFwiMSAxIGF1dG9cIixcbiAgbWluV2lkdGg6IDAsXG4gIG1hcmdpblRvcDogNCxcbiAgbWFyZ2luQm90dG9tOiA0LFxuICBbYC4ke3NhLnJvb3R9OndoZXJlKCYgLiR7ZW4ucHJpbWFyeX0pYF06IHtcbiAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgfSxcbiAgW2AuJHtzYS5yb290fTp3aGVyZSgmIC4ke2VuLnNlY29uZGFyeX0pYF06IHtcbiAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgfSxcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiBlXG4gICAgfSkgPT4gZS5wcmltYXJ5ICYmIGUuc2Vjb25kYXJ5LFxuICAgIHN0eWxlOiB7XG4gICAgICBtYXJnaW5Ub3A6IDYsXG4gICAgICBtYXJnaW5Cb3R0b206IDZcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IGVcbiAgICB9KSA9PiBlLmluc2V0LFxuICAgIHN0eWxlOiB7XG4gICAgICBwYWRkaW5nTGVmdDogNTZcbiAgICB9XG4gIH1dXG59KSwgb2kgPSAvKiBAX19QVVJFX18gKi8gQy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsIHIpIHtcbiAgY29uc3QgbiA9IEhlKHtcbiAgICBwcm9wczogdCxcbiAgICBuYW1lOiBcIk11aUxpc3RJdGVtVGV4dFwiXG4gIH0pLCB7XG4gICAgY2hpbGRyZW46IG8sXG4gICAgY2xhc3NOYW1lOiBpLFxuICAgIGRpc2FibGVUeXBvZ3JhcGh5OiBzID0gITEsXG4gICAgaW5zZXQ6IGMgPSAhMSxcbiAgICBwcmltYXJ5OiBsLFxuICAgIHByaW1hcnlUeXBvZ3JhcGh5UHJvcHM6IHUsXG4gICAgc2Vjb25kYXJ5OiBwLFxuICAgIHNlY29uZGFyeVR5cG9ncmFwaHlQcm9wczogbSxcbiAgICBzbG90czogZyA9IHt9LFxuICAgIHNsb3RQcm9wczogeCA9IHt9LFxuICAgIC4uLnlcbiAgfSA9IG4sIHtcbiAgICBkZW5zZTogZlxuICB9ID0gQy51c2VDb250ZXh0KG9yKTtcbiAgbGV0IFMgPSBsID8/IG8sIEUgPSBwO1xuICBjb25zdCBQID0ge1xuICAgIC4uLm4sXG4gICAgZGlzYWJsZVR5cG9ncmFwaHk6IHMsXG4gICAgaW5zZXQ6IGMsXG4gICAgcHJpbWFyeTogISFTLFxuICAgIHNlY29uZGFyeTogISFFLFxuICAgIGRlbnNlOiBmXG4gIH0sIFQgPSBPbShQKSwgYiA9IHtcbiAgICBzbG90czogZyxcbiAgICBzbG90UHJvcHM6IHtcbiAgICAgIHByaW1hcnk6IHUsXG4gICAgICBzZWNvbmRhcnk6IG0sXG4gICAgICAuLi54XG4gICAgfVxuICB9LCBbaCwgd10gPSBCdChcInByaW1hcnlcIiwge1xuICAgIGNsYXNzTmFtZTogVC5wcmltYXJ5LFxuICAgIGVsZW1lbnRUeXBlOiBidCxcbiAgICBleHRlcm5hbEZvcndhcmRlZFByb3BzOiBiLFxuICAgIG93bmVyU3RhdGU6IFBcbiAgfSksIFtrLCBMXSA9IEJ0KFwic2Vjb25kYXJ5XCIsIHtcbiAgICBjbGFzc05hbWU6IFQuc2Vjb25kYXJ5LFxuICAgIGVsZW1lbnRUeXBlOiBidCxcbiAgICBleHRlcm5hbEZvcndhcmRlZFByb3BzOiBiLFxuICAgIG93bmVyU3RhdGU6IFBcbiAgfSk7XG4gIHJldHVybiBTICE9IG51bGwgJiYgUy50eXBlICE9PSBidCAmJiAhcyAmJiAoUyA9IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChoLCB7XG4gICAgdmFyaWFudDogZiA/IFwiYm9keTJcIiA6IFwiYm9keTFcIixcbiAgICBjb21wb25lbnQ6IHcgIT0gbnVsbCAmJiB3LnZhcmlhbnQgPyB2b2lkIDAgOiBcInNwYW5cIixcbiAgICAuLi53LFxuICAgIGNoaWxkcmVuOiBTXG4gIH0pKSwgRSAhPSBudWxsICYmIEUudHlwZSAhPT0gYnQgJiYgIXMgJiYgKEUgPSAvKiBAX19QVVJFX18gKi8gTi5qc3goaywge1xuICAgIHZhcmlhbnQ6IFwiYm9keTJcIixcbiAgICBjb2xvcjogXCJ0ZXh0U2Vjb25kYXJ5XCIsXG4gICAgLi4uTCxcbiAgICBjaGlsZHJlbjogRVxuICB9KSksIC8qIEBfX1BVUkVfXyAqLyBOLmpzeHMoUm0sIHtcbiAgICBjbGFzc05hbWU6IHNlKFQucm9vdCwgaSksXG4gICAgb3duZXJTdGF0ZTogUCxcbiAgICByZWY6IHIsXG4gICAgLi4ueSxcbiAgICBjaGlsZHJlbjogW1MsIEVdXG4gIH0pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKG9pLnByb3BUeXBlcyA9IHtcbiAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFdhcm5pbmcg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIC8vIOKUgiBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMuIOKUglxuICAvLyDilIIgICAgVG8gdXBkYXRlIHRoZW0sIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIGBwbnBtIHByb3B0eXBlc2AuICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgdGhlIGBwcmltYXJ5YCBwcm9wLlxuICAgKi9cbiAgY2hpbGRyZW46IGEubm9kZSxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNoaWxkcmVuIHdvbid0IGJlIHdyYXBwZWQgYnkgYSBUeXBvZ3JhcGh5IGNvbXBvbmVudC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZnVsIHRvIHJlbmRlciBhbiBhbHRlcm5hdGl2ZSBUeXBvZ3JhcGh5IHZhcmlhbnQgYnkgd3JhcHBpbmdcbiAgICogdGhlIGBjaGlsZHJlbmAgKG9yIGBwcmltYXJ5YCkgdGV4dCwgYW5kIG9wdGlvbmFsIGBzZWNvbmRhcnlgIHRleHRcbiAgICogd2l0aCB0aGUgVHlwb2dyYXBoeSBjb21wb25lbnQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlVHlwb2dyYXBoeTogYS5ib29sLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY2hpbGRyZW4gYXJlIGluZGVudGVkLlxuICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIGlmIHRoZXJlIGlzIG5vIGxlZnQgYXZhdGFyIG9yIGxlZnQgaWNvbi5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGluc2V0OiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUaGUgbWFpbiBjb250ZW50IGVsZW1lbnQuXG4gICAqL1xuICBwcmltYXJ5OiBhLm5vZGUsXG4gIC8qKlxuICAgKiBUaGVzZSBwcm9wcyB3aWxsIGJlIGZvcndhcmRlZCB0byB0aGUgcHJpbWFyeSB0eXBvZ3JhcGh5IGNvbXBvbmVudFxuICAgKiAoYXMgbG9uZyBhcyBkaXNhYmxlVHlwb2dyYXBoeSBpcyBub3QgYHRydWVgKS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzbG90UHJvcHMucHJpbWFyeWAgaW5zdGVhZC4gVGhpcyBwcm9wIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4gU2VlIFtNaWdyYXRpbmcgZnJvbSBkZXByZWNhdGVkIEFQSXNdKC9tYXRlcmlhbC11aS9taWdyYXRpb24vbWlncmF0aW5nLWZyb20tZGVwcmVjYXRlZC1hcGlzLykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIHByaW1hcnlUeXBvZ3JhcGh5UHJvcHM6IGEub2JqZWN0LFxuICAvKipcbiAgICogVGhlIHNlY29uZGFyeSBjb250ZW50IGVsZW1lbnQuXG4gICAqL1xuICBzZWNvbmRhcnk6IGEubm9kZSxcbiAgLyoqXG4gICAqIFRoZXNlIHByb3BzIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHRoZSBzZWNvbmRhcnkgdHlwb2dyYXBoeSBjb21wb25lbnRcbiAgICogKGFzIGxvbmcgYXMgZGlzYWJsZVR5cG9ncmFwaHkgaXMgbm90IGB0cnVlYCkuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgc2xvdFByb3BzLnNlY29uZGFyeWAgaW5zdGVhZC4gVGhpcyBwcm9wIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4gU2VlIFtNaWdyYXRpbmcgZnJvbSBkZXByZWNhdGVkIEFQSXNdKC9tYXRlcmlhbC11aS9taWdyYXRpb24vbWlncmF0aW5nLWZyb20tZGVwcmVjYXRlZC1hcGlzLykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIHNlY29uZGFyeVR5cG9ncmFwaHlQcm9wczogYS5vYmplY3QsXG4gIC8qKlxuICAgKiBUaGUgcHJvcHMgdXNlZCBmb3IgZWFjaCBzbG90IGluc2lkZS5cbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIHNsb3RQcm9wczogYS5zaGFwZSh7XG4gICAgcHJpbWFyeTogYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3RdKSxcbiAgICBzZWNvbmRhcnk6IGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0XSlcbiAgfSksXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgc2xvdHM6IGEuc2hhcGUoe1xuICAgIHByaW1hcnk6IGEuZWxlbWVudFR5cGUsXG4gICAgc2Vjb25kYXJ5OiBhLmVsZW1lbnRUeXBlXG4gIH0pLFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogYS5vbmVPZlR5cGUoW2EuYXJyYXlPZihhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdCwgYS5ib29sXSkpLCBhLmZ1bmMsIGEub2JqZWN0XSlcbn0pO1xuZnVuY3Rpb24gJG0oZSkge1xuICByZXR1cm4gVmUoXCJNdWlUb29sdGlwXCIsIGUpO1xufVxuY29uc3QgTmUgPSBGZShcIk11aVRvb2x0aXBcIiwgW1wicG9wcGVyXCIsIFwicG9wcGVySW50ZXJhY3RpdmVcIiwgXCJwb3BwZXJBcnJvd1wiLCBcInBvcHBlckNsb3NlXCIsIFwidG9vbHRpcFwiLCBcInRvb2x0aXBBcnJvd1wiLCBcInRvdWNoXCIsIFwidG9vbHRpcFBsYWNlbWVudExlZnRcIiwgXCJ0b29sdGlwUGxhY2VtZW50UmlnaHRcIiwgXCJ0b29sdGlwUGxhY2VtZW50VG9wXCIsIFwidG9vbHRpcFBsYWNlbWVudEJvdHRvbVwiLCBcImFycm93XCJdKTtcbmZ1bmN0aW9uIFBtKGUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoZSAqIDFlNSkgLyAxZTU7XG59XG5jb25zdCBrbSA9IChlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjbGFzc2VzOiB0LFxuICAgIGRpc2FibGVJbnRlcmFjdGl2ZTogcixcbiAgICBhcnJvdzogbixcbiAgICB0b3VjaDogbyxcbiAgICBwbGFjZW1lbnQ6IGlcbiAgfSA9IGUsIHMgPSB7XG4gICAgcG9wcGVyOiBbXCJwb3BwZXJcIiwgIXIgJiYgXCJwb3BwZXJJbnRlcmFjdGl2ZVwiLCBuICYmIFwicG9wcGVyQXJyb3dcIl0sXG4gICAgdG9vbHRpcDogW1widG9vbHRpcFwiLCBuICYmIFwidG9vbHRpcEFycm93XCIsIG8gJiYgXCJ0b3VjaFwiLCBgdG9vbHRpcFBsYWNlbWVudCR7ZWUoaS5zcGxpdChcIi1cIilbMF0pfWBdLFxuICAgIGFycm93OiBbXCJhcnJvd1wiXVxuICB9O1xuICByZXR1cm4gR2UocywgJG0sIHQpO1xufSwgQW0gPSBsZShlaSwge1xuICBuYW1lOiBcIk11aVRvb2x0aXBcIixcbiAgc2xvdDogXCJQb3BwZXJcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJTdGF0ZTogclxuICAgIH0gPSBlO1xuICAgIHJldHVybiBbdC5wb3BwZXIsICFyLmRpc2FibGVJbnRlcmFjdGl2ZSAmJiB0LnBvcHBlckludGVyYWN0aXZlLCByLmFycm93ICYmIHQucG9wcGVyQXJyb3csICFyLm9wZW4gJiYgdC5wb3BwZXJDbG9zZV07XG4gIH1cbn0pKHFlKCh7XG4gIHRoZW1lOiBlXG59KSA9PiAoe1xuICB6SW5kZXg6IChlLnZhcnMgfHwgZSkuekluZGV4LnRvb2x0aXAsXG4gIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICB2YXJpYW50czogW3tcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiAhdC5kaXNhYmxlSW50ZXJhY3RpdmUsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvcGVuOiB0XG4gICAgfSkgPT4gIXQsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiB0XG4gICAgfSkgPT4gdC5hcnJvdyxcbiAgICBzdHlsZToge1xuICAgICAgW2AmW2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJib3R0b21cIl0gLiR7TmUuYXJyb3d9YF06IHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBtYXJnaW5Ub3A6IFwiLTAuNzFlbVwiLFxuICAgICAgICBcIiY6OmJlZm9yZVwiOiB7XG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIjAgMTAwJVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbYCZbZGF0YS1wb3BwZXItcGxhY2VtZW50Kj1cInRvcFwiXSAuJHtOZS5hcnJvd31gXToge1xuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogXCItMC43MWVtXCIsXG4gICAgICAgIFwiJjo6YmVmb3JlXCI6IHtcbiAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiMTAwJSAwXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtgJltkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwicmlnaHRcIl0gLiR7TmUuYXJyb3d9YF06IHtcbiAgICAgICAgaGVpZ2h0OiBcIjFlbVwiLFxuICAgICAgICB3aWR0aDogXCIwLjcxZW1cIixcbiAgICAgICAgXCImOjpiZWZvcmVcIjoge1xuICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogXCIxMDAlIDEwMCVcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2AmW2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJsZWZ0XCJdIC4ke05lLmFycm93fWBdOiB7XG4gICAgICAgIGhlaWdodDogXCIxZW1cIixcbiAgICAgICAgd2lkdGg6IFwiMC43MWVtXCIsXG4gICAgICAgIFwiJjo6YmVmb3JlXCI6IHtcbiAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiMCAwXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+IHQuYXJyb3cgJiYgIXQuaXNSdGwsXG4gICAgc3R5bGU6IHtcbiAgICAgIFtgJltkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwicmlnaHRcIl0gLiR7TmUuYXJyb3d9YF06IHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgbWFyZ2luTGVmdDogXCItMC43MWVtXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiB0LmFycm93ICYmICEhdC5pc1J0bCxcbiAgICBzdHlsZToge1xuICAgICAgW2AmW2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJyaWdodFwiXSAuJHtOZS5hcnJvd31gXToge1xuICAgICAgICByaWdodDogMCxcbiAgICAgICAgbWFyZ2luUmlnaHQ6IFwiLTAuNzFlbVwiXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiB0XG4gICAgfSkgPT4gdC5hcnJvdyAmJiAhdC5pc1J0bCxcbiAgICBzdHlsZToge1xuICAgICAgW2AmW2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJsZWZ0XCJdIC4ke05lLmFycm93fWBdOiB7XG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBtYXJnaW5SaWdodDogXCItMC43MWVtXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiB0LmFycm93ICYmICEhdC5pc1J0bCxcbiAgICBzdHlsZToge1xuICAgICAgW2AmW2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJsZWZ0XCJdIC4ke05lLmFycm93fWBdOiB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiLTAuNzFlbVwiXG4gICAgICB9XG4gICAgfVxuICB9XVxufSkpKSwgTm0gPSBsZShcImRpdlwiLCB7XG4gIG5hbWU6IFwiTXVpVG9vbHRpcFwiLFxuICBzbG90OiBcIlRvb2x0aXBcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChlLCB0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJTdGF0ZTogclxuICAgIH0gPSBlO1xuICAgIHJldHVybiBbdC50b29sdGlwLCByLnRvdWNoICYmIHQudG91Y2gsIHIuYXJyb3cgJiYgdC50b29sdGlwQXJyb3csIHRbYHRvb2x0aXBQbGFjZW1lbnQke2VlKHIucGxhY2VtZW50LnNwbGl0KFwiLVwiKVswXSl9YF1dO1xuICB9XG59KShxZSgoe1xuICB0aGVtZTogZVxufSkgPT4gKHtcbiAgYmFja2dyb3VuZENvbG9yOiBlLnZhcnMgPyBlLnZhcnMucGFsZXR0ZS5Ub29sdGlwLmJnIDogRGUoZS5wYWxldHRlLmdyZXlbNzAwXSwgMC45MiksXG4gIGJvcmRlclJhZGl1czogKGUudmFycyB8fCBlKS5zaGFwZS5ib3JkZXJSYWRpdXMsXG4gIGNvbG9yOiAoZS52YXJzIHx8IGUpLnBhbGV0dGUuY29tbW9uLndoaXRlLFxuICBmb250RmFtaWx5OiBlLnR5cG9ncmFwaHkuZm9udEZhbWlseSxcbiAgcGFkZGluZzogXCI0cHggOHB4XCIsXG4gIGZvbnRTaXplOiBlLnR5cG9ncmFwaHkucHhUb1JlbSgxMSksXG4gIG1heFdpZHRoOiAzMDAsXG4gIG1hcmdpbjogMixcbiAgd29yZFdyYXA6IFwiYnJlYWstd29yZFwiLFxuICBmb250V2VpZ2h0OiBlLnR5cG9ncmFwaHkuZm9udFdlaWdodE1lZGl1bSxcbiAgW2AuJHtOZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJsZWZ0XCJdICZgXToge1xuICAgIHRyYW5zZm9ybU9yaWdpbjogXCJyaWdodCBjZW50ZXJcIlxuICB9LFxuICBbYC4ke05lLnBvcHBlcn1bZGF0YS1wb3BwZXItcGxhY2VtZW50Kj1cInJpZ2h0XCJdICZgXToge1xuICAgIHRyYW5zZm9ybU9yaWdpbjogXCJsZWZ0IGNlbnRlclwiXG4gIH0sXG4gIFtgLiR7TmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwidG9wXCJdICZgXToge1xuICAgIHRyYW5zZm9ybU9yaWdpbjogXCJjZW50ZXIgYm90dG9tXCIsXG4gICAgbWFyZ2luQm90dG9tOiBcIjE0cHhcIlxuICB9LFxuICBbYC4ke05lLnBvcHBlcn1bZGF0YS1wb3BwZXItcGxhY2VtZW50Kj1cImJvdHRvbVwiXSAmYF06IHtcbiAgICB0cmFuc2Zvcm1PcmlnaW46IFwiY2VudGVyIHRvcFwiLFxuICAgIG1hcmdpblRvcDogXCIxNHB4XCJcbiAgfSxcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiB0XG4gICAgfSkgPT4gdC5hcnJvdyxcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgIG1hcmdpbjogMFxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+IHQudG91Y2gsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmc6IFwiOHB4IDE2cHhcIixcbiAgICAgIGZvbnRTaXplOiBlLnR5cG9ncmFwaHkucHhUb1JlbSgxNCksXG4gICAgICBsaW5lSGVpZ2h0OiBgJHtQbSgxNiAvIDE0KX1lbWAsXG4gICAgICBmb250V2VpZ2h0OiBlLnR5cG9ncmFwaHkuZm9udFdlaWdodFJlZ3VsYXJcbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiAhdC5pc1J0bCxcbiAgICBzdHlsZToge1xuICAgICAgW2AuJHtOZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJsZWZ0XCJdICZgXToge1xuICAgICAgICBtYXJnaW5SaWdodDogXCIxNHB4XCJcbiAgICAgIH0sXG4gICAgICBbYC4ke05lLnBvcHBlcn1bZGF0YS1wb3BwZXItcGxhY2VtZW50Kj1cInJpZ2h0XCJdICZgXToge1xuICAgICAgICBtYXJnaW5MZWZ0OiBcIjE0cHhcIlxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+ICF0LmlzUnRsICYmIHQudG91Y2gsXG4gICAgc3R5bGU6IHtcbiAgICAgIFtgLiR7TmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwibGVmdFwiXSAmYF06IHtcbiAgICAgICAgbWFyZ2luUmlnaHQ6IFwiMjRweFwiXG4gICAgICB9LFxuICAgICAgW2AuJHtOZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJyaWdodFwiXSAmYF06IHtcbiAgICAgICAgbWFyZ2luTGVmdDogXCIyNHB4XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiAhIXQuaXNSdGwsXG4gICAgc3R5bGU6IHtcbiAgICAgIFtgLiR7TmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwibGVmdFwiXSAmYF06IHtcbiAgICAgICAgbWFyZ2luTGVmdDogXCIxNHB4XCJcbiAgICAgIH0sXG4gICAgICBbYC4ke05lLnBvcHBlcn1bZGF0YS1wb3BwZXItcGxhY2VtZW50Kj1cInJpZ2h0XCJdICZgXToge1xuICAgICAgICBtYXJnaW5SaWdodDogXCIxNHB4XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBwcm9wczogKHtcbiAgICAgIG93bmVyU3RhdGU6IHRcbiAgICB9KSA9PiAhIXQuaXNSdGwgJiYgdC50b3VjaCxcbiAgICBzdHlsZToge1xuICAgICAgW2AuJHtOZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJsZWZ0XCJdICZgXToge1xuICAgICAgICBtYXJnaW5MZWZ0OiBcIjI0cHhcIlxuICAgICAgfSxcbiAgICAgIFtgLiR7TmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwicmlnaHRcIl0gJmBdOiB7XG4gICAgICAgIG1hcmdpblJpZ2h0OiBcIjI0cHhcIlxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIHByb3BzOiAoe1xuICAgICAgb3duZXJTdGF0ZTogdFxuICAgIH0pID0+IHQudG91Y2gsXG4gICAgc3R5bGU6IHtcbiAgICAgIFtgLiR7TmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPVwidG9wXCJdICZgXToge1xuICAgICAgICBtYXJnaW5Cb3R0b206IFwiMjRweFwiXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgcHJvcHM6ICh7XG4gICAgICBvd25lclN0YXRlOiB0XG4gICAgfSkgPT4gdC50b3VjaCxcbiAgICBzdHlsZToge1xuICAgICAgW2AuJHtOZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9XCJib3R0b21cIl0gJmBdOiB7XG4gICAgICAgIG1hcmdpblRvcDogXCIyNHB4XCJcbiAgICAgIH1cbiAgICB9XG4gIH1dXG59KSkpLCBNbSA9IGxlKFwic3BhblwiLCB7XG4gIG5hbWU6IFwiTXVpVG9vbHRpcFwiLFxuICBzbG90OiBcIkFycm93XCIsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAoZSwgdCkgPT4gdC5hcnJvd1xufSkocWUoKHtcbiAgdGhlbWU6IGVcbn0pID0+ICh7XG4gIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICB3aWR0aDogXCIxZW1cIixcbiAgaGVpZ2h0OiBcIjAuNzFlbVwiLFxuICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICBjb2xvcjogZS52YXJzID8gZS52YXJzLnBhbGV0dGUuVG9vbHRpcC5iZyA6IERlKGUucGFsZXR0ZS5ncmV5WzcwMF0sIDAuOSksXG4gIFwiJjo6YmVmb3JlXCI6IHtcbiAgICBjb250ZW50OiAnXCJcIicsXG4gICAgbWFyZ2luOiBcImF1dG9cIixcbiAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHRyYW5zZm9ybTogXCJyb3RhdGUoNDVkZWcpXCJcbiAgfVxufSkpKTtcbmxldCB0biA9ICExO1xuY29uc3QgdmEgPSBuZXcgVm4oKTtcbmxldCBociA9IHtcbiAgeDogMCxcbiAgeTogMFxufTtcbmZ1bmN0aW9uIHJuKGUsIHQpIHtcbiAgcmV0dXJuIChyLCAuLi5uKSA9PiB7XG4gICAgdCAmJiB0KHIsIC4uLm4pLCBlKHIsIC4uLm4pO1xuICB9O1xufVxuY29uc3QganMgPSAvKiBAX19QVVJFX18gKi8gQy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsIHIpIHtcbiAgY29uc3QgbiA9IEhlKHtcbiAgICBwcm9wczogdCxcbiAgICBuYW1lOiBcIk11aVRvb2x0aXBcIlxuICB9KSwge1xuICAgIGFycm93OiBvID0gITEsXG4gICAgY2hpbGRyZW46IGksXG4gICAgY2xhc3NlczogcyxcbiAgICBjb21wb25lbnRzOiBjID0ge30sXG4gICAgY29tcG9uZW50c1Byb3BzOiBsID0ge30sXG4gICAgZGVzY3JpYmVDaGlsZDogdSA9ICExLFxuICAgIGRpc2FibGVGb2N1c0xpc3RlbmVyOiBwID0gITEsXG4gICAgZGlzYWJsZUhvdmVyTGlzdGVuZXI6IG0gPSAhMSxcbiAgICBkaXNhYmxlSW50ZXJhY3RpdmU6IGcgPSAhMSxcbiAgICBkaXNhYmxlVG91Y2hMaXN0ZW5lcjogeCA9ICExLFxuICAgIGVudGVyRGVsYXk6IHkgPSAxMDAsXG4gICAgZW50ZXJOZXh0RGVsYXk6IGYgPSAwLFxuICAgIGVudGVyVG91Y2hEZWxheTogUyA9IDcwMCxcbiAgICBmb2xsb3dDdXJzb3I6IEUgPSAhMSxcbiAgICBpZDogUCxcbiAgICBsZWF2ZURlbGF5OiBUID0gMCxcbiAgICBsZWF2ZVRvdWNoRGVsYXk6IGIgPSAxNTAwLFxuICAgIG9uQ2xvc2U6IGgsXG4gICAgb25PcGVuOiB3LFxuICAgIG9wZW46IGssXG4gICAgcGxhY2VtZW50OiBMID0gXCJib3R0b21cIixcbiAgICBQb3BwZXJDb21wb25lbnQ6IEIsXG4gICAgUG9wcGVyUHJvcHM6IGQgPSB7fSxcbiAgICBzbG90UHJvcHM6IEEgPSB7fSxcbiAgICBzbG90czogRCA9IHt9LFxuICAgIHRpdGxlOiBqLFxuICAgIFRyYW5zaXRpb25Db21wb25lbnQ6IFcsXG4gICAgVHJhbnNpdGlvblByb3BzOiB6LFxuICAgIC4uLlVcbiAgfSA9IG4sIFYgPSAvKiBAX19QVVJFX18gKi8gQy5pc1ZhbGlkRWxlbWVudChpKSA/IGkgOiAvKiBAX19QVVJFX18gKi8gTi5qc3goXCJzcGFuXCIsIHtcbiAgICBjaGlsZHJlbjogaVxuICB9KSwgdGUgPSBMcigpLCBGID0gaXMoKSwgW1IsIEldID0gQy51c2VTdGF0ZSgpLCBbSiwgUV0gPSBDLnVzZVN0YXRlKG51bGwpLCBIID0gQy51c2VSZWYoITEpLCBYID0gZyB8fCBFLCBfID0gRHQoKSwgcSA9IER0KCksIEcgPSBEdCgpLCByZSA9IER0KCksIFtaLCBhZV0gPSBWdSh7XG4gICAgY29udHJvbGxlZDogayxcbiAgICBkZWZhdWx0OiAhMSxcbiAgICBuYW1lOiBcIlRvb2x0aXBcIixcbiAgICBzdGF0ZTogXCJvcGVuXCJcbiAgfSk7XG4gIGxldCBPID0gWjtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnQ6IG5lXG4gICAgfSA9IEMudXNlUmVmKGsgIT09IHZvaWQgMCk7XG4gICAgQy51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgUiAmJiBSLmRpc2FibGVkICYmICFuZSAmJiBqICE9PSBcIlwiICYmIFIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJ1dHRvblwiICYmIGNvbnNvbGUud2FybihbXCJNVUk6IFlvdSBhcmUgcHJvdmlkaW5nIGEgZGlzYWJsZWQgYGJ1dHRvbmAgY2hpbGQgdG8gdGhlIFRvb2x0aXAgY29tcG9uZW50LlwiLCBcIkEgZGlzYWJsZWQgZWxlbWVudCBkb2VzIG5vdCBmaXJlIGV2ZW50cy5cIiwgXCJUb29sdGlwIG5lZWRzIHRvIGxpc3RlbiB0byB0aGUgY2hpbGQgZWxlbWVudCdzIGV2ZW50cyB0byBkaXNwbGF5IHRoZSB0aXRsZS5cIiwgXCJcIiwgXCJBZGQgYSBzaW1wbGUgd3JhcHBlciBlbGVtZW50LCBzdWNoIGFzIGEgYHNwYW5gLlwiXS5qb2luKGBcbmApKTtcbiAgICB9LCBbaiwgUiwgbmVdKTtcbiAgfVxuICBjb25zdCB5ZSA9IFFhKFApLCBFZSA9IEMudXNlUmVmKCksIE1lID0gUXQoKCkgPT4ge1xuICAgIEVlLmN1cnJlbnQgIT09IHZvaWQgMCAmJiAoZG9jdW1lbnQuYm9keS5zdHlsZS5XZWJraXRVc2VyU2VsZWN0ID0gRWUuY3VycmVudCwgRWUuY3VycmVudCA9IHZvaWQgMCksIHJlLmNsZWFyKCk7XG4gIH0pO1xuICBDLnVzZUVmZmVjdCgoKSA9PiBNZSwgW01lXSk7XG4gIGNvbnN0IFFlID0gKG5lKSA9PiB7XG4gICAgdmEuY2xlYXIoKSwgdG4gPSAhMCwgYWUoITApLCB3ICYmICFPICYmIHcobmUpO1xuICB9LCB2ZSA9IFF0KFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVhY3QuU3ludGhldGljRXZlbnQgfCBFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICAobmUpID0+IHtcbiAgICAgIHZhLnN0YXJ0KDgwMCArIFQsICgpID0+IHtcbiAgICAgICAgdG4gPSAhMTtcbiAgICAgIH0pLCBhZSghMSksIGggJiYgTyAmJiBoKG5lKSwgXy5zdGFydCh0ZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVzdCwgKCkgPT4ge1xuICAgICAgICBILmN1cnJlbnQgPSAhMTtcbiAgICAgIH0pO1xuICAgIH1cbiAgKSwgUGUgPSAobmUpID0+IHtcbiAgICBILmN1cnJlbnQgJiYgbmUudHlwZSAhPT0gXCJ0b3VjaHN0YXJ0XCIgfHwgKFIgJiYgUi5yZW1vdmVBdHRyaWJ1dGUoXCJ0aXRsZVwiKSwgcS5jbGVhcigpLCBHLmNsZWFyKCksIHkgfHwgdG4gJiYgZiA/IHEuc3RhcnQodG4gPyBmIDogeSwgKCkgPT4ge1xuICAgICAgUWUobmUpO1xuICAgIH0pIDogUWUobmUpKTtcbiAgfSwgemUgPSAobmUpID0+IHtcbiAgICBxLmNsZWFyKCksIEcuc3RhcnQoVCwgKCkgPT4ge1xuICAgICAgdmUobmUpO1xuICAgIH0pO1xuICB9LCBbLCBMZV0gPSBDLnVzZVN0YXRlKCExKSwgdiA9IChuZSkgPT4ge1xuICAgIGhuKG5lLnRhcmdldCkgfHwgKExlKCExKSwgemUobmUpKTtcbiAgfSwgTSA9IChuZSkgPT4ge1xuICAgIFIgfHwgSShuZS5jdXJyZW50VGFyZ2V0KSwgaG4obmUudGFyZ2V0KSAmJiAoTGUoITApLCBQZShuZSkpO1xuICB9LCBZID0gKG5lKSA9PiB7XG4gICAgSC5jdXJyZW50ID0gITA7XG4gICAgY29uc3QgZnQgPSBWLnByb3BzO1xuICAgIGZ0Lm9uVG91Y2hTdGFydCAmJiBmdC5vblRvdWNoU3RhcnQobmUpO1xuICB9LCBvZSA9IChuZSkgPT4ge1xuICAgIFkobmUpLCBHLmNsZWFyKCksIF8uY2xlYXIoKSwgTWUoKSwgRWUuY3VycmVudCA9IGRvY3VtZW50LmJvZHkuc3R5bGUuV2Via2l0VXNlclNlbGVjdCwgZG9jdW1lbnQuYm9keS5zdHlsZS5XZWJraXRVc2VyU2VsZWN0ID0gXCJub25lXCIsIHJlLnN0YXJ0KFMsICgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuV2Via2l0VXNlclNlbGVjdCA9IEVlLmN1cnJlbnQsIFBlKG5lKTtcbiAgICB9KTtcbiAgfSwgUmUgPSAobmUpID0+IHtcbiAgICBWLnByb3BzLm9uVG91Y2hFbmQgJiYgVi5wcm9wcy5vblRvdWNoRW5kKG5lKSwgTWUoKSwgRy5zdGFydChiLCAoKSA9PiB7XG4gICAgICB2ZShuZSk7XG4gICAgfSk7XG4gIH07XG4gIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIU8pXG4gICAgICByZXR1cm47XG4gICAgZnVuY3Rpb24gbmUoZnQpIHtcbiAgICAgIGZ0LmtleSA9PT0gXCJFc2NhcGVcIiAmJiB2ZShmdCk7XG4gICAgfVxuICAgIHJldHVybiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBuZSksICgpID0+IHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG5lKTtcbiAgICB9O1xuICB9LCBbdmUsIE9dKTtcbiAgY29uc3QgdWUgPSBhdChCbyhWKSwgSSwgcik7XG4gICFqICYmIGogIT09IDAgJiYgKE8gPSAhMSk7XG4gIGNvbnN0IEsgPSBDLnVzZVJlZigpLCBiZSA9IChuZSkgPT4ge1xuICAgIGNvbnN0IGZ0ID0gVi5wcm9wcztcbiAgICBmdC5vbk1vdXNlTW92ZSAmJiBmdC5vbk1vdXNlTW92ZShuZSksIGhyID0ge1xuICAgICAgeDogbmUuY2xpZW50WCxcbiAgICAgIHk6IG5lLmNsaWVudFlcbiAgICB9LCBLLmN1cnJlbnQgJiYgSy5jdXJyZW50LnVwZGF0ZSgpO1xuICB9LCB3ZSA9IHt9LCBPZSA9IHR5cGVvZiBqID09IFwic3RyaW5nXCI7XG4gIHUgPyAod2UudGl0bGUgPSAhTyAmJiBPZSAmJiAhbSA/IGogOiBudWxsLCB3ZVtcImFyaWEtZGVzY3JpYmVkYnlcIl0gPSBPID8geWUgOiBudWxsKSA6ICh3ZVtcImFyaWEtbGFiZWxcIl0gPSBPZSA/IGogOiBudWxsLCB3ZVtcImFyaWEtbGFiZWxsZWRieVwiXSA9IE8gJiYgIU9lID8geWUgOiBudWxsKTtcbiAgY29uc3QgY2UgPSB7XG4gICAgLi4ud2UsXG4gICAgLi4uVSxcbiAgICAuLi5WLnByb3BzLFxuICAgIGNsYXNzTmFtZTogc2UoVS5jbGFzc05hbWUsIFYucHJvcHMuY2xhc3NOYW1lKSxcbiAgICBvblRvdWNoU3RhcnQ6IFksXG4gICAgcmVmOiB1ZSxcbiAgICAuLi5FID8ge1xuICAgICAgb25Nb3VzZU1vdmU6IGJlXG4gICAgfSA6IHt9XG4gIH07XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoY2VbXCJkYXRhLW11aS1pbnRlcm5hbC1jbG9uZS1lbGVtZW50XCJdID0gITAsIEMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBSICYmICFSLmdldEF0dHJpYnV0ZShcImRhdGEtbXVpLWludGVybmFsLWNsb25lLWVsZW1lbnRcIikgJiYgY29uc29sZS5lcnJvcihbXCJNVUk6IFRoZSBgY2hpbGRyZW5gIGNvbXBvbmVudCBvZiB0aGUgVG9vbHRpcCBpcyBub3QgZm9yd2FyZGluZyBpdHMgcHJvcHMgY29ycmVjdGx5LlwiLCBcIlBsZWFzZSBtYWtlIHN1cmUgdGhhdCBwcm9wcyBhcmUgc3ByZWFkIG9uIHRoZSBzYW1lIGVsZW1lbnQgdGhhdCB0aGUgcmVmIGlzIGFwcGxpZWQgdG8uXCJdLmpvaW4oYFxuYCkpO1xuICB9LCBbUl0pKTtcbiAgY29uc3QgSWUgPSB7fTtcbiAgeCB8fCAoY2Uub25Ub3VjaFN0YXJ0ID0gb2UsIGNlLm9uVG91Y2hFbmQgPSBSZSksIG0gfHwgKGNlLm9uTW91c2VPdmVyID0gcm4oUGUsIGNlLm9uTW91c2VPdmVyKSwgY2Uub25Nb3VzZUxlYXZlID0gcm4oemUsIGNlLm9uTW91c2VMZWF2ZSksIFggfHwgKEllLm9uTW91c2VPdmVyID0gUGUsIEllLm9uTW91c2VMZWF2ZSA9IHplKSksIHAgfHwgKGNlLm9uRm9jdXMgPSBybihNLCBjZS5vbkZvY3VzKSwgY2Uub25CbHVyID0gcm4odiwgY2Uub25CbHVyKSwgWCB8fCAoSWUub25Gb2N1cyA9IE0sIEllLm9uQmx1ciA9IHYpKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFYucHJvcHMudGl0bGUgJiYgY29uc29sZS5lcnJvcihbXCJNVUk6IFlvdSBoYXZlIHByb3ZpZGVkIGEgYHRpdGxlYCBwcm9wIHRvIHRoZSBjaGlsZCBvZiA8VG9vbHRpcCAvPi5cIiwgYFJlbW92ZSB0aGlzIHRpdGxlIHByb3AgXFxgJHtWLnByb3BzLnRpdGxlfVxcYCBvciB0aGUgVG9vbHRpcCBjb21wb25lbnQuYF0uam9pbihgXG5gKSk7XG4gIGNvbnN0IFdlID0ge1xuICAgIC4uLm4sXG4gICAgaXNSdGw6IEYsXG4gICAgYXJyb3c6IG8sXG4gICAgZGlzYWJsZUludGVyYWN0aXZlOiBYLFxuICAgIHBsYWNlbWVudDogTCxcbiAgICBQb3BwZXJDb21wb25lbnRQcm9wOiBCLFxuICAgIHRvdWNoOiBILmN1cnJlbnRcbiAgfSwgVWUgPSB0eXBlb2YgQS5wb3BwZXIgPT0gXCJmdW5jdGlvblwiID8gQS5wb3BwZXIoV2UpIDogQS5wb3BwZXIsIHV0ID0gQy51c2VNZW1vKCgpID0+IHtcbiAgICB2YXIgZnQsIGlpO1xuICAgIGxldCBuZSA9IFt7XG4gICAgICBuYW1lOiBcImFycm93XCIsXG4gICAgICBlbmFibGVkOiAhIUosXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGVsZW1lbnQ6IEosXG4gICAgICAgIHBhZGRpbmc6IDRcbiAgICAgIH1cbiAgICB9XTtcbiAgICByZXR1cm4gKGZ0ID0gZC5wb3BwZXJPcHRpb25zKSAhPSBudWxsICYmIGZ0Lm1vZGlmaWVycyAmJiAobmUgPSBuZS5jb25jYXQoZC5wb3BwZXJPcHRpb25zLm1vZGlmaWVycykpLCAoaWkgPSBVZSA9PSBudWxsID8gdm9pZCAwIDogVWUucG9wcGVyT3B0aW9ucykgIT0gbnVsbCAmJiBpaS5tb2RpZmllcnMgJiYgKG5lID0gbmUuY29uY2F0KFVlLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzKSksIHtcbiAgICAgIC4uLmQucG9wcGVyT3B0aW9ucyxcbiAgICAgIC4uLlVlID09IG51bGwgPyB2b2lkIDAgOiBVZS5wb3BwZXJPcHRpb25zLFxuICAgICAgbW9kaWZpZXJzOiBuZVxuICAgIH07XG4gIH0sIFtKLCBkLnBvcHBlck9wdGlvbnMsIFVlID09IG51bGwgPyB2b2lkIDAgOiBVZS5wb3BwZXJPcHRpb25zXSksIFVuID0ga20oV2UpLCBCcyA9IHR5cGVvZiBBLnRyYW5zaXRpb24gPT0gXCJmdW5jdGlvblwiID8gQS50cmFuc2l0aW9uKFdlKSA6IEEudHJhbnNpdGlvbiwgenIgPSB7XG4gICAgc2xvdHM6IHtcbiAgICAgIHBvcHBlcjogYy5Qb3BwZXIsXG4gICAgICB0cmFuc2l0aW9uOiBjLlRyYW5zaXRpb24gPz8gVyxcbiAgICAgIHRvb2x0aXA6IGMuVG9vbHRpcCxcbiAgICAgIGFycm93OiBjLkFycm93LFxuICAgICAgLi4uRFxuICAgIH0sXG4gICAgc2xvdFByb3BzOiB7XG4gICAgICBhcnJvdzogQS5hcnJvdyA/PyBsLmFycm93LFxuICAgICAgcG9wcGVyOiB7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIC4uLlVlID8/IGwucG9wcGVyXG4gICAgICB9LFxuICAgICAgLy8gcmVzb2x2ZWRQb3BwZXJQcm9wcyBjYW4gYmUgc3ByZWFkIGJlY2F1c2UgaXQncyBhbHJlYWR5IGFuIG9iamVjdFxuICAgICAgdG9vbHRpcDogQS50b29sdGlwID8/IGwudG9vbHRpcCxcbiAgICAgIHRyYW5zaXRpb246IHtcbiAgICAgICAgLi4ueixcbiAgICAgICAgLi4uQnMgPz8gbC50cmFuc2l0aW9uXG4gICAgICB9XG4gICAgfVxuICB9LCBbVnMsIEZzXSA9IEJ0KFwicG9wcGVyXCIsIHtcbiAgICBlbGVtZW50VHlwZTogQW0sXG4gICAgZXh0ZXJuYWxGb3J3YXJkZWRQcm9wczogenIsXG4gICAgb3duZXJTdGF0ZTogV2UsXG4gICAgY2xhc3NOYW1lOiBzZShVbi5wb3BwZXIsIGQgPT0gbnVsbCA/IHZvaWQgMCA6IGQuY2xhc3NOYW1lKVxuICB9KSwgW3pzLCBXc10gPSBCdChcInRyYW5zaXRpb25cIiwge1xuICAgIGVsZW1lbnRUeXBlOiBPbixcbiAgICBleHRlcm5hbEZvcndhcmRlZFByb3BzOiB6cixcbiAgICBvd25lclN0YXRlOiBXZVxuICB9KSwgW1VzLCBZc10gPSBCdChcInRvb2x0aXBcIiwge1xuICAgIGVsZW1lbnRUeXBlOiBObSxcbiAgICBjbGFzc05hbWU6IFVuLnRvb2x0aXAsXG4gICAgZXh0ZXJuYWxGb3J3YXJkZWRQcm9wczogenIsXG4gICAgb3duZXJTdGF0ZTogV2VcbiAgfSksIFtIcywgcXNdID0gQnQoXCJhcnJvd1wiLCB7XG4gICAgZWxlbWVudFR5cGU6IE1tLFxuICAgIGNsYXNzTmFtZTogVW4uYXJyb3csXG4gICAgZXh0ZXJuYWxGb3J3YXJkZWRQcm9wczogenIsXG4gICAgb3duZXJTdGF0ZTogV2UsXG4gICAgcmVmOiBRXG4gIH0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4cyhDLkZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gQy5jbG9uZUVsZW1lbnQoViwgY2UpLCAvKiBAX19QVVJFX18gKi8gTi5qc3goVnMsIHtcbiAgICAgIGFzOiBCID8/IGVpLFxuICAgICAgcGxhY2VtZW50OiBMLFxuICAgICAgYW5jaG9yRWw6IEUgPyB7XG4gICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogKCkgPT4gKHtcbiAgICAgICAgICB0b3A6IGhyLnksXG4gICAgICAgICAgbGVmdDogaHIueCxcbiAgICAgICAgICByaWdodDogaHIueCxcbiAgICAgICAgICBib3R0b206IGhyLnksXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0pXG4gICAgICB9IDogUixcbiAgICAgIHBvcHBlclJlZjogSyxcbiAgICAgIG9wZW46IFIgPyBPIDogITEsXG4gICAgICBpZDogeWUsXG4gICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgIC4uLkllLFxuICAgICAgLi4uRnMsXG4gICAgICBwb3BwZXJPcHRpb25zOiB1dCxcbiAgICAgIGNoaWxkcmVuOiAoe1xuICAgICAgICBUcmFuc2l0aW9uUHJvcHM6IG5lXG4gICAgICB9KSA9PiAvKiBAX19QVVJFX18gKi8gTi5qc3goenMsIHtcbiAgICAgICAgdGltZW91dDogdGUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlcixcbiAgICAgICAgLi4ubmUsXG4gICAgICAgIC4uLldzLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4cyhVcywge1xuICAgICAgICAgIC4uLllzLFxuICAgICAgICAgIGNoaWxkcmVuOiBbaiwgbyA/IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChIcywge1xuICAgICAgICAgICAgLi4ucXNcbiAgICAgICAgICB9KSA6IG51bGxdXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXVxuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChqcy5wcm9wVHlwZXMgPSB7XG4gIC8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBXYXJuaW5nIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zLiDilIJcbiAgLy8g4pSCICAgIFRvIHVwZGF0ZSB0aGVtLCBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBgcG5wbSBwcm9wdHlwZXNgLiAgICAg4pSCXG4gIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAvKipcbiAgICogSWYgYHRydWVgLCBhZGRzIGFuIGFycm93IHRvIHRoZSB0b29sdGlwLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYXJyb3c6IGEuYm9vbCxcbiAgLyoqXG4gICAqIFRvb2x0aXAgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogam8uaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IGEub2JqZWN0LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBhLnN0cmluZyxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnRzIHVzZWQgZm9yIGVhY2ggc2xvdCBpbnNpZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHVzZSB0aGUgYHNsb3RzYCBwcm9wIGluc3RlYWQuIFRoaXMgcHJvcCB3aWxsIGJlIHJlbW92ZWQgaW4gdjcuIFNlZSBbTWlncmF0aW5nIGZyb20gZGVwcmVjYXRlZCBBUElzXShodHRwczovL211aS5jb20vbWF0ZXJpYWwtdWkvbWlncmF0aW9uL21pZ3JhdGluZy1mcm9tLWRlcHJlY2F0ZWQtYXBpcy8pIGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBjb21wb25lbnRzOiBhLnNoYXBlKHtcbiAgICBBcnJvdzogYS5lbGVtZW50VHlwZSxcbiAgICBQb3BwZXI6IGEuZWxlbWVudFR5cGUsXG4gICAgVG9vbHRpcDogYS5lbGVtZW50VHlwZSxcbiAgICBUcmFuc2l0aW9uOiBhLmVsZW1lbnRUeXBlXG4gIH0pLFxuICAvKipcbiAgICogVGhlIGV4dHJhIHByb3BzIGZvciB0aGUgc2xvdCBjb21wb25lbnRzLlxuICAgKiBZb3UgY2FuIG92ZXJyaWRlIHRoZSBleGlzdGluZyBwcm9wcyBvciBhZGQgbmV3IG9uZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHVzZSB0aGUgYHNsb3RQcm9wc2AgcHJvcCBpbnN0ZWFkLiBUaGlzIHByb3Agd2lsbCBiZSByZW1vdmVkIGluIHY3LiBTZWUgW01pZ3JhdGluZyBmcm9tIGRlcHJlY2F0ZWQgQVBJc10oaHR0cHM6Ly9tdWkuY29tL21hdGVyaWFsLXVpL21pZ3JhdGlvbi9taWdyYXRpbmctZnJvbS1kZXByZWNhdGVkLWFwaXMvKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgY29tcG9uZW50c1Byb3BzOiBhLnNoYXBlKHtcbiAgICBhcnJvdzogYS5vYmplY3QsXG4gICAgcG9wcGVyOiBhLm9iamVjdCxcbiAgICB0b29sdGlwOiBhLm9iamVjdCxcbiAgICB0cmFuc2l0aW9uOiBhLm9iamVjdFxuICB9KSxcbiAgLyoqXG4gICAqIFNldCB0byBgdHJ1ZWAgaWYgdGhlIGB0aXRsZWAgYWN0cyBhcyBhbiBhY2Nlc3NpYmxlIGRlc2NyaXB0aW9uLlxuICAgKiBCeSBkZWZhdWx0IHRoZSBgdGl0bGVgIGFjdHMgYXMgYW4gYWNjZXNzaWJsZSBsYWJlbCBmb3IgdGhlIGNoaWxkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGVzY3JpYmVDaGlsZDogYS5ib29sLFxuICAvKipcbiAgICogRG8gbm90IHJlc3BvbmQgdG8gZm9jdXMtdmlzaWJsZSBldmVudHMuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlRm9jdXNMaXN0ZW5lcjogYS5ib29sLFxuICAvKipcbiAgICogRG8gbm90IHJlc3BvbmQgdG8gaG92ZXIgZXZlbnRzLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZUhvdmVyTGlzdGVuZXI6IGEuYm9vbCxcbiAgLyoqXG4gICAqIE1ha2VzIGEgdG9vbHRpcCBub3QgaW50ZXJhY3RpdmUsIGkuZS4gaXQgd2lsbCBjbG9zZSB3aGVuIHRoZSB1c2VyXG4gICAqIGhvdmVycyBvdmVyIHRoZSB0b29sdGlwIGJlZm9yZSB0aGUgYGxlYXZlRGVsYXlgIGlzIGV4cGlyZWQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlSW50ZXJhY3RpdmU6IGEuYm9vbCxcbiAgLyoqXG4gICAqIERvIG5vdCByZXNwb25kIHRvIGxvbmcgcHJlc3MgdG91Y2ggZXZlbnRzLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZVRvdWNoTGlzdGVuZXI6IGEuYm9vbCxcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHNob3dpbmcgdGhlIHRvb2x0aXAuXG4gICAqIFRoaXMgcHJvcCB3b24ndCBpbXBhY3QgdGhlIGVudGVyIHRvdWNoIGRlbGF5IChgZW50ZXJUb3VjaERlbGF5YCkuXG4gICAqIEBkZWZhdWx0IDEwMFxuICAgKi9cbiAgZW50ZXJEZWxheTogYS5udW1iZXIsXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBzaG93aW5nIHRoZSB0b29sdGlwIHdoZW4gb25lIHdhcyBhbHJlYWR5IHJlY2VudGx5IG9wZW5lZC5cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZW50ZXJOZXh0RGVsYXk6IGEubnVtYmVyLFxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYSB1c2VyIG11c3QgdG91Y2ggdGhlIGVsZW1lbnQgYmVmb3JlIHNob3dpbmcgdGhlIHRvb2x0aXAuXG4gICAqIEBkZWZhdWx0IDcwMFxuICAgKi9cbiAgZW50ZXJUb3VjaERlbGF5OiBhLm51bWJlcixcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHRvb2x0aXAgZm9sbG93IHRoZSBjdXJzb3Igb3ZlciB0aGUgd3JhcHBlZCBlbGVtZW50LlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZm9sbG93Q3Vyc29yOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUaGlzIHByb3AgaXMgdXNlZCB0byBoZWxwIGltcGxlbWVudCB0aGUgYWNjZXNzaWJpbGl0eSBsb2dpYy5cbiAgICogSWYgeW91IGRvbid0IHByb3ZpZGUgdGhpcyBwcm9wLiBJdCBmYWxscyBiYWNrIHRvIGEgcmFuZG9tbHkgZ2VuZXJhdGVkIGlkLlxuICAgKi9cbiAgaWQ6IGEuc3RyaW5nLFxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgaGlkaW5nIHRoZSB0b29sdGlwLlxuICAgKiBUaGlzIHByb3Agd29uJ3QgaW1wYWN0IHRoZSBsZWF2ZSB0b3VjaCBkZWxheSAoYGxlYXZlVG91Y2hEZWxheWApLlxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBsZWF2ZURlbGF5OiBhLm51bWJlcixcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFmdGVyIHRoZSB1c2VyIHN0b3BzIHRvdWNoaW5nIGFuIGVsZW1lbnQgYmVmb3JlIGhpZGluZyB0aGUgdG9vbHRpcC5cbiAgICogQGRlZmF1bHQgMTUwMFxuICAgKi9cbiAgbGVhdmVUb3VjaERlbGF5OiBhLm51bWJlcixcbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCByZXF1ZXN0cyB0byBiZSBjbG9zZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3QuU3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgb25DbG9zZTogYS5mdW5jLFxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IHJlcXVlc3RzIHRvIGJlIG9wZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3QuU3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgb25PcGVuOiBhLmZ1bmMsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgaXMgc2hvd24uXG4gICAqL1xuICBvcGVuOiBhLmJvb2wsXG4gIC8qKlxuICAgKiBUb29sdGlwIHBsYWNlbWVudC5cbiAgICogQGRlZmF1bHQgJ2JvdHRvbSdcbiAgICovXG4gIHBsYWNlbWVudDogYS5vbmVPZihbXCJib3R0b20tZW5kXCIsIFwiYm90dG9tLXN0YXJ0XCIsIFwiYm90dG9tXCIsIFwibGVmdC1lbmRcIiwgXCJsZWZ0LXN0YXJ0XCIsIFwibGVmdFwiLCBcInJpZ2h0LWVuZFwiLCBcInJpZ2h0LXN0YXJ0XCIsIFwicmlnaHRcIiwgXCJ0b3AtZW5kXCIsIFwidG9wLXN0YXJ0XCIsIFwidG9wXCJdKSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHBvcHBlci5cbiAgICogQGRlcHJlY2F0ZWQgdXNlIHRoZSBgc2xvdHMucG9wcGVyYCBwcm9wIGluc3RlYWQuIFRoaXMgcHJvcCB3aWxsIGJlIHJlbW92ZWQgaW4gdjcuIFNlZSBbTWlncmF0aW5nIGZyb20gZGVwcmVjYXRlZCBBUElzXShodHRwczovL211aS5jb20vbWF0ZXJpYWwtdWkvbWlncmF0aW9uL21pZ3JhdGluZy1mcm9tLWRlcHJlY2F0ZWQtYXBpcy8pIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBQb3BwZXJDb21wb25lbnQ6IGEuZWxlbWVudFR5cGUsXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYFBvcHBlcmBdKGh0dHBzOi8vbXVpLmNvbS9tYXRlcmlhbC11aS9hcGkvcG9wcGVyLykgZWxlbWVudC5cbiAgICogQGRlcHJlY2F0ZWQgdXNlIHRoZSBgc2xvdFByb3BzLnBvcHBlcmAgcHJvcCBpbnN0ZWFkLiBUaGlzIHByb3Agd2lsbCBiZSByZW1vdmVkIGluIHY3LiBTZWUgW01pZ3JhdGluZyBmcm9tIGRlcHJlY2F0ZWQgQVBJc10oaHR0cHM6Ly9tdWkuY29tL21hdGVyaWFsLXVpL21pZ3JhdGlvbi9taWdyYXRpbmctZnJvbS1kZXByZWNhdGVkLWFwaXMvKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgUG9wcGVyUHJvcHM6IGEub2JqZWN0LFxuICAvKipcbiAgICogVGhlIHByb3BzIHVzZWQgZm9yIGVhY2ggc2xvdCBpbnNpZGUuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBzbG90UHJvcHM6IGEuc2hhcGUoe1xuICAgIGFycm93OiBhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdF0pLFxuICAgIHBvcHBlcjogYS5vbmVPZlR5cGUoW2EuZnVuYywgYS5vYmplY3RdKSxcbiAgICB0b29sdGlwOiBhLm9uZU9mVHlwZShbYS5mdW5jLCBhLm9iamVjdF0pLFxuICAgIHRyYW5zaXRpb246IGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0XSlcbiAgfSksXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgc2xvdHM6IGEuc2hhcGUoe1xuICAgIGFycm93OiBhLmVsZW1lbnRUeXBlLFxuICAgIHBvcHBlcjogYS5lbGVtZW50VHlwZSxcbiAgICB0b29sdGlwOiBhLmVsZW1lbnRUeXBlLFxuICAgIHRyYW5zaXRpb246IGEuZWxlbWVudFR5cGVcbiAgfSksXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHByb3AgdGhhdCBhbGxvd3MgZGVmaW5pbmcgc3lzdGVtIG92ZXJyaWRlcyBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHN4OiBhLm9uZU9mVHlwZShbYS5hcnJheU9mKGEub25lT2ZUeXBlKFthLmZ1bmMsIGEub2JqZWN0LCBhLmJvb2xdKSksIGEuZnVuYywgYS5vYmplY3RdKSxcbiAgLyoqXG4gICAqIFRvb2x0aXAgdGl0bGUuIFplcm8tbGVuZ3RoIHRpdGxlcyBzdHJpbmcsIHVuZGVmaW5lZCwgbnVsbCBhbmQgZmFsc2UgYXJlIG5ldmVyIGRpc3BsYXllZC5cbiAgICovXG4gIHRpdGxlOiBhLm5vZGUsXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSB0cmFuc2l0aW9uLlxuICAgKiBbRm9sbG93IHRoaXMgZ3VpZGVdKGh0dHBzOi8vbXVpLmNvbS9tYXRlcmlhbC11aS90cmFuc2l0aW9ucy8jdHJhbnNpdGlvbmNvbXBvbmVudC1wcm9wKSB0byBsZWFybiBtb3JlIGFib3V0IHRoZSByZXF1aXJlbWVudHMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgdGhlIGBzbG90cy50cmFuc2l0aW9uYCBwcm9wIGluc3RlYWQuIFRoaXMgcHJvcCB3aWxsIGJlIHJlbW92ZWQgaW4gdjcuIFNlZSBbTWlncmF0aW5nIGZyb20gZGVwcmVjYXRlZCBBUElzXShodHRwczovL211aS5jb20vbWF0ZXJpYWwtdWkvbWlncmF0aW9uL21pZ3JhdGluZy1mcm9tLWRlcHJlY2F0ZWQtYXBpcy8pIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBUcmFuc2l0aW9uQ29tcG9uZW50OiBhLmVsZW1lbnRUeXBlLFxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgdHJhbnNpdGlvbiBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgZWxlbWVudCBpcyBiYXNlZCBvbiB0aGlzIFtgVHJhbnNpdGlvbmBdKGh0dHBzOi8vcmVhY3Rjb21tdW5pdHkub3JnL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvdHJhbnNpdGlvbi8pIGNvbXBvbmVudC5cbiAgICogQGRlcHJlY2F0ZWQgdXNlIHRoZSBgc2xvdFByb3BzLnRyYW5zaXRpb25gIHByb3AgaW5zdGVhZC4gVGhpcyBwcm9wIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4gU2VlIFtNaWdyYXRpbmcgZnJvbSBkZXByZWNhdGVkIEFQSXNdKGh0dHBzOi8vbXVpLmNvbS9tYXRlcmlhbC11aS9taWdyYXRpb24vbWlncmF0aW5nLWZyb20tZGVwcmVjYXRlZC1hcGlzLykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIFRyYW5zaXRpb25Qcm9wczogYS5vYmplY3Rcbn0pO1xuY29uc3QgSW0gPSBzcigvKiBAX19QVVJFX18gKi8gTi5qc3goXCJwYXRoXCIsIHtcbiAgZDogXCJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMm0wIDE4Yy00LjQxIDAtOC0zLjU5LTgtOHMzLjU5LTggOC04IDggMy41OSA4IDgtMy41OSA4LTggOG0wLTEyLjVjLTIuNDkgMC00LjUgMi4wMS00LjUgNC41czIuMDEgNC41IDQuNSA0LjUgNC41LTIuMDEgNC41LTQuNS0yLjAxLTQuNS00LjUtNC41bTAgNS41Yy0uNTUgMC0xLS40NS0xLTFzLjQ1LTEgMS0xIDEgLjQ1IDEgMS0uNDUgMS0xIDFcIlxufSksIFwiQWxidW1PdXRsaW5lZFwiKSwgX20gPSAoe1xuICB1c2VyTmFtZTogZSA9IFwiXCIsXG4gIGRlc2lnbmF0aW9uOiB0ID0gXCJcIixcbiAgdXNlcmltZzogciA9IFwiXCIsXG4gIGlzQ29sbGFwc2U6IG4gPSAhMSxcbiAgb25Mb2dvdXQ6IG9cbn0pID0+IHtcbiAgY29uc3QgaSA9IExyKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goZHQsIHsgY2hpbGRyZW46IG4gPyBcIlwiIDogLyogQF9fUFVSRV9fICovIE4uanN4cyhcbiAgICBkdCxcbiAgICB7XG4gICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICBnYXA6IDIsXG4gICAgICBzeDoge1xuICAgICAgICBtOiAzLFxuICAgICAgICBwOiAyLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiOHB4XCIsXG4gICAgICAgIGJnY29sb3I6IGkucGFsZXR0ZS5zZWNvbmRhcnkubWFpbiArIDIwXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIE4uanN4KF9zLCB7IGFsdDogXCJSZW15IFNoYXJwXCIsIHNyYzogciB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIE4uanN4cyhkdCwgeyBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChidCwgeyB2YXJpYW50OiBcImg2XCIsIGNoaWxkcmVuOiBlIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChidCwgeyB2YXJpYW50OiBcImNhcHRpb25cIiwgY2hpbGRyZW46IHQgfSlcbiAgICAgICAgXSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIE4uanN4KGR0LCB7IHN4OiB7IG1sOiBcImF1dG9cIiB9LCBvbkNsaWNrOiBvLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KGpzLCB7IHRpdGxlOiBcIkxvZ291dFwiLCBwbGFjZW1lbnQ6IFwidG9wXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goQ3MsIHsgY29sb3I6IFwicHJpbWFyeVwiLCBcImFyaWEtbGFiZWxcIjogXCJsb2dvdXRcIiwgc2l6ZTogXCJzbWFsbFwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KEltLCB7fSkgfSkgfSkgfSlcbiAgICAgIF1cbiAgICB9XG4gICkgfSk7XG59LCBGciA9IEMuY3JlYXRlQ29udGV4dCh7XG4gIHdpZHRoOiBcIjI3MHB4XCIsXG4gIGNvbGxhcHNld2lkdGg6IFwiODBweFwiLFxuICB0ZXh0Q29sb3I6IFwiIzhEOTM5RFwiLFxuICBpc0NvbGxhcHNlOiAhMSxcbiAgdGhlbWVDb2xvcjogXCIjNWQ4N2ZmXCJcbn0pO1xubGV0IGptID0gKCkgPT4ge1xuICBhbGVydChcIkxvZ291dCBTdWNjZXNzZnVsbHlcIik7XG59O1xuY29uc3QgVW0gPSAoe1xuICBjaGlsZHJlbjogZSxcbiAgd2lkdGg6IHQgPSBcIjI2MHB4XCIsXG4gIGNvbGxhcHNld2lkdGg6IHIgPSBcIjgwcHhcIixcbiAgdGV4dENvbG9yOiBuID0gXCIjMmIyYjJiXCIsXG4gIGlzQ29sbGFwc2U6IG8gPSAhMSxcbiAgdGhlbWVDb2xvcjogaSA9IFwiIzVkODdmZlwiLFxuICB0aGVtZVNlY29uZGFyeUNvbG9yOiBzID0gXCIjNDliZWZmXCIsXG4gIG1vZGU6IGMgPSBcImxpZ2h0XCIsXG4gIGRpcmVjdGlvbjogbCA9IFwibHRyXCIsXG4gIHVzZXJOYW1lOiB1ID0gXCJNYXRoZXdcIixcbiAgZGVzaWduYXRpb246IHAgPSBcIkRlc2lnbmVyXCIsXG4gIHNob3dQcm9maWxlOiBtID0gITAsXG4gIHVzZXJpbWc6IGcgPSBcImh0dHBzOi8vYm9vdHN0cmFwZGVtb3MuYWRtaW5tYXJ0LmNvbS9tb2Rlcm5pemUvZGlzdC9hc3NldHMvaW1hZ2VzL3Byb2ZpbGUvdXNlci0xLmpwZ1wiLFxuICBvbkxvZ291dDogeCA9IGptXG59KSA9PiB7XG4gIGNvbnN0IFt5LCBmXSA9IEMudXNlU3RhdGUoITEpLCBTID0gbyAmJiAheSA/IHIgOiB0LCBFID0gRm4oe1xuICAgIGRpcmVjdGlvbjogbCxcbiAgICBwYWxldHRlOiB7XG4gICAgICBtb2RlOiBjLFxuICAgICAgcHJpbWFyeToge1xuICAgICAgICBtYWluOiBpXG4gICAgICB9LFxuICAgICAgc2Vjb25kYXJ5OiB7XG4gICAgICAgIG1haW46IHMsXG4gICAgICAgIGNvbnRyYXN0VGV4dDogXCIjZmZmXCJcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYyA9PT0gXCJkYXJrXCIgJiYgKG4gPSBcInJnYmEoMjU1LDI1NSwyNTUsIDAuOSlcIiksIC8qIEBfX1BVUkVfXyAqLyBOLmpzeCh6ZiwgeyB0aGVtZTogRSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChcbiAgICBkdCxcbiAgICB7XG4gICAgICBkaXI6IGwsXG4gICAgICBzeDoge1xuICAgICAgICB3aWR0aDogUyxcbiAgICAgICAgZmxleFNocmluazogMCxcbiAgICAgICAgZm9udEZhbWlseTogXCJpbmhlcml0XCIsXG4gICAgICAgIGNvbG9yOiBuXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeHMoZHQsIHsgc3g6IHsgd2lkdGg6IFMgfSwgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIE4uanN4KFxuICAgICAgICAgIEZyLlByb3ZpZGVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlOiB7IHRleHRDb2xvcjogbiwgaXNDb2xsYXBzZTogbywgd2lkdGg6IHQsIGNvbGxhcHNld2lkdGg6IHIsIHRoZW1lQ29sb3I6IGkgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBlXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBtID8gLyogQF9fUFVSRV9fICovIE4uanN4KFxuICAgICAgICAgIF9tLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHVzZXJOYW1lOiB1LFxuICAgICAgICAgICAgZGVzaWduYXRpb246IHAsXG4gICAgICAgICAgICB1c2VyaW1nOiBnLFxuICAgICAgICAgICAgaXNDb2xsYXBzZTogbyxcbiAgICAgICAgICAgIG9uTG9nb3V0OiB4XG4gICAgICAgICAgfVxuICAgICAgICApIDogbnVsbFxuICAgICAgXSB9KVxuICAgIH1cbiAgKSB9KTtcbn0sIFltID0gKHsgY2hpbGRyZW46IGUsIHN1YkhlYWRpbmc6IHQgPSBcIm1lbnVcIiB9KSA9PiB7XG4gIGNvbnN0IHIgPSBDLnVzZUNvbnRleHQoRnIpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIE4uanN4KGR0LCB7IHN4OiB7IHB4OiByLmlzQ29sbGFwc2UgPyAyIDogMywgcHQ6IDIgfSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChcbiAgICB0aSxcbiAgICB7XG4gICAgICBjb21wb25lbnQ6IFwibmF2XCIsXG4gICAgICBzdWJoZWFkZXI6IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChcbiAgICAgICAgd24sXG4gICAgICAgIHtcbiAgICAgICAgICBjb21wb25lbnQ6IFwiZGl2XCIsXG4gICAgICAgICAgc3g6IHtcbiAgICAgICAgICAgIHBhZGRpbmdZOiBcIjNweFwiLFxuICAgICAgICAgICAgY29sb3I6IHIudGV4dENvbG9yLFxuICAgICAgICAgICAgcGFkZGluZ1g6IFwiMHB4XCIsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiBcIjIwcHhcIixcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICAgICAgICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogci5pc0NvbGxhcHNlID8gXCIuLi5cIiA6IHRcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIGNoaWxkcmVuOiBlXG4gICAgfVxuICApIH0pO1xufSwgRG0gPSBzcigvKiBAX19QVVJFX18gKi8gTi5qc3goXCJwYXRoXCIsIHtcbiAgZDogXCJtMTIgOC02IDYgMS40MSAxLjQxTDEyIDEwLjgzbDQuNTkgNC41OEwxOCAxNHpcIlxufSksIFwiRXhwYW5kTGVzc1wiKSwgTG0gPSBzcigvKiBAX19QVVJFX18gKi8gTi5qc3goXCJwYXRoXCIsIHtcbiAgZDogXCJNMTYuNTkgOC41OSAxMiAxMy4xNyA3LjQxIDguNTkgNiAxMGw2IDYgNi02elwiXG59KSwgXCJFeHBhbmRNb3JlXCIpLCBEcyA9IHNyKC8qIEBfX1BVUkVfXyAqLyBOLmpzeChcInBhdGhcIiwge1xuICBkOiBcIk0xMiAyQzYuNDcgMiAyIDYuNDcgMiAxMnM0LjQ3IDEwIDEwIDEwIDEwLTQuNDcgMTAtMTBTMTcuNTMgMiAxMiAybTAgMThjLTQuNDIgMC04LTMuNTgtOC04czMuNTgtOCA4LTggOCAzLjU4IDggOC0zLjU4IDgtOCA4XCJcbn0pLCBcIkNpcmNsZU91dGxpbmVkXCIpLCBIbSA9ICh7XG4gIGNoaWxkcmVuOiBlLFxuICB0aXRsZTogdCA9IFwiXCIsXG4gIGljb246IHIsXG4gIGJvcmRlclJhZGl1czogbiA9IFwiOHB4XCIsXG4gIHRleHRGb250U2l6ZTogbyA9IFwiMTRweFwiLFxuICBkaXNhYmxlZDogaSA9ICExXG59KSA9PiB7XG4gIGNvbnN0IHMgPSBDLnVzZUNvbnRleHQoRnIpLCBbYywgbF0gPSBDLnVzZVN0YXRlKCExKSwgdSA9ICgpID0+IHtcbiAgICBsKCFjKTtcbiAgfSwgcCA9IGxlKHJpKSgoKSA9PiAoe1xuICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gICAgbWFyZ2luQm90dG9tOiBcIjJweFwiLFxuICAgIHBhZGRpbmc6IFwiMTBweCAxMnB4XCIsXG4gICAgYm9yZGVyUmFkaXVzOiBuLFxuICAgIGNvbG9yOiBjID8gXCIjZmZmXCIgOiBzLnRleHRDb2xvcixcbiAgICBjdXJzb3I6IGkgPyBcImRlZmF1bHRcIiA6IFwicG9pbnRlclwiLFxuICAgIG9wYWNpdHk6IGkgPyBcIjAuNlwiIDogXCIxXCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBjID8gcy50aGVtZUNvbG9yIDogXCJcIixcbiAgICBcIi5NdWlMaXN0SXRlbUljb24tcm9vdFwiOiB7XG4gICAgICBjb2xvcjogYyA/IFwiI2ZmZlwiIDogcy50ZXh0Q29sb3JcbiAgICB9LFxuICAgIFwiJjpob3ZlclwiOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGMgPyBzLnRoZW1lQ29sb3IgOiBzLnRoZW1lQ29sb3IgKyAyMCxcbiAgICAgIGNvbG9yOiBjID8gXCIjZmZmXCIgOiBzLnRoZW1lQ29sb3IsXG4gICAgICBcIi5NdWlMaXN0SXRlbUljb24tcm9vdFwiOiB7XG4gICAgICAgIGNvbG9yOiBjID8gXCIjZmZmXCIgOiBzLnRoZW1lQ29sb3JcbiAgICAgIH1cbiAgICB9XG4gIH0pKSwgbSA9IGxlKG5pKSgoKSA9PiAoe1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGdhcDogXCIxMHB4XCIsXG4gICAgbWFyZ2luQm90dG9tOiBcIjBweFwiLFxuICAgIHBhZGRpbmc6IFwiMHB4XCIsXG4gICAgbWluV2lkdGg6IFwiMzBweFwiLFxuICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgY29sb3I6IFwiaW5oZXJpdFwiXG4gIH0pKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeHMoZHQsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gTi5qc3hzKHAsIHsgb25DbGljazogdSwgc3g6IHsgZGlzcGxheTogXCJmbGV4XCIsIGdhcDogXCIxNXB4XCIgfSwgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChtLCB7IHN0eWxlOiB7IG1pbldpZHRoOiBcIjBweFwiIH0sIGNoaWxkcmVuOiByIHx8IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChEcywge30pIH0pLFxuICAgICAgIXMuaXNDb2xsYXBzZSAmJiAvKiBAX19QVVJFX18gKi8gTi5qc3hzKE4uRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIE4uanN4KG9pLCB7IHN4OiB7IG15OiAwIH0sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goYnQsIHsgZm9udFNpemU6IG8sIHN4OiB7IGxpbmVIZWlnaHQ6IFwiMVwiIH0sIHZhcmlhbnQ6IFwiY2FwdGlvblwiLCBjaGlsZHJlbjogdCB9KSB9KSxcbiAgICAgICAgYyA/IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChEbSwge30pIDogLyogQF9fUFVSRV9fICovIE4uanN4KExtLCB7fSlcbiAgICAgIF0gfSlcbiAgICBdIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBOLmpzeCh4biwgeyBpbjogYywgdGltZW91dDogXCJhdXRvXCIsIHVubW91bnRPbkV4aXQ6ICEwLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KHRpLCB7IGNvbXBvbmVudDogXCJkaXZcIiwgZGlzYWJsZVBhZGRpbmc6ICEwLCBjaGlsZHJlbjogZSB9KSB9KVxuICBdIH0pO1xufSwgTHMgPSAoe1xuICBjb21wb25lbnQ6IGUgPSBcImFcIixcbiAgY2hpbGRyZW46IHQsXG4gIC4uLnJcbn0pID0+IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChlLCB7IC4uLnIsIHN0eWxlOiB7IHRleHREZWNvcmF0aW9uOiBcIm5vbmVcIiB9LCBjaGlsZHJlbjogdCB9KSwgcW0gPSAoe1xuICBjaGlsZHJlbjogZSxcbiAgaWNvbjogdCxcbiAgY29tcG9uZW50OiByLFxuICBiYWRnZTogbiA9ICExLFxuICBsaW5rOiBvID0gXCIvXCIsXG4gIGJhZGdlQ29sb3I6IGkgPSBcInNlY29uZGFyeVwiLFxuICBiYWRnZUNvbnRlbnQ6IHMgPSBcIjZcIixcbiAgYmFkZ2VUZXh0Q29sb3I6IGMgPSBcIiNmZmZcIixcbiAgdGV4dEZvbnRTaXplOiBsID0gXCIxNHB4XCIsXG4gIGJvcmRlclJhZGl1czogdSA9IFwiOHB4XCIsXG4gIGRpc2FibGVkOiBwID0gITEsXG4gIGJhZGdlVHlwZTogbSA9IFwiZmlsbGVkXCIsXG4gIHRhcmdldDogZyA9IFwiXCIsXG4gIGlzU2VsZWN0ZWQ6IHggPSAhMVxufSkgPT4ge1xuICBjb25zdCB5ID0gQy51c2VDb250ZXh0KEZyKSwgZiA9IExyKCksIFMgPSBsZShyaSkoKCkgPT4gKHtcbiAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICAgIG1hcmdpbkJvdHRvbTogXCIycHhcIixcbiAgICBwYWRkaW5nOiBcIjEwcHggMTJweFwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICB0ZXh0QWxpZ246IGYuZGlyZWN0aW9uID09PSBcImx0clwiID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIsXG4gICAgYm9yZGVyUmFkaXVzOiB1LFxuICAgIGNvbG9yOiB5LnRleHRDb2xvcixcbiAgICBjdXJzb3I6IHAgPyBcImRlZmF1bHRcIiA6IFwicG9pbnRlclwiLFxuICAgIG9wYWNpdHk6IHAgPyBcIjAuNlwiIDogXCIxXCIsXG4gICAgXCIuTXVpTGlzdEl0ZW1JY29uLXJvb3RcIjoge1xuICAgICAgY29sb3I6IHkudGV4dENvbG9yXG4gICAgfSxcbiAgICBcIiY6aG92ZXJcIjoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBwID8gXCIjZmZmXCIgOiB5LnRoZW1lQ29sb3IgKyAyMCxcbiAgICAgIGNvbG9yOiB5LnRoZW1lQ29sb3IsXG4gICAgICBcIi5NdWlMaXN0SXRlbUljb24tcm9vdFwiOiB7XG4gICAgICAgIGNvbG9yOiB5LnRoZW1lQ29sb3JcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiJi5NdWktc2VsZWN0ZWRcIjoge1xuICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogeS50aGVtZUNvbG9yLFxuICAgICAgXCImOmhvdmVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB5LnRoZW1lQ29sb3IsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICAgIH0sXG4gICAgICBcIi5NdWlMaXN0SXRlbUljb24tcm9vdFwiOiB7XG4gICAgICAgIGNvbG9yOiBcIiNmZmZcIlxuICAgICAgfVxuICAgIH1cbiAgfSkpLCBFID0gbGUobmkpKCgpID0+ICh7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBnYXA6IFwiMTBweFwiLFxuICAgIG1hcmdpbkJvdHRvbTogXCIwcHhcIixcbiAgICBwYWRkaW5nOiBcIjBweFwiLFxuICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgY29sb3I6IFwiaW5oZXJpdFwiXG4gIH0pKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChkdCwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIE4uanN4KExzLCB7IGNvbXBvbmVudDogciwgaHJlZjogbywgdG86IG8sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3hzKFxuICAgIFMsXG4gICAge1xuICAgICAgc3g6IHsgZGlzcGxheTogXCJmbGV4XCIsIGdhcDogXCIxNXB4XCIgfSxcbiAgICAgIHRhcmdldDogZyxcbiAgICAgIHNlbGVjdGVkOiAhIXgsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gTi5qc3goXG4gICAgICAgICAgRSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzeDoge1xuICAgICAgICAgICAgICBtaW5XaWR0aDogXCIwcHhcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0IHx8IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChEcywge30pXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB5LmlzQ29sbGFwc2UgPyBudWxsIDogLyogQF9fUFVSRV9fICovIE4uanN4cyhOLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIE4uanN4KG9pLCB7IHN4OiB7IG15OiAwIH0sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gTi5qc3goXG4gICAgICAgICAgICBidCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZm9udFNpemU6IGwsXG4gICAgICAgICAgICAgIHN4OiB7IGxpbmVIZWlnaHQ6IFwiMVwiIH0sXG4gICAgICAgICAgICAgIHZhcmlhbnQ6IFwiY2FwdGlvblwiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICkgfSksXG4gICAgICAgICAgbiAmJiAvKiBAX19QVVJFX18gKi8gTi5qc3goXG4gICAgICAgICAgICBJcyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGFiZWw6IHMsXG4gICAgICAgICAgICAgIGNvbG9yOiBpLFxuICAgICAgICAgICAgICB2YXJpYW50OiBtLFxuICAgICAgICAgICAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgICAgICAgICAgIHN4OiB7IGNvbG9yOiBjIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIF0gfSlcbiAgICAgIF1cbiAgICB9XG4gICkgfSkgfSk7XG59LCBHbSA9ICh7XG4gIGNoaWxkcmVuOiBlLFxuICBpbWc6IHQgPSBcImh0dHBzOi8vYWRtaW5tYXJ0LmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAyNC8wMy9sb2dvLWFkbWluLW1hcnQtbmV3cy5wbmdcIixcbiAgaHJlZjogciA9IFwiL1wiLFxuICBjb21wb25lbnQ6IG5cbn0pID0+IHtcbiAgY29uc3QgbyA9IEMudXNlQ29udGV4dChGciksIGkgPSBsZShcInNwYW5cIikoKCkgPT4gKHtcbiAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICAgIG92ZXJmbG93OiBvLmlzQ29sbGFwc2UgPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCIsXG4gICAgV2Via2l0TGluZUNsYW1wOiBcIjFcIixcbiAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgcGFkZGluZzogXCIxNXB4IDIycHhcIixcbiAgICB0ZXh0T3ZlcmZsb3c6IFwiZWxsaXBzaXNcIlxuICB9KSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gTi5qc3goTHMsIHsgaHJlZjogciwgY29tcG9uZW50OiBuLCB0bzogciwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChpLCB7IGNoaWxkcmVuOiB0ID09PSBcIlwiID8gLyogQF9fUFVSRV9fICovIE4uanN4KGJ0LCB7IHZhcmlhbnQ6IFwiYm9keTFcIiwgY2hpbGRyZW46IGUgfSkgOiAvKiBAX19QVVJFX18gKi8gTi5qc3goXG4gICAgZHQsXG4gICAge1xuICAgICAgY29tcG9uZW50OiBcImltZ1wiLFxuICAgICAgc3g6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCJcbiAgICAgIH0sXG4gICAgICBzcmM6IHRcbiAgICB9XG4gICkgfSkgfSk7XG59O1xuZXhwb3J0IHtcbiAgR20gYXMgTG9nbyxcbiAgWW0gYXMgTWVudSxcbiAgcW0gYXMgTWVudUl0ZW0sXG4gIFVtIGFzIFNpZGViYXIsXG4gIEhtIGFzIFN1Ym1lbnVcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-mui-sidebar/dist/index.es.js\n");

/***/ })

};
;